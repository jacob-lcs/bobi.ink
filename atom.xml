<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2019-09-07T02:57:07.855Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>if 我是前端团队 Leader，怎么做好概要设计</title>
    <link href="https://bobi.ink/2019/09/06/fe-design/"/>
    <id>https://bobi.ink/2019/09/06/fe-design/</id>
    <published>2019-09-05T16:00:00.000Z</published>
    <updated>2019-09-07T02:57:07.855Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范?</a>在掘金目前已经突破740个👍了, 谢谢大家的支持，这篇文章是前者延展。继续介绍我在前端团队管理方面的思考和探索。</p><p>软件工程中有一个软件设计阶段，通俗的讲就是在开工之前将能确定的确定下来，把该考虑的考虑了。这相比在开发阶段发现问题，解决的成本要低很多。</p><p>如果按照教科书上的定义，软件设计就是<strong>是一个将需求转变为软件陈述（表达）的过程</strong>。一般有<strong>概要设计(或者初步设计， Preliminary design)</strong>和<strong>详细设计(Detail design)</strong>. 概要设计将需求转换成数据和软件框架，而详细设计将框架逐步求精细化为具体的数据结构和软件的算法表达。本文讲述的是前端项目的概要设计。</p><p>相比后端开发, 对于前端，’软件设计‘很少被提及，也有可能是一直以来前端的工作都比较’简单’，所以比较粗放。一般给了原型和接口文档就直接开干了。但是随着前端开发者的工作越来越复杂，或者项目/团队的规模变大，我们越来越需要在编码之前进行合理的设计。</p><p>作为<strong>前端入门Leader</strong>, 最近面临了一些问题: 比如项目分工问题、项目维护缺乏文档问题, 让我开始重视软件设计阶段. 就目前看来，做好前端<strong>概要设计</strong>，至少有以下好处:</p><ul><li><strong>事前</strong>. 设计文档是开发的蓝图，后续开发可以按照这个文档逐步展开。良好的设计可以保证开发沿着正常轨道迈进。<ul><li>我们在设计阶段会进一步梳理业务流程，加深对业务流程的理解，甚至可以找出业务流程中的不合理的东西。</li><li>模块拆分。这个阶段我们会识别各个模块之间边界和重叠，将重叠的(共享的)部分抽离出来。另外模块是基本的开发工作单元，也是我们团队分工和时间评估的基础。</li><li>考察关键的技术点。提出多种备选方案，充分考虑各种风险, 选择符合实际需求的方案</li></ul></li><li><strong>事后</strong>. 设计文档对事后的软件维护、功能新增，有很大的帮助</li></ul><p><br></p><p>下面开始介绍，前端在<strong>软件设计阶段</strong>应该考虑东西，或者说前端的<code>概要设计文档</code>里面应该包含哪些东西. 当然这些只是一些初步的想法，随着后面深入实践后，本文会持续更新迭代.</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#关键业务流程的梳理">关键业务流程的梳理</a></li><li><a href="#关键技术点">关键技术点</a></li><li><a href="#模块设计">模块设计</a><ul><li><a href="#入口层">入口层</a></li><li><a href="#页面层">页面层</a></li><li><a href="#组件层">组件层</a></li><li><a href="#分工">分工</a></li></ul></li><li><a href="#状态设计">状态设计</a></li><li><a href="#接口设计">接口设计</a></li><li><a href="#版本规划">版本规划</a></li><li><a href="#验证">验证</a></li><li><a href="#项目要求和目标">项目要求和目标</a></li><li><a href="#文档索引">文档索引</a></li><li><a href="#构建说明">构建说明</a></li><li><a href="#持续迭代">持续迭代</a></li><li><a href="#模板">模板</a></li><li><a href="#总结">总结</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><p><br></p><blockquote><p>这方面我的经验实践比较少, 也没有在大厂待过，所以本文只是我的一些思考和尝试, 可能不太现实。如果你或你的团队有这方面的更好的实践，欢迎分享给我。感激🙏</p></blockquote><p><br><br><br></p><h2 id="关键业务流程的梳理"><a href="#关键业务流程的梳理" class="headerlink" title="关键业务流程的梳理"></a>关键业务流程的梳理</h2><p>开发任何一个产品之前，首先要确保的是对业务流程的理解，否则就会出现南辕北辙的情况。</p><p>在现实项目中发生过多次这类情况：<em>项目到达测试阶段，测试人员才发现应用的业务实现和产品定义不一样，或者业务流程不合理</em>。<br>这其实是一种很低级的失误，改动的成本可能很高，甚至会让你的所有工作白干。</p><p>管理比较成熟的公司会有很多手段来规避这种失误。</p><p>比如定义明确需求文档，这方面可以模仿一些标准/规范(Spec)的写作方法，严格定义一些关键字，避免模棱两可的描述;</p><p>另外可以通过各种宣贯会议，将相关人员聚集在一起，统一导入需求。在这些会议中可以进行头脑风暴，优化或细化需求的定义、发现缺陷和风险，分析可行性等等。通过不断沟通，成员之间可以分享交叉知识，确保对业务一致理解.</p><p><img src="/images/fe-design/doc.png" alt></p><p><br></p><p>因此，我觉得<strong>前端在设计阶段也应该像后端一样，用流程图或者时序图这类工具，将关键业务流程描述清楚. 尤其是涉及到前后端, 跨系统/跨页面/跨终端之间的业务交互的场景</strong>.</p><p>举个例子，比如我们在做一个’扫码登录‘功能。我们可以将跨终端的业务梳理出来：</p><p><img src="/images/fe-design/scan-login.png" alt></p><p><br></p><p>从上面的业务梳理中我们可以识别出业务对象的基本行为和状态. 例如二维码的状态转换图:</p><p><img src="/images/fe-design/scan-login-state.png" alt></p><p><br></p><p>当然, 简单的增删查改花篇幅去阐述没有意义。<strong>我们只关注应用关键的业务流程</strong>.</p><p>总之，业务流程的梳理，可以加深我们对业务的理解，是后续设计步骤和开发的基础.</p><p><br><br><br></p><h2 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h2><p>描述应用采用的或者涉及到关键技术/算法, 也可以认为是<strong>技术选型</strong>.</p><p>比如典型的有视频直播应用，涉及到的各种直播方案:</p><ul><li>RTMP 协议</li><li>RTP协议</li><li>HLS 协议</li><li>flv.js</li><li>WebRTC协议</li><li>等等</li></ul><p><strong>在开启一个项目之前, 我们需要对项目涉及到的关键技术点进行调研和测试，最好多找几个替代方案，横向地比较它们的优势和劣势</strong>。选择符合项目或团队自己情况的方案. 如果时间充足, 可以写一些Demo，实地踩一下坑.</p><p>如果有多个备选方案，最后要甄选出推荐方案，并说明选择的原因和考虑。</p><p><strong>提前做好技术的调研和选型，确定可行性，不至于开发处于被动的境地</strong>.</p><p>关于如何进行技术选型，我在<a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed#heading-10" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范?</a>进行了简单的讨论，可以参考一下.</p><p><br><br><br></p><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>现代前端一般都使用<strong>组件化思维</strong>进行开发，<strong>这时候我们的应用其实就是一颗由不同粒度的组件复合起来的组件树</strong>，这颗组件树最终会体现到项目的目录结构上。 <strong>在设计阶段我们可以根据产品原型或UI设计稿，识别出各种页面和组件</strong>。</p><p><img src="/images/fe-design/module-tree-map.png" alt></p><p>正常的应用，我们可以分三个层级进行拆分:</p><p><img src="/images/fe-design/module.png" alt></p><h3 id="入口层"><a href="#入口层" class="headerlink" title="入口层"></a>入口层</h3><p>稍微复杂一点的应用可能有多个入口，这些入口呈现的页面可能差异很大. 下面是一个常见的划分方法:</p><ul><li>按子系统划分: 比如前台和后台。</li><li>按角色划分：比如管理员、普通用户</li><li>按入口划分：比如移动端、桌面端等等</li></ul><p><br></p><h3 id="页面层"><a href="#页面层" class="headerlink" title="页面层"></a>页面层</h3><p>下一步就是识别各种页面，这些页面即对应到我们的前端路由配置规则. 以下面简单的应用为例:</p><p><img src="/images/fe-design/sample-pages.png" alt></p><p>关于模块的划分，我建议使用<strong>思维导图</strong>进行组织。<strong>模块划分这个环节，你可以召集团队的其他成员开个会议，一起进行头脑风暴。大家参照着产品原型，识别出各种模块或组件的边界和交集, 讨论怎么设计页面的数据流、组件的接口等等</strong>, 这样可以利用集体智慧，让模块拆分更加合理，另外可以促进团队成员提前熟悉项目的结构。</p><p>所以说<strong>软件设计不是架构师或设计人员一个人的事，应该鼓励大家一起参与，设计文档是整个软件团队的产出, 是团队的知识沉淀</strong>。</p><p>上面的应用通过页面层划分后，结果大概如下：</p><p><img src="/images/fe-design/pages.png" alt></p><p>在这个阶段我们会确定以下内容:</p><ul><li><strong>页面以及路由设计, 确定页面之间的层级关系</strong></li><li><strong>页面之间交互流程、数据传递</strong></li></ul><p><strong>关于路由设计，可以遵循一些规范，笔者比较推荐<a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">Restful URL规范</a></strong>, 这篇<a href="https://novoland.github.io/设计/2015/08/17/Restful%20API%20的设计规范.html" target="_blank" rel="noopener">文章</a>写得也不错.</p><p>路由之间的数据传递一般有以下几种方式:</p><ul><li>少量数据：可以通过路由变量(例如<code>/posts/:id</code>)或者查询字符串形式传递. 还有如果你使用的是<a href="https://react-router.docschina.org/web/api/BrowserRouter" target="_blank" rel="noopener">基于History API的前端路由模式</a>，可以使用History的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">state</a>对象来存储一些状态(最大640k)</li><li>大量数据：可以通过全局变量，或者状态管理器的机制进行存储, 不管这种存储在内存的方式，一旦页面刷新就会丢失。所以也可以考虑存储在本地缓存中, 例如LocalStorage</li></ul><p><br></p><h3 id="组件层"><a href="#组件层" class="headerlink" title="组件层"></a>组件层</h3><p>Ok，再往下拆分，不过要量力而行。对于一个非常复杂的项目来说，可能有成千上百个组件，而且这些组件在未来可能会不断变化，在设计阶段考虑这些拆分可能需要花费很多时间，而且收益并不明显。</p><p>那么需要怎么把握粒度呢？其实组件层设计阶段的主要目的是<strong>找出重复的、或者结构类似的组件，将它们抽取出来统一的设计，在多个页面进行复用. 并不是把所有的组件都列举出来</strong>。</p><p>我在<a href="https://juejin.im/post/5cd8fb916fb9a03218556fc1" target="_blank" rel="noopener">React组件设计实践总结02 - 组件的组织</a>这篇文章中，专门介绍React组件如何进行组织和拆分。其中提出了以下集中模式:</p><ul><li>容器组件和展示组件分离。或者说分离视图和逻辑, 业务组件和傻瓜组件. 纯逻辑的东西放在Hooks中，使用起来会更加方便</li><li>纯组件和非纯组件. 可以认为纯组件完全依赖外部输入</li><li>有状态组件和无状态组件</li><li>布局组件和内容组件</li><li>统一设计同一类型组件的接口. 比如表单组件应该保持接口统一</li></ul><p><img src="/images/fe-design/sample-pages2.png" alt></p><p>还是上面的示例应用，申报页面有非常多的表单项，而且经常变动，另外你会发现它和预览页面的结构是差不多的，而且后面可能会有桌面端页面。</p><p>经过讨论，我们决定采用配置文件的方式来动态渲染表单页和预览页。实现一套配置控制移动端申请表单、桌面端申请表单、移动端预览、桌面端预览页面。</p><p>类似上面这种应用场景，前期的组件层设计就很有必要了。</p><p><br></p><p><img src="/images/fe-design/components.png" alt></p><p><br></p><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>将模块拆分清楚后，我们就可以针对这些模块进行合理的分工和时间评估。基本上有三个步骤：</p><p><img src="/images/fe-design/module-plan.png" alt></p><p>通过上面的步骤，我们识别出来了各种模块，接着我们要确定下来这些模块之间的依赖关系，这些依赖关系影响它们是否要作为一个整体进行实现。最后再根据业务的优先级或依赖关系决定这些<strong>模块簇</strong>的实现优先级。</p><p>Ok, 现在可以将这些模块簇按照优先级排序, 加上评估时间(人天)，整理成一个清单。 如果你们使用看板来进行项目管理, 可以将它们作为一个任务单元，贴到看板中.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. Foo 功能</span><br><span class="line">  - c 2d</span><br><span class="line">  - d 1d</span><br><span class="line">  - f 3d</span><br><span class="line">2. Bar 功能</span><br><span class="line">  - e 1d</span><br><span class="line">  - h 0.5d</span><br><span class="line">3. Baz 功能</span><br><span class="line">  - g 1d</span><br><span class="line">4. Fu 功能</span><br><span class="line">  - a 4d</span><br><span class="line">  - b 1d</span><br><span class="line"></span><br><span class="line">总计人天: 13.5</span><br></pre></td></tr></table></figure><p><br></p><p>任务的分工有很多策略, 例如：</p><ul><li>横向划分<ul><li>公共组件 vs 业务组件(对接业务)</li><li>自上而下 vs 自下而上(指的是组件树)</li></ul></li><li>垂直划分: 按照独立的垂直模块分工</li></ul><p><img src="/images/fe-design/module-tree.png" alt></p><p><br><br><br></p><h2 id="状态设计"><a href="#状态设计" class="headerlink" title="状态设计"></a>状态设计</h2><p><img src="/images/fe-design/redux.png" alt></p><p>前端组件化伴随而来的是各种<code>数据驱动</code>或<code>数据流驱动</code>的开发模式。这种模式下，前端应用可以总结为这样一个等式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view = f(state)</span><br></pre></td></tr></table></figure><p>也就是说<strong>视图是数据或者数据流的映射</strong>. 可见状态管理对现代前端开发的重要性。</p><p>状态的设计和后端对象模型设计差不多。<strong>你需要根据业务和页面渲染要求抽象出各种对象模型，以及缕清对象模型之间的关系</strong>。这个阶段可能需要和后端紧密结合，才能确定出合理的对象结构。</p><p>当然状态的设计还跟你选择的状态管理方案也有关系, 不同状态管理器方案体现的思想差异较大：<em>如果你选择Redux，那么应用的状态就是一颗对象树；如果你选择Mobx，应用的状态可能由多个模型对象组成，更接近传统的OOP模式</em>。</p><p>如果采用OOP设计方法，可以绘制<code>UML</code>图，可视化表现对象的结构和关系:</p><p><img src="/images/fe-design/uml-sample.png" alt><br><i>(图片来源: <a href="https://zongren.me/2016/12/30/uml-diagram-sample/" target="_blank" rel="noopener">https://zongren.me/2016/12/30/uml-diagram-sample/</a>)</i></p><p><br></p><p>我在<a href="https://juejin.im/post/5ce3ee436fb9a07f070e0220" target="_blank" rel="noopener">React组件设计实践总结05 - 状态管理</a>这篇文章花了很多篇幅来介绍各种状态管理器的思想和开发模式, 所以这里就不展开了:</p><p><strong>Redux 状态设计</strong>:</p><p><img src="/images/fe-design/redux-design.png" alt></p><p><strong>Mobx 状态设计</strong>:</p><p><img src="/images/fe-design/mobx-design.png" alt></p><p><br><br><br></p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>如果前端团队在接口设计方面有主导权, 或者使用<a href="https://www.phodal.com/blog/architecture-101-bff-for-legacy-system-migrate/" target="_blank" rel="noopener">BFF架构(服务于前端的后端)</a>，在设计阶段我们需要对各类接口进行设计。</p><p>不过一般主导权都掌握在后端手里，因为前端对业务的关心程度较低，后端一般会综合考虑各端的接口需求、数据库存储效率、可维护性等多个方面来设计接口, 这时候前端就是接口的用户，我们有责任来验证后端接口是否符合需求.</p><p>我在<a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed#heading-45" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范?</a>已经提及了各种接口规范. 这里不予赘述。</p><p><br><br><br></p><h2 id="版本规划"><a href="#版本规划" class="headerlink" title="版本规划"></a>版本规划</h2><p>通过上面的步骤，我们基本已经了解我们需要做什么、需要花多久。接下来，</p><p>应该制定一个版本计划，对于一个大项目可以拆分为多个<strong>里程碑</strong>, 估计版本发布的时间. 加不加班就看你了，作为Leader要综合考虑各种影响因素，实事求是合理地安排版本发布计划。</p><p>这个发布计划可能还需要经过PM和项目经理审核, 作为前端项目，开发计划通常还依赖于后端团队.</p><p><img src="/images/fe-design/roadmap.png" alt></p><p><br></p><p>这个版本计划中会包含这些内容:</p><ul><li>版本号</li><li>发布时间</li><li>包含的主要模块</li></ul><p><br><br><br></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证，或者称为’测试指导‘。 除了测试团队提供的测试用例，从开发(白盒)的角度还需要注意哪些东西?</p><p>产品或者测试可能只会从业务的层次考虑应用的运行，我们需要从研发的角度，充分考虑各种<strong>异常情况</strong>、<strong>性能瓶颈</strong>、进行<strong>风险评估</strong>. 阐明风险的应对方案等待.</p><p>这些情况也可以反馈给测试团队，以完善测试的用例.</p><p><br></p><h2 id="项目要求和目标"><a href="#项目要求和目标" class="headerlink" title="项目要求和目标"></a>项目要求和目标</h2><p>一些需求是要提前确定下来的，对于前端来说，比较典型的就是浏览器兼容性要求。你可不要等到项目上线后，才跟我提用户要求兼容IE6!</p><p>这些项目要求可能会影响我们的开发成本、选型、测试和其他因素的评估。基本上，对于一个前端项目来说，这些要求是要提前问清楚的:</p><ul><li>浏览器兼容性</li><li>运行环境. 例如操作系统、小程序等等</li><li>时间点</li><li>性能指标要求. 例如首屏指标、数据量指标</li></ul><p><br><br><br></p><h2 id="文档索引"><a href="#文档索引" class="headerlink" title="文档索引"></a>文档索引</h2><p>前端项目开发可能会关联很多文档，这些文档是分散的，在设计文档中最好把它们聚合起来，方便查阅和引用. 例如:</p><ul><li>需求文档</li><li>DEMO, UI设计稿</li><li>测试用例</li><li>接口文档</li><li>UI设计规范文档</li><li>前端规范文档</li><li>…</li></ul><p><br><br><br></p><h2 id="构建说明"><a href="#构建说明" class="headerlink" title="构建说明"></a>构建说明</h2><p>如果你的项目需要设计构建流程，也可以在设计文档中简单提及。</p><p>例如<strong>如何编译和运行</strong>? <strong>如何测试和调试</strong>? <strong>如何部署或发布</strong>？ <strong>代码如何组织</strong>？<strong>开发工作流</strong>、<strong>编码约定</strong>等等</p><p>新成员通过这些说明可以快速上手开发.</p><p><br></p><h2 id="持续迭代"><a href="#持续迭代" class="headerlink" title="持续迭代"></a>持续迭代</h2><p>设计文档不是一次性的，它应该跟随项目不断的迭代，不然就失去了文档的意义。</p><p><br><br><br></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>最后，规范一些设计文档的格式和内容</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># XXX 概要设计文档</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 背景</span></span><br><span class="line"></span><br><span class="line">填写项目的背景, 或者开发或重构的目的/出发点.</span><br><span class="line"></span><br><span class="line"><span class="section">## 关键业务流程</span></span><br><span class="line"></span><br><span class="line">可以放置关键的业务流程图、状态图、对象图等等. 梳理关键的业务流程</span><br><span class="line"></span><br><span class="line"><span class="section">## 关键技术描述</span></span><br><span class="line"></span><br><span class="line">可选, 描述项目中使用到的关键技术、算法、选型结论等等</span><br><span class="line"></span><br><span class="line"><span class="section">## 模块拆分</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>入口</span><br><span class="line"><span class="bullet">- </span>页面路由</span><br><span class="line"><span class="bullet">- </span>组件设计</span><br><span class="line"></span><br><span class="line">可以使用思维导图描述</span><br><span class="line"></span><br><span class="line"><span class="section">## 状态设计</span></span><br><span class="line"></span><br><span class="line">描述应用涉及的关键领域对象, 比如外形、行为和关系. 如果是OOP方式，可以使用UML描述</span><br><span class="line"></span><br><span class="line"><span class="section">## 接口设计</span></span><br><span class="line"></span><br><span class="line">可选，如题</span><br><span class="line"></span><br><span class="line"><span class="section">## 项目要求和目标</span></span><br><span class="line"></span><br><span class="line">项目目标、运行环境、兼容性要求、性能指标等等</span><br><span class="line"></span><br><span class="line"><span class="section">## 验证</span></span><br><span class="line"></span><br><span class="line">可选, 风险评估、异常情况考虑、特殊测试规则、测试指导等等</span><br><span class="line"></span><br><span class="line"><span class="section">## 分工和版本计划</span></span><br><span class="line"></span><br><span class="line">可选, 可以在单独文档或者看板中维护</span><br><span class="line"></span><br><span class="line"><span class="section">## 构建说明</span></span><br><span class="line"></span><br><span class="line">可选, 项目组织、构建、测试说明</span><br><span class="line"></span><br><span class="line"><span class="section">## 文档索引</span></span><br><span class="line"></span><br><span class="line">相关文档的索引和链接</span><br><span class="line"></span><br><span class="line"><span class="section">## 参考资料</span></span><br><span class="line"></span><br><span class="line">文档中索引页的外部参考资料</span><br><span class="line"></span><br><span class="line"><span class="section">## CHANGELOG</span></span><br><span class="line"></span><br><span class="line">列出本文档修改的历史纪录。必须指明修改的内容、日期以及修改人</span><br></pre></td></tr></table></figure><p>很多开发人员都不喜欢写文档，包括我以前也是这样的。我们会找各种借口：’时间紧张，没时间做设计‘、’用来写设计文档的时间，我的开发早就做完了‘。</p><p>这些想法显然是不正确的，给我的启示是<strong>我们要根据团队情况而定，不要求设计文档有多么详尽，在时间紧张的时候可以粗略一点。等时间充裕再回顾补充也是可以接受的; 或者如果项目划分为多个周期进行开发，我们也可以在每个周期开始时进行详细的设计</strong>。</p><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章差不多写完了，看到了知乎<a href="https://www.zhihu.com/people/zhang-ming-yun-88/activities" target="_blank" rel="noopener">@张明云</a><a href="https://www.zhihu.com/question/300407894" target="_blank" rel="noopener">现代软件开发中，详细设计这一步要如何来做？</a>下面的一个回答:</p><p><br></p><p><img src="/images/fe-design/zhihu.png" alt></p><p><br></p><p>和我上文所介绍基本吻合。一个软件’概要‘设计文档基本就包含这几大块。</p><p>本文完。</p><p><br></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.infoq.cn/article/how-to-write-a-good-software-design-document" target="_blank" rel="noopener">如何才能写出好的软件设计文档？</a></li><li><a href="https://blog.csdn.net/lori2004/article/details/80011806" target="_blank" rel="noopener">软件设计文档编写概述</a></li><li><a href="https://www.zhihu.com/question/300407894" target="_blank" rel="noopener">现代软件开发中，详细设计这一步要如何来做？</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d3a7134f265da1b5d57f1ed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;if 我是前端团队 Leader，怎么制定前端协作规范?&lt;/a&gt;在掘金目前已经突破740个👍了
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器和Node中的JavaScript是如何工作的? 可视化解释</title>
    <link href="https://bobi.ink/2019/08/29/js-bs/"/>
    <id>https://bobi.ink/2019/08/29/js-bs/</id>
    <published>2019-08-28T16:00:00.000Z</published>
    <updated>2019-08-30T15:12:30.729Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址: <a href="https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f" target="_blank" rel="noopener">How JavaScript works in browser and node?</a></p><p>有非常多满怀激情的开发者，他们搞前端或者搞后端，为JavaScript奉献自己青春和血汗。JavaScript是一种非常容易理解语言，毫无疑问它是前端开发中一个非常关键的部分。但是和其他语言不同的是， 它是单线程的，这就意味着，同一时间只能有一个代码片段在执行。因为代码执行是线性的，如果当中有任何代码执行很长时间，将会阻塞后面需要被执行的代码。因此有时候你会在Google Chrome中看到这样的界面:</p><p><br></p><p><img src="/images/js-bs/crashed.png" alt></p><p><br></p><p>当你在浏览器打开一个网站时，它会使用一个JavaScript执行线程。这个线程负责响应一切操作，比如页面滚动、页面渲染、监听DOM事件(比如用户点击按钮)等等。但是如果JavaScript执行被阻塞了，那浏览器就什么事情也做不了，即意味着浏览器会呈现为卡死，无法响应的现象。</p><p>不信你就在控制台输入试试:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>你会上面语句之后的任何代码都不会被执行，这个‘死循环’会霸占着系统资源, 让浏览器无法响应用户操作. 无限递归调用也会出现这种情况, 不过下文会介绍，Javascript引擎对调用栈长度进行限制，无限递归会抛出RangeError异常, 而不会无休止地运行。</p><p><br></p><p><img src="/images/js-bs/crashed2.png" alt></p><p><br></p><p>感谢现代浏览器，现在不是所有打开的标签页都依赖于一个JavaScript线程。而是每个标签页或者域名都会有独立的JavaScript线程。这样每个标签页之间不会互相阻塞。比如你可以在Chrome中打开多个标签页，在某个标签页下执行上面的死循环，你会发现只有执行了上面语句的标签卡死，其他不受影响。</p><p><br><br><br></p><h2 id="调用栈-call-stack"><a href="#调用栈-call-stack" class="headerlink" title="调用栈(Call Stack)"></a>调用栈(Call Stack)</h2><p>为了可视化JavaScript 如何执行程序，我们首先要理解JavaScript运行时。</p><p><img src="/images/js-bs/vis1.png" alt></p><p><br></p><p>和其他编程语言一样，JavaScript运行时有一个栈(Stack)和一个堆(Heap)存储器。</p><p><img src="/images/js-bs/stack-vs-heap.jpg" alt></p><p>上图来源于<a href="Confused about Stack and Heap?">Fhinkel</a>文章，关于栈和堆之间的差异讲得比较清晰. 举个例子:</p><p><em>在Java或者C#中， 值类型(primitives原始类型)存储在栈中，而引用类型(reference)则存储在堆中。C++规范没有规定栈和堆的内存分配，而是使用<code>自动存储(automatic)期</code>和<code>动态存储(dynamic)期</code>来作区分，局部变量是自动存储期，编译器会将它们存储在栈中。而动态分配的对象则通常保存在堆中。放在栈中的数据会在函数执行完毕后自动回收，而放在堆中的对象，如果没有释放就会造成<strong>内存泄露</strong></em></p><p><br></p><p>本文不会深入解释Heap，你可以看<a href="https://hashnode.com/post/does-javascript-use-stack-or-heap-for-memory-allocation-or-both-cj5jl90xl01nh1twuv8ug0bjk" target="_blank" rel="noopener">这里</a>. 在本文我们感兴趣的是栈，<strong>栈是一个LIFO(后进先出)的数据结构，用来保存程序当前的函数执行上下文, 换句话说，它表示的是当前程序执行的位置. 每次开始执行一个函数，就会将该函数推入栈中，当函数返回时从栈中弹出。 当栈为空时表示没有程序正在执行。所以栈常常也称为‘调用栈’</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Hello from baz'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>因此, 当上面的程序加载进内存时，会开始执行第一个函数，即<code>foo</code>。 因此第一个栈元素就是<code>foo()</code>, 因为<code>foo</code>函数会调用<code>bar</code>函数，第二个栈元素就是<code>bar()</code>; 同理<code>bar</code>函数会调用<code>baz</code>，第三个栈元素就是<code>baz()</code>. 最后，<code>baz</code>调用<code>console.log</code>，最后一个栈元素就是<code>console.log(&#39;Hello from baz&#39;)</code></p><p>栈会在函数执行完毕时(到达函数底部或者调用return)弹出。然后继续执行函数调用后续的语句:</p><p><img src="/images/js-bs/vis1.gif" alt></p><p><br></p><p>每个栈元素中，元素的状态也被称为栈帧(Stack Frame). 如果在函数调用抛出错误，JavaScript会输出栈跟踪记录(Stack trace)，表示代码执行时的栈帧的快照。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something went wrong.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的程序，我们在<code>baz</code>中抛出错误，JavaScript会打印出栈跟中记录，指出错误发生的地方和错误信息。</p><p><img src="/images/js-bs/err-msg.png" alt></p><p><br></p><p><strong>栈的大小不是无限的。例如Chrome就会限定栈的最大为16,000帧。所以无限递归会导致Chrome抛出<code>Maximum Call Stack size exceeded</code></strong>:</p><p><img src="/images/js-bs/overstack.png" alt></p><p><br><br><br></p><h2 id="事件循环与web-api"><a href="#事件循环与web-api" class="headerlink" title="事件循环与Web API"></a>事件循环与Web API</h2><p><strong>因为JavaScript是单线程的，所以它只有一个栈和堆</strong>。因此，如果其他程序想要执行一些东西，需要等待上一个程序执行完毕</p><p>对比其他语言，这可能是一个糟糕的设计，但是JavaScript的定位就是通用编程语言，而不是用于非常复杂的场景</p><p>考虑这样一个场景。假设浏览器发送一个HTTP请求到服务器，加载图片并展示到页面。浏览器会卡死等待请求完成吗？显然不会，这样用户体验太差了</p><p>浏览器通过JavaScript引擎来提供JavaScript运行环境。比如Chrome使用V8 引擎。但是浏览器内部可不只有JavaScript引擎。下面是浏览器的底层结构：</p><p><br></p><p><img src="/images/js-bs/underhood.png" alt></p><p><br></p><p>看起来很复杂，但是它也很好理解。JavaScript引擎需要和其他2个组件协作，即<strong>事件循环(EventLoop)</strong>和<strong>回调队列(CallbackQueue)</strong>，回调队列也被称为消息队列或任务队列。</p><p>除了JavaScript引擎，浏览器还包含了许多不同的应用来做各种各样的事情，比如HTTP请求、DOM事件监听、通过setTimeout、setInterval延迟执行、缓存、数据存储等等。这些特性可以帮助我们创建丰富的Web应用。</p><p>想一下，如果浏览器只使用同一个JavaScript线程来处理上面这些特性，用户体验会有多糟糕。因为用户即使只是简单的滚动页面，背后是需要处理很多事情的, 单个Javascript线程压根忙不过来。因此浏览器会使用低级的语言，比如C++，来执行这些操作，并暴露简洁的JavaScript API给开发者。这些API统称为<strong>Web API</strong>。</p><p><strong>这些Web API通常是异步的</strong>。这意味着，你可以命令这些API在’后台’(独立线程)去做一些事情，完成任务之后再通知Javascript运行时. 在此同时，Javascript引擎会继续执行剩下的JavaScript代码. 在命令这些API在后台做事情时，我们通常需要给它们提供一个回调。这个回调的职责就是在Web API完成任务后执行JavaScript代码。让我们将上述的所有东西整合起来理解一下:</p><p><img src="/images/js-bs/webapi-call.png" alt></p><p>当你调用一个函数时，它会被推进栈中。如果这个函数中包含了Web API调用，JavaScript会代理Web API的调用, 通知Web API执行任务，接着继续执行下一行代码直到函数返回。一旦函数到达return语句或者函数底部，这个函数就会从调用栈中弹出来。</p><p>与此同时，如果Web API在后台完成了它的工作，且有一个回调和这个工作绑定，Web API会将消息结果和回调进行绑定，并推入到消息队列中(或者称为回调队列).</p><p><strong>事件循环, 就像一个无限循环，它的唯一工作是检查回调队列，一旦回调队列中有待处理的任务，就将该回调推送到调用栈</strong>。不过因为Javascript是单线程的, 事件循环一次只能推送一个回调到调用栈，栈将会执行回调函数，<strong>一旦调用栈为空，事件循环才会将下一个回调函数推送到调用堆</strong>。</p><p>事件循环的伪代码大概如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> task</span><br><span class="line">   <span class="keyword">while</span>(task = popCallbackQueue()) &#123;<span class="comment">// 弹出回调队列任务</span></span><br><span class="line">      executeTask(task) <span class="comment">// 执行任务, 这里面可能会触发新的Web API调用</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasAnyPendingTask()) &#123;</span><br><span class="line">      sleep() <span class="comment">// 睡一觉，有新任务推送到回调队列时时再唤醒我哦</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span> <span class="comment">// 终止程序, 没什么好干的拜拜了</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我们通过setTimeout Web API这个例子一步一步看看上述的一切是怎么运作的。setTimeout Web API主要用于延时执行一些操作，但是回调真正被执行, 需要等待当前程序执行完毕(即栈为空), 也就是说，<strong>setTimeout函数回调执行时间未必等于你指定的延时时间</strong>。setTimeout的语法如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(callbackFunction, timeInMilliseconds);</span><br></pre></td></tr></table></figure><p>callbackFunction是一个回调函数，它将会在timeInMilliseconds之后执行. 我们修改上面的代码来调用setTimeout:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello from baz'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(printHello, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码延时调用了console.log. 栈还是会像之前一样，如<code>foo() =&gt; bar() =&gt; baz()</code>, 当baz开始执行并到达setTimeout时，Javascript会将回调函数传递给Web API，并且继续执行下一行。 因为这里没有下一行了，栈会弹出baz，接着弹出bar和foo。</p><p>在这期间，Web API正在进行3s等待，当时间到达时，它会将回调推进回调队列中。 因为这时候调用栈为空，事件循环会将这个回调推进栈中，并执行这个回调。</p><p><br></p><p><strong>🎉🎉<a href="http://latentflip.com/" target="_blank" rel="noopener">Philip Robers</a>创建了一个神奇的在线工具<a href="http://latentflip.com/loupe/" target="_blank" rel="noopener">Loupe</a>，来可视化Javascript的底层运行。上面的实例可以查看这个<a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gcHJpbnRIZWxsbygpIHsNCiAgICBjb25zb2xlLmxvZygnSGVsbG8gZnJvbSBiYXonKTsNCn0NCg0KZnVuY3Rpb24gYmF6KCkgew0KICAgIHNldFRpbWVvdXQocHJpbnRIZWxsbywgMzAwMCk7DQp9DQoNCmZ1bmN0aW9uIGJhcigpIHsNCiAgICBiYXooKTsNCn0NCg0KZnVuY3Rpb24gZm9vKCkgew0KICAgIGJhcigpOw0KfQ0KDQpmb28oKTs%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">链接</a>🎉🎉</strong></p><p><img src="/images/js-bs/vis2.gif" alt></p><p><strong>所以说我们Javascript是单线程的，但是很多Web API的执行是多线程的。也就是说Javascript的单线程指的是‘Javascript代码’的执行是单线程</strong>.</p><p><br></p><h2 id="node-js"><a href="#node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>通过Node.js我们可以做更多的事情, 而不仅限于浏览器的端。那么它是怎么运作的？</p><p>Node.js 和Chrome一样，同样使用Google的V8引擎来提供Javascript运行时. 它使用<a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>(C++编写)来和V8的事件循环配合，扩展更多可以在后台执行的东西, 比如文件系统I/O, 网络I/O。Node的标准库API遵循了浏览器Web API的类似回调风格。</p><p><img src="/images/js-bs/node.jpg" alt></p><p>如果你比较了浏览器和node的结构图，你会发现两者非常相似。右侧的部分类似于Web API，同样包含事件队列(或者称为回调队列/消息队列)和事件循环。</p><p>V8、事件循环、事件队列都在单线程中运行，最右侧还有工作线程(Worker Thread)负责提供异步的I/O操作。这就是为什么说Node.js拥有非阻塞的、事件驱动的异步I/O架构。</p><p>上面的内容都来源于<a href="http://latentflip.com/" target="_blank" rel="noopener">Philip Roberts</a>30min的高光<a href="https://youtu.be/8aGhZQkoFbQ" target="_blank" rel="noopener">演讲</a>(五年前)</p><p>本文完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址: &lt;a href=&quot;https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How JavaScript wor
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Typescript版图解Functor , Applicative 和 Monad</title>
    <link href="https://bobi.ink/2019/08/22/ts-fam/"/>
    <id>https://bobi.ink/2019/08/22/ts-fam/</id>
    <published>2019-08-21T16:00:00.000Z</published>
    <updated>2019-08-24T14:25:35.093Z</updated>
    
    <content type="html"><![CDATA[<p>本文是经典的<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures</a>的Typescript翻译版本。</p><p>Functor/Applicative/Monad是函数式编程中的一些比较‘基础’的概念，反正我是不认同‘基础’这个说法的，笔者也阅读过很多类似介绍Monad的文章，最后都不了了之，这些概念是比较难以理解的，而且平时编程实践中也很难会接触到这些东西。</p><p>后来拜读了<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures</a>, 不错，好像懂了。于是自己想通过翻译，再深入消化消化这篇文章，这里使用<code>Typescript</code>作为描述语言，对于前端来说会更好理解。</p><p>有理解不正确的地方，敬请指正. 开始吧！</p><p><br></p><p>这是一个简单的值:</p><p><img src="/images/ts-fam/value.png" alt></p><p>例如这些</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>        <span class="comment">// number</span></span><br><span class="line"><span class="string">'string'</span> <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>大家都知道怎么将一个函数应用到这个值上面:</p><p><img src="/images/ts-fam/value_apply.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// So easy</span></span><br><span class="line"><span class="keyword">const</span> add3 = <span class="function">(<span class="params">val: <span class="built_in">number</span></span>) =&gt;</span> val + <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(add3(<span class="number">2</span>)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>很简单了. 我们来扩展一下, 让任意的值是可以包装在一个<strong>上下文(context)</strong>当中. 现在的情况你可以想象一个可以把值放进去的盒子:</p><p><img src="/images/ts-fam/value_and_context.png" alt></p><p>现在你<strong>把一个函数应用到这个包装值的时候, 根据其上下文类型你会得到不同的结果</strong>. 这就是 <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, <code>Arrow</code> 之类概念的基础. </p><p><code>Maybe</code> 就是一个典型的数据类型, 它定义了两种相关的‘<strong>上下文</strong>’, Maybe本身也是一个‘上下文’(除了值，其他类型都可以是一个上下文？):</p><p><img src="/images/ts-fam/context.png" alt></p><p>原文基于Haskell，它的Maybe类型有两个上下文Just(蓝色盒子)和None(红色空盒子)。仿造Haskell在Typescript中我们可以使用<code>可选类型(Maybe)</code>来表示:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Maybe&lt;T&gt; = Just&lt;T&gt; | Nothing <span class="comment">// Just 表示值‘存在’，Nothing表示空值，类似于null、undefined的概念</span></span><br></pre></td></tr></table></figure><p>Just和Nothing的基本结构:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们只用None来取代null, 这里我们将None作为一个值，而不是一个类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> None &#123;&#125;</span><br><span class="line"><span class="comment">// 对应None的类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Nothing = <span class="keyword">typeof</span> None</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是Nothing，这里使用Typescript的 `Type Guards`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isNothing = (val: <span class="built_in">any</span>): val is Nothing =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> val === None</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Just类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Just&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> of&lt;T&gt;(val: T) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Just(val)</span><br><span class="line">  &#125;</span><br><span class="line">  value: T</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: Maybe&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">a = None;</span><br><span class="line">a = Just.of(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><blockquote><p>说实在这个实现有点挫, 但是为了更加贴近原文描述，暂且使用这个实现。之前考虑过的一个版本是下面这样的, 因为无法给它们扩展方法，就放弃了这个方案:<br>  <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Optional&lt;T&gt; = NonNullable&lt;T&gt; | nul</span><br><span class="line"><span class="keyword">let</span> a: Optional&lt;<span class="built_in">number</span>&gt; = <span class="number">1</span>;</span><br><span class="line">a = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p></blockquote><p><br></p><p>很快我们会看到对一个 <code>Just&lt;a&gt;</code> 和一个 Nothing 来说, 函数应用有何不同. 首先我们来看看 Functor!</p><p><br><br><br></p><h2 id="functors"><a href="#functors" class="headerlink" title="Functors"></a>Functors</h2><p>当一个值被包装在一个上下文中时, 你就不能拿普通函数来应用了:</p><p><img src="/images/ts-fam/no_fmap_ouch.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> a: Just&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add3 = <span class="function">(<span class="params">v: <span class="built_in">number</span></span>) =&gt;</span> v + <span class="number">3</span></span><br><span class="line">add3(a) <span class="comment">// ❌ 类型“Just&lt;number&gt;”的参数不能赋给类型“number”的参</span></span><br></pre></td></tr></table></figure><p>这时候, 该 <code>fmap</code> 出场了. fmap 翩翩而来，从容应对上下文(fmap is from the street, fmap is hip to contexts). 还有谁? fmap 知道怎样将一个函数应用到一个包装在上下文的值上. <strong>你可以对任何一个类型为 Functor 的类型使用 fmap</strong>， 换句话说，Functor都定义了fmap.</p><p>比如说, 想一下你想把 add3 应用到 Just 2. 用 fmap:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">2</span>).fmap(add3) <span class="comment">// Just 5</span></span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/fmap_apply.png" alt></p><p><strong>💥嘭！</strong> fmap 向我们展示了它的成果。 但是 fmap 怎么知道如何应用该函数的呢？</p><p><br></p><h2 id="究竟什么是-functor-呢？"><a href="#究竟什么是-functor-呢？" class="headerlink" title="究竟什么是 Functor 呢？"></a>究竟什么是 Functor 呢？</h2><p>在 Haskell 中 <code>Functor</code> 是一个<a href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101" target="_blank" rel="noopener">类型类(typeclass)</a>。 其定义如下：</p><p><img src="/images/ts-fam/functor_def.png" alt></p><p>在Typescript中， 一个Functor认为是<strong>定义了fmap的任意类型</strong>. 看看<code>fmap</code>是如何工作的:</p><p><img src="/images/ts-fam/fmap_def.png" alt></p><ol><li>一个Functor类型的 fa, 例如Just 2</li><li>fa 定义了一个fmap, fmap 接受一个函数fn，例如add3</li><li>fmap 直到如何将fa应用到fn中， 返回一个Functor类型的 fb. <strong>fa和fb的包装上下文类型一样</strong>, 例如fa是Just, 那么fb也是Just; 反之fa是Nothing，fb也是Nothing;</li></ol><p>用Typescript的函数签名描述一下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;Functor T&gt;.fmap&lt;U&gt;<span class="function">(<span class="params">fn: (<span class="params">val: T</span>) =&gt; U</span>): &lt;<span class="params">Functor</span> <span class="params">U</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们可以这么做：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">2</span>).fmap(add3) <span class="comment">// Just 5</span></span><br></pre></td></tr></table></figure><p>而 fmap 神奇地应用了这个函数，因为 Maybe 是一个 Functor, 它指定了 fmap 如何应用到 Just 上与 Nothing 上:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Just&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 实现fmap</span></span><br><span class="line">  fmap&lt;U&gt;<span class="function">(<span class="params">fn: (<span class="params">val: T</span>) =&gt; U</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">Just</span>.<span class="params">of</span>(<span class="params">fn(<span class="params"><span class="keyword">this</span>.value</span>)</span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">class</span> <span class="params">None</span> &#123;</span></span><br><span class="line"><span class="function">  // <span class="params">None</span> 接受任何函数都返回<span class="params">None</span></span></span><br><span class="line"><span class="function">  <span class="params">static</span> <span class="params">fmap</span>(<span class="params">fn: <span class="built_in">any</span></span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">None</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>当我们写 <code>Just.of(2).fmap(add3)</code> 时，这是幕后发生的事情：</p><p><img src="/images/ts-fam/fmap_just.png" alt></p><p>那么然后，就像这样，fmap，请将 add3 应用到 Nothing 上如何？</p><p><img src="/images/ts-fam/fmap_nothing.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">None.fmap(add3) <span class="comment">// Nothing</span></span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/bill.png" alt></p><p>就像《黑客帝国》中的 Morpheus，fmap 知道都要做什么；如果你从 Nothing 开始，那么你会以 Nothing 结束！ fmap 是禅。</p><p>现在它告诉我们了 Maybe 数据类型存在的意义。 例如，这是在一个没有 Maybe 的语言中处理一个数据库记录的方式, 比如Javascript:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> post = Post.findByID(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (post != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> post.title</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了fmap后:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设findPost返回Maybe&lt;Article&gt;</span></span><br><span class="line">findPost(<span class="number">1</span>).fmap(getPostTitle)</span><br></pre></td></tr></table></figure><p>如果 findPost 返回一篇文章，我们就会通过 getPostTitle 获取其标题。 如果它返回 Nothing，我们就也返回 Nothing！ 较之前简洁了很多对吧?</p><blockquote><p>Typescript有了Optional Chaining后，处理null也可以很简洁:<br> <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">findPost(<span class="number">1</span>)?.title <span class="comment">// 异曲同工</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>原文还有定义了一个fmap的重载操作符版本，因为JavaScript不支持操作符重载，所以这里简单带过<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getPostTitle &lt;$&gt; findPost(1) // 使用操作符重载&lt;$&gt; 来简化fmap. 等价于上面的代码</span><br></pre></td></tr></table></figure></p></blockquote><p><br></p><p>再看一个示例：如果将一个函数应用到一个 Array（Haksell 中是 List）上会发生什么？</p><p><img src="/images/ts-fam/fmap_list.png" alt></p><p>Array 也是 functor！</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(add3) <span class="comment">// [4, 5, 6]. fa是Array，输出fb也是Array，符合Functor的定义吧，所以Javascript的map就是fmap，Array就是Functor</span></span><br></pre></td></tr></table></figure><p><br></p><p>好了，好了，最后一个示例：如果将一个函数应用到另一个函数上会发生什么？</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply3 = <span class="function">(<span class="params">v: <span class="built_in">number</span></span>) =&gt;</span> v * <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> add3 = <span class="function">(<span class="params">v: <span class="built_in">number</span></span>) =&gt;</span> v + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">add3.fmap(multiply3) <span class="comment">// ❓</span></span><br></pre></td></tr></table></figure><p>这是一个函数：</p><p><img src="/images/ts-fam/function_with_value.png" alt></p><p>这是一个应用到另一个函数上的函数：</p><p><img src="/images/ts-fam/fmap_function.png" alt></p><p>其结果是又一个函数！</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅作示例，不要模仿</span></span><br><span class="line"><span class="keyword">interface</span> Function &#123;</span><br><span class="line">  fmap&lt;V, T, U&gt;<span class="function">(<span class="params"><span class="keyword">this</span>: (<span class="params">val: V</span>) =&gt; T, fn: (<span class="params">val: T</span>) =&gt; U</span>): (<span class="params">val: V</span>) =&gt;</span> U</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">v</span> =&gt;</span> fn(<span class="keyword">this</span>(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以函数也是 Functor！ 对一个函数使用 fmap，其实就是函数组合(compose)！ 也就是说: <code>f.fmap(g)</code> 等价于 <code>compose(f, g)</code></p><p><br></p><h3 id="functor总结"><a href="#functor总结" class="headerlink" title="Functor总结"></a>Functor总结</h3><p>通过上面的例子，可以知道Functor其实并没有那么难以理解, 一个Functor就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Functor T&gt;.fmap(fn: (v: T) =&gt; U): &lt;Functor U&gt;</span><br></pre></td></tr></table></figure><p>Functor会定义一个‘fmap’操作，这个fmap接受一个函数fn，fn接收的是具体的值，返回另一个具体的值，例如上面的add3. <strong>fmap决定如何来应用fn到源Functor(a)</strong>， 返回一个新的Functor(b)。 也就是fmap的源和输出的值‘上下文’类型是一样的。比如</p><ul><li><code>Just -&gt; fmap -&gt; Just</code></li><li><code>Nothing -&gt; fmap -&gt; Nothing</code></li><li><code>Maybe -&gt; fmap -&gt; Maybe</code></li><li><code>Array -&gt; fmap -&gt; Array</code></li></ul><p><br><br><br></p><h2 id="applicative"><a href="#applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>现在练到二重天了。 Applicative 又提升了一个层次。</p><p>对于 Applicative，我们的值依然和 Functor 一样包装在一个上下文中</p><p><img src="/images/ts-fam/value_and_context.png" alt></p><p>不一样的是，我们<strong>将Functor中的函数(例如add3)也包装在一个上下文中</strong>！</p><p><img src="/images/ts-fam/function_and_context.png" alt></p><p>嗯。 我们继续深入。 Applicative 并没有开玩笑。不像Haskell，Typescript并没有内置方式来处理Applicative。我们可以给需要支持Applicative的类型定义一个apply函数。<strong>apply函数知道怎么将<code>包装在上下文的函数</code>应用到一个<code>包装在上下文的值</code></strong>：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> None &#123;</span><br><span class="line">  <span class="keyword">static</span> apply(fn: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> None;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Just&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 使用方法重载，让Typescript更好推断</span></span><br><span class="line">  <span class="comment">// 如果值和函数都是Just类型，结果也是Just类型</span></span><br><span class="line">  apply&lt;U&gt;<span class="function">(<span class="params">fn: Just&lt;(<span class="params">a: T</span>) =&gt; U&gt;</span>): <span class="params">Just</span>&lt;<span class="params">U</span>&gt;;</span></span><br><span class="line"><span class="function">  // 如果函数是<span class="params">Nothing</span>类型，结果是<span class="params">Nothing</span>.</span></span><br><span class="line"><span class="function">  // 严格上<span class="params">apply</span>只应该接收同一个上下文类型的函数，即<span class="params">Just</span>,</span></span><br><span class="line"><span class="function">  // 因为<span class="params">Maybe</span>是<span class="params">Typescript</span>的<span class="params">Union</span>类型，没办法给它扩展方法，这里将<span class="params">Maybe</span>和<span class="params">Just</span>混在一起了</span></span><br><span class="line"><span class="function">  <span class="params">apply</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: Nothing</span>): <span class="params">Nothing</span>;</span></span><br><span class="line"><span class="function">  // 如果值和函数都是<span class="params">Maybe</span>类型, 返回一个<span class="params">Maybe</span>类型</span></span><br><span class="line"><span class="function">  <span class="params">apply</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: Maybe&lt;(<span class="params">a: T</span>) =&gt; U&gt;</span>): <span class="params">Maybe</span>&lt;<span class="params">U</span>&gt; &#123;</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">!isNothing(<span class="params">fn</span>)</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">return</span> <span class="params">Just</span>.<span class="params">of</span>(<span class="params">fn.value(<span class="params"><span class="keyword">this</span>.value</span>)</span>);</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">None</span>.<span class="params">apply</span>(<span class="params">fn</span>);</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>再来看看数组:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅作示例</span></span><br><span class="line"><span class="keyword">interface</span> Array&lt;T&gt; &#123;</span><br><span class="line">  apply&lt;U&gt;<span class="function">(<span class="params">fns: <span class="built_in">Array</span>&lt;(<span class="params">e: T</span>) =&gt; U&gt;</span>): <span class="params">U</span>[]</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 接收一个函数‘数组(<span class="params">上下文</span>)’，返回一个应用了‘函数’的新的数组</span></span><br><span class="line"><span class="function"><span class="params">Array</span>.<span class="params">prototype</span>.<span class="params">apply</span> = <span class="params">function</span>&lt;<span class="params">T</span>, <span class="params">U</span>&gt;(<span class="params">fns: <span class="built_in">Array</span>&lt;(<span class="params">e: T</span>) =&gt; U&gt;</span>) &#123;</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">res</span>: <span class="params">U</span>[] = []</span></span><br><span class="line"><span class="function">  <span class="params">for</span> (<span class="params"><span class="keyword">const</span> fn of fns</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">this</span>.<span class="params">forEach</span>(<span class="params">el =&gt; res.push(<span class="params">fn(<span class="params">el</span>)</span>)</span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="params">return</span> <span class="params">res</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>在Haskell中，使用<code>&lt;*&gt;</code>来表示apply操作: <code>Just (+3) &lt;*&gt; Just 2 == Just 5</code>. Typescript不支持操作符重载，所以忽略.</p><p>Just类型的Applicative应用图解：</p><p><img src="/images/ts-fam/applicative_just.png" alt></p><p>数组类型的Applicative应用图解：</p><p><img src="/images/ts-fam/applicative_list.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(num.apply([multiply2, add3]))</span><br><span class="line"><span class="comment">// [2, 4, 6, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p><strong>这里有 Applicative 能做到而 Functor 不能做到的事情</strong>。 如何将一个接受两个参数的函数应用到两个已包装的值上？</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个支持两个参数的Curry型加法函数</span></span><br><span class="line"><span class="keyword">const</span> curriedAddition = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> (b: <span class="built_in">number</span>) =&gt; a + b</span><br><span class="line"></span><br><span class="line">Just.of(<span class="number">5</span>).fmap(curriedAddition) <span class="comment">// 返回 `Just.of((b: number) =&gt; 5 + b)`</span></span><br><span class="line"><span class="comment">// Ok 继续</span></span><br><span class="line">Just.of(<span class="number">4</span>).fmap(Just.of(<span class="function">(<span class="params">b: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">5</span> + b))  <span class="comment">// ❌不行了，报错了，Functor没办法处理包装在上下文的fn</span></span><br></pre></td></tr></table></figure><p>但是Applicative可以：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">5</span>).fmap(curriedAddition) <span class="comment">// 返回 `Just.of((b: number) =&gt; 5 + b)`</span></span><br><span class="line"><span class="comment">// ✅当当当</span></span><br><span class="line">Just.of(<span class="number">3</span>).apply(Just.of(<span class="function">(<span class="params">b: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">5</span> + b)) <span class="comment">// Just.of(8)</span></span><br></pre></td></tr></table></figure><p>这时候Applicative 把 Functor 推到一边。 “大人物可以使用具有任意数量参数的函数，”它说。 “装备了 &lt;$&gt;(fmap) 与 &lt;*&gt;(apply) 之后，我可以接受具有任意个数未包装值参数的任意函数。 然后我传给它所有已包装的值，而我会得到一个已包装的值出来！ 啊啊啊啊啊！”</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">3</span>).apply(Just.of(<span class="number">5</span>).fmap(curriedAddition)) <span class="comment">// 返回 `Just.of(8)`</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="applicative总结"><a href="#applicative总结" class="headerlink" title="Applicative总结"></a>Applicative总结</h3><p>我们重申一个Applicative的定义, <strong>如果Functor要求实现fmap的话，Applicative就是要求实现apply</strong>，apply符合以下定义:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这是Functor的fmap定义</span><br><span class="line">&lt;Functor T&gt;.fmap(fn: (v: T) =&gt; U): &lt;Functor U&gt;</span><br><span class="line"></span><br><span class="line">// 这是Applicative的apply定义，和上面对比，fn变成了一个包装在上下文的函数</span><br><span class="line">&lt;Applicative T&gt;.apply(fn: &lt;Applicative (v: T) =&gt; U&gt;): &lt;Applicative U&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="monad"><a href="#monad" class="headerlink" title="Monad"></a>Monad</h2><p>终于练到三重天了！继续⛽加油️</p><p>如何学习 Monad 呢：</p><ol><li>你要取得计算机科学博士学位。</li><li>然后把它扔掉，因为在本文你并不需要它！</li></ol><p>Monad 增加了一个新的转变。</p><p><code>Functor</code> 将一个<code>函数</code>应用到一个<code>已包装的值</code>上：</p><p><img src="/images/ts-fam/fmap.png" alt></p><p><code>Applicative</code> 将一个<code>已包装的函数</code>应用到一个<code>已包装的值</code>上：</p><p><img src="/images/ts-fam/applicative.png" alt></p><p>Monad 将一个<code>返回已包装值的函数</code>应用到一个<code>已包装的值</code>上。 Monad 定义一个函数<code>flatMap</code>（在 Haskell 中是使用操作符 <code>&gt;&gt;=</code> 来应用Monad，读作“bind”）来做这个。</p><p>让我们来看个示例。 老搭档 Maybe 是一个 Monad：</p><p><img src="/images/ts-fam/context.png" alt></p><p>假设 <code>half</code> 是一个只适用于偶数的函数：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这就是一个典型的: "返回已包装值"的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">half</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">Maybe</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Just.of(value / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> None</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/half.png" alt></p><p>如果我们喂给它一个<code>已包装的值</code>会怎样？</p><p><img src="/images/ts-fam/half_ouch.png" alt></p><p>我们需要使用flatMap(Haskell 中的&gt;&gt;=)来将我们已包装的值塞进该函数。 这是 &gt;&gt;= 的照片：</p><p><img src="/images/ts-fam/plunger.jpg" alt></p><p>以下是它的工作方式：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">3</span>).flatMap(half) <span class="comment">// =&gt; Nothing, Haskell中使用操作符这样操作: Just 3 &gt;&gt;= half</span></span><br><span class="line">Just.of(<span class="number">4</span>).flatMap(half) <span class="comment">// =&gt; Just 2</span></span><br><span class="line">None.flatMap(half)       <span class="comment">// =&gt; Nothing</span></span><br></pre></td></tr></table></figure><p>内部发生了什么？我们再看看flatMap的方法签名:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Maybe</span></span><br><span class="line">Maybe&lt;T&gt;.flatMap&lt;U&gt;<span class="function">(<span class="params">fn: (<span class="params">val: T</span>) =&gt; Maybe&lt;U&gt;</span>): <span class="params">Maybe</span>&lt;<span class="params">U</span>&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="params">Array</span></span></span><br><span class="line"><span class="function"><span class="params">Array</span>&lt;<span class="params">T</span>&gt;.<span class="params">flatMap</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: (<span class="params">val: T</span>) =&gt; U[]</span>): <span class="params">U</span>[]</span></span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/bind_def.png" alt></p><p><strong>Array是一个Monad</strong>, Javascript的Array的flatMap已经正式成为标准， 看看它的使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]); </span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// only one level is flattened</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><p><br></p><p>Maybe 也是一个 Monad：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> None &#123;</span><br><span class="line">  <span class="keyword">static</span> flatMap(fn: <span class="built_in">any</span>): Nothing &#123;</span><br><span class="line">    <span class="keyword">return</span> None;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Just&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 和上面的apply差不多</span></span><br><span class="line">  <span class="comment">// 使用方法重载，让Typescript更好推断</span></span><br><span class="line">  <span class="comment">// 如果函数返回Just类型，结果也是Just类型</span></span><br><span class="line">  flatMap&lt;U&gt;<span class="function">(<span class="params">fn: (<span class="params">a: T</span>) =&gt; Just&lt;U&gt;</span>): <span class="params">Just</span>&lt;<span class="params">U</span>&gt;;</span></span><br><span class="line"><span class="function">  // 如果函数返回值是<span class="params">Nothing</span>类型，结果是<span class="params">Nothing</span>.</span></span><br><span class="line"><span class="function">  <span class="params">flatMap</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: (<span class="params">a: T</span>) =&gt; Nothing</span>): <span class="params">Nothing</span>;</span></span><br><span class="line"><span class="function">  // 如果函数返回值是<span class="params">Maybe</span>类型, 返回一个<span class="params">Maybe</span>类型</span></span><br><span class="line"><span class="function">  <span class="params">flatMap</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: (<span class="params">a: T</span>) =&gt; Maybe&lt;U&gt;</span>): <span class="params">Maybe</span>&lt;<span class="params">U</span>&gt; &#123;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">fn</span>(<span class="params"><span class="keyword">this</span>.value</span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 示例</span></span><br><span class="line"><span class="function"><span class="params">Just</span>.<span class="params">of</span>(<span class="params">3</span>).<span class="params">flatMap</span>(<span class="params">half</span>) // <span class="params">Nothing</span></span></span><br><span class="line"><span class="function"><span class="params">Just</span>.<span class="params">of</span>(<span class="params">4</span>).<span class="params">flatMap</span>(<span class="params">half</span>) // <span class="params">Just</span>.<span class="params">of</span>(<span class="params">4</span>)</span></span><br></pre></td></tr></table></figure><p>这是与 Just 3 运作的情况！</p><p><img src="/images/ts-fam/monad_just.png" alt></p><p>如果传入一个 Nothing 就更简单了：</p><p><img src="/images/ts-fam/monad_nothing.png" alt></p><p>你还可以将这些调用串联起来：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">20</span>).flatMap(half).flatMap(half).flatMap(falf) <span class="comment">// =&gt; Nothing</span></span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/monad_chain.png" alt><br><img src="/images/ts-fam/whoa.png" alt></p><p><br></p><p>很炫酷哈！所以我们现在知道Maybe既是一个Functor、Applicative，还是一个Monad。</p><p>原文还示范了另一个例子: <code>IO</code> Monad, 我们这里就简单了解一下</p><p><img src="/images/ts-fam/io.png" alt></p><p>IO的签名大概如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> IO&lt;T&gt; &#123;</span><br><span class="line">  val: T</span><br><span class="line">  <span class="comment">// 具体实现我们暂不关心</span></span><br><span class="line">  flatMap(fn: <span class="function">(<span class="params">val: T</span>) =&gt;</span> IO&lt;U&gt;): IO&lt;U&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来看三个函数。 getLine 没有参数, 用来获取用户输入：</p><p><img src="/images/ts-fam/getLine.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLine</span>(<span class="params"></span>): <span class="title">IO</span>&lt;<span class="title">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>readFile 接受一个字符串（文件名）并返回该文件的内容：</p><p><img src="/images/ts-fam/readFile.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename: <span class="built_in">string</span></span>): <span class="title">IO</span>&lt;<span class="title">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>putStrLn 输出字符串到控制台：</p><p><img src="/images/ts-fam/putStrLn.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putStrLn</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title">IO</span>&lt;<span class="title">void</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有这三个函数都接受普通值（或无值）并返回一个已包装的值，即IO。 我们可以使用 flatMap 将它们串联起来！</p><p><img src="/images/ts-fam/monad_io.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">getLine().flatMap(readFile).flatMap(putStrLn)</span><br></pre></td></tr></table></figure><p>太棒了！ 前排占座来看 monad 展示！我们不需要在取消包装和重新包装 IO monad 的值上浪费时间. flatMap 为我们做了那些工作!</p><p>Haskell 还为 monad 提供了语法糖, 叫做 do 表达式:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foo</span> = <span class="keyword">do</span></span><br><span class="line">    filename &lt;- getLine</span><br><span class="line">    contents &lt;- readFile filename</span><br><span class="line">    putStrLn contents</span><br></pre></td></tr></table></figure><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>functor 是实现了 <code>fmap</code> 的数据类型。</li><li>applicative 是实现了 <code>apply</code> 的数据类型。</li><li>monad 是实现了 <code>flatMap</code> 的数据类型。</li><li>Maybe 实现了这三者，所以它是 functor、 applicative、 以及 monad。</li></ol><p>这三者有什么区别呢？</p><p><img src="/images/ts-fam/recap.png" alt></p><ol><li><strong>functor</strong>: 可通过 fmap 将一个<code>函数</code>应用到一个<code>已包装的值</code>上。</li><li><strong>applicative</strong>: 可通过 apply 将一个<code>已包装的函数</code>应用到<code>已包装的值</code>上。</li><li><strong>monad</strong>: 可通过 flatMap 将一个<code>返回已包装值的函数</code>应用到<code>已包装的值</code>上。</li></ol><p>综合起来看看它们的签名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这是Functor的fmap定义</span><br><span class="line">&lt;Functor T&gt;.fmap(fn: (v: T) =&gt; U): &lt;Functor U&gt;</span><br><span class="line"></span><br><span class="line">// 这是Applicative的apply定义，和上面对比，fn变成了一个包装在上下文的函数</span><br><span class="line">&lt;Applicative T&gt;.apply(fn: &lt;Applicative (v: T) =&gt; U&gt;): &lt;Applicative U&gt;</span><br><span class="line"></span><br><span class="line">// Monad的定义, 而接受一个函数， 这个函数返回一个包装在上下文的值</span><br><span class="line">&lt;Monad T&gt;.flatmap(fn: (v: T) =&gt; &lt;Monad U&gt;): &lt;Monad U&gt;</span><br></pre></td></tr></table></figure><p>所以，亲爱的朋友（我觉得我们现在是朋友了），我想我们都同意 monad 是一个简单且高明的主意（SMART IDEA(tm)）。 现在你已经通过这篇指南润湿了你的口哨，为什么不拉上 Mel Gibson 并抓住整个瓶子呢。 参阅《Haskell 趣学指南》的《来看看几种 Monad》。 很多东西我其实掩饰了因为 Miran 深入这方面做得很棒.</p><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>本文在<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">原文</a>的基础上, 参考了下列这些翻译版本，再次感谢这些作者:</p><ul><li><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html#translations" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures</a> - 原文</li><li><a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="noopener">Swift Functors, Applicatives, and Monads in Pictures</a> - Swift版本, 本文主要参考这篇文章</li><li><a href="https://hltj.me/kotlin/2017/08/25/kotlin-functor-applicative-monad-cn.html" target="_blank" rel="noopener">Kotlin 版图解 Functor、Applicative 与 Monad</a> - Kotlin版本，翻译非常棒</li><li><a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="noopener">Functor, Applicative, 以及 Monad 的图片阐释</a> - 中文版本，<strong>题叶</strong>翻译</li><li><a href="https://medium.com/@lettier/your-easy-guide-to-monads-applicatives-functors-862048d61610" target="_blank" rel="noopener">Your easy guide to Monads, Applicatives, &amp; Functors</a> - Medium上一篇动图图解Monad的文章，写得也不错. 读完本文可以再读这篇文章</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是经典的&lt;a href=&quot;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Functo
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年了，整理了N个实用案例帮你快速迁移到React Hooks(收藏慢慢看系列)</title>
    <link href="https://bobi.ink/2019/08/10/react-hooks/"/>
    <id>https://bobi.ink/2019/08/10/react-hooks/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-18T06:14:32.162Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><img src="/images/react-hooks/cover.png" alt></p><p><br></p><p>在<a href="https://www.youtube.com/channel/UCz5vTaEhvh7dOHEyd1efcaQ" target="_blank" rel="noopener">React Conf 2018</a>宣布React Hooks后，我第一时间开始尝试使用React Hooks，现在新项目基本不写Class组件了。对我来说，它确实让我的开发效率提高了很多，改变了已有的组件开发思维和模式.</p><p>我在<a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-3" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a>中已经总结过<strong>React Hooks的意义，以及一些应用场景</strong>。</p><p>那这篇文章就完全是介绍<strong>React Hooks的应用实例</strong>，列举了我使用React Hooks的一些实践。 希望通过这些案例，可以帮助你快速熟练，并迁移到React Hooks开发模式. </p><blockquote><p><strong>文章篇幅很长，建议收藏不看, 至少看看目录吧</strong></p></blockquote><p><br></p><p>把之前文章整理的<code>React Hooks应用场景</code>总结拿过来, 本文基本按照<strong>这个范围进行组织</strong>:</p><p><img src="/images/react-hooks/apply.png" alt></p><p><br></p><p><strong>如果你想要了解React Hooks的原理可以阅读这些文章</strong>:</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fmedium.com%2F%40ryardley%2Freact-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a></li><li><a href="https://juejin.im/post/5cfa29e151882539c33e4f5e#heading-8" target="_blank" rel="noopener">从Preact中了解组件和hooks基本原理</a></li></ul><p><br></p><p><strong>目录索引</strong></p><!-- TOC --><ul><li><a href="#1-组件状态"><strong>1. 组件状态</strong></a><ul><li><a href="#1-1-usesetstate-模拟传统的setstate">1-1 useSetState 模拟传统的setState</a></li><li><a href="#1-2-usereducer-redux风格状态管理">1-2 useReducer Redux风格状态管理</a></li><li><a href="#1-3-useforceupdate-强制重新渲染">1-3 useForceUpdate 强制重新渲染</a></li><li><a href="#1-4-usestorage-简化localstorage存取">1-4 useStorage 简化localStorage存取</a></li><li><a href="#1-5-userefstate-引用state的最新值">1-5 useRefState 引用state的最新值</a><ul><li><a href="#1-5-1-每次重新渲染都创建闭包会影响效率吗">1-5-1 每次重新渲染都创建闭包会影响效率吗?</a></li></ul></li><li><a href="#1-6-userefprops-引用最新的props">1-6 useRefProps 引用最新的Props</a></li><li><a href="#1-7-useinstance-实例变量存取">1-7 useInstance ‘实例’变量存取</a></li><li><a href="#1-9-useprevious-获取上一次渲染的值">1-9 usePrevious 获取上一次渲染的值</a></li><li><a href="#1-10-useimmer-简化不可变数据操作">1-10 useImmer 简化不可变数据操作</a></li><li><a href="#1-11-封装工具hooks简化state的操作">1-11 封装’工具Hooks’简化State的操作</a><ul><li><a href="#1-11-1-usetoggle-开关">1-11-1 useToggle 开关</a></li><li><a href="#1-11-2-usearray-简化数组状态操作">1-11-2 useArray 简化数组状态操作</a></li></ul></li></ul></li><li><a href="#2-模拟生命周期函数"><strong>2. 模拟生命周期函数</strong></a><ul><li><a href="#2-1-useonmount-模拟componentdidmount">2-1 useOnMount 模拟componentDidMount</a></li><li><a href="#2-2-useonunmount-模拟componentwillunmount">2-2 useOnUnmount 模拟componentWillUnmount</a></li><li><a href="#2-3-useonupdate-模拟componentdidupdate">2-3 useOnUpdate 模拟componentDidUpdate</a></li></ul></li><li><a href="#3-事件处理"><strong>3. 事件处理</strong></a><ul><li><a href="#3-1-usechange-简化onchange表单双向绑定">3-1 useChange 简化onChange表单双向绑定</a></li><li><a href="#3-2-usebind-绑定回调参数">3-2 useBind 绑定回调参数</a></li><li><a href="#3-3-自定义事件封装">3-3 自定义事件封装</a><ul><li><a href="#3-3-1-useactive">3-3-1 useActive</a></li><li><a href="#3-3-2-usetouch-手势事件封装">3-3-2 useTouch 手势事件封装</a></li><li><a href="#3-3-3-usedraggable-拖拽事件封装">3-3-3 useDraggable 拖拽事件封装</a></li><li><a href="#3-3-4-react-events-面向未来的高级事件封装">3-3-4 react-events 面向未来的高级事件封装</a></li></ul></li><li><a href="#3-4-usesubscription-通用事件源订阅">3-4 useSubscription 通用事件源订阅</a></li><li><a href="#3-5-useobservable-hooks和rxjs优雅的结合rxjs-hooks">3-5 useObservable Hooks和RxJS优雅的结合(rxjs-hooks)</a></li><li><a href="#3-6-useeventemitter-对接eventemitter">3-6 useEventEmitter 对接eventEmitter</a></li></ul></li><li><a href="#4-context的妙用"><strong>4. Context的妙用</strong></a><ul><li><a href="#4-1-usetheme-主题配置">4-1 useTheme 主题配置</a></li><li><a href="#4-2-unstated-简单状态管理器">4-2 unstated 简单状态管理器</a></li><li><a href="#4-3-usei18n-国际化">4-3 useI18n 国际化</a></li><li><a href="#4-4-userouter-简化路由状态的访问">4-4 useRouter 简化路由状态的访问</a></li><li><a href="#4-5-react-hook-form-hooks和表单能擦出什么火花">4-5 react-hook-form Hooks和表单能擦出什么火花?</a></li></ul></li><li><a href="#5-副作用封装"><strong>5. 副作用封装</strong></a><ul><li><a href="#5-1-usetimeout-超时修改状态">5-1 useTimeout 超时修改状态</a></li><li><a href="#5-2-useonlinestatus-监听在线状态">5-2 useOnlineStatus 监听在线状态</a></li></ul></li><li><a href="#6-副作用衍生"><strong>6. 副作用衍生</strong></a><ul><li><a href="#6-1-usetitle-设置文档title">6-1 useTitle 设置文档title</a></li><li><a href="#6-2-usedebounce">6-2 useDebounce</a></li><li><a href="#6-3-usethrottle">6-3 useThrottle</a></li></ul></li><li><a href="#7-简化业务逻辑"><strong>7. 简化业务逻辑</strong></a><ul><li><a href="#7-1-usepromise-封装异步请求">7-1 usePromise 封装异步请求</a></li><li><a href="#7-2-usepromiseeffect-自动进行异步请求">7-2 usePromiseEffect 自动进行异步请求</a></li><li><a href="#7-3-useinfinitelist-实现无限加载列表">7-3 useInfiniteList 实现无限加载列表</a></li><li><a href="#7-4-usepoll-用hook实现轮询">7-4 usePoll 用hook实现轮询</a></li><li><a href="#7-5-业务逻辑抽离">7-5 业务逻辑抽离</a></li></ul></li><li><a href="#8-开脑洞"><strong>8. 开脑洞</strong></a><ul><li><a href="#8-1-usescript-hooks--suspend--❤️">8-1 useScript: Hooks + Suspend = ❤️</a></li><li><a href="#8-2-usemodal-模态框数据流管理">8-2 useModal 模态框数据流管理</a></li></ul></li><li><a href="#react-hooks-技术地图"><strong>React Hooks 技术地图</strong></a></li><li><a href="#总结">总结</a></li></ul><!-- /TOC --><p><br></p><h2 id="1-组件状态"><a href="#1-组件状态" class="headerlink" title="1. 组件状态"></a><strong>1. 组件状态</strong></h2><p>React提供了一个很基本的组件状态设置Hook:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure><p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener">useState</a>返回<strong>一个state，以及更新state的函数</strong>. setState可以接受一个新的值，会触发组件重新渲染.</p><blockquote><p><strong>React会确保setState函数是稳定的，不会在组件重新渲染时改变</strong>。下面的useReducer的dispatch函数、useRef的current属性也一样。<br><strong>这就意味着setState、dispatch、ref.current, 可以安全地在useEffect、useMemo、 useCallback中引用</strong></p></blockquote><p><br></p><h3 id="1-1-usesetstate-模拟传统的setstate"><a href="#1-1-usesetstate-模拟传统的setstate" class="headerlink" title="1-1 useSetState 模拟传统的setState"></a>1-1 useSetState 模拟传统的setState</h3><p>useState和Class组件的setState不太一样.</p><p>Class组件的state属性一般是一个对象，调用setState时，会浅拷贝到state属性, 并触发更新, 比如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    name: <span class="string">'_sx_'</span>,</span><br><span class="line">    age: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleIncrementAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只更新age</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">age</span>: <span class="keyword">this</span>.state.age + <span class="number">1</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>而<strong>useState会直接覆盖state值</strong>。为了实现和setState一样的效果, 可以这样子做:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;name: <span class="string">'sx'</span>, age: <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">const</span> MyComp: FC = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(initialState)</span><br><span class="line">  <span class="keyword">const</span> handleIncrementAge = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// setState方法支持接收一个函数，通过这个函数可以获取最新的state值</span></span><br><span class="line">    <span class="comment">// 然后使用...操作符实现对象浅拷贝</span></span><br><span class="line">    setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;...preState, age: prevState.age + <span class="number">1</span>&#125;) )</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Ok，现在把它封装成通用的hooks，在其他组件中复用。这时候就体现出来Hooks强大的逻辑抽象能力：<strong>Hooks 旨在让组件的内部逻辑组织成可复用的更小单元，这些单元各自维护一部分组件‘状态和逻辑’</strong></p><p>看看我们的<code>useSetState</code>, 我会使用Typescript进行代码编写:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useSetState</span>&lt;<span class="title">S</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initalState: S | ((</span>) =&gt; <span class="title">S</span>),</span></span><br><span class="line">): [S, (state: Partial&lt;S&gt; | ((state: S) =&gt; Partial&lt;S&gt;)) =&gt; void] &#123;</span><br><span class="line">  <span class="keyword">const</span> [_state, _setState] = useState&lt;S&gt;(initalState)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setState = useCallback(<span class="function">(<span class="params">state: Partial&lt;S&gt; | ((state: S</span>) =&gt;</span> Partial&lt;S&gt;)) =&gt; &#123;</span><br><span class="line">    _setState(<span class="function">(<span class="params">prev: S</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> nextState = state</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> state === <span class="string">'function'</span>) &#123;</span><br><span class="line">        nextState = state(prev)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; ...prev, ...nextState &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [_state, setState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseSetState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useSetState&lt;&#123; <span class="attr">name</span>: string; age: number &#125;&gt;(&#123; <span class="attr">name</span>: <span class="string">'sx'</span>, <span class="attr">age</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> incrementAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setState(<span class="function"><span class="params">prev</span> =&gt;</span> (&#123; <span class="attr">age</span>: prev.age + <span class="number">1</span> &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onClick=&#123;incrementAge&#125;&gt;</span><br><span class="line">      &#123;state.name&#125;: &#123;state.age&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>hooks命名以<code>use</code>为前缀</p></blockquote><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-2-usereducer-redux风格状态管理"><a href="#1-2-usereducer-redux风格状态管理" class="headerlink" title="1-2 useReducer Redux风格状态管理"></a>1-2 useReducer Redux风格状态管理</h3><p>如果组件状态比较复杂，推荐使用useReducer来管理状态。如果你熟悉Redux，会很习惯这种方式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义初始状态</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Reducer</span></span><br><span class="line"><span class="comment">// ruducer接受当前state，以及一个用户操作，返回一个'新'的state</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回state，以及dispatch函数</span></span><br><span class="line">  <span class="comment">// dispatch函数可以触发reducer执行，给reducer传递指令和载荷</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>了解更多reducer的思想可以参考<a href="https://redux.js.org/basics/reducers" target="_blank" rel="noopener">Redux文档</a></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-3-useforceupdate-强制重新渲染"><a href="#1-3-useforceupdate-强制重新渲染" class="headerlink" title="1-3 useForceUpdate 强制重新渲染"></a>1-3 useForceUpdate 强制重新渲染</h3><p>Class组件可以通过<code>forceUpdate</code>实例方法来触发强制重新渲染。使用useState也可以模拟相同的效果：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useForceUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [, setValue] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 递增state值，强制React进行重新渲染</span></span><br><span class="line">    setValue(<span class="function"><span class="params">val</span> =&gt;</span> (val + <span class="number">1</span>) % (<span class="built_in">Number</span>.MAX_SAFE_INTEGER - <span class="number">1</span>))</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ForceUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> forceUpdate = useForceUpdate()</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    somethingChange(forceUpdate)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-4-usestorage-简化localstorage存取"><a href="#1-4-usestorage-简化localstorage存取" class="headerlink" title="1-4 useStorage 简化localStorage存取"></a>1-4 useStorage 简化localStorage存取</h3><p>通过自定义Hooks，可以将状态代理到其他数据源，比如localStorage。 下面案例展示如果使用Hooks封装和简化localStorage的存取:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useCallback, Dispatch, SetStateAction &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useStorage</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 默认值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue?: T | (() =&gt; T),</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 是否在窗口关闭后保持数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">  keepOnWindowClosed: <span class="built_in">boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">T</span> | <span class="title">undefined</span>, <span class="title">Dispatch</span>&lt;<span class="title">SetStateAction</span>&lt;<span class="title">T</span>&gt;&gt;, (<span class="params"></span>) =&gt; <span class="title">void</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> storage = keepOnWindowClosed ? localStorage : sessionStorage</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试从Storage恢复值</span></span><br><span class="line">  <span class="keyword">const</span> getStorageValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> storageValue = storage.getItem(key)</span><br><span class="line">      <span class="keyword">if</span> (storageValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(storageValue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultValue) &#123;</span><br><span class="line">        <span class="comment">// 设置默认值</span></span><br><span class="line">        <span class="keyword">const</span> value = <span class="keyword">typeof</span> defaultValue === <span class="string">'function'</span> ? <span class="function">(<span class="params">defaultValue <span class="keyword">as</span> (<span class="params"></span>) =&gt; T</span>)<span class="params">()</span> : <span class="params">defaultValue</span></span></span><br><span class="line"><span class="function">        <span class="params">storage</span>.<span class="params">setItem</span>(<span class="params">key, <span class="built_in">JSON</span>.stringify(<span class="params">value</span>)</span>)</span></span><br><span class="line"><span class="function">        <span class="params">return</span> <span class="params">value</span></span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125; <span class="params">catch</span> (<span class="params">err</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">console</span>.<span class="params">warn</span>(<span class="params">`useStorage 无法获取$&#123;key&#125;: `, err</span>)</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">undefined</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">const</span> [<span class="params">value</span>, <span class="params">setValue</span>] = <span class="params">useState</span>&lt;<span class="params">T</span> | <span class="params">undefined</span>&gt;(<span class="params">getStorageValue</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 更新组件状态并保存到<span class="params">Storage</span></span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">save</span> = <span class="params">useCallback</span>&lt;<span class="params">Dispatch</span>&lt;<span class="params">SetStateAction</span>&lt;<span class="params">T</span>&gt;&gt;&gt;(<span class="params">value =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    setValue(<span class="params">prev =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">const</span> finalValue = <span class="keyword">typeof</span> value === '<span class="keyword">function</span>' ? (<span class="params">value <span class="keyword">as</span> (<span class="params">prev: T | <span class="literal">undefined</span></span>) =&gt; T</span>)(<span class="params">prev</span>) : value</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      storage.setItem(<span class="params">key, <span class="built_in">JSON</span>.stringify(<span class="params">finalValue</span>)</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">return</span> finalValue</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 移除状态</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">clear</span> = <span class="params">useCallback</span>(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    storage.removeItem(<span class="params">key</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    setValue(<span class="params"><span class="literal">undefined</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> [<span class="params">value</span>, <span class="params">save</span>, <span class="params">clear</span>]</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// --------</span></span><br><span class="line"><span class="function">// <span class="params">EXAMPLE</span></span></span><br><span class="line"><span class="function">// --------</span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">Demo</span><span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">  // 保存登录状态</span></span><br><span class="line"><span class="function">  <span class="params">const</span> [<span class="params">use</span>, <span class="params">setUser</span>, <span class="params">clearUser</span>] = <span class="params">useStorage</span>(<span class="params">'user'</span>)</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">handleLogin</span> = (<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    setUser(user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleLogout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearUser()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-5-userefstate-引用state的最新值"><a href="#1-5-userefstate-引用state的最新值" class="headerlink" title="1-5 useRefState 引用state的最新值"></a>1-5 useRefState 引用state的最新值</h3><p><br></p><p><img src="/images/react-hooks/vue-api.png" alt></p><p><br></p><p>上图是今年六月份<a href="https://vue.w3ctech.com" target="_blank" rel="noopener">VueConf</a>，尤雨溪的Slide截图，他对比了Vue最新的<a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener">FunctionBase API</a>和React Hook. 它<strong>指出React Hooks有很多问题</strong>:</p><ul><li>每个Hooks在组件每次渲染时都执行。也就是说每次渲染都要重新创建闭包和对象</li><li>需要理解闭包变量</li><li>内容回调/对象会导致纯组件props比对失效, 导致组件永远更新</li></ul><p><br></p><p>闭包变量问题是你掌握React Hooks过程中的重要一关。闭包问题是指什么呢？举个简单的例子, Counter:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> handleIncr = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;: <span class="tag">&lt;<span class="name">ComplexButton</span> <span class="attr">onClick</span>=<span class="string">&#123;handleIncr&#125;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">ComplexButton</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设ComplexButton是一个非常复杂的组件，每一次点击它，我们会递增count，从而触发组将重新渲染。<strong>因为Counter每次渲染都会重新生成handleIncr，所以也会导致ComplexButton重新渲染，不管ComplexButton使用了<code>PureComponent</code>还是使用<code>React.memo</code>包装</strong>。</p><p><br></p><p>为了解决这个问题，<strong>React也提供了一个<code>useCallback</code> Hook, 用来‘缓存’函数, 保持回调的不变性</strong>. 比如我们可以这样使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> handleIncr = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;: <span class="tag">&lt;<span class="name">ComplexButton</span> <span class="attr">onClick</span>=<span class="string">&#123;handleIncr&#125;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">ComplexButton</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是有bug的，不过怎么点击，count会一直显示为1！</p><p>再仔细阅读useCallback的文档，useCallback支持第二个参数，当这些值变动时更新缓存的函数, <strong>useCallback的内部逻辑大概是这样的</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memoFn, memoArgs</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果变动则更新缓存函数</span></span><br><span class="line">  <span class="keyword">if</span> (!isEqual(memoArgs, args)) &#123;</span><br><span class="line">    memoArgs = args</span><br><span class="line">    <span class="keyword">return</span> (memoFn = fn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memoFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok, 现在理解一下为什么会一直显示1？</p><p><img src="/images/react-hooks/usecallback.png" alt></p><p>首次渲染时缓存了闭包，这时候闭包捕获的count值是0。在后续的重新渲染中，因为useCallback第二个参数指定的值没有变动，handleIncr闭包会永远被缓存。这就解释了为什么每次点击，count只能为1.</p><p>解决办法也很简单，让我们在count变动时，让useCallback更新缓存函数:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> handleIncr = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;&#123;count&#125;: &lt;ComplexButton onClick=&#123;handleIncr&#125;&gt;increment&lt;<span class="regexp">/ComplexButton&gt;&lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>如果useCallback依赖很多值，你的代码可能是这样的：<code>useCallback(fn, [a, b, c, d, e])</code>. 反正我是无法接受这种代码的，很容易遗漏, 而且可维护性很差，尽管通过<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">ESLint插件</a>可以检查这些问题**。</p><p><br></p><p>其实通过<a href="https://reactjs.org/docs/hooks-reference.html#useref" target="_blank" rel="noopener"><code>useRef</code></a> Hook，可以让我们像Class组件一样保存一些‘实例变量’, React会保证useRef返回值的稳定性，我们可以在组件任何地方安全地引用ref。</p><p>基于这个原理，我们尝试封装一个<code>useRefState</code>, 它在useState的基础上扩展了一个返回值，用于获取state的最新值:</p><p><br></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useRef, useCallback, Dispatch, SetStateAction, MutableRefObject &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRefState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ins = useRef()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">typeof</span> initialState === <span class="string">'function'</span> ? initialState() : initialState</span><br><span class="line">    ins.current = value</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setValue = useCallback(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) &#123;</span><br><span class="line">      setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> finalValue = value(prevState)</span><br><span class="line">        ins.current = finalValue</span><br><span class="line">        <span class="keyword">return</span> finalValue</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ins.current = value</span><br><span class="line">      setState(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, setValue, ins]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount, countRef] = useRefState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> handleIncr = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(countRef.current + <span class="number">1</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在组件卸载时保存当前的count</span></span><br><span class="line">      saveCount(countRef.current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;&#123;count&#125;: &lt;ComplexButton onClick=&#123;handleIncr&#125;&gt;increment&lt;<span class="regexp">/ComplexButton&gt;&lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://reactjs.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener"><code>useEffect</code></a>、<a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener"><code>useMemo</code></a>和<code>useCallback</code>一样存在闭包变量问题，它们和useCallback一个支持指定第二个参数，当这个参数变化时执行副作用。</p></blockquote><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="1-5-1-每次重新渲染都创建闭包会影响效率吗"><a href="#1-5-1-每次重新渲染都创建闭包会影响效率吗" class="headerlink" title="1-5-1 每次重新渲染都创建闭包会影响效率吗?"></a>1-5-1 每次重新渲染都创建闭包会影响效率吗?</h4><p>函数组件和Class组件不一样的是，函数组件将所有状态和逻辑都放到一个函数中, 每一次重新渲染会重复创建大量的闭包、对象。而传统的Class组件的render函数则要简洁很多，一般只放置JSX渲染逻辑。相比大家都跟我一样，会怀疑函数组件的性能问题</p><p>我们看看官方是怎么回应的：</p><p><img src="/images/react-hooks/fn-perf.png" alt></p><p><br></p><p>我在SegmentFault的<a href="https://segmentfault.com/q/1010000019644156/a-1020000019706666" target="_blank" rel="noopener"><strong>react function组件与class组件性能问题</strong></a>也进行了详细的回答, 结论是:</p><blockquote><p>目前而言，实现同样的功能，类组件和函数组件的效率是不相上下的。但是函数组件是未来，而且还有优化空间，React团队会继续优化它。而类组件会逐渐退出历史</p></blockquote><p>为了提高函数组件的性能，可以在这些地方做一些<strong>优化</strong>:</p><ul><li><p>能否将函数提取为静态的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1️⃣例如将不依赖于组件状态的回调抽取为静态方法</span></span><br><span class="line"><span class="keyword">const</span> goback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  history.go(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//const goback = () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//  history.go(-1)</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;goback&#125;</span>&gt;</span>back<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 抽离useState的初始化函数</span></span><br><span class="line"><span class="keyword">const</span> returnEmptyObject = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> returnEmptyArray = <span class="function"><span class="params">()</span> =&gt;</span> []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(returnEmptyObject)</span><br><span class="line">  <span class="keyword">const</span> [arr, setArr] = useState(returnEmptyArray)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化组件的复杂度，动静分离</p></li><li>再拆分更细粒度的组件，这些组件使用React.memo缓存</li></ul><p><br><br><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-6-userefprops-引用最新的props"><a href="#1-6-userefprops-引用最新的props" class="headerlink" title="1-6 useRefProps 引用最新的Props"></a>1-6 useRefProps 引用最新的Props</h3><p>现实项目中也有很多这种场景: 我们想<strong>在组件的任何地方获取最新的props值</strong>，这个同样可以通过useRef来实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useRefProps</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef&lt;T&gt;(props)</span><br><span class="line">  <span class="comment">// 每次重新渲染设置值</span></span><br><span class="line">  ref.current = props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ref</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsRef = useRefProps(props)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 永久不变的事件处理器</span></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; onClick &#125; = propsRef.current</span><br><span class="line">    <span class="keyword">if</span> (onClick) &#123;</span><br><span class="line">      onClick()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ComplexButton</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">ComplexButton</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-7-useinstance-‘实例’变量存取"><a href="#1-7-useinstance-‘实例’变量存取" class="headerlink" title="1-7 useInstance ‘实例’变量存取"></a>1-7 useInstance ‘实例’变量存取</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>&lt;<span class="title">T</span>&gt;(<span class="params">initial?: T | (() =&gt; T)</span>): <span class="title">initial</span> <span class="title">is</span> (<span class="params"></span>) =&gt; <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> initial === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInstance</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;&#125;&gt;<span class="function">(<span class="params">initial?: T | (<span class="params">(<span class="params"></span>) =&gt; T</span>)</span>) &#123;</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">instance</span> = <span class="params">useRef</span>&lt;<span class="params">T</span>&gt;<span class="params">()</span></span></span><br><span class="line"><span class="function">  // 初始化</span></span><br><span class="line"><span class="function">  <span class="params">if</span> (<span class="params">instance.current == <span class="literal">null</span></span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">initial</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">instance</span>.<span class="params">current</span> = <span class="params">isFunction</span>(<span class="params">initial</span>) ? <span class="params">initial</span><span class="params">()</span> : <span class="params">initial</span></span></span><br><span class="line"><span class="function">    &#125; <span class="params">else</span> &#123;</span></span><br><span class="line"><span class="function">      <span class="params">instance</span>.<span class="params">current</span> = &#123;&#125; <span class="params">as</span> <span class="params">T</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> <span class="params">instance</span>.<span class="params">current</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// ---------</span></span><br><span class="line"><span class="function">// <span class="params">EXAMPLE</span></span></span><br><span class="line"><span class="function">// ---------</span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">Demo</span><span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">inst</span> = <span class="params">useInstance</span>(<span class="params">&#123; count: 1 &#125;</span>)</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">update</span> = <span class="params">useForceUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="params">useEffect</span>(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> timer = setInterval(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="comment">// 像类组件一样，进行‘实例变量’存储</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="comment">// 在函数组件的任意地方引用</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="comment">// 只不过更新这些数据不会触发组件的重新渲染</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      inst.count++</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;, 1000</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> (<span class="params"></span>) =&gt; clearInterval(<span class="params">timer</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;div&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">      count: &#123;inst.count&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &lt;button onClick=&#123;update&#125;&gt;刷新&lt;/button&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;/div&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意不要滥用</p></blockquote><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-9-useprevious-获取上一次渲染的值"><a href="#1-9-useprevious-获取上一次渲染的值" class="headerlink" title="1-9 usePrevious 获取上一次渲染的值"></a>1-9 usePrevious 获取上一次渲染的值</h3><p>在Class组件中，我们经常会在<code>shouldComponentUpdate</code>或<code>componentDidUpdate</code>这类生命周期方法中对props或state进行比对，来决定做某些事情，例如重新发起请求、监听事件等等.</p><p>Hooks中我们可以使用useEffect或useMemo来响应状态变化，进行状态或副作用衍生. 所以上述比对的场景在Hooks中很少见。但也不是不可能，React官方案例中就有一个<code>usePrevious</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePrevious</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef();</span><br><span class="line">  <span class="comment">// useEffect会在完成这次'渲染'之后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = value;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="keyword">const</span> calculation = count * <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> prevCalculation = usePrevious(calculation);</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-10-useimmer-简化不可变数据操作"><a href="#1-10-useimmer-简化不可变数据操作" class="headerlink" title="1-10 useImmer 简化不可变数据操作"></a>1-10 useImmer 简化不可变数据操作</h3><p>这个案例来源于<a href="https://github.com/immerjs/use-immer" target="_blank" rel="noopener">use-immer</a>, 结合<a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">immer.js</a>和Hooks来简化不可变数据操作, 看看代码示例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [person, updatePerson] = useImmer(&#123;</span><br><span class="line">  name: <span class="string">"Michel"</span>,</span><br><span class="line">  age: <span class="number">33</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  updatePerson(<span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">    draft.name = name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">becomeOlder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  updatePerson(<span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">    draft.age++;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现也非常简单:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useImmer</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [val, updateValue] = useState(initialValue);</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    val,</span><br><span class="line">    useCallback(<span class="function"><span class="params">updater</span> =&gt;</span> &#123;</span><br><span class="line">      updateValue(produce(updater));</span><br><span class="line">    &#125;, [])</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简洁的Hooks配合简洁的Immer，简直完美</strong></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-11-封装’工具hooks’简化state的操作"><a href="#1-11-封装’工具hooks’简化state的操作" class="headerlink" title="1-11 封装’工具Hooks’简化State的操作"></a>1-11 封装’工具Hooks’简化State的操作</h3><p>Hooks只是普通函数，所以可以灵活地自定义。下面举一些例子，利用自定义Hooks来简化常见的数据操作场景</p><p><br></p><h4 id="1-11-1-usetoggle-开关"><a href="#1-11-1-usetoggle-开关" class="headerlink" title="1-11-1 useToggle 开关"></a>1-11-1 useToggle 开关</h4><p>实现boolean值切换</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useToggle</span>(<span class="params">initialValue?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(!!initialValue)</span><br><span class="line">  <span class="keyword">const</span> toggler = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setValue(<span class="function"><span class="params">value</span> =&gt;</span> !value), [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [value, toggler]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [enable, toggleEnable] = useToggle()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;Switch value=&#123;enable&#125; onClick=&#123;toggleEnable&#125;&gt;&lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="1-11-2-usearray-简化数组状态操作"><a href="#1-11-2-usearray-简化数组状态操作" class="headerlink" title="1-11-2 useArray 简化数组状态操作"></a>1-11-2 useArray 简化数组状态操作</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">initial?: T[] | (() =&gt; T[]), idKey: <span class="built_in">string</span> = 'id'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(initial || [])</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    setValue,</span><br><span class="line">    push: useCallback(<span class="function"><span class="params">a</span> =&gt;</span> setValue(<span class="function"><span class="params">v</span> =&gt;</span> [...v, a]), []),</span><br><span class="line">    clear: useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setValue(<span class="function"><span class="params">()</span> =&gt;</span> []), []),</span><br><span class="line">    removeById: useCallback(<span class="function"><span class="params">id</span> =&gt;</span> setValue(<span class="function"><span class="params">arr</span> =&gt;</span> arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v &amp;&amp; v[idKey] !== id)), []),</span><br><span class="line">    removeIndex: useCallback(</span><br><span class="line">      index =&gt;</span><br><span class="line">        setValue(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          v.splice(index, <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> v</span><br><span class="line">        &#125;),</span><br><span class="line">      [],</span><br><span class="line">    ),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;value, push, removeById&#125; = useArray&lt;&#123;id: <span class="built_in">number</span>, name: <span class="built_in">string</span>&#125;&gt;()</span><br><span class="line">  <span class="keyword">const</span> handleAdd = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    push(&#123;id: <span class="built_in">Math</span>.random(), name: getName()&#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;value.map(<span class="function"><span class="params">i</span> =&gt;</span> &lt;span key=&#123;i.id&#125; onClick=&#123;<span class="function"><span class="params">()</span> =&gt;</span> removeById(i.id)&#125;&gt;&#123;i.name&#125;&lt;<span class="regexp">/span&gt;)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;button onClick=&#123;handleAdd&#125;&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限于篇幅，其他数据结构, 例如Set、Map, 就不展开介绍了，读者可以自己发挥想象力.</p><p><br><br><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="2-模拟生命周期函数"><a href="#2-模拟生命周期函数" class="headerlink" title="2. 模拟生命周期函数"></a><strong>2. 模拟生命周期函数</strong></h2><p>组件生命周期相关的操作依赖于<code>useEffect</code> Hook. <strong>React在函数组件中刻意淡化了组件生命周期的概念，而更关注‘数据的响应’</strong>.</p><p><code>useEffect</code>名称意图非常明显，就是<strong>专门用来管理组件的副作用</strong>。和useCallback一样，useEffect支持传递第二个参数，告知React在这些值发生变动时才执行父作用. 原理大概如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memoCallback = &#123;<span class="attr">fn</span>: <span class="literal">undefined</span>, <span class="attr">disposer</span>: <span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="keyword">let</span> memoArgs</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果变动则执行副作用</span></span><br><span class="line">  <span class="keyword">if</span> (args == <span class="literal">null</span> || !isEqual(memoArgs, args)) &#123;</span><br><span class="line">    memoArgs = args</span><br><span class="line">    memoCallback.fn = fn</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放进队列等待调度执行</span></span><br><span class="line">    pushIntoEffectQueue(memoCallback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 副作用执行</span></span><br><span class="line"><span class="comment">// 这个会在组件完成渲染，在布局(layout)和绘制(paint)之后被执行</span></span><br><span class="line"><span class="comment">// 如果是useLayoutEffect, 执行的时机会更早一些</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueExecute</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先执行清理函数</span></span><br><span class="line">  <span class="keyword">if</span> (callback.disposer) &#123;</span><br><span class="line">    callback.disposer()</span><br><span class="line">  &#125;</span><br><span class="line">  callback.disposer = callback.fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>关于useEffect官网有详尽的<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener">描述</a>; Dan Abramov也写了一篇<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">useEffect 完整指南</a>, 推荐👍。</p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="2-1-useonmount-模拟componentdidmount"><a href="#2-1-useonmount-模拟componentdidmount" class="headerlink" title="2-1 useOnMount 模拟componentDidMount"></a>2-1 useOnMount 模拟componentDidMount</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useOnMount</span>(<span class="params">fn: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fn()</span><br><span class="line">  &#125;, []) <span class="comment">// 第二个参数设置为[], 表示不必对任何数据， 所以只在首次渲染时调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useOnMount(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> loadList()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// log</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>如果需要在挂载/状态更新时请求一些资源、并且需要在卸载时释放这些资源，还是推荐使用useEffect，因为这些逻辑最好放在一起, 方便维护和理解</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 但是useEffect传入的函数不支持async/await(返回Promise)</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求资源</span></span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放资源</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="2-2-useonunmount-模拟componentwillunmount"><a href="#2-2-useonunmount-模拟componentwillunmount" class="headerlink" title="2-2 useOnUnmount 模拟componentWillUnmount"></a>2-2 useOnUnmount 模拟componentWillUnmount</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useOnUnmount</span>(<span class="params">fn: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="2-3-useonupdate-模拟componentdidupdate"><a href="#2-3-useonupdate-模拟componentdidupdate" class="headerlink" title="2-3 useOnUpdate 模拟componentDidUpdate"></a>2-3 useOnUpdate 模拟componentDidUpdate</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnUpdate</span>(<span class="params">fn: () =&gt; <span class="built_in">void</span>, dep?: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(&#123; fn, mounted: <span class="literal">false</span> &#125;)</span><br><span class="line">  ref.current.fn = fn</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 首次渲染不执行</span></span><br><span class="line">    <span class="keyword">if</span> (!ref.current.mounted) &#123;</span><br><span class="line">      ref.current.mounted = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.current.fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  useOnUpdate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dosomethingwith(props.a)</span><br><span class="line">  &#125;, [props.a])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>其他生命周期函数的模拟:</p><ul><li><code>shouldComponentUpdate</code> - React.memo包裹组件</li><li><code>componentDidCatch</code> - 暂不支持</li></ul><p><br><br><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="3-事件处理"><a href="#3-事件处理" class="headerlink" title="3. 事件处理"></a><strong>3. 事件处理</strong></h2><h3 id="3-1-usechange-简化onchange表单双向绑定"><a href="#3-1-usechange-简化onchange表单双向绑定" class="headerlink" title="3-1 useChange 简化onChange表单双向绑定"></a>3-1 useChange 简化onChange表单双向绑定</h3><p>表单值的双向绑定在项目中非常常见，通常我们的代码是这样的:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback&lt;React.ChangeEventHandler&lt;HTMLInputElement&gt;&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(evt.target.value)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;input value=&#123;value&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要维护多个表单，这种代码就会变得难以接受。幸好有Hooks，我们可以简化这些代码:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useChange</span>&lt;<span class="title">S</span>&gt;(<span class="params">initial?: S | (() =&gt; S)</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState&lt;S | <span class="literal">undefined</span>&gt;(initial)</span><br><span class="line">  <span class="keyword">const</span> onChange = useCallback(<span class="function"><span class="params">e</span> =&gt;</span> setValue(e.target.value), [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    setValue,</span><br><span class="line">    onChange,</span><br><span class="line">    <span class="comment">// 绑定到原生事件</span></span><br><span class="line">    bindEvent: &#123;</span><br><span class="line">      onChange,</span><br><span class="line">      value,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 绑定到自定义组件</span></span><br><span class="line">    bind: &#123;</span><br><span class="line">      onChange: setValue,</span><br><span class="line">      value,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userName = useChange(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> password = useChange(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input &#123;...userName.bindEvent&#125; /&gt;</span><br><span class="line">      &lt;input <span class="keyword">type</span>=<span class="string">"password"</span> &#123;...password.bindEvent&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-2-usebind-绑定回调参数"><a href="#3-2-usebind-绑定回调参数" class="headerlink" title="3-2 useBind 绑定回调参数"></a>3-2 useBind 绑定回调参数</h3><p>绑定一些回调参数，并利用useMemo给下级传递一个缓存的回调, 避免重新渲染:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useBind</span>(<span class="params">fn?: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>): (<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt; <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;fn &amp;&amp; fn.bind(<span class="literal">null</span>, ...args)&#125;, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;id, onClick&#125; = props</span><br><span class="line">  <span class="keyword">const</span> handleClick = useBind(onClick, id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;ComplexComponent onClick=&#123;handleClick&#125;&gt;&lt;<span class="regexp">/ComplexComponent&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 等价于</span></span><br><span class="line"><span class="regexp">function Demo(props) &#123;</span></span><br><span class="line"><span class="regexp">  const &#123;id, onClick&#125; = props</span></span><br><span class="line"><span class="regexp">  const handleClick = useCallback(() =&gt; onClick(id), [id])</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return &lt;ComplexComponent onClick=&#123;handleClick&#125;&gt;&lt;/</span>ComplexComponent&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-3-自定义事件封装"><a href="#3-3-自定义事件封装" class="headerlink" title="3-3 自定义事件封装"></a>3-3 自定义事件封装</h3><p>Hooks也可以用于封装一些高级事件或者简化事件的处理，比如拖拽、手势、鼠标Active/Hover等等；</p><p><br></p><h4 id="3-3-1-useactive"><a href="#3-3-1-useactive" class="headerlink" title="3-3-1 useActive"></a>3-3-1 useActive</h4><p>举个简单的例子, useActive, 在鼠标按下时设置状态为true，鼠标释放时恢复为false:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useActive</span>(<span class="params">refEl: React.RefObject&lt;HTMLElement&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="literal">false</span>)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleMouseDown = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setValue(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> handleMouseUp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setValue(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DOM 事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (refEl &amp;&amp; refEl.current) &#123;</span><br><span class="line">      refEl.current.addEventListener(<span class="string">'mousedown'</span>, handleMouseDown)</span><br><span class="line">      refEl.current.addEventListener(<span class="string">'mouseup'</span>, handleMouseUp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (refEl &amp;&amp; refEl.current) &#123;</span><br><span class="line">        refEl.current.removeEventListener(<span class="string">'mousedown'</span>, handleMouseDown)</span><br><span class="line">        refEl.current.removeEventListener(<span class="string">'mouseup'</span>, handleMouseUp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elRef = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> active = useActive(inputRef)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div ref=&#123;elRef&#125;&gt;&#123;active ? <span class="string">"Active"</span> : <span class="string">"Nop"</span>&#125;&lt;<span class="regexp">/div&gt;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="3-3-2-usetouch-手势事件封装"><a href="#3-3-2-usetouch-手势事件封装" class="headerlink" title="3-3-2 useTouch 手势事件封装"></a>3-3-2 useTouch 手势事件封装</h4><p>更复杂的自定义事件, 例如手势。限于篇幅就不列举它们的实现代码，我们可以看看它们的Demo:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;ref&#125; = useTouch(&#123;</span><br><span class="line">    onTap: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* 点击 */</span> &#125;,</span><br><span class="line">    onLongTap: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* 长按 */</span> &#125;,</span><br><span class="line">    onRotate: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* 旋转 */</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div className=<span class="string">"box"</span> ref=&#123;ref&#125;&gt;&lt;<span class="regexp">/div&gt;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useTouch的实现可以参考<a href="https://github.com/GDJiaMi/hooks/blob/master/src/useTouch.ts" target="_blank" rel="noopener">useTouch.ts</a></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="3-3-3-usedraggable-拖拽事件封装"><a href="#3-3-3-usedraggable-拖拽事件封装" class="headerlink" title="3-3-3 useDraggable 拖拽事件封装"></a>3-3-3 useDraggable 拖拽事件封装</h4><p>拖拽也是一个典型的自定义事件, 下面这个例子来源于<a href="https://stackblitz.com/edit/usedraggable" target="_blank" rel="noopener">这里</a></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDraggable</span>(<span class="params">ref: React.RefObject&lt;HTMLElement&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [&#123; dx, dy &#125;, setOffset] = useState(&#123; dx: <span class="number">0</span>, dy: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`[useDraggable] ref未注册到组件中`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> el = ref.current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleMouseDown = <span class="function">(<span class="params">event: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> startX = event.pageX - dx</span><br><span class="line">      <span class="keyword">const</span> startY = event.pageY - dy</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> handleMouseMove = <span class="function">(<span class="params">event: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newDx = event.pageX - startX</span><br><span class="line">        <span class="keyword">const</span> newDy = event.pageY - startY</span><br><span class="line">        setOffset(&#123; dx: newDx, dy: newDy &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, handleMouseMove)</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(</span><br><span class="line">        <span class="string">'mouseup'</span>,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">          <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, handleMouseMove)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; once: <span class="literal">true</span> &#125;,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    el.addEventListener(<span class="string">'mousedown'</span>, handleMouseDown)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      el.removeEventListener(<span class="string">'mousedown'</span>, handleMouseDown)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [dx, dy])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref.current) &#123;</span><br><span class="line">      ref.current.style.transform = <span class="string">`translate3d(<span class="subst">$&#123;dx&#125;</span>px, <span class="subst">$&#123;dy&#125;</span>px, 0)`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [dx, dy])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = useRef();</span><br><span class="line">  useDraggable(el);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"box"</span> ref=&#123;el&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可运行<a href="https://stackblitz.com/edit/usedraggable" target="_blank" rel="noopener">例子</a></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="3-3-4-react-events-面向未来的高级事件封装"><a href="#3-3-4-react-events-面向未来的高级事件封装" class="headerlink" title="3-3-4 react-events 面向未来的高级事件封装"></a>3-3-4 react-events 面向未来的高级事件封装</h4><p>我在<a href="https://juejin.im/post/5d44e3745188255d5861d654" target="_blank" rel="noopener">&lt;谈谈React事件机制和未来(react-events)&gt;</a>介绍了<code>React-Events</code>这个<strong>实验性</strong>的API。当这个API成熟后，我们可以基于它来实现更优雅的高级事件的封装：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PressResponder, usePressListener &#125; <span class="keyword">from</span> <span class="string">'react-events/press'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">const</span> listener = usePressListener(&#123;  <span class="comment">// ⚛️ 通过hooks创建Responder</span></span><br><span class="line">    onPressStart,</span><br><span class="line">    onPress,</span><br><span class="line">    onPressEnd,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div listeners=&#123;listener&#125;&gt;</span><br><span class="line">      &#123;subtrees&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-4-usesubscription-通用事件源订阅"><a href="#3-4-usesubscription-通用事件源订阅" class="headerlink" title="3-4 useSubscription 通用事件源订阅"></a>3-4 useSubscription 通用事件源订阅</h3><p>React官方维护了一个<a href="https://github.com/facebook/react/tree/master/packages/use-subscription" target="_blank" rel="noopener">use-subscription</a>包，支持使用Hooks的形式来监听事件源. 事件源可以是DOM事件、RxJS的Observable等等.</p><p>先来看看使用示例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听rxjs behaviorSubject</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = useMemo(</span><br><span class="line">    () =&gt; (&#123;</span><br><span class="line">      getCurrentValue: <span class="function"><span class="params">()</span> =&gt;</span> behaviorSubject.getValue(),</span><br><span class="line">      subscribe: <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当事件触发时调用callback</span></span><br><span class="line">        <span class="keyword">const</span> subscription = behaviorSubject.subscribe(callback);</span><br><span class="line">        <span class="comment">// 和useEffect一样，返回一个函数来取消订阅</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> subscription.unsubscribe();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 在behaviorSubject变化后重新订阅</span></span><br><span class="line">    [behaviorSubject]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value = useSubscription(subscription);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看看实现:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useSubscription</span>&lt;<span class="title">T</span>&gt;(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  getCurrentValue,</span></span></span><br><span class="line"><span class="function"><span class="params">  subscribe,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 获取当前值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  getCurrentValue?: () =&gt; T</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 用于订阅事件源</span></span></span></span><br><span class="line"><span class="function"><span class="params">  subscribe: (callback: <span class="built_in">Function</span>) =&gt; () =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; getCurrentValue, subscribe, value: getCurrentValue() &#125;))</span><br><span class="line">  <span class="keyword">let</span> valueToReturn = state.value</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新getCurrentValue和subscribe</span></span><br><span class="line">  <span class="keyword">if</span> (state.getCurrentValue !== getCurrentValue || state.subscribe !== subscribe) &#123;</span><br><span class="line">    valueToReturn = getCurrentValue()</span><br><span class="line">    setState(&#123; getCurrentValue, subscribe, value: valueToReturn &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> didUnsubscribe = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> checkForUpdates = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (didUnsubscribe) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 检查getCurrentValue和subscribe是否变动</span></span><br><span class="line">        <span class="comment">// setState时如果返回值没有变化，则不会触发重新渲染</span></span><br><span class="line">        <span class="keyword">if</span> (prevState.getCurrentValue !== getCurrentValue || prevState.subscribe !== subscribe) &#123;</span><br><span class="line">          <span class="keyword">return</span> prevState</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值没变动</span></span><br><span class="line">        <span class="keyword">const</span> value = getCurrentValue()</span><br><span class="line">        <span class="keyword">if</span> (prevState.value === value) &#123;</span><br><span class="line">          <span class="keyword">return</span> prevState</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123; ...prevState, value &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> unsubscribe = subscribe(checkForUpdates)</span><br><span class="line">    checkForUpdates()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      didUnsubscribe = <span class="literal">true</span></span><br><span class="line">      unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [getCurrentValue, subscribe])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> valueToReturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现也不复杂，甚至可以说有点啰嗦.</p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-5-useobservable-hooks和rxjs优雅的结合-rxjs-hooks"><a href="#3-5-useobservable-hooks和rxjs优雅的结合-rxjs-hooks" class="headerlink" title="3-5 useObservable Hooks和RxJS优雅的结合(rxjs-hooks)"></a>3-5 useObservable Hooks和RxJS优雅的结合(rxjs-hooks)</h3><p>如果要配合RxJS使用，LeetCode团队封装了一个<a href="https://github.com/LeetCode-OpenSource/rxjs-hooks/blob/master/README.md" target="_blank" rel="noopener">rxjs-hooks</a>库，用起来则要优雅很多, 非常推荐:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useObservable(<span class="function"><span class="params">()</span> =&gt;</span> interval(<span class="number">500</span>).pipe(map(<span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Incremental <span class="built_in">number</span>: &#123;value&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-6-useeventemitter-对接eventemitter"><a href="#3-6-useeventemitter-对接eventemitter" class="headerlink" title="3-6 useEventEmitter 对接eventEmitter"></a>3-6 useEventEmitter 对接eventEmitter</h3><p>我在<a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-3" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a>这篇文章里面提过：<strong>自定义 hook 和函数组件的代码结构基本一致, 所以有时候hooks 写着写着原来越像组件, 组件写着写着越像 hooks. 我觉得可以认为组件就是一种特殊的 hook, 只不过它输出 Virtual DOM</strong></p><p>Hooks跟组件一样，是一个逻辑和状态的聚合单元。可以维护自己的状态、有自己的’生命周期’.</p><p><code>useEventEmitter</code>就是一个典型的例子，可以独立地维护和释放自己的资源:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">function</span><span class="title">ReturnObject</span> = (<span class="params"></span>) =&gt; (<span class="params">&#123;&#125;</span>)</span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="function"><span class="keyword">function</span><span class="title">ReturnArray</span> = (<span class="params"></span>) =&gt; []</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEventEmitter</span>(<span class="params">emmiter: EventEmitter</span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">disposers</span> = <span class="title">useRef</span>&lt;<span class="title">Function</span>[]&gt;(<span class="params">[]</span>)</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">listeners</span> = <span class="title">useRef</span>&lt;</span>&#123; [<span class="title">name</span>: <span class="title">string</span>]: <span class="title">Function</span> &#125;&gt;(<span class="params">&#123;&#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">const</span> <span class="title">on</span> = <span class="title">useCallback</span>(<span class="params">&lt;P&gt;(name: <span class="built_in">string</span>, cb: (data: P) =&gt; <span class="built_in">void</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (!(name <span class="keyword">in</span> listeners.current)) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> call = (...args: <span class="built_in">any</span>[]) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> fn = listeners.current[name]</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> (fn) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">          fn(...args)</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="comment">// 监听eventEmitter</span></span></span></span><br><span class="line"><span class="function"><span class="params">      emmiter.on(name, call)</span></span></span><br><span class="line"><span class="function"><span class="params">      disposers.current.push(() =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        emmiter.off(name, call)</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    listeners.current[name] = cb</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">useEffect</span>(<span class="params">() =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// 资源释放</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> () =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      disposers.current.forEach(i =&gt; i())</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">return</span> </span>&#123;</span><br><span class="line">    on,</span><br><span class="line">    emit: emmiter.emit,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; on, emit &#125; = useEventEmitter(eventBus)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件监听</span></span><br><span class="line">  on(<span class="string">'someEvent'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 事件触发</span></span><br><span class="line">    emit(<span class="string">'anotherEvent'</span>, someData)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div onClick=&#123;handleClick&#125;&gt;...&lt;<span class="regexp">/div&gt;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>更多脑洞：</p><ul><li><a href="https://github.com/mfrachet/use-socketio" target="_blank" rel="noopener">use-socketio</a></li></ul><p><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="4-context的妙用"><a href="#4-context的妙用" class="headerlink" title="4. Context的妙用"></a><strong>4. Context的妙用</strong></h2><p>通过<a href="https://reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener"><code>useContext</code></a>可以方便地引用Context。不过需要注意的是如果上级<code>Context.Provider</code>的value变化，使用useContext的组件就会被强制重新渲染。</p><h3 id="4-1-usetheme-主题配置"><a href="#4-1-usetheme-主题配置" class="headerlink" title="4-1 useTheme 主题配置"></a>4-1 useTheme 主题配置</h3><p>原本需要使用高阶组件注入或Context.Consumer获取的Context值，现在变得非常简洁：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传统方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 通过高阶组件注入</span></span><br><span class="line">withTheme(MyComponent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取利用Context.Consumer</span></span><br><span class="line"><span class="keyword">const</span> MyComponentWithTheme = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;<span class="function"><span class="params">value</span> =&gt;</span> &lt;MyComponent theme=&#123;value&#125; &#123;...props&#125;&gt;&lt;<span class="regexp">/MyComponent&gt;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>ThemeContext.Consumer&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hooks方式</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext, FC &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext&lt;object&gt;(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeProvider: FC&lt;&#123; theme: object &#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;ThemeContext.Provider value=&#123;props.theme&#125;&gt;&#123;props.children&#125;&lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export function useTheme&lt;T extends object&gt;(): T &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(ThemeContext)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ---------</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ EXAMPLE</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ---------</span></span><br><span class="line"><span class="regexp">const theme = &#123;</span></span><br><span class="line"><span class="regexp">  primary: '#000',</span></span><br><span class="line"><span class="regexp">  secondary: '#444',</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemeProvider theme=&#123;theme&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;...&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeProvider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Button: FC = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const t = useTheme&lt;typeof theme&gt;()</span></span><br><span class="line"><span class="regexp">  const style = &#123;</span></span><br><span class="line"><span class="regexp">    color: t.primary,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return &lt;button style=&#123;style&#125;&gt;&#123;props.children&#125;&lt;/</span>button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="4-2-unstated-简单状态管理器"><a href="#4-2-unstated-简单状态管理器" class="headerlink" title="4-2 unstated 简单状态管理器"></a>4-2 unstated 简单状态管理器</h3><p>Hooks + Context 也可以用于实现简单的状态管理。</p><p>我在<a href="https://juejin.im/post/5ce3ee436fb9a07f070e0220#heading-2" target="_blank" rel="noopener">React组件设计实践总结05 - 状态管理</a>就提到过<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Funstated-next" target="_blank" rel="noopener">unstated-next</a>， 这个库只有主体代码十几行，<strong>利用了React本身的机制来实现状态管理</strong>.</p><p>先来看看使用示例</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContainer &#125; <span class="keyword">from</span> <span class="string">"unstated-next"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCounter</span>(<span class="params">initialState = 0</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [count, setCount] = useState(initialState)</span><br><span class="line">  <span class="keyword">let</span> decrement = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123; count, decrement, increment &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Counter = createContainer(useCounter)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterDisplay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = Counter.useContainer()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;counter.decrement&#125;&gt;-&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;&#123;counter.count&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;button onClick=&#123;counter.increment&#125;&gt;+&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看它的源码:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params">useHook</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只是创建一个Context</span></span><br><span class="line"><span class="keyword">let</span> Context = React.createContext(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Provider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> value = useHook(props.initialState)</span><br><span class="line"><span class="keyword">return</span> &lt;Context.Provider value=&#123;value&#125;&gt;&#123;props.children&#125;&lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function useContainer() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 只是使用useContext</span></span><br><span class="line"><span class="regexp">let value = React.useContext(Context)</span></span><br><span class="line"><span class="regexp">if (value === null) &#123;</span></span><br><span class="line"><span class="regexp">throw new Error("Component must be wrapped with &lt;Container.Provider&gt;")</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">return value</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return &#123; Provider, useContainer &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export function useContainer(container) &#123;</span></span><br><span class="line"><span class="regexp">return container.useContainer()</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>到这里，你会说，我靠，就这样? 这个库感觉啥事情都没干啊?</p><p>需要注意的是, <strong>Context不是万金油，它作为状态管理有一个比较致命的缺陷</strong>，我在<a href="https://juejin.im/post/5d045350f265da1b695d5bf2#heading-14" target="_blank" rel="noopener">浅谈React性能优化的方向</a>文章中也提到了这一点:<br><strong>它是可以穿透React.memo或者shouldComponentUpdate的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate</strong></p><p>所以如果你打算使用Context作为状态管理，一定要注意规避这一点. 它可能会导致组件频繁重新渲染.</p><p><br></p><p>其他状态管理方案:</p><ul><li><a href="https://github.com/ctrlplusb/easy-peasy" target="_blank" rel="noopener">easy-peasy</a></li><li><a href="https://github.com/dai-shi/react-hooks-global-state" target="_blank" rel="noopener">react-hooks-global-state</a></li></ul><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="4-3-usei18n-国际化"><a href="#4-3-usei18n-国际化" class="headerlink" title="4-3 useI18n 国际化"></a>4-3 useI18n 国际化</h3><p>I18n是另一个Context的典型使用场景。<a href="https://github.com/formatjs/react-intl/blob/master/docs/API.md#useintl-hook-currently-available-in-300-beta" target="_blank" rel="noopener">react-intl</a>和<a href="https://react.i18next.com/latest/usetranslation-hook" target="_blank" rel="noopener">react-i18next</a>都与时俱进，推出了自己的Hook API, <strong>基本上原本使用高阶组件(HOC)实现的功能都可以用Hooks代替，让代码变得更加简洁</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useTranslation &#125; <span class="keyword">from</span> <span class="string">'react-i18next'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; t, i18n &#125; = useTranslation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;t('my translated text')&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="4-4-userouter-简化路由状态的访问"><a href="#4-4-userouter-简化路由状态的访问" class="headerlink" title="4-4 useRouter 简化路由状态的访问"></a>4-4 useRouter 简化路由状态的访问</h3><p>React Hooks 推出已经接近一年，ReactRouter竟然还没有正式推出Hook API。不过它们也提上了计划 —— <a href="https://reacttraining.com/blog/reach-react-router-future/" target="_blank" rel="noopener">The Future of React Router and @reach/router</a>，5.X版本会推出Hook API. 我们暂时先看看一些代码示例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SomeComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 访问路由变量</span></span><br><span class="line">  <span class="keyword">const</span> &#123; userId &#125; = useParams()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePageViews</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 访问location对象</span></span><br><span class="line">  <span class="comment">// 原本对于非路由组件，需要访问路由信息需要通过withRouter高阶组件注入</span></span><br><span class="line">  <span class="keyword">const</span> &#123; location &#125; = useLocation()</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>, location.pathname)</span><br><span class="line">  &#125;, [location])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再等等吧!</p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="4-5-react-hook-form-hooks和表单能擦出什么火花"><a href="#4-5-react-hook-form-hooks和表单能擦出什么火花" class="headerlink" title="4-5 react-hook-form Hooks和表单能擦出什么火花?"></a>4-5 react-hook-form Hooks和表单能擦出什么火花?</h3><p><a href="https://github.com/react-hook-form/react-hook-form" target="_blank" rel="noopener">react-hook-form</a>是Hooks+Form的典型案例，比较符合我理想中的表单管理方式:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> useForm <span class="keyword">from</span> <span class="string">'react-hook-form'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; register, handleSubmit, errors &#125; = useForm(); <span class="comment">// initialise the hook</span></span><br><span class="line">  <span class="keyword">const</span> onSubmit = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;; <span class="comment">// callback when validation pass</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt;</span><br><span class="line">      &lt;input name=<span class="string">"firstname"</span> ref=&#123;register&#125; /&gt; &#123;<span class="comment">/* register an input */</span>&#125;</span><br><span class="line">      </span><br><span class="line">      &lt;input name=<span class="string">"lastname"</span> ref=&#123;register(&#123; <span class="attr">required</span>: <span class="literal">true</span> &#125;)&#125; /&gt;</span><br><span class="line">      &#123;errors.lastname &amp;&amp; <span class="string">'Last name is required.'</span>&#125;</span><br><span class="line">      </span><br><span class="line">      &lt;input name=<span class="string">"age"</span> ref=&#123;register(&#123; <span class="attr">pattern</span>: <span class="regexp">/\d+/</span> &#125;)&#125; /&gt;</span><br><span class="line">      &#123;errors.age &amp;&amp; <span class="string">'Please enter number for age.'</span>&#125;</span><br><span class="line">      </span><br><span class="line">      &lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><p><br></p><h2 id="5-副作用封装"><a href="#5-副作用封装" class="headerlink" title="5. 副作用封装"></a><strong>5. 副作用封装</strong></h2><p>我们可以<strong>利用Hooks来封装或监听组件外部的副作用，将它们转换为组件的状态</strong>。</p><p><br></p><h3 id="5-1-usetimeout-超时修改状态"><a href="#5-1-usetimeout-超时修改状态" class="headerlink" title="5-1 useTimeout 超时修改状态"></a>5-1 useTimeout 超时修改状态</h3><p>useTimeout由用户触发，在指定时间后恢复状态. 比如可以用于’短期禁用’按钮, 避免重复点击:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [disabled, start] = useTimeout(<span class="number">5000</span>)</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    start()</span><br><span class="line">    dosomething()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;Button onClick=&#123;handleClick&#125; disabled=&#123;disabled&#125;&gt;点我&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>实现:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTimeout</span>(<span class="params">ms: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ready, setReady] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> timerRef = useRef&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> start = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timerRef.current)</span><br><span class="line">    setReady(<span class="literal">true</span>)</span><br><span class="line">    timerRef.current = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setReady(<span class="literal">false</span>)</span><br><span class="line">    &#125;, ms)</span><br><span class="line">  &#125;, [ms])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stop = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timeRef.current)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  useOnUnmount(stop)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [ready, start, stop]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="5-2-useonlinestatus-监听在线状态"><a href="#5-2-useonlinestatus-监听在线状态" class="headerlink" title="5-2 useOnlineStatus 监听在线状态"></a>5-2 useOnlineStatus 监听在线状态</h3><p>副作用封装一个比较典型的案例就是监听主机的在线状态：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOnlineStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> navigator.onLine === <span class="string">'boolean'</span> ? navigator.onLine : <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnlineStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [onlineStatus, setOnlineStatus] = useState(getOnlineStatus())</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> online = <span class="function"><span class="params">()</span> =&gt;</span> setOnlineStatus(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> offline = <span class="function"><span class="params">()</span> =&gt;</span> setOnlineStatus(<span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, online)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, offline)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'online'</span>, online)</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'offline'</span>, offline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> onlineStatus</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> onlineStatus = useOnlineStatus();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;网络状态: &#123;onlineStatus ? <span class="string">"在线"</span> : <span class="string">"离线"</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>还有很多案例, 这里就不一一列举，读者可以自己尝试去实现，比如:</p><ul><li>useDeviceOrientation 监听设备方向</li><li>useGeolocation 监听GPS坐标变化</li><li>useScrollPosition 监听滚动位置</li><li>useMotion 监听设备运动</li><li>useMediaDevice 监听媒体设备</li><li>useDarkMode 夜间模式监听</li><li>useKeyBindings 监听快捷键</li><li>….</li></ul><p><br></p><p><a href="#">⤴️回到顶部</a></p><p><br></p><h2 id="6-副作用衍生"><a href="#6-副作用衍生" class="headerlink" title="6. 副作用衍生"></a><strong>6. 副作用衍生</strong></h2><p><strong>和<code>副作用封装</code>相反，副作用衍生是指当组件状态变化时，衍生出其他副作用. 两者的方向是相反的</strong>.</p><p>副作用衍生主要会用到useEffect，使用useEffect来响应状态的变化.</p><h3 id="6-1-usetitle-设置文档title"><a href="#6-1-usetitle-设置文档title" class="headerlink" title="6-1 useTitle 设置文档title"></a>6-1 useTitle 设置文档title</h3><p>useTitle是最简单的，当给定的值变化时，更新<code>document.title</code></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTitle</span>(<span class="params">t: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = t</span><br><span class="line">  &#125;, [t])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  useTitle(props.isEdit ? <span class="string">'编辑'</span> : <span class="string">'新增'</span>)</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="6-2-usedebounce"><a href="#6-2-usedebounce" class="headerlink" title="6-2 useDebounce"></a>6-2 useDebounce</h3><p>再来个复杂一点的，useDebounce：当某些状态变化时，它会延迟执行某些操作：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn: () =&gt; <span class="built_in">void</span>, args?: <span class="built_in">any</span>[], ms: <span class="built_in">number</span> = 100, skipMount?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mounted = useRef(<span class="literal">false</span>)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 跳过挂载执行</span></span><br><span class="line">    <span class="keyword">if</span> (skipMount &amp;&amp; !mounted.current) &#123;</span><br><span class="line">      mounted.current = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> timer = setTimeout(fn, ms)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果args变化，先清除计时器</span></span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="keyword">const</span> returnEmptyArray = <span class="function"><span class="params">()</span> =&gt;</span> []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState(returnEmptyArray)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索</span></span><br><span class="line">  <span class="keyword">const</span> handleSearch = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    setList(<span class="keyword">await</span> fetchList(query))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当query变化时执行搜索</span></span><br><span class="line">  useDebounce(handleSearch, [query], <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">    &lt;SearchBar value=&#123;query&#125; onChange=&#123;setQuery&#125; /&gt;</span><br><span class="line">    &lt;Result list=&#123;list&#125;&gt;&lt;<span class="regexp">/Result&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="6-3-usethrottle"><a href="#6-3-usethrottle" class="headerlink" title="6-3 useThrottle"></a>6-3 useThrottle</h3><p>同理可以实现useThrottle, 下面的例子来源于<a href="https://github.com/streamich/react-use/blob/master/src/useThrottleFn.ts" target="_blank" rel="noopener">react-use</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useThrottleFn = &lt;T&gt;<span class="function">(<span class="params">fn: (<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt; T, ms: <span class="built_in">number</span> = 200, args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState&lt;T&gt;(<span class="literal">null</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">  <span class="keyword">const</span> timeout = useRef&lt;<span class="built_in">any</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> nextArgs = useRef(<span class="literal">null</span>) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">const</span> hasNextArgs = useRef(<span class="literal">false</span>) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timeout.current) &#123;</span><br><span class="line">      setState(fn(...args));</span><br><span class="line">      <span class="keyword">const</span> timeoutCallback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNextArgs.current) &#123;</span><br><span class="line">          hasNextArgs.current = <span class="literal">false</span>;</span><br><span class="line">          setState(fn(...nextArgs.current));</span><br><span class="line">          timeout.current = setTimeout(timeoutCallback, ms);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          timeout.current = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      timeout.current = setTimeout(timeoutCallback, ms);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextArgs.current = args;</span><br><span class="line">      hasNextArgs.current = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, args);</span><br><span class="line"></span><br><span class="line">  useOnUnmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timeout.current);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><p><br></p><h2 id="7-简化业务逻辑"><a href="#7-简化业务逻辑" class="headerlink" title="7. 简化业务逻辑"></a><strong>7. 简化业务逻辑</strong></h2><p><strong>80%的程序员80%的时间在写业务代码</strong>. 有了Hooks，React开发者如获至宝. 组件的代码可以变得很精简，且这些Hooks可以方便地在组件之间复用:</p><p><img src="/images/react-hooks/hooks-transform.png" alt></p><p><br></p><p>下面介绍，如何利用Hooks来简化业务代码</p><h3 id="7-1-usepromise-封装异步请求"><a href="#7-1-usepromise-封装异步请求" class="headerlink" title="7-1 usePromise 封装异步请求"></a>7-1 usePromise 封装异步请求</h3><p>第一个例子，试试封装一下promise，简化简单页面异步请求的流程. 先来看看usePromise的使用示例，我理想中的usePromise应该长这样:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Demo() &#123;</span><br><span class="line">  const list = usePromise(async (id: string) =&gt; &#123;</span><br><span class="line">    return fetchList(id)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return (&lt;div&gt;</span><br><span class="line">    &#123;/* 触发请求 */&#125;</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; list.callIgnoreError(&apos;myId&apos;)&#125;&gt;Get List&lt;/button&gt;</span><br><span class="line">    &#123;/* 错误信息展示和重试 */&#125;</span><br><span class="line">    &#123;!!list.error &amp;&amp; &lt;ErrorMessage error=&#123;list.error&#125; retry=&#123;list.retry&#125;&gt;加载失败:&lt;/ErrorMessage&gt;&#125;</span><br><span class="line">    &#123;/* 加载状态 */&#125;</span><br><span class="line">    &lt;Loader loading=&#123;list.loading&#125;&gt;</span><br><span class="line">      &#123;/* 请求结果 */&#125;</span><br><span class="line">      &lt;Result value=&#123;list.value&#125;&gt;&lt;/Result&gt;</span><br><span class="line">    &lt;/Loader&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>usePromise是我用得比较多的一个Hooks，所以我把它完整的代码，包括Typescript注解都贴出来，供大家参考参考:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义usePromise的返回值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Res&lt;T, S&gt; &#123;</span><br><span class="line">  loading: <span class="built_in">boolean</span></span><br><span class="line">  error?: <span class="built_in">Error</span></span><br><span class="line">  value?: S</span><br><span class="line">  setValue: <span class="function">(<span class="params">v: S</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  call: T</span><br><span class="line">  callIgnoreError: T</span><br><span class="line">  reset: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  retry: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义usePromise 参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UsePromiseOptions &#123;</span><br><span class="line">  <span class="comment">// 如果promise正在加载中则跳过，默认为true</span></span><br><span class="line">  skipOnLoading?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👇 下面是一堆Typescript函数重载声明，为了方便Typescript推断泛型变量. 小白可以跳过</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>&gt;(<span class="params">action: () =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params"></span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>, <span class="title">A</span>&gt;(<span class="params">action: (arg0: A) =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">arg0: A</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">B</span>&gt;(<span class="params">action: (arg0: A, arg1: B) =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">arg0: A, arg1: B</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt;(<span class="params"> action: (arg0: A, arg1: B, arg2: C) =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">arg0: A, arg1: B, arg2: C</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;(<span class="params">action: (arg0: A, arg1: B, arg2: C, arg3: D) =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">arg0: A, arg1: B, arg2: C, arg3: D</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params">action: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">...args: <span class="built_in">any</span></span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">any</span>&gt;, <span class="title">any</span>&gt;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">// 👆 上面是一堆<span class="title">Typescript</span>函数重载声明，可以跳过</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">/**</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"> * 接受一个<span class="title">action</span>，用于执行异步操作</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"> */</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params"></span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  action: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;,</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  option: UsePromiseOptions = &#123; skipOnLoading: <span class="literal">true</span> &#125;,</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params"></span>): <span class="title">Res</span>&lt;(<span class="params">...args: <span class="built_in">any</span></span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">any</span>&gt;, <span class="title">any</span>&gt; </span>&#123;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">actionRef</span> = <span class="title">useRefProps</span>(<span class="params">action</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">optionRef</span> = <span class="title">useRefProps</span>(<span class="params">option</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> [<span class="title">loading</span>, <span class="title">setLoading</span>, <span class="title">loadingRef</span>] = <span class="title">useRefState</span>(<span class="params"><span class="literal">false</span></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">taskIdRef</span> = <span class="title">useRef</span>&lt;<span class="title">number</span>&gt;(<span class="params"></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">argsRef</span> = <span class="title">useRef</span>&lt;<span class="title">any</span>[]&gt;(<span class="params"></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> [<span class="title">value</span>, <span class="title">setValue</span>] = <span class="title">useState</span>(<span class="params"></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> [<span class="title">error</span>, <span class="title">setError</span>, <span class="title">errorRef</span>] = <span class="title">useRefState</span>&lt;<span class="title">Error</span> | <span class="title">undefined</span>&gt;(<span class="params"></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">caller</span> = <span class="title">useCallback</span>(<span class="params"><span class="keyword">async</span> (...args: <span class="built_in">any</span>[]) =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    argsRef.current = args</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">if</span> (loadingRef.current &amp;&amp; optionRef.current.skipOnLoading) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">return</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">const</span> taskId = getUid()</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    taskIdRef.current = taskId</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params"></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="comment">// 已经有新的任务在执行了，什么都不做</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">const</span> shouldContinue = () =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">if</span> (taskId !== taskIdRef.current) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        <span class="keyword">return</span> <span class="literal">false</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">return</span> <span class="literal">true</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params"></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">try</span> &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      setLoading(<span class="literal">true</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      setError(<span class="literal">undefined</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">const</span> res = <span class="keyword">await</span> actionRef.current(...args)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params"></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">if</span> (!shouldContinue()) <span class="keyword">return</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      setValue(res)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">return</span> res</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125; <span class="keyword">catch</span> (err) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">if</span> (shouldContinue()) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        setError(err)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">throw</span> err</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125; <span class="keyword">finally</span> &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">if</span> (shouldContinue()) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        setLoading(<span class="literal">false</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  &#125;, []</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  // 不抛出异常</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">callIgnoreError</span> = <span class="title">useCallback</span>(<span class="params"></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">async</span> (...args: <span class="built_in">any</span>[]) =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">try</span> &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        <span class="keyword">return</span> <span class="keyword">await</span> caller(...args)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125; <span class="keyword">catch</span> &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        <span class="comment">// ignore</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;,</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    [caller],</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  </span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">reset</span> = <span class="title">useCallback</span>(<span class="params">() =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    setLoading(<span class="literal">false</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    setValue(<span class="literal">undefined</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    setError(<span class="literal">undefined</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  &#125;, []</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  // 失败后重试</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">retry</span> = <span class="title">useCallback</span>(<span class="params">() =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">if</span> (argsRef.current &amp;&amp; errorRef.current) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">return</span> callIgnoreError(...argsRef.current)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(`not call yet`)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  &#125;, []</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">return</span> </span>&#123;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">loading</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">error</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">call</span>: <span class="title">caller</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">callIgnoreError</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">value</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">setValue</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">reset</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">retry</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  &#125;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="7-2-usepromiseeffect-自动进行异步请求"><a href="#7-2-usepromiseeffect-自动进行异步请求" class="headerlink" title="7-2 usePromiseEffect 自动进行异步请求"></a>7-2 usePromiseEffect 自动进行异步请求</h3><p>很多时候，我们是在组件一挂载或者某些状态变化时自动进行一步请求的，我们在usePromise的基础上，结合useEffect来实现自动调用:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了缩短篇幅，这里就不考虑跟usePromise一样的函数重载了</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">usePromiseEffect</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  action: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">Promise</span>&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  args?: <span class="built_in">any</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prom = usePromise(action)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用useEffect监听参数变动并执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    prom.callIgnoreError.apply(<span class="literal">null</span>, args)</span><br><span class="line">  &#125;, args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在挂载或者id变化时请求</span></span><br><span class="line">  <span class="keyword">const</span> list = usePromiseEffect(<span class="function">(<span class="params">id</span>) =&gt;</span> fetchById(id), [id])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同usePromise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，应该惊叹Hooks的抽象能力了吧！😸</p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="7-3-useinfinitelist-实现无限加载列表"><a href="#7-3-useinfinitelist-实现无限加载列表" class="headerlink" title="7-3 useInfiniteList 实现无限加载列表"></a>7-3 useInfiniteList 实现无限加载列表</h3><p>这里例子在之前的文章中也提及过</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useInfiniteList</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: (params: &#123; offset: <span class="built_in">number</span>; pageSize: <span class="built_in">number</span>; list: T[] &#125;) =&gt; <span class="built_in">Promise</span>&lt;T[]&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pageSize: <span class="built_in">number</span> = 20,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;T[]&gt;(returnEmptyArray)</span><br><span class="line">  <span class="comment">// 列表是否全部加载完毕</span></span><br><span class="line">  <span class="keyword">const</span> [hasMore, setHasMore, hasMoreRef] = useRefState(<span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 列表是否为空</span></span><br><span class="line">  <span class="keyword">const</span> [empty, setEmpty] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> promise = usePromise(<span class="function"><span class="params">()</span> =&gt;</span> fn(&#123; list, offset: list.length, pageSize &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> load = useCallback(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasMoreRef.current) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> promise.call()</span><br><span class="line">    <span class="keyword">if</span> (res.length &lt; pageSize) &#123;</span><br><span class="line">      setHasMore(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setList(<span class="function"><span class="params">l</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.length === <span class="number">0</span> &amp;&amp; l.length === <span class="number">0</span>) &#123;</span><br><span class="line">        setEmpty(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> [...l, ...res]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空列表</span></span><br><span class="line">  <span class="keyword">const</span> clean = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setList([])</span><br><span class="line">    setHasMore(<span class="literal">true</span>)</span><br><span class="line">    setEmpty(<span class="literal">false</span>)</span><br><span class="line">    promise.reset()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 刷新列表</span></span><br><span class="line">  <span class="keyword">const</span> refresh = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clean()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      load()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    list,</span><br><span class="line">    hasMore,</span><br><span class="line">    empty,</span><br><span class="line">    loading: promise.loading,</span><br><span class="line">    error: promise.error,</span><br><span class="line">    load,</span><br><span class="line">    refresh,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Item &#123;</span><br><span class="line">  id: <span class="built_in">number</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; load, list, hasMore, refresh &#125; = useInfiniteList&lt;Item&gt;<span class="function">(<span class="params"><span class="keyword">async</span> (<span class="params">&#123; offset, pageSize &#125;</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> list = []</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> (<span class="params"><span class="keyword">let</span> i = offset; i &lt; offset + pageSize; i++</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">if</span> (<span class="params">i === 200</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">break</span></span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      list.push(<span class="params">&#123; id: i, name: `$&#123;i&#125;-----` &#125;</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> list</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">useEffect</span>(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    load(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;div className="App"&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">      &lt;button onClick=&#123;refresh&#125;&gt;Refresh&lt;/button&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;list.map(<span class="params">i =&gt; (<span class="params"></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        &lt;div key=&#123;i.id&#125;&gt;&#123;i.name&#125;&lt;/div&gt;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">      </span>)</span>)&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;hasMore ? &lt;button onClick=&#123;load&#125;&gt;Load more&lt;/button&gt; : &lt;div&gt;No more&lt;/div&gt;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;/div&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="7-4-usepoll-用hook实现轮询"><a href="#7-4-usepoll-用hook实现轮询" class="headerlink" title="7-4 usePoll 用hook实现轮询"></a>7-4 usePoll 用hook实现轮询</h3><p>下面使用Hooks实现一个定时轮询器</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UsePollOptions&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 决定是否要继续轮询</span></span><br><span class="line"><span class="comment">   * @param arg 上一次轮询返回的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  condition: <span class="function">(<span class="params">arg?: T, error?: <span class="built_in">Error</span></span>) =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">boolean</span>&gt;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 轮询操作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  poller: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>&lt;T&gt;</span><br><span class="line">  onError?: <span class="function">(<span class="params">err: <span class="built_in">Error</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 轮询间隔. 默认 5000</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  duration?: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听的参数，当这些参数变化时，重新检查轮询条件，决定是否继续轮询</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  args?: <span class="built_in">any</span>[]</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否立即轮询</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  immediately?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现页面轮询机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">usePoll</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params">options: UsePollOptions&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [polling, setPolling, pollingRef] = useRefState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState&lt;<span class="built_in">Error</span>&gt;()</span><br><span class="line">  <span class="keyword">const</span> state = useInstance&lt;&#123; timer?: <span class="built_in">number</span>; unmounted?: <span class="built_in">boolean</span> &#125;&gt;(&#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> optionsRef = useRefProps(options)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> poll = useCallback(<span class="keyword">async</span> (immediate?: <span class="built_in">boolean</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 已经卸载，或其他轮询器正在轮询</span></span><br><span class="line">    <span class="keyword">if</span> (state.unmounted || pollingRef.current) <span class="keyword">return</span></span><br><span class="line">    setPolling(<span class="literal">true</span>)</span><br><span class="line">    state.timer = <span class="built_in">window</span>.setTimeout(</span><br><span class="line">      <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.unmounted) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res: T | <span class="literal">undefined</span></span><br><span class="line">          <span class="keyword">let</span> error: <span class="built_in">Error</span> | <span class="literal">undefined</span></span><br><span class="line">          setError(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            res = <span class="keyword">await</span> optionsRef.current.poller()</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            error = err</span><br><span class="line">            setError(err)</span><br><span class="line">            <span class="keyword">if</span> (optionsRef.current.onError) &#123;</span><br><span class="line">              optionsRef.current.onError(err)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 准备下一次轮询</span></span><br><span class="line">          <span class="keyword">if</span> (!state.unmounted &amp;&amp; (<span class="keyword">await</span> optionsRef.current.condition(res, error))) &#123;</span><br><span class="line">            setTimeout(poll)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          !state.unmounted &amp;&amp; setPolling(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate ? <span class="number">0</span> : optionsRef.current.duration || <span class="number">5000</span>,</span><br><span class="line">    )</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  useOnUpdate(</span><br><span class="line">    <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">await</span> optionsRef.current.condition()) poll(options.immediately)</span><br><span class="line">    &#125;,</span><br><span class="line">    options.args || [],</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  useOnUnmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    state.unmounted = <span class="literal">true</span></span><br><span class="line">    clearTimeout(state.timer)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; polling, error &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">')</span></span><br><span class="line"><span class="string">  const [result, setResult] = useState&lt;Result&gt;()</span></span><br><span class="line"><span class="string">  usePoll(&#123;</span></span><br><span class="line"><span class="string">    poller: await() =&gt; &#123;</span></span><br><span class="line"><span class="string">      const res =await fetch(query)</span></span><br><span class="line"><span class="string">      setResult(res)</span></span><br><span class="line"><span class="string">      return res</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    condition: async () =&gt; &#123;</span></span><br><span class="line"><span class="string">      return query !== '</span><span class="string">'</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    args: [query],</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="7-5-业务逻辑抽离"><a href="#7-5-业务逻辑抽离" class="headerlink" title="7-5 业务逻辑抽离"></a>7-5 业务逻辑抽离</h3><p>通过上面的案例可以看到, Hooks非常适合用于抽离重复的业务逻辑。</p><p>在<a href="https://juejin.im/post/5cd8fb916fb9a03218556fc1#heading-6" target="_blank" rel="noopener">React组件设计实践总结02 - 组件的组织</a>介绍了容器组件和展示组件分离，Hooks时代，<strong>我们可以自然地将逻辑都放置到Hooks中，实现逻辑和视图的分离</strong>。</p><p>抽离的后业务逻辑可以复用于不同的’展示平台’, 例如 web 版和 native 版:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Login/</span><br><span class="line">  useLogin.ts   // 将所有逻辑都抽取到Hooks中</span><br><span class="line">  index.web.tsx // 只保留视图</span><br><span class="line">  index.tsx</span><br></pre></td></tr></table></figure><p><br><br><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="8-开脑洞"><a href="#8-开脑洞" class="headerlink" title="8. 开脑洞"></a><strong>8. 开脑洞</strong></h2><p>一些奇奇怪怪的东西，不知道怎么分类。作者想象力非常丰富!</p><h3 id="8-1-usescript-hooks-suspend-❤️"><a href="#8-1-usescript-hooks-suspend-❤️" class="headerlink" title="8-1 useScript: Hooks + Suspend = ❤️"></a>8-1 useScript: Hooks + Suspend = ❤️</h3><p>这个案例来源于<a href="https://github.com/palmerhq/the-platform#usescript" target="_blank" rel="noopener">the-platform</a>, 使用script标签来加载外部脚本:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意: 这还是实验性特性</span></span><br><span class="line"><span class="keyword">import</span> &#123;createResource&#125; <span class="keyword">from</span> <span class="string">'react-cache'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ScriptResource = createResource(<span class="function">(<span class="params">src: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line">    script.onload = <span class="function"><span class="params">()</span> =&gt;</span> resolve(script);</span><br><span class="line">    script.onerror = reject;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useScript</span>(<span class="params">options: &#123; src: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ScriptResource.read(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useScript &#125; <span class="keyword">from</span> <span class="string">'the-platform'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   useScript(&#123; src: <span class="string">'bundle.js'</span> &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Suspend</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Suspense fallback=&#123;<span class="string">'loading...'</span>&#125;&gt;&lt;Example&gt;&lt;<span class="regexp">/Example&gt;&lt;/</span>Suspense&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理还可以实现</p><ul><li><a href="https://github.com/palmerhq/the-platform/blob/master/src/Stylesheet.tsx" target="_blank" rel="noopener">useStylesheet</a> 用于加载样式表</li><li><a href="https://github.com/CharlesStover/fetch-suspense" target="_blank" rel="noopener">fetch-suspense</a></li></ul><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="8-2-usemodal-模态框数据流管理"><a href="#8-2-usemodal-模态框数据流管理" class="headerlink" title="8-2 useModal 模态框数据流管理"></a>8-2 useModal 模态框数据流管理</h3><p>我在<a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-6" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a>也举到一个使用<code>Hooks + Context</code>来巧妙实现模态框管理的例子。</p><p>先来看看如何使用Context来渲染模态框, 很简单, ModalContext.Provider给下级组件暴露一个render方法，通过这个方法来传递需要渲染的模态框组件和props:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模态框组件要实现的接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> BaseModalProps &#123;</span><br><span class="line">  visible: <span class="built_in">boolean</span></span><br><span class="line">  onHide: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ModalContextValue &#123;</span><br><span class="line">  render(Component: React.ComponentType&lt;<span class="built_in">any</span>&gt;, props: <span class="built_in">any</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = React.createContext&lt;ModalContextValue&gt;(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"useModal 必须在ModalRenderer 下级"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模态框渲染器</span></span><br><span class="line"><span class="keyword">const</span> ModalRenderer: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [modal, setModal] = useState&lt;</span><br><span class="line">    | &#123; Comp: React.ComponentType&lt;<span class="built_in">any</span>&gt;; props: <span class="built_in">any</span>; visible?: <span class="built_in">boolean</span> &#125;</span><br><span class="line">    | <span class="literal">undefined</span></span><br><span class="line">  &gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hide = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setModal(<span class="function"><span class="params">prev</span> =&gt;</span> prev &amp;&amp; &#123; ...prev, visible: <span class="literal">false</span> &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由下级组件调用，传递需要渲染的组件和props</span></span><br><span class="line">  <span class="keyword">const</span> render = useCallback&lt;ModalContextValue[<span class="string">"render"</span>]&gt;<span class="function">(<span class="params">(<span class="params">Comp, props</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    setModal(<span class="params">&#123; Comp, props, visible: <span class="literal">true</span> &#125;</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">value</span> = <span class="params">useMemo</span>(<span class="params">(<span class="params"></span>) =&gt; (<span class="params">&#123;render&#125;</span>), []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;Context.Provider value=&#123;value&#125;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;props.children&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &lt;div className="modal-container"&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#123;<span class="comment">/*模态框渲染 */</span>&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#123;!!modal &amp;&amp;</span></span></span><br><span class="line"><span class="function"><span class="params">          React.createElement(<span class="params">modal.Comp, &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            ...modal.props,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            visible: modal.visible,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            onHide: hide,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span>)&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &lt;/div&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;/Context.Provider&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>再看看Hooks的实现, 也很简单，就是使用useContext来访问ModalContext， 并调用render方法:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useModal</span>&lt;<span class="title">P</span> <span class="title">extends</span> <span class="title">BaseModalProps</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Modal: React.ComponentType&lt;P&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> renderer = useContext(Context)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> useCallback(</span><br><span class="line">    (props: Omit&lt;P, keyof BaseModalProps&gt;) =&gt; &#123;</span><br><span class="line">      renderer.render(Modal, props || &#123;&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    [Modal],</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyModal: FC&lt;BaseModalProps &amp; &#123; a: <span class="built_in">number</span> &#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Modal visible=&#123;props.visible&#125; onOk=&#123;props.onHide&#125; onCancel=&#123;props.onHide&#125;&gt;</span><br><span class="line">      &#123;props.a&#125;</span><br><span class="line">    &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Home: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const showMyModal = useModal(MyModal)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  const handleShow = useCallback(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 显示模态框</span></span><br><span class="line"><span class="regexp">    showMyModal(&#123;</span></span><br><span class="line"><span class="regexp">      a: 123,</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;, [])</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      showMyModal: &lt;button onClick=&#123;handleShow&#125;&gt;show&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可运行的完整示例可以看<a href="https://codesandbox.io/s/lryom9617l?fontsize=14" target="_blank" rel="noopener">这里</a></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="react-hooks-技术地图"><a href="#react-hooks-技术地图" class="headerlink" title="React Hooks 技术地图"></a><strong>React Hooks 技术地图</strong></h2><p><strong>全家桶和Hooks的结合</strong>:</p><ul><li><a href="https://react-redux.js.org/api/hooks" target="_blank" rel="noopener">Redux + Hooks</a></li><li><a href="https://github.com/mobxjs/mobx-react-lite" target="_blank" rel="noopener">Mobx + Hooks</a></li><li><a href="https://www.react-spring.io/docs/hooks/basics" target="_blank" rel="noopener">ReactSpring + Hooks</a></li><li><a href="https://www.apollographql.com/docs/react/api/react-hooks/" target="_blank" rel="noopener">Appoll</a></li><li><a href="https://react.i18next.com/latest/usetranslation-hook" target="_blank" rel="noopener">react-i18next</a></li><li><a href="https://reacttraining.com/blog/reach-react-router-future/" target="_blank" rel="noopener">react-router</a> Come in soon</li></ul><p><br></p><p><strong>一些有趣的Hooks集合</strong>:</p><ul><li><a href="https://github.com/palmerhq/the-platform#usescript" target="_blank" rel="noopener">the-platform</a></li><li><a href="https://github.com/streamich/react-use" target="_blank" rel="noopener">react-use</a></li><li><a href="https://github.com/rehooks/ideas/issues" target="_blank" rel="noopener">rehooks/ideas</a> 一起开脑洞</li><li><a href="https://github.com/kitze/react-hanger" target="_blank" rel="noopener">react-hanger</a></li></ul><p><br></p><p><strong>Awesome</strong></p><ul><li><a href="https://github.com/rehooks/awesome-react-hooks" target="_blank" rel="noopener">Awesome React Hooks</a></li><li><a href="https://www.hooks.guide/rehooks/useComponentSize" target="_blank" rel="noopener">Hooks.Guide</a></li><li><a href="https://usehooks.com/" target="_blank" rel="noopener">useHooks</a></li></ul><p><br></p><p><strong>FAQ</strong></p><ul><li><a href="https://zh-hans.reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">官方Hooks FAQ</a> 可以解答大部分的疑问</li></ul><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文篇幅很长、代码很多。能滑到这里相当不容易, 给你点个赞。</p><p>你用React Hook遇到过什么问题？ 开过什么脑洞，下方评论告诉我.</p><p>欢迎关注我, 和我交流. 我有社恐, 但想多交些圈内朋友(<code>atob(&#39;YmxhbmstY2FybmV5&#39;)</code>, 备注掘金，我不喝茶，近期也不换工作)</p><p>本文完!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/react-hooks/cover.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.youtube.com/channel/UCz5vTaEhvh7dOHEyd
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>100来行代码, 自己动手写一个模板引擎</title>
    <link href="https://bobi.ink/2019/08/09/ejs/"/>
    <id>https://bobi.ink/2019/08/09/ejs/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-14T01:29:53.703Z</updated>
    
    <content type="html"><![CDATA[<p>一张图说明Ejs模板引擎的原理</p><p><img src="/images/ejs/ejs.png" alt></p><p><br></p><p>上面一张图，已经大概把一个简单模板引擎(这里以<a href="https://ejs.co/" target="_blank" rel="noopener">EJS</a>为例)的原理解释得七七八八了。本文将描述一个简单的模板引擎是怎么运作的？包含实现的关键步骤、以及其背后的思想。</p><p>基本上模板引擎的套路也就这样了，但这些思想是通用的，比如你在看vue的模板编译器源码、也可以套用这些思想和方法.</p><p><br></p><h2 id="基本api设计"><a href="#基本api设计" class="headerlink" title="基本API设计"></a>基本API设计</h2><p>我们将实现一个简化版的EJS, 这个模板引擎支持这些标签:</p><ul><li><p><code>&lt;% script %&gt;</code> - 脚本执行. 一般用于控制语句，不会输出值 例如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">user</span>) &#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>some thing<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;%= expression %&gt;</code> - 输出表达式的值，但是会转义HTML:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;%= title %&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;%- expression %&gt;</code> -  和<code>&lt;%= expr %&gt;</code>一样，只不过不会对HTML进行转义</p></li><li><code>&lt;%%</code> 和<code>%%&gt;</code> - 表示标签转义, 比如<code>&lt;%%</code>会输出为<code>&lt;%</code></li><li><code>&lt;%# 注释 %&gt;</code> - 不会有内容输出</li></ul><p><br></p><p>下面是一个完整的模板示例，下文会基于这个模板进行讲解:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%%</span> 转义 %%&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%#</span> 这里是注释 %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">before</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">show</span>) &#123; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>root<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>基本API设计</strong></p><p>我们将模板解析和渲染相关的逻辑放到一个Template类中，它的基本接口如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Template &#123;</span><br><span class="line">  <span class="keyword">public</span> template: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> tokens: <span class="built_in">string</span>[] = [];</span><br><span class="line">  <span class="keyword">private</span> source: <span class="built_in">string</span> = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">private</span> state?: State;</span><br><span class="line">  <span class="keyword">private</span> fn?: <span class="built_in">Function</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">template: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.template = template;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 模板编译</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> compile() &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseTemplateText();</span><br><span class="line">    <span class="keyword">this</span>.transformTokens();</span><br><span class="line">    <span class="keyword">this</span>.wrapit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 渲染方法，由用户指定一个对象来渲染字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> render(local: object) &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * token解析</span></span><br><span class="line"><span class="comment">   * 将&lt;% if (codintion) &#123; %&gt;</span></span><br><span class="line"><span class="comment">   * 解析为token数组，例如['&lt;%', ' if (condition) &#123; ', '%&gt;']</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> parseTemplateText() &#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将Token转换为Javascript语句</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> transformTokens() &#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将上一个步骤转换出来的Javascript语句，封装成一个渲染方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> wrapit() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="token解析"><a href="#token解析" class="headerlink" title="token解析"></a>token解析</h2><p>第一步我们需要将所有的开始标签(start tag)和结束标签(end tag)都解析出来，我们期望的解析结果是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"\n&lt;html&gt;\n  &lt;head&gt;"</span>,</span><br><span class="line">  <span class="string">"&lt;%="</span>,</span><br><span class="line">  <span class="string">" title "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"&lt;/head&gt;\n  &lt;body&gt;\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%%"</span>,</span><br><span class="line">  <span class="string">" 转义 "</span>,</span><br><span class="line">  <span class="string">"%%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%#"</span>,</span><br><span class="line">  <span class="string">" 这里是注释 "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%-"</span>,</span><br><span class="line">  <span class="string">" before "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%"</span>,</span><br><span class="line">  <span class="string">" if (show) &#123; "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n      &lt;div&gt;root&lt;/div&gt;\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%"</span>,</span><br><span class="line">  <span class="string">" &#125; "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n  &lt;/body&gt;\n&lt;/html&gt;\n"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>因为我们的模板引擎语法非常简单, 压根就不需要解析成什么抽象语法树(AST)(即省去了语法解析, 只进行词法解析). 直接通过<code>正则表达式</code>就可以实现将标签抽取出来。</p><p>先定义正则表达式, 用来匹配我们所有支持的标签：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;%% %%&gt; 用于转义</span></span><br><span class="line"><span class="comment">// &lt;% 脚本</span></span><br><span class="line"><span class="comment">// &lt;%= 输出脚本值</span></span><br><span class="line"><span class="comment">// &lt;%- 输出脚本值，unescape</span></span><br><span class="line"><span class="comment">// &lt;%# 注释</span></span><br><span class="line"><span class="comment">// %&gt; 结束标签</span></span><br><span class="line"><span class="keyword">const</span> REGEXP = <span class="regexp">/(&lt;%%|%%&gt;|&lt;%=|&lt;%-|&lt;%#|&lt;%|%&gt;)/</span>;</span><br></pre></td></tr></table></figure><p>使用正则表达式逐个进行匹配，将字符串拆分出来. 代码也很简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseTemplateText() &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="keyword">this</span>.template;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">this</span>.tokens;</span><br><span class="line">  <span class="comment">// 通过exec方法可以获取匹配的位置, 如果匹配失败则返回null</span></span><br><span class="line">  <span class="keyword">let</span> res = REGEXP.exec(str);</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (res) &#123;</span><br><span class="line">    index = res.index;</span><br><span class="line">    <span class="comment">// 前置字符串</span></span><br><span class="line">    <span class="keyword">if</span> (index !== <span class="number">0</span>) &#123;</span><br><span class="line">      arr.push(str.substring(<span class="number">0</span>, index));</span><br><span class="line">      str = str.slice(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.push(res[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 截断字符串，继续匹配</span></span><br><span class="line">    str = str.slice(res[<span class="number">0</span>].length);</span><br><span class="line">    res = REGEXP.exec(str);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (str) &#123;</span><br><span class="line">    arr.push(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="简单的语法检查"><a href="#简单的语法检查" class="headerlink" title="简单的语法检查"></a>简单的语法检查</h2><p>Ok，将标签解析出来后，就可以开始准备将它们转换称为‘渲染’函数了.</p><p>首先进行一下<strong>简单的语法检查</strong>，检查标签是否<strong>闭合</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> start = <span class="string">"&lt;%"</span>;           <span class="comment">// 开始标签</span></span><br><span class="line"><span class="keyword">const</span> end = <span class="string">"%&gt;"</span>;             <span class="comment">// 结束标签</span></span><br><span class="line"><span class="keyword">const</span> escpStart = <span class="string">"&lt;%%"</span>;      <span class="comment">// 开始标签转义</span></span><br><span class="line"><span class="keyword">const</span> escpEnd = <span class="string">"%%&gt;"</span>;        <span class="comment">// 结束标签转义</span></span><br><span class="line"><span class="keyword">const</span> escpoutStart = <span class="string">"&lt;%="</span>;   <span class="comment">// 转义的表达式输出</span></span><br><span class="line"><span class="keyword">const</span> unescpoutStart = <span class="string">"&lt;%-"</span>; <span class="comment">// 不转义的表达式输出</span></span><br><span class="line"><span class="keyword">const</span> comtStart = <span class="string">"&lt;%#"</span>;      <span class="comment">// 注释</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tok.includes(start) &amp;&amp; !tok.includes(escpStart)) &#123;</span><br><span class="line">  closing = <span class="keyword">this</span>.tokens[idx + <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (closing == <span class="literal">null</span> || !closing.includes(end)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;tok&#125;</span> 未找到对应的闭合标签`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>现在开始遍历token。我们可以使用一个有限的状态机(Finite-state machine, FSM)来描述转换的逻辑.</p><p><code>状态机</code>是表示<strong>有限个状态以及在这些状态之间的转移和动作等行为的数学模型</strong>。简单而言，有限状态机由一组状态、一个初始状态、输入和根据输入及现有状态转换为下一个状态的转换函数组成。它有三个特征:</p><ul><li>状态总数是有限的。</li><li>任一时刻，只处在一种状态之中。</li><li>某种条件下，会从一种状态转变到另一种状态</li></ul><p><br></p><p>稍微分析一下，我们模板引擎的状态转换图如下:</p><p><img src="/images/ejs/state.png" alt></p><p><br></p><p>通过上图可以抽取出以下状态:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum State &#123;</span><br><span class="line">  EVAL,    <span class="comment">// 脚本执行</span></span><br><span class="line">  ESCAPED, <span class="comment">// 表达式输出</span></span><br><span class="line">  RAW,     <span class="comment">// 表达式输出不转义</span></span><br><span class="line">  COMMENT, <span class="comment">// 注释</span></span><br><span class="line">  LITERAL  <span class="comment">// 字面量，直接输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Ok, 现在开始遍历token:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.tokens.forEach(<span class="function">(<span class="params">tok, idx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> (tok) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标签识别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> start:</span><br><span class="line">      <span class="comment">// 脚本开始</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.EVAL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> escpoutStart:</span><br><span class="line">      <span class="comment">// 转义输出</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.ESCAPED;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> unescpoutStart:</span><br><span class="line">      <span class="comment">// 非转义输出</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.RAW;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> comtStart:</span><br><span class="line">      <span class="comment">// 注释</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.COMMENT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> escpStart:</span><br><span class="line">      <span class="comment">// 标签转义</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.LITERAL;</span><br><span class="line">      <span class="keyword">this</span>.source += <span class="string">`;__append('&lt;%');\n`</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> escpEnd:</span><br><span class="line">      <span class="keyword">this</span>.state = State.LITERAL;</span><br><span class="line">      <span class="keyword">this</span>.source += <span class="string">`;__append('%&gt;');\n`</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> end:</span><br><span class="line">      <span class="comment">// 恢复初始状态</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 转换输出</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">          <span class="keyword">case</span> State.EVAL:</span><br><span class="line">            <span class="comment">// 代码</span></span><br><span class="line">            <span class="keyword">this</span>.source += <span class="string">`;<span class="subst">$&#123;tok&#125;</span>\n`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> State.ESCAPED:</span><br><span class="line">            <span class="comment">// stripSemi 将多余的分号移除</span></span><br><span class="line">            <span class="keyword">this</span>.source += <span class="string">`;__append(escapeFn(<span class="subst">$&#123;stripSemi(tok)&#125;</span>));\n`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> State.RAW:</span><br><span class="line">            <span class="keyword">this</span>.source += <span class="string">`;__append(<span class="subst">$&#123;stripSemi(tok)&#125;</span>);\n`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> State.LITERAL:</span><br><span class="line">            <span class="comment">// 因为我们把字符串放到单引号中，所以transformString将tok中的单引号、换行符、转义符进行转移</span></span><br><span class="line">            <span class="keyword">this</span>.source += <span class="string">`;__append('<span class="subst">$&#123;transformString(tok)&#125;</span>');\n`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> State.COMMENT:</span><br><span class="line">            <span class="comment">// 什么都不做</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 字面量</span></span><br><span class="line">        <span class="keyword">this</span>.source += <span class="string">`;__append('<span class="subst">$&#123;transformString(tok)&#125;</span>');\n`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>经过上面的转换，我们可以得到这样的结果:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;__append(<span class="string">'\n&lt;html&gt;\n  &lt;head&gt;'</span>);</span><br><span class="line">;__append(escapeFn( title ));</span><br><span class="line">;__append(<span class="string">'&lt;/head&gt;\n  &lt;body&gt;\n    '</span>);</span><br><span class="line">;__append(<span class="string">'&lt;%'</span>);</span><br><span class="line">;__append(<span class="string">' 转义 '</span>);</span><br><span class="line">;__append(<span class="string">'%&gt;'</span>);</span><br><span class="line">;__append(<span class="string">'\n    '</span>);</span><br><span class="line">;__append(<span class="string">'\n    '</span>);</span><br><span class="line">;__append( before );</span><br><span class="line">;__append(<span class="string">'\n    '</span>);</span><br><span class="line">; <span class="keyword">if</span> (show) &#123;</span><br><span class="line">;__append(<span class="string">'\n      &lt;div&gt;root&lt;/div&gt;\n    '</span>);</span><br><span class="line">; &#125;</span><br><span class="line">;__append(<span class="string">'\n  &lt;/body&gt;\n&lt;/html&gt;\n'</span>);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="最后一步，生成函数"><a href="#最后一步，生成函数" class="headerlink" title="最后一步，生成函数"></a>最后一步，生成函数</h2><p>现在我们把转换结果包裹成函数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrapit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.source = <span class="string">`\</span></span><br><span class="line"><span class="string">const __out = [];</span></span><br><span class="line"><span class="string">const __append = __out.push.bind(__out);</span></span><br><span class="line"><span class="string">with(local||&#123;&#125;) &#123;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="keyword">this</span>.source&#125;</span></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return __out.join('');\</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">    <span class="keyword">this</span>.fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"local"</span>, <span class="string">"escapeFn"</span>, <span class="keyword">this</span>.source);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里使用到了<code>with</code>语句，来包裹上面转换的代码，这样可以免去local对象访问限定前缀。</p><p>渲染方法就很简单了，直接调用上面包裹的函数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render(local: object) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.fn.call(<span class="literal">null</span>, local, <span class="built_in">escape</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = <span class="keyword">new</span> Template(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;&lt;%= title %&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;%% 转义 %%&gt;</span></span><br><span class="line"><span class="string">    &lt;%# 这里是注释 %&gt;</span></span><br><span class="line"><span class="string">    &lt;%- before %&gt;</span></span><br><span class="line"><span class="string">    &lt;% if (show) &#123; %&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;root&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line">temp.compile();</span><br><span class="line">temp.render(&#123; <span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">title</span>: <span class="string">"hello"</span>, <span class="attr">before</span>: <span class="string">"&lt;div&gt;xx&lt;/div&gt;"</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;html&gt;</span></span><br><span class="line"><span class="comment">//   &lt;head&gt;hello&lt;/head&gt;</span></span><br><span class="line"><span class="comment">//   &lt;body&gt;</span></span><br><span class="line"><span class="comment">//     &lt;% 转义 %&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;xx&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//       &lt;div&gt;root&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;/body&gt;</span></span><br><span class="line"><span class="comment">// &lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>你可以在CodeSandbox运行完整的代码:</p><p><a href="https://codesandbox.io/s/ejs-wp11m?fontsize=14" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit ejs"></a></p><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文其实受到了<a href="https://github.com/jamiebuilds/the-super-tiny-compiler" target="_blank" rel="noopener">the-super-tiny-compiler</a>启发，实现了一个极简的模板引擎，其实模板引擎本质上也是一个Compiler，通过上文可以了解到一个模板引擎编译有三个步骤：</p><ol><li><p><strong>解析</strong> 将模板代码解析成抽象的表示形式。复杂的编译器会有<code>词法解析(Lexical Analysis)</code>和<code>语法解析(Syntactic Analysis)</code></p><p> <strong>词法解析</strong>, 上文我们将模板内容解析成token的过程就可以认为是‘词法解析’，它会将源代码拆分称为token数组，token是一个小单元，表示独立的‘语法片段’。</p><p> <strong>语法解析</strong>，语法解析器接收token数组，将它们重新格式化称为抽象语法树(Abstract Syntax Tree, AST), 抽象语法树可以用于描述语法单元, 以及单元之间的关系。 语法解析阶段可以发现语法问题。</p><p> <img src="/images/ejs/ast.png" alt></p><p> (图片来源: <a href="https://ruslanspivak.com/lsbasi-part7" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part7</a>)</p><p> 本文介绍的模板引擎，因为语法太简单了，所以不需要AST这个中间表示形式。直接在tokens上进行转换</p></li><li><p><strong>转换</strong> 将上个步骤抽象的表示形式，转换成为编译器想要的。比如上文模板引擎会转换为对应语言的语句。复杂的编译器会基于AST进行‘转换’，也就是对AST进行‘增删查改’. 通常会配合Visitors模式来遍历/访问AST的节点</p></li><li><strong>代码生成</strong> 将转换后的抽象表示转换为新的代码。 比如模板引擎最后一步会封装成为一个渲染函数. 复杂的编译器会将AST转换为目标代码</li></ol><p>编译器相关的东西确实很有趣，后续有机会可以讲讲怎么编写babel插件。</p><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://github.com/mde/ejs/tree/master/lib" target="_blank" rel="noopener">Ejs源代码</a></li><li><a href="https://github.com/jamiebuilds/the-super-tiny-compiler" target="_blank" rel="noopener">the-super-tiny-compiler</a></li><li><a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">Let’s Build A Simple Interpreter. Part 7: Abstract Syntax Trees</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一张图说明Ejs模板引擎的原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ejs/ejs.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上面一张图，已经大概把一个简单模板引擎(这里以&lt;a href=&quot;https://ejs.co/&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>揭开Electron的remote模块的面纱</title>
    <link href="https://bobi.ink/2019/08/04/electron-remote/"/>
    <id>https://bobi.ink/2019/08/04/electron-remote/</id>
    <published>2019-08-03T16:00:00.000Z</published>
    <updated>2019-08-09T13:28:24.883Z</updated>
    
    <content type="html"><![CDATA[<p>Electron的remote模块是一个比较神奇的东西，为<code>渲染进程</code>和<code>主进程</code>通信封装了一种简单方法，通过remote你可以’直接’获取主进程对象或者调用主进程函数或对象的方法, 而不必显式发送进程间消息, 类似于 Java 的 RMI. 例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; remote &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="keyword">const</span> myModal = remote.require(<span class="string">'myModal'</span>) <span class="comment">// 让主进程require指定模块，并返回到渲染进程</span></span><br><span class="line">myModal.dosomething()                     <span class="comment">// 调用方法</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>本质上，remote模块是基于Electron的IPC机制的，进程之间的通信的数据必须是可序列化的，比如JSON序列化</strong>。所以本文的目的是介绍Electron是如何设计remote模块的，以及里面有什么坑。</p><p><br></p><p><img src="/images/electron-remote/ipc.png" alt></p><p><br></p><p><strong>文章大纲</strong></p><ul><li><a href="#%e9%80%9a%e4%bf%a1%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%ae%9a%e4%b9%89">通信协议的定义</a></li><li><a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96">对象的序列化</a></li><li><a href="#%e5%bd%b1%e5%ad%90%e5%af%b9%e8%b1%a1">影子对象</a></li><li><a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">对象的生命周期</a></li><li><a href="#%e6%b8%b2%e6%9f%93%e8%bf%9b%e7%a8%8b%e6%80%8e%e4%b9%88%e7%bb%99%e4%b8%bb%e8%bf%9b%e7%a8%8b%e4%bc%a0%e9%80%92%e5%9b%9e%e8%b0%83">渲染进程怎么给主进程传递回调</a></li><li><a href="#%e4%b8%80%e4%ba%9b%e7%bc%ba%e9%99%b7">一些缺陷</a></li><li><a href="#remote%e6%a8%a1%e5%9d%97%e5%ae%9e%e8%b7%b5%e5%92%8c%e4%bc%98%e5%8c%96">remote模块实践和优化</a></li><li><a href="#%e6%80%bb%e7%bb%93">总结</a></li><li><a href="#%e6%89%a9%e5%b1%95">扩展</a></li></ul><p><br></p><h2 id="通信协议的定义"><a href="#通信协议的定义" class="headerlink" title="通信协议的定义"></a>通信协议的定义</h2><p>上文说到，remote本质上基于序列化的IPC通信的，所以首先关键需要<strong>定义一个协议来描述一个模块/对象的外形</strong>，其中包含下列类型:</p><ul><li>原始值。例如字符串、数字、布尔值</li><li>数组。</li><li>对象。对象属性、对象的方法、以及对象的原型</li><li>函数。普通函数和构造方法、异常处理</li><li>特殊对象。Date、Buffer、Promise、异常对象等等</li></ul><p><br></p><p>Electron使用MetaData(元数据)来描述这些对象外形的协议. 下面是一些转换的示例:</p><ul><li><p><strong>基本对象</strong>: 基本对象很容易处理，直接值拷贝传递即可</p><ul><li><p>输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">Buffer.from(<span class="string">'hello world'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'message'</span>);</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>: <span class="string">"value"</span>, <span class="attr">value</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"date"</span>, <span class="attr">value</span>: <span class="number">1565002306662</span>&#125;;  <span class="comment">// 序列化为时间戳</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"buffer"</span>, <span class="attr">value</span>: &#123;<span class="attr">data</span>: <span class="built_in">Uint8Array</span>(<span class="number">11</span>), <span class="attr">length</span>: <span class="number">11</span>, <span class="attr">type</span>: <span class="string">"Buffer"</span>&#125;&#125;; <span class="comment">// 序列化为数组</span></span><br><span class="line">&#123;</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">"stack"</span>,</span><br><span class="line">      value: <span class="string">"Error: message\n    at Object.&lt;anonymous&gt; (省略调用栈)"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"message"</span>, <span class="attr">value</span>: <span class="string">"message"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"name"</span>, <span class="attr">value</span>: <span class="string">"Error"</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  type: <span class="string">"error"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p></li></ul></li><li><p><strong>数组</strong>: 数组也是值拷贝</p><ul><li><p>输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></li><li><p>输出</p><p>数组会递归对成员进行转换. 注意数组和基本类型没什么区别，它也是值拷贝，也就是说修改数组不会影响到对端进程的数组值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"members"</span>: [</span><br><span class="line">    &#123;<span class="string">"type"</span>:<span class="string">"value"</span>,<span class="string">"value"</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"type"</span>:<span class="string">"value"</span>,<span class="string">"value"</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"type"</span>:<span class="string">"value"</span>,<span class="string">"value"</span>:<span class="number">3</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"type"</span>:<span class="string">"array"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><br></p><ul><li><p><strong>纯对象</strong>: </p><ul><li><p>输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="string">'d'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这里有一个id，用于标识主进程的一个对象</span></span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// 对象成员</span></span><br><span class="line">  members: [</span><br><span class="line">    &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"a"</span>, <span class="attr">type</span>: <span class="string">"get"</span>, <span class="attr">writable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"b"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    <span class="comment">// electron只会转换一层，不会递归转换内嵌对象</span></span><br><span class="line">    &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"c"</span>, <span class="attr">type</span>: <span class="string">"get"</span>, <span class="attr">writable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  name: <span class="string">"Object"</span>,</span><br><span class="line">  <span class="comment">// 对象的上级原型的MetaData</span></span><br><span class="line">  proto: <span class="literal">null</span>,</span><br><span class="line">  type: <span class="string">"object"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p></li></ul></li><li><p><strong>函数</strong>:</p><ul><li><p>输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 函数也有一个唯一id标识，因为它也是对象，主进程需要保持该对象的引用</span></span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 函数属性成员</span></span><br><span class="line">  members: [],</span><br><span class="line">  name: <span class="string">"Function"</span>,</span><br><span class="line">  type: <span class="string">"function"</span></span><br><span class="line">  <span class="comment">// Electron解析对象的原型链</span></span><br><span class="line">  proto: &#123;</span><br><span class="line">    members: [</span><br><span class="line">      <span class="comment">// 构造函数</span></span><br><span class="line">      &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        name: <span class="string">"constructor"</span>,</span><br><span class="line">        type: <span class="string">"method"</span>,</span><br><span class="line">        writable: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"apply"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"bind"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"call"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"toString"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    proto: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p></li></ul></li><li><p><strong>Promise</strong>：Promise只需描述then函数</p><ul><li><p>输入:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure></li><li><p>输入:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise这里关键在于then，详见上面的函数元数据</span></span><br><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"promise"</span></span><br><span class="line">  then: &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    members: [],</span><br><span class="line">    name: <span class="string">"Function"</span>,</span><br><span class="line">    proto: &#123;<span class="comment">/*见上面*/</span>&#125;,</span><br><span class="line">    type: <span class="string">"function"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><br></p><p>了解remote的数据传输协议后，有经验的开发者应该心里有底了，它的原理大概是这样的：</p><p><img src="/images/electron-remote/meta-transform.png" alt></p><p>主进程和渲染进程之间需要将对象序列化成MetaData描述，转换的规则上面已经解释的比较清楚了。这里面需要特殊处理是对象和函数，渲染进程拿到MetaData后需要封装成一个影子对象/函数，来供渲染进程应用调用。</p><p>其中比较复杂的是对象和函数的处理，Electron为了防止对象被垃圾回收，需要将这些对象放进一个注册表中，在这个表中每个对象都有一个唯一的id来标识。这个id有点类似于‘指针’，渲染进程会拿着这个id向主进程请求访问对象。</p><p>那什么时候需要释放这些对象呢？下文会讲具体的实现细节。</p><p>还有一个上图没有展示出来的细节是，Electron不会递归去转换对象，也就是说它只会转换一层。这样可以安全地引用存在循环引用的对象、另外所有属性值应该从远程获取最新的值，不能假设它的结构不可变。</p><p><br><br><br></p><h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><p>先来看看主进程的实现，它的代码位于<a href="https://github.com/electron/electron/blob/master/lib/browser/rpc-server.js" target="_blank" rel="noopener">/lib/browser/rpc-server.js</a>，代码很少而且很好理解，读者可以自己读一下。</p><p>这里我们不关注对象序列化的细节，重点关注对象的生命周期和调用的流程. </p><p><br></p><p>以<code>remote.require</code>为例, 这个方法用于让主进程去require指定模块，然后返回模块内容给渲染进程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleRemoteCommand(<span class="string">'ELECTRON_BROWSER_REQUIRE'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, contextId, moduleName</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用require</span></span><br><span class="line">  <span class="keyword">const</span> returnValue = process.mainModule.require(moduleName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将returnValue序列化为MetaData</span></span><br><span class="line">  <span class="keyword">return</span> valueToMeta(event.sender, contextId, returnValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>handleRemoteCommand</code> 使用<a href="https://electronjs.org/docs/api/ipc-main" target="_blank" rel="noopener">ipcMain</a>监听renderer发送的请求，<code>contextId</code>用于标识一个渲染进程。</p><p><br></p><p><code>valueToMeta</code>方法将值序列化为MetaData:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> valueToMeta = <span class="function"><span class="keyword">function</span> (<span class="params">sender, contextId, value, optimizeSimpleObject = false</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Determine the type of value.</span></span><br><span class="line">  <span class="keyword">const</span> meta = &#123; <span class="attr">type</span>: <span class="keyword">typeof</span> value &#125;</span><br><span class="line">  <span class="keyword">if</span> (meta.type === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="comment">// Recognize certain types of objects.</span></span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">      meta.type = <span class="string">'value'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bufferUtils.isBuffer(value)) &#123;</span><br><span class="line">      <span class="comment">// ... 🔴 基本类型</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (meta.type === <span class="string">'array'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴 数组转换</span></span><br><span class="line">    meta.members = value.map(<span class="function">(<span class="params">el</span>) =&gt;</span> valueToMeta(sender, contextId, el, optimizeSimpleObject))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'object'</span> || meta.type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    meta.name = value.constructor ? value.constructor.name : <span class="string">''</span></span><br><span class="line">    <span class="comment">// 🔴 将对象保存到注册表中，并返回唯一的对象id.</span></span><br><span class="line">    <span class="comment">// Electron会假设渲染进程会一直引用这个对象, 直到渲染进程退出</span></span><br><span class="line">    meta.id = objectsRegistry.add(sender, contextId, value)</span><br><span class="line">    meta.members = getObjectMembers(value)</span><br><span class="line">    meta.proto = getObjectPrototype(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'buffer'</span>) &#123;</span><br><span class="line">    meta.value = bufferUtils.bufferToMeta(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'promise'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴promise</span></span><br><span class="line">    value.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">    meta.then = valueToMeta(sender, contextId, <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">      value.then(onFulfilled, onRejected)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'error'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴错误对象</span></span><br><span class="line">    meta.members = plainObjectToMeta(value)</span><br><span class="line">    meta.members.push(&#123;</span><br><span class="line">      name: <span class="string">'name'</span>,</span><br><span class="line">      value: value.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'date'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴日期</span></span><br><span class="line">    meta.value = value.getTime()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他</span></span><br><span class="line">    meta.type = <span class="string">'value'</span></span><br><span class="line">    meta.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> meta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="影子对象"><a href="#影子对象" class="headerlink" title="影子对象"></a>影子对象</h2><p><img src="/images/electron-remote/naruto.jpeg" alt></p><p>渲染进程会从MetaData中反序列化的对象或函数, 不过这只是一个‘影子’，我们也可以将它们称为<strong>影子对象</strong>或者<strong>代理对象</strong>、<strong>替身</strong>. 类似于火影忍者中的影分身之术，主体存储在主进程中，影子对象不包含任何实体数据，当访问这些对象或调用函数/方法时，影子对象直接远程请求。</p><blockquote><p>渲染进程的代码可以看<a href="https://github.com/electron/electron/blob/master/lib/renderer/api/remote.js" target="_blank" rel="noopener">这里</a></p></blockquote><p>来看看渲染进程怎么创建‘影子对象’:</p><p><strong>函数的处理</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (meta.type === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// 🔴创建一个'影子'函数</span></span><br><span class="line">  <span class="keyword">const</span> remoteFunction = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> command</span><br><span class="line">    <span class="comment">// 通过new Obj形式调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.constructor === remoteFunction) &#123;</span><br><span class="line">      command = <span class="string">'ELECTRON_BROWSER_CONSTRUCTOR'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      command = <span class="string">'ELECTRON_BROWSER_FUNCTION_CALL'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 🔴同步IPC远程</span></span><br><span class="line">    <span class="comment">// wrapArgs将函数参数序列化为MetaData</span></span><br><span class="line">    <span class="keyword">const</span> obj = ipcRendererInternal.sendSync(command, contextId, meta.id, wrapArgs(args))</span><br><span class="line">    <span class="comment">// 🔴反序列化返回值</span></span><br><span class="line">    <span class="keyword">return</span> metaToValue(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  ret = remoteFunction</span><br></pre></td></tr></table></figure><p><br></p><p><strong>对象成员的处理</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setObjectMembers</span> (<span class="params">ref, object, metaId, members</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> member <span class="keyword">of</span> members) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(member.name)) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> descriptor = &#123; <span class="attr">enumerable</span>: member.enumerable &#125;</span><br><span class="line">    <span class="keyword">if</span> (member.type === <span class="string">'method'</span>) &#123;</span><br><span class="line">      <span class="comment">// 🔴创建‘影子’方法. 和上面的函数调用差不多</span></span><br><span class="line">      <span class="keyword">const</span> remoteMemberFunction = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> command</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.constructor === remoteMemberFunction) &#123;</span><br><span class="line">          command = <span class="string">'ELECTRON_BROWSER_MEMBER_CONSTRUCTOR'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          command = <span class="string">'ELECTRON_BROWSER_MEMBER_CALL'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> ret = ipcRendererInternal.sendSync(command, contextId, metaId, member.name, wrapArgs(args))</span><br><span class="line">        <span class="keyword">return</span> metaToValue(ret)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (member.type === <span class="string">'get'</span>) &#123;</span><br><span class="line">      <span class="comment">// 🔴属性的获取</span></span><br><span class="line">      descriptor.get = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> command = <span class="string">'ELECTRON_BROWSER_MEMBER_GET'</span></span><br><span class="line">        <span class="keyword">const</span> meta = ipcRendererInternal.sendSync(command, contextId, metaId, member.name)</span><br><span class="line">        <span class="keyword">return</span> metaToValue(meta)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 🔴属性的设置</span></span><br><span class="line">      <span class="keyword">if</span> (member.writable) &#123;</span><br><span class="line">        descriptor.set = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> args = wrapArgs([value])</span><br><span class="line">          <span class="keyword">const</span> command = <span class="string">'ELECTRON_BROWSER_MEMBER_SET'</span></span><br><span class="line">          <span class="keyword">const</span> meta = ipcRendererInternal.sendSync(command, contextId, metaId, member.name, args)</span><br><span class="line">          <span class="keyword">if</span> (meta != <span class="literal">null</span>) metaToValue(meta)</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(object, member.name, descriptor)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><p><strong>主进程的<code>valueToMeta</code>会将每一个对象和函数都放入注册表中，包括每次函数调用的返回值</strong>。</p><p>这是否意味着，如果频繁调用函数，会导致注册表暴涨占用太多内存呢？这些对象什么时候释放?</p><p><br></p><p>首先<strong>当渲染进程销毁时，主进程会集中销毁掉该进程的所有对象引用</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染进程退出时会通过这个事件告诉主进程，但是这个并不能保证收到</span></span><br><span class="line">handleRemoteCommand(<span class="string">'ELECTRON_BROWSER_CONTEXT_RELEASE'</span>, (event, contextId) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 清空对象注册表</span></span><br><span class="line">  objectsRegistry.clear(event.sender, contextId)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为<code>ELECTRON_BROWSER_CONTEXT_RELEASE</code>不能保证能够收到，所以<code>objectsRegistry</code>还会监听对应渲染进程的销毁事件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectsRegistry</span> </span>&#123;</span><br><span class="line">    registerDeleteListener (webContents, contextId) &#123;</span><br><span class="line">    <span class="comment">// contextId =&gt; $&#123;processHostId&#125;-$&#123;contextCount&#125;</span></span><br><span class="line">    <span class="keyword">const</span> processHostId = contextId.split(<span class="string">'-'</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> listener = <span class="function">(<span class="params">event, deletedProcessHostId</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (deletedProcessHostId &amp;&amp;</span><br><span class="line">          deletedProcessHostId.toString() === processHostId) &#123;</span><br><span class="line">        webContents.removeListener(<span class="string">'render-view-deleted'</span>, listener)</span><br><span class="line">        <span class="keyword">this</span>.clear(webContents, contextId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//🔴 监听渲染进程销毁事件, 确保万无一失</span></span><br><span class="line">    webContents.on(<span class="string">'render-view-deleted'</span>, listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>等<strong>到渲染进程销毁再去释放这些对象显然是无法接受的</strong>，和网页不一样，桌面端应用可能会7*24不间断运行，如果要等到渲染进程退出才去回收对象, 最终会导致系统资源被消耗殆尽。</p><p>所以<strong>Electron会在渲染进程中监听对象的垃圾回收事件，再通过IPC通知主进程来递减对应对象的引用计数</strong>， 看看渲染进程是怎么做的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渲染进程，反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">metaToValue</span> (<span class="params">meta</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对象类型转换</span></span><br><span class="line">    <span class="keyword">let</span> ret</span><br><span class="line">    <span class="keyword">if</span> (remoteObjectCache.has(meta.id)) &#123;</span><br><span class="line">      <span class="comment">// 🔴 对象再一次被访问，递增对象引用计数. </span></span><br><span class="line">      <span class="comment">// v8Util是electron原生模块</span></span><br><span class="line">      v8Util.addRemoteObjectRef(contextId, meta.id)</span><br><span class="line">      <span class="keyword">return</span> remoteObjectCache.get(meta.id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个影子类表示远程函数对象</span></span><br><span class="line">    <span class="keyword">if</span> (meta.type === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> remoteFunction = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      ret = remoteFunction</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setObjectMembers(ret, ret, meta.id, meta.members)</span><br><span class="line">    setObjectPrototype(ret, ret, meta.id, meta.proto)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(ret.constructor, <span class="string">'name'</span>, &#123; <span class="attr">value</span>: meta.name &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔴 监听对象的生命周期，当对象被垃圾回收时，通知到主进程</span></span><br><span class="line">    v8Util.setRemoteObjectFreer(ret, contextId, meta.id)</span><br><span class="line">    v8Util.setHiddenValue(ret, <span class="string">'atomId'</span>, meta.id)</span><br><span class="line">    <span class="comment">// 🔴 添加对象引用计数</span></span><br><span class="line">    v8Util.addRemoteObjectRef(contextId, meta.id)</span><br><span class="line">    remoteObjectCache.set(meta.id, ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>简单了解一下ObjectFreer代码:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// atom/common/api/remote_object_freer.cc</span></span><br><span class="line"><span class="comment">// 添加引用计数</span></span><br><span class="line"><span class="keyword">void</span> RemoteObjectFreer::AddRef(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; context_id, <span class="keyword">int</span> object_id) &#123;</span><br><span class="line">  ref_mapper_[context_id][object_id]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象释放事件处理器</span></span><br><span class="line"><span class="keyword">void</span> RemoteObjectFreer::RunDestructor() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">auto</span>* channel = <span class="string">"ELECTRON_BROWSER_DEREFERENCE"</span>;</span><br><span class="line">  base::ListValue args;</span><br><span class="line">  args.AppendString(context_id_);</span><br><span class="line">  args.AppendInteger(object_id_);</span><br><span class="line">  args.AppendInteger(ref_mapper_[context_id_][object_id_]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 清空引用表</span></span><br><span class="line">  ref_mapper_[context_id_].erase(object_id_);</span><br><span class="line">  <span class="keyword">if</span> (ref_mapper_[context_id_].empty())</span><br><span class="line">    ref_mapper_.erase(context_id_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 ipc通知主进程</span></span><br><span class="line">  electron_ptr-&gt;Message(<span class="literal">true</span>, channel, args.Clone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>再回到主进程, 主进程监听<code>ELECTRON_BROWSER_DEREFERENCE</code>事件，并递减指定对象的引用计数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleRemoteCommand(<span class="string">'ELECTRON_BROWSER_DEREFERENCE'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, contextId, id, rendererSideRefCount</span>) </span>&#123;</span><br><span class="line">  objectsRegistry.remove(event.sender, contextId, id, rendererSideRefCount)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>如果被上面的代码绕得优点晕，那就看看下面的流程图, 消化消化：</p><p><img src="/images/electron-remote/lifetime.png" alt></p><p><br><br><br></p><h2 id="渲染进程怎么给主进程传递回调"><a href="#渲染进程怎么给主进程传递回调" class="headerlink" title="渲染进程怎么给主进程传递回调"></a>渲染进程怎么给主进程传递回调</h2><p>在渲染进程中，通过remote还可以给主进程的函数传递回调。其实跟主进程暴露函数/对象给渲染进程的原理一样，渲染进程在将回调传递给主进程之前会放置到<strong>回调注册表</strong>中，然后给主进程暴露一个callbackID。</p><p>渲染进程会调用<code>wrapArgs</code>将函数调用参数序列化为MetaData:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapArgs</span> (<span class="params">args, visited = new Set(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> valueToMeta = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 🔴 防止循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (visited.has(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        type: <span class="string">'value'</span>,</span><br><span class="line">        value: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略其他类型的处理，这些类型基本都是值拷贝</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        type: <span class="string">'function'</span>,</span><br><span class="line">        <span class="comment">// 🔴 给主进程传递callbackId，并添加到回调注册表中</span></span><br><span class="line">        id: callbacksRegistry.add(value),</span><br><span class="line">        location: v8Util.getHiddenValue(value, <span class="string">'location'</span>),</span><br><span class="line">        length: value.length</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>回到主进程，这里也有一个对应的<code>unwrapArgs</code>函数来反序列化函数参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unwrapArgs = <span class="function"><span class="keyword">function</span> (<span class="params">sender, frameId, contextId, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> metaToValue = <span class="function"><span class="keyword">function</span> (<span class="params">meta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (meta.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'value'</span>:</span><br><span class="line">        <span class="keyword">return</span> meta.value</span><br><span class="line">      <span class="comment">// ... 省略</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'function'</span>: &#123;</span><br><span class="line">        <span class="keyword">const</span> objectId = [contextId, meta.id]</span><br><span class="line">        <span class="comment">// 回调缓存</span></span><br><span class="line">        <span class="keyword">if</span> (rendererFunctions.has(objectId)) &#123;</span><br><span class="line">          <span class="keyword">return</span> rendererFunctions.get(objectId)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 🔴 封装影子函数</span></span><br><span class="line">        <span class="keyword">const</span> callIntoRenderer = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> succeed = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">if</span> (!sender.isDestroyed()) &#123;</span><br><span class="line">            <span class="comment">// 🔴 调用时，通过IPC通知渲染进程</span></span><br><span class="line">            <span class="comment">// 忽略回调返回值</span></span><br><span class="line">            succeed = sender._sendToFrameInternal(frameId, <span class="string">'ELECTRON_RENDERER_CALLBACK'</span>, contextId, meta.id, valueToMeta(sender, contextId, args))</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!succeed) &#123;</span><br><span class="line">            <span class="comment">// 没有发送成功则表明渲染进程的回调可能被释放了，输出警告信息</span></span><br><span class="line">            <span class="comment">// 这种情况比较常见，比如被渲染进程刷新了</span></span><br><span class="line">            removeRemoteListenersAndLogWarning(<span class="keyword">this</span>, callIntoRenderer)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v8Util.setHiddenValue(callIntoRenderer, <span class="string">'location'</span>, meta.location)</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(callIntoRenderer, <span class="string">'length'</span>, &#123; <span class="attr">value</span>: meta.length &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 🔴 监听回调函数垃圾回收事件</span></span><br><span class="line">        v8Util.setRemoteCallbackFreer(callIntoRenderer, contextId, meta.id, sender)</span><br><span class="line">        rendererFunctions.set(objectId, callIntoRenderer)</span><br><span class="line">        <span class="keyword">return</span> callIntoRenderer</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Unknown type: <span class="subst">$&#123;meta.type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> args.map(metaToValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染进程响应就比较简单了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleMessage(<span class="string">'ELECTRON_RENDERER_CALLBACK'</span>, (id, args) =&gt; &#123;</span><br><span class="line">  callbacksRegistry.apply(id, metaToValue(args))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>那回调什么时候释放呢？这个相比渲染进程的对象引用要简单很多，因为主进程只有一个。通过上面的代码可以知道, <code>setRemoteCallbackFreer</code>会监听影子回调是否被垃圾回收，一旦被垃圾回收了则通知渲染进程:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染进程</span></span><br><span class="line">handleMessage(<span class="string">'ELECTRON_RENDERER_RELEASE_CALLBACK'</span>, (id) =&gt; &#123;</span><br><span class="line">  callbacksRegistry.remove(id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>按照惯例，来个流程图:</p><p><img src="/images/electron-remote/callback.png" alt></p><p><br><br><br></p><h2 id="一些缺陷"><a href="#一些缺陷" class="headerlink" title="一些缺陷"></a>一些缺陷</h2><p>remote机制只是对远程对象的一个‘影分身’，无法百分百和远程对象的行为保持一致，下面是一些比较常见的缺陷:</p><ul><li>当渲染进程调用远程对象的方法/函数时，是进行同步IPC通信的。换言之，同步IPC调用会阻塞用户代码的执行，而且跨端的通信效率无法和原生函数调用相比，所以频繁的IPC调用会影响主进程和渲染进程的性能.</li><li>主进程会保持引用每一个渲染进程访问的对象，包括函数的返回值。同理，频繁的远程对象请求，对内存的占用和垃圾回收造成不小的压力</li><li>无法完全模拟JavaScript对象的行为。比如在remote模块中存在这些问题:<ul><li>数组属于’基本对象’，它是通过值拷贝传递给对端的。也就是说它不是一个‘引用对象’，在对端修改它们时，无法反应到原始的数组.</li><li>对象在第一次引用时，只有可枚举的属性可以远程访问。这也意味着，一开始对象的外形就确定下来了，如果远程对象动态扩展了属性，是无法被远程访问到的</li><li>渲染进程传递的回调会被异步调用，而且主进程会忽略它的返回值。异步调用是为了避免产生死锁</li></ul></li><li>对象泄露。<ul><li>如果远程对象在渲染进程中泄露（例如存储在映射中，但从未释放），则主进程中的相应对象也将被泄漏，所以您应该非常小心，不要泄漏远程对象。</li><li>在给主进程传递回调时也要特别小心，主进程会保持回调的引用，直到它被释放。所以在使用remote模块进行一些‘事件订阅’时，切记要解除事件订阅.</li><li>还有一种场景，下文会提到</li></ul></li></ul><p><br><br><br></p><h2 id="remote模块实践和优化"><a href="#remote模块实践和优化" class="headerlink" title="remote模块实践和优化"></a>remote模块实践和优化</h2><p><img src="/images/electron-remote/gzb.png" alt></p><p>上面是我参与过的某个项目的软件架构图，<code>Hybrid</code>层使用C/C++编写，封装了跨平台的核心业务逻辑，在此之上来构建各个平台的视图。其中桌面端我们使用的是Electron技术。</p><p>如上图，Bridge进是对Hybrid的一层Node桥接封装。一个应用中只能有一个Bridge实例，因此我们的做法是使用Electron的remote模块，让渲染进程通过主进程间接地访问Bridge.</p><p><br></p><p>页面需要监听Bridge的一些事件，最初我们的代码是这样的:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bridge.ts</span></span><br><span class="line"><span class="comment">// 使用remote的一个好处时，可以配合Typescript实现较好的类型检查</span></span><br><span class="line"><span class="keyword">const</span> bridge = electron.remote.require(<span class="string">'bridge'</span>) <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="keyword">import</span>(<span class="string">'bridge'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> bridge</span><br></pre></td></tr></table></figure><p>监听Bridge事件:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bridge <span class="keyword">from</span> <span class="string">'~/bridge'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Store <span class="keyword">extends</span> MobxStore &#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  pageReady() &#123;</span><br><span class="line">    <span class="keyword">this</span>.someEventDispose = bridge.addListener(<span class="string">'someEvent'</span>, <span class="keyword">this</span>.handleSomeEvent)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 页面关闭</span></span><br><span class="line">  pageWillClose() &#123;</span><br><span class="line">    <span class="keyword">this</span>.someEventDispose()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图如下:</p><p><img src="/images/electron-remote/addListener.png" alt></p><p>这种方式存在很多问题:</p><ul><li><p>主进程需要为每一个addListener回调都维持一个引用。上面的代码会在页面关闭时释放订阅，但是它没有考虑用户刷新页面或者页面崩溃的场景。这会导致回调在主进程泄露。</p><p>然而就算Electron可以在调用回调时发现回调在渲染进程已经被释放掉了，但是开发者却获取不到这些信息， Bridge会始终保持对影子回调的引用.</p></li><li><p>另外一个比较明显的是调用效率的问题。假设页面监听了N次A事件，当A事件触发时，主进程需要给这个页面发送N个通知。</p></li></ul><p><br></p><p>后来我们抛弃了使用remote进行事件订阅这种方式，让主进程来维护这种订阅关系, 如下图:</p><p><img src="/images/electron-remote/addListener2.png" alt></p><p>我们改进了很多东西：</p><p><strong>主进程现在只维护‘哪个页面’订阅了哪个事件，从‘绑定回调’进化成为‘绑定页面’</strong>。这样可以解决上面调用效率和回调泄露问题、比如不会因为页面刷新导致回调泄露, 并且当事件触发时只会通知一次页面。</p><p>另外这里参考了remote本身的实现，在页面销毁时移除该页面的所有订阅。相比比remote黑盒，我们自己来实现这种事件订阅关系比之前要更好调试。</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>remote模块对于Electron开发有很重要的意义，毕竟很多模块只有在主进程才能访问，比如BrowserWindow、dialog. </p><p>相比ipc通信，remote实在方面很多。通过上文我们也了解了它的基本原理和缺陷，所以remote虽好，切忌不要滥用。</p><p>remote的源码也很容易理解，值得学习. 毕竟前端目前跨端通信非常常见，例如WebViewBridge、Worker. </p><p>remote可以给你一些灵感，但是要完全照搬它是不可行的，因为比如它依赖一些v8 ‘Hack’来监听对象的垃圾回收，普通开发场景是做不到的。</p><p>本文完.</p><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://electronjs.org/docs/api/remote" target="_blank" rel="noopener">Electron remote 文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Electron的remote模块是一个比较神奇的东西，为&lt;code&gt;渲染进程&lt;/code&gt;和&lt;code&gt;主进程&lt;/code&gt;通信封装了一种简单方法，通过remote你可以’直接’获取主进程对象或者调用主进程函数或对象的方法, 而不必显式发送进程间消息, 类似于 Java 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>谈谈React事件机制和未来(react-events)</title>
    <link href="https://bobi.ink/2019/07/29/react-event/"/>
    <id>https://bobi.ink/2019/07/29/react-event/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-08-04T08:19:59.764Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react-event/sample.png" alt></p><p>当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发. </p><p>具体来讲，React利用事件委托机制在Document上统一监听DOM事件，再根据触发的target将事件分发到具体的组件实例。另外上面e是一个合成事件对象(SyntheticEvent), 而不是原始的DOM事件对象.</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#那为什么要自定义一套事件系统">那为什么要自定义一套事件系统?</a></li><li><a href="#基本概念">基本概念</a><ul><li><a href="#整体的架构">整体的架构</a></li><li><a href="#事件分类与优先级">事件分类与优先级</a></li></ul></li><li><a href="#实现细节">实现细节</a><ul><li><a href="#事件是如何绑定的">事件是如何绑定的？</a></li><li><a href="#事件是如何分发的">事件是如何分发的？</a><ul><li><a href="#事件触发调度">事件触发调度</a></li><li><a href="#插件是如何处理事件">插件是如何处理事件?</a></li><li><a href="#批量执行">批量执行</a></li></ul></li></ul></li><li><a href="#未来">未来</a><ul><li><a href="#初探responder的创建">初探Responder的创建</a></li><li><a href="#react-events意义何在">react-events意义何在?</a></li></ul></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><blockquote><p>截止本文写作时，React版本是16.8.6</p></blockquote><p><br></p><h2 id="那为什么要自定义一套事件系统"><a href="#那为什么要自定义一套事件系统" class="headerlink" title="那为什么要自定义一套事件系统?"></a>那为什么要自定义一套事件系统?</h2><p>如果了解过Preact(笔者之前写过一篇文章<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">解析Preact的源码</a>)，Preact裁剪了很多React的东西，其中包括事件机制，Preact是直接在DOM元素上进行事件绑定的。</p><p>在研究一个事物之前，我首先要问为什么？了解它的动机，才有利于你对它有本质的认识。</p><p>React自定义一套事件系统的动机有以下几个:</p><ul><li><p><strong>1. 抹平浏览器之间的兼容性差异</strong>。 这是估计最原始的动机，React根据<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C 规范</a>来定义这些合成事件(SyntheticEvent), 意在抹平浏览器之间的差异。</p><p>另外React还会试图通过其他相关事件来模拟一些低版本不兼容的事件, 这才是‘合成’的本来意思吧？。</p></li><li><p><strong>2. 事件‘合成’, 即事件自定义</strong>。事件合成除了处理兼容性问题，还可以用来自定义高级事件，比较典型的是React的onChange事件，它为表单元素定义了统一的值变动事件。另外第三方也可以通过React的事件插件机制来合成自定义事件，尽管很少人这么做。</p></li><li><p><strong>3. 抽象跨平台事件机制</strong>。 和VirtualDOM的意义差不多，VirtualDOM抽象了跨平台的渲染方式，那么对应的SyntheticEvent目的也是想提供一个抽象的跨平台事件机制。</p></li><li><p><strong>4. React打算做更多优化</strong>。比如利用事件委托机制，大部分事件最终绑定到了Document，而不是DOM节点本身. 这样简化了DOM事件处理逻辑，减少了内存开销. 但这也意味着，<strong>React需要自己模拟一套事件冒泡的机制</strong>。</p></li><li><p><strong>5. React打算干预事件的分发</strong>。v16引入Fiber架构，React为了优化用户的交互体验，会干预事件的分发。不同类型的事件有不同的优先级，比如高优先级的事件可以中断渲染，让用户代码可以及时响应用户交互。</p></li></ul><p><br></p><p>Ok, 后面我们会深入了解React的事件实现，我会尽量不贴代码，用流程图说话。</p><p><br></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="整体的架构"><a href="#整体的架构" class="headerlink" title="整体的架构"></a>整体的架构</h3><p><img src="/images/react-event/st.png" alt></p><ul><li><strong>ReactEventListener</strong> - 事件处理器. 在这里进行事件处理器的绑定。当DOM触发事件时，会从这里开始调度分发到React组件树</li><li><strong>ReactEventEmitter</strong> - 暴露接口给React组件层用于添加事件订阅</li><li><strong>EventPluginHub</strong> - 如其名，这是一个‘插件插槽’，负责管理和注册各种插件。在事件分发时，调用插件来生成合成事件</li><li><p><strong>Plugin</strong> - React事件系统使用了插件机制来管理不同行为的事件。这些插件会处理自己感兴趣的事件类型，并生成合成事件对象。目前ReactDOM有以下几种插件类型:</p><ul><li><strong>SimpleEventPlugin</strong> - 简单事件, 处理一些比较通用的事件类型，例如click、input、keyDown、mouseOver、mouseOut、pointerOver、pointerOut</li><li><p><strong>EnterLeaveEventPlugin</strong> - mouseEnter/mouseLeave和pointerEnter/pointerLeave这两类事件比较特殊, 和<code>*over/*leave</code>事件相比, 它们不支持事件冒泡, <code>*enter</code>会给所有进入的元素发送事件, 行为有点类似于<code>:hover</code>; 而<code>*over</code>在进入元素后，还会冒泡通知其上级. 可以通过这个<a href="https://codesandbox.io/s/enter-and-over-608cl" target="_blank" rel="noopener">实例</a>观察enter和over的区别.</p><p>如果树层次比较深，大量的mouseenter触发可能导致性能问题。另外其不支持冒泡，无法在Document完美的监听和分发, 所以ReactDOM使用<code>*over/*out</code>事件来模拟这些<code>*enter/*leave</code>。</p></li><li><p><strong>ChangeEventPlugin</strong> - change事件是React的一个自定义事件，旨在规范化表单元素的变动事件。</p><p>它支持这些表单元素: input, textarea, select </p></li><li><p><strong>SelectEventPlugin</strong> - 和change事件一样，React为表单元素规范化了select(选择范围变动)事件，适用于input、textarea、contentEditable元素.</p></li><li><strong>BeforeInputEventPlugin</strong> - beforeinput事件以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart" target="_blank" rel="noopener">composition</a>事件处理。</li></ul><p>本文主要会关注<code>SimpleEventPlugin</code>的实现，有兴趣的读者可以自己阅读React的源代码.</p></li><li><p><strong>EventPropagators</strong> 按照DOM事件传播的两个阶段，遍历React组件树，并收集所有组件的事件处理器.</p></li><li><strong>EventBatching</strong> 负责批量执行事件队列和事件处理器，处理事件冒泡。</li><li><p><strong>SyntheticEvent</strong> 这是‘合成’事件的基类，可以对应DOM的Event对象。只不过React为了减低内存损耗和垃圾回收，使用一个对象池来构建和释放事件对象， 也就是说SyntheticEvent不能用于异步引用，它在同步执行完事件处理器后就会被释放。</p><p>SyntheticEvent也有子类，和DOM具体事件类型一一匹配:</p><ul><li>SyntheticAnimationEvent</li><li>SyntheticClipboardEvent</li><li>SyntheticCompositionEvent</li><li>SyntheticDragEvent</li><li>SyntheticFocusEvent</li><li>SyntheticInputEvent</li><li>SyntheticKeyboardEvent</li><li>SyntheticMouseEvent</li><li>SyntheticPointerEvent</li><li>SyntheticTouchEvent</li><li>….</li></ul></li></ul><p><br></p><h3 id="事件分类与优先级"><a href="#事件分类与优先级" class="headerlink" title="事件分类与优先级"></a>事件分类与优先级</h3><p>SimpleEventPlugin将事件类型划分成了三类, 对应不同的优先级(<strong>优先级由低到高</strong>):</p><ul><li><strong>DiscreteEvent</strong> 离散事件. 例如blur、focus、 click、 submit、 touchStart. 这些事件都是离散触发的</li><li><strong>UserBlockingEvent</strong> 用户阻塞事件. 例如touchMove、mouseMove、scroll、drag、dragOver等等。这些事件会’阻塞’用户的交互。</li><li><strong>ContinuousEvent</strong> 可连续事件。例如load、error、loadStart、abort、animationEnd. 这个优先级最高，也就是说它们应该是立即同步执行的，这就是Continuous的意义，即可连续的执行，不被打断.</li></ul><p>可能要先了解一下React调度(Schedule)的优先级，才能理解这三种事件类型的区别。截止到本文写作时，React有5个优先级级别:</p><ul><li><code>Immediate</code> - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms timeout) 这些任务一般是用户交互的结果, 需要即时得到反馈 .</li><li><code>Normal</code> (5s timeout) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s timeout) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (no timeout) 一些没有必要做的任务 (e.g. 比如隐藏的内容).</li></ul><p>目前ContinuousEvent对应的是Immediate优先级; UserBlockingEvent对应的是UserBlocking(需要手动开启); 而DiscreteEvent对应的也是UserBlocking, 只不过它在执行之前，先会执行完其他Discrete任务。</p><p>本文不会深入React Fiber架构的细节，有兴趣的读者可以阅读文末的扩展阅读列表.</p><p><br><br><br></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>现在开始进入文章正题，React是怎么实现事件机制？主要分为两个部分: <strong>绑定</strong>和<strong>分发</strong>.</p><h3 id="事件是如何绑定的？"><a href="#事件是如何绑定的？" class="headerlink" title="事件是如何绑定的？"></a>事件是如何绑定的？</h3><p>为了避免后面绕晕了，有必要先了解一下React事件机制中的插件协议。 每个插件的结构如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> EventTypes = &#123;[key: <span class="built_in">string</span>]: DispatchConfig&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PluginModule&lt;NativeEvent&gt; = &#123;</span><br><span class="line">  eventTypes: EventTypes,          <span class="comment">// 声明插件支持的事件类型</span></span><br><span class="line">  extractEvents: (                 <span class="comment">// 对事件进行处理，并返回合成事件对象</span></span><br><span class="line">    topLevelType: TopLevelType,</span><br><span class="line">    targetInst: <span class="literal">null</span> | Fiber,</span><br><span class="line">    nativeEvent: NativeEvent,</span><br><span class="line">    nativeEventTarget: EventTarget,</span><br><span class="line">  ) =&gt; ?ReactSyntheticEvent,</span><br><span class="line">  tapMoveThreshold?: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>eventTypes</strong>声明该插件负责的事件类型, 它通过<code>DispatchConfig</code>来描述:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DispatchConfig = &#123;</span><br><span class="line">  dependencies: <span class="built_in">Array</span>&lt;TopLevelType&gt;, <span class="comment">// 依赖的原生事件，表示关联这些事件的触发. ‘简单事件’一般只有一个，复杂事件如onChange会监听多个, 如下图👇</span></span><br><span class="line">  phasedRegistrationNames?: &#123;    <span class="comment">// 两阶段props事件注册名称, React会根据这些名称在组件实例中查找对应的props事件处理器</span></span><br><span class="line">    bubbled: <span class="built_in">string</span>,             <span class="comment">// 冒泡阶段, 如onClick</span></span><br><span class="line">    captured: <span class="built_in">string</span>,            <span class="comment">// 捕获阶段，如onClickCapture</span></span><br><span class="line">  &#125;,</span><br><span class="line">  registrationName?: <span class="built_in">string</span>      <span class="comment">// props事件注册名称, 比如onMouseEnter这些不支持冒泡的事件类型，只会定义  registrationName，不会定义phasedRegistrationNames</span></span><br><span class="line">  eventPriority: EventPriority,  <span class="comment">// 事件的优先级，上文已经介绍过了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>看一下实例:</p><p><img src="/images/react-event/dispatch-config.png" alt></p><p>上面列举了三个典型的EventPlugin：</p><ul><li><p><strong>SimpleEventPlugin</strong> - 简单事件最好理解，它们的行为都比较通用，没有什么Trick, 例如不支持事件冒泡、不支持在Document上绑定等等. 和原生DOM事件是一一对应的关系，比较好处理.</p></li><li><p><strong>EnterLeaveEventPlugin</strong> - 从上图可以看出来，<code>mouseEnter</code>和<code>mouseLeave</code>依赖的是<code>mouseout</code>和<code>mouseover</code>事件。也就是说<code>*Enter/*Leave</code>事件在React中是通过<code>*Over/*Out</code>事件来模拟的。这样做的好处是可以在document上面进行委托监听，还有避免<code>*Enter/*Leave</code>一些奇怪而不实用的行为。</p></li><li><p><strong>ChangeEventPlugin</strong> - onChange是React的一个自定义事件，可以看出它依赖了多种原生DOM事件类型来模拟onChange事件.</p></li></ul><p><br></p><p>另外每个插件还会定义<code>extractEvents</code>方法，这个方法接受事件名称、原生DOM事件对象、事件触发的DOM元素以及React组件实例, 返回一个合成事件对象，如果返回空则表示不作处理. 关于extractEvents的细节会在下一节阐述.</p><p><br></p><p>在ReactDOM启动时就会向<code>EventPluginHub</code>注册这些插件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EventPluginHubInjection.injectEventPluginsByName(&#123;</span><br><span class="line">  SimpleEventPlugin: SimpleEventPlugin,</span><br><span class="line">  EnterLeaveEventPlugin: EnterLeaveEventPlugin,</span><br><span class="line">  ChangeEventPlugin: ChangeEventPlugin,</span><br><span class="line">  SelectEventPlugin: SelectEventPlugin,</span><br><span class="line">  BeforeInputEventPlugin: BeforeInputEventPlugin,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>Ok, 回到正题，事件是怎么绑定的呢？ 打个断点看一下调用栈:</p><p><img src="/images/react-event/listento.png" alt></p><p>前面调用栈关于React树如何更新和渲染就不在本文的范围内了，通过调用栈可以看出React在props初始化和更新时会进行事件绑定。这里先看一下流程图，忽略杂乱的跳转：</p><p><img src="/images/react-event/binding.png" alt></p><ul><li><strong>1. 在props初始化和更新时会进行事件绑定</strong>。首先React会判断元素是否是<code>媒体类型</code>，<strong>媒体类型的事件是无法在Document监听的，所以会直接在元素上进行绑定</strong></li><li><strong>2. 反之就在Document上绑定</strong>. 这里面需要两个信息，一个就是上文提到的’事件依赖列表’, 比如<code>onMouseEnter</code>依赖<code>mouseover/mouseout</code>; 第二个是ReactBrowserEventEmitter维护的’已订阅事件表’。<strong>事件处理器只需在Document订阅一次，所以相比在每个元素上订阅事件会节省很多资源</strong>.</li></ul><p>代码大概如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">listenTo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  registrationName: <span class="built_in">string</span>,           <span class="comment">// 注册名称，如onClick</span></span></span></span><br><span class="line"><span class="function"><span class="params">  mountAt: Document | Element | Node, <span class="comment">// 组件树容器，一般是Document</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeningSet = getListeningSetForElement(mountAt);             <span class="comment">// 已订阅事件表</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = registrationNameDependencies[registrationName]; <span class="comment">// 事件依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dependency = dependencies[i];</span><br><span class="line">    <span class="keyword">if</span> (!listeningSet.has(dependency)) &#123;                               <span class="comment">// 未订阅</span></span><br><span class="line">      <span class="keyword">switch</span> (dependency) &#123;</span><br><span class="line">        <span class="comment">// ... 特殊的事件监听处理</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">const</span> isMediaEvent = mediaEventTypes.indexOf(dependency) !== <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">if</span> (!isMediaEvent) &#123;</span><br><span class="line">            trapBubbledEvent(dependency, mountAt);                     <span class="comment">// 设置事件处理器</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      listeningSet.add(dependency);                                    <span class="comment">// 更新已订阅表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>接下来就是根据事件的’优先级’和’捕获阶段’(是否是capture)来设置事件处理器</strong>:</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trapEventForPluginEventSystem</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: Document | Element | Node,   <span class="comment">// 绑定到元素，一般是Document</span></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType: DOMTopLevelEventType,   <span class="comment">// 事件名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">  capture: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> listener;</span><br><span class="line">  <span class="keyword">switch</span> (getEventPriority(topLevelType)) &#123;</span><br><span class="line">    <span class="comment">// 不同优先级的事件类型，有不同的事件处理器进行分发, 下文会详细介绍</span></span><br><span class="line">    <span class="keyword">case</span> DiscreteEvent:                      <span class="comment">// ⚛️离散事件</span></span><br><span class="line">      listener = dispatchDiscreteEvent.bind(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        topLevelType,</span><br><span class="line">        PLUGIN_EVENT_SYSTEM,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingEvent:                 <span class="comment">// ⚛️用户阻塞事件</span></span><br><span class="line">      listener = dispatchUserBlockingUpdate.bind(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        topLevelType,</span><br><span class="line">        PLUGIN_EVENT_SYSTEM,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ContinuousEvent:                   <span class="comment">// ⚛️可连续事件</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      listener = dispatchEvent.bind(<span class="literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rawEventName = getRawEventName(topLevelType);</span><br><span class="line">  <span class="keyword">if</span> (capture) &#123;                            <span class="comment">// 绑定事件处理器到元素</span></span><br><span class="line">    addEventCaptureListener(element, rawEventName, listener);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addEventBubbleListener(element, rawEventName, listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件绑定的过程还比较简单, 接下来看看事件是如何分发的。</p><p><br></p><h3 id="事件是如何分发的？"><a href="#事件是如何分发的？" class="headerlink" title="事件是如何分发的？"></a>事件是如何分发的？</h3><p>按惯例还是先上流程图:</p><p><img src="/images/react-event/binding.png" alt></p><h4 id="事件触发调度"><a href="#事件触发调度" class="headerlink" title="事件触发调度"></a>事件触发调度</h4><p>通过上面的<code>trapEventForPluginEventSystem</code>函数可以知道，不同的事件类型有不同的事件处理器, 它们的区别是调度的优先级不一样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 离散事件</span></span><br><span class="line"><span class="comment">// discrentUpdates 在UserBlocking优先级中执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchDiscreteEvent</span>(<span class="params">topLevelType, eventSystemFlags, nativeEvent</span>) </span>&#123;</span><br><span class="line">  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);</span><br><span class="line">  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchUserBlockingUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果开启了enableUserBlockingEvents, 则在UserBlocking优先级中调度，</span></span><br><span class="line">  <span class="comment">// 开启enableUserBlockingEvents可以防止饥饿问题，因为阻塞事件中有scroll、mouseMove这类频繁触发的事件</span></span><br><span class="line">  <span class="comment">// 否则同步执行</span></span><br><span class="line">  <span class="keyword">if</span> (enableUserBlockingEvents) &#123;</span><br><span class="line">    runWithPriority(</span><br><span class="line">      UserBlockingPriority,</span><br><span class="line">      dispatchEvent.bind(<span class="literal">null</span>, topLevelType, eventSystemFlags, nativeEvent),</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dispatchEvent(topLevelType, eventSystemFlags, nativeEvent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可连续事件则直接同步调用dispatchEvent</span></span><br></pre></td></tr></table></figure><p><br></p><p>最终不同的事件类型都会调用<code>dispatchEvent</code>函数. <code>dispatchEvent</code>中会从DOM原生事件对象获取事件触发的target，再根据这个target获取关联的React节点实例.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatchEvent</span>(<span class="params">topLevelType: DOMTopLevelEventType, eventSystemFlags: EventSystemFlags, nativeEvent: AnyNativeEvent</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取事件触发的目标DOM</span></span><br><span class="line">  <span class="keyword">const</span> nativeEventTarget = getEventTarget(nativeEvent);</span><br><span class="line">  <span class="comment">// 获取离该DOM最近的组件实例(只能是DOM元素组件)</span></span><br><span class="line">  <span class="keyword">let</span> targetInst = getClosestInstanceFromNode(nativeEventTarget);</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>接着(中间还有一些步骤，这里忽略)会调用<code>EventPluginHub</code>的<code>runExtractedPluginEventsInBatch</code>，这个方法遍历插件列表来处理事件，生成一个SyntheticEvent列表:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runExtractedPluginEventsInBatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst: <span class="literal">null</span> | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历插件列表, 调用插件的extractEvents，生成SyntheticEvent列表</span></span><br><span class="line">  <span class="keyword">const</span> events = extractPluginEvents(</span><br><span class="line">    topLevelType,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件处理器执行, 见后文批量执行</span></span><br><span class="line">  runEventsInBatch(events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="插件是如何处理事件"><a href="#插件是如何处理事件" class="headerlink" title="插件是如何处理事件?"></a>插件是如何处理事件?</h4><p>现在来看看插件是如何处理事件的，我们以<code>SimpleEventPlugin</code>为例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleEventPlugin: PluginModule&lt;MouseEvent&gt; &amp; &#123;</span><br><span class="line">  getEventPriority: <span class="function">(<span class="params">topLevelType: TopLevelType</span>) =&gt;</span> EventPriority,</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  eventTypes: eventTypes,</span><br><span class="line">  <span class="comment">// 抽取事件对象</span></span><br><span class="line">  extractEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">    targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEvent: MouseEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">null</span> | <span class="title">ReactSyntheticEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事件配置</span></span><br><span class="line">    <span class="keyword">const</span> dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1️⃣ 根据事件类型获取SyntheticEvent子类事件构造器</span></span><br><span class="line">    <span class="keyword">let</span> EventConstructor;</span><br><span class="line">    <span class="keyword">switch</span> (topLevelType) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_DOWN:</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_UP:</span><br><span class="line">        EventConstructor = SyntheticKeyboardEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_BLUR:</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_FOCUS:</span><br><span class="line">        EventConstructor = SyntheticFocusEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ... 省略</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_GOT_POINTER_CAPTURE:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_UP:</span><br><span class="line">        EventConstructor = SyntheticPointerEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        EventConstructor = SyntheticEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2️⃣ 构造事件对象, 从对象池中获取</span></span><br><span class="line">    <span class="keyword">const</span> event = EventConstructor.getPooled(</span><br><span class="line">      dispatchConfig,</span><br><span class="line">      targetInst,</span><br><span class="line">      nativeEvent,</span><br><span class="line">      nativeEventTarget,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3️⃣ 根据DOM事件传播的顺序获取用户事件处理器</span></span><br><span class="line">    accumulateTwoPhaseDispatches(event);</span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>SimpleEventPlugin</code>的<code>extractEvents</code>主要做以下三个事情:</p><ul><li>1️⃣ 根据事件的类型确定SyntheticEvent构造器</li><li>2️⃣ 构造SyntheticEvent对象。</li><li>3️⃣ 根据DOM事件传播的顺序获取用户事件处理器列表</li></ul><p><br></p><p><strong>为了避免频繁创建和释放事件对象导致性能损耗(对象创建和垃圾回收)，React使用一个事件池来负责管理事件对象，使用完的事件对象会放回池中，以备后续的复用</strong>。</p><p>这也意味着，<strong>在事件处理器同步执行完后，SyntheticEvent对象就会马上被回收</strong>，所有属性都会无效。所以一般不会在异步操作中访问SyntheticEvent事件对象。你也可以通过以下方法来保持事件对象的引用：</p><ul><li>调用<code>SyntheticEvent#persist()</code>方法，告诉React不要回收到对象池</li><li>直接引用<code>SyntheticEvent#nativeEvent</code>, nativeEvent是可以持久引用的，不过为了不打破抽象，建议不要直接引用nativeEvent</li></ul><p><br></p><p>构建完SyntheticEvent对象后，就需要<strong>遍历组件树来获取订阅该事件的用户事件处理器</strong>了:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateTwoPhaseDispatchesSingle</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以_targetInst为基点, 按照DOM事件传播的顺序遍历组件树</span></span><br><span class="line">  traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历方法其实很简单：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverseTwoPhase</span>(<span class="params">inst, fn, arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="keyword">while</span> (inst) &#123;           <span class="comment">// 从inst开始，向上级回溯</span></span><br><span class="line">    path.push(inst);</span><br><span class="line">    inst = getParent(inst);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="comment">// 捕获阶段，先从最顶层的父组件开始, 向下级传播</span></span><br><span class="line">  <span class="keyword">for</span> (i = path.length; i-- &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">    fn(path[i], <span class="string">'captured'</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 冒泡阶段，从inst，即事件触发点开始, 向上级传播</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">    fn(path[i], <span class="string">'bubbled'</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>accumulateDirectionalDispatches</code>函数则是简单查找当前节点是否有对应的事件处理器:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateDirectionalDispatches</span>(<span class="params">inst, phase, event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否存在事件处理器</span></span><br><span class="line">  <span class="keyword">const</span> listener = listenerAtPhase(inst, event, phase);</span><br><span class="line">  <span class="comment">// 所有处理器都放入到_dispatchListeners队列中，后续批量执行这个队列</span></span><br><span class="line">  <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">    event._dispatchListeners = accumulateInto(</span><br><span class="line">      event._dispatchListeners,</span><br><span class="line">      listener,</span><br><span class="line">    );</span><br><span class="line">    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>例如下面的组件树, 遍历过程是这样的：</p><p><img src="/images/react-event/event-delivery.png" alt></p><p>最终计算出来的<code>_dispatchListeners</code>队列是这样的：<code>[handleB, handleC, handleA]</code></p><p><br></p><h4 id="批量执行"><a href="#批量执行" class="headerlink" title="批量执行"></a>批量执行</h4><p>遍历执行插件后，会得到一个SyntheticEvent列表，<code>runEventsInBatch</code>就是批量执行这些事件中的<code>_dispatchListeners</code>事件队列</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runEventsInBatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  events: Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👇</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> executeDispatchesAndRelease = <span class="function"><span class="keyword">function</span>(<span class="params">event: ReactSyntheticEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event) &#123;</span><br><span class="line">    <span class="comment">// 按顺序执行_dispatchListeners</span></span><br><span class="line">    <span class="comment">// 👇</span></span><br><span class="line">    executeDispatchesInOrder(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有调用persist()方法则直接回收</span></span><br><span class="line">    <span class="keyword">if</span> (!event.isPersistent()) &#123;</span><br><span class="line">      event.constructor.release(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">executeDispatchesInOrder</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历dispatchListeners</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 通过调用 stopPropagation 方法可以禁止执行下一个事件处理器</span></span><br><span class="line">    <span class="keyword">if</span> (event.isPropagationStopped()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行事件处理器</span></span><br><span class="line">    executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/react-event/dispatch.png" alt></p><p>OK, 到这里React的事件机制就基本介绍完了，这里只是简单了介绍了一下<code>SimpleEventPlugin</code>, 实际代码中还有很多事件处理的细节，限于篇幅，本文就不展开去讲了。有兴趣的读者可以亲自去观摩React的源代码.</p><p><br><br><br></p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>React内部有一个实验性的事件API，React内部称为<code>React Flare</code>、正式名称是<a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener"><code>react-events</code></a>, <strong>通过这个API可以实现跨平台、跨设备的高级事件封装</strong>.</p><p>react-events定义了一个<strong>事件响应器(Event Responders)</strong>的概念，这个事件响应器可以捕获子组件树或应用根节点的事件，然后转换为自定义事件.</p><p>比较典型的高级事件是press、longPress、swipe这些手势。通常我们需要自己或者利用第三方库来实现这一套手势识别, 例如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Gesture <span class="keyword">from</span> <span class="string">'rc-gesture'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Gesture</span><br><span class="line">    onTap=&#123;handleTap&#125;</span><br><span class="line">    onSwipe=&#123;onSwipe&#125;</span><br><span class="line">    onPinch=&#123;handlePinch&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;div&gt;container&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Gesture&gt;,</span><br><span class="line">container);</span><br></pre></td></tr></table></figure><p><br></p><p>那么react-events的目的就是<strong>提供一套通用的事件机制给开发者来实现’高级事件’的封装, 甚至实现事件的跨平台、跨设备</strong>, 现在你可以通过react-events来封装这些手势事件.</p><p>react-events除了核心的<code>Responder</code>接口，还封装了一些内置模块, 实现跨平台的、常用的高级事件封装：</p><ul><li>Focus module</li><li>Hover module</li><li>Press module</li><li>FocusScope module</li><li>Input module</li><li>KeyBoard module</li><li>Drag module</li><li>Pan module</li><li>Scroll module</li><li>Swipe module</li></ul><p>举<code>Press</code>模块作为例子, <a href="https://github.com/facebook/react/blob/master/packages/react-events/docs/Press.md" target="_blank" rel="noopener">Press模块</a>会响应它包裹的元素的press事件。press事件包括onContextMenu、onLongPress、onPress、onPressEnd、onPressMove、onPressStart等等. 其底层通过mouse、pen、touch、trackpad等事件来转换.</p><p>看看使用示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PressResponder, usePressListener &#125; <span class="keyword">from</span> <span class="string">'react-events/press'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">const</span> listener = usePressListener(&#123;  <span class="comment">// ⚛️通过hooks创建Responder</span></span><br><span class="line">    onPressStart,</span><br><span class="line">    onPress,</span><br><span class="line">    onPressEnd,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div listeners=&#123;listener&#125;&gt;</span><br><span class="line">      &#123;subtrees&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><p>react-events的运作流程图如下, <strong>事件响应器(Event Responders)会挂载到host节点，它会在host节点监听host或子节点分发的原生事件(DOM或React Native), 并将它们转换/合并成高级的事件</strong>:</p><p><img src="/images/react-event/responder.png" alt></p><p><br></p><blockquote><p>你可以通过这个Codesanbox玩一下<code>react-events</code>: <a href="https://codesandbox.io/s/github/ivan-94/react-events-playground" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit react-events-playground"></a></p></blockquote><p><br></p><h3 id="初探responder的创建"><a href="#初探responder的创建" class="headerlink" title="初探Responder的创建"></a>初探Responder的创建</h3><p>我们挑一个简单的模块来了解一些react-events的核心API, 目前最简单的是Keyboard模块. Keyboard模块的目的就是规范化keydown和keyup事件对象的key属性(部分浏览器key属性的行为不一样)，它的实现如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Responder的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> keyboardResponderImpl = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1️⃣定义Responder需要监听的子树的DOM事件，对于Keyboard来说是['keydown', 'keyup';]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  targetEventTypes,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 2️⃣监听子树触发的事件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onEvent(</span><br><span class="line">    event: ReactDOMResponderEvent,     <span class="comment">// 包含了当前触发事件的相关信息，如原生事件对象，事件触发的节点，事件类型等等</span></span><br><span class="line">    context: ReactDOMResponderContext, <span class="comment">// Responder的上下文，给Responder提供了一些方法来驱动事件分发</span></span><br><span class="line">    props: KeyboardResponderProps,     <span class="comment">// 传递给Responder的props</span></span><br><span class="line">  ): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;responderTarget, type&#125; = event;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (props.disabled) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'keydown'</span>) &#123;</span><br><span class="line">      dispatchKeyboardEvent(</span><br><span class="line">        <span class="string">'onKeyDown'</span>,</span><br><span class="line">        event,</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">'keydown'</span>,</span><br><span class="line">        ((responderTarget: any): Element | Document),</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'keyup'</span>) &#123;</span><br><span class="line">      dispatchKeyboardEvent(</span><br><span class="line">        <span class="string">'onKeyUp'</span>,</span><br><span class="line">        event,</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">'keyup'</span>,</span><br><span class="line">        ((responderTarget: any): Element | Document),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看看dispatchKeyboardEvent:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchKeyboardEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  eventPropName: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  event: ReactDOMResponderEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: ReactDOMResponderContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: KeyboardEventType,</span></span></span><br><span class="line"><span class="function"><span class="params">  target: Element | Document,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️创建合成事件对象，在这个函数中会规范化事件的key属性</span></span><br><span class="line">  <span class="keyword">const</span> syntheticEvent = createKeyboardEvent(event, context, type, target);</span><br><span class="line">  <span class="comment">// ⚛️通过Responder上下文分发事件</span></span><br><span class="line">  context.dispatchEvent(eventPropName, syntheticEvent, DiscreteEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出Responder:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️createResponder把keyboardResponderImpl转换为组件形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> KeyboardResponder = React.unstable_createResponder(</span><br><span class="line">  <span class="string">'Keyboard'</span>,</span><br><span class="line">  keyboardResponderImpl,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️创建hooks形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useKeyboardListener</span>(<span class="params">props: KeyboardListenerProps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  React.unstable_useListener(KeyboardResponder, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在读者应该对<strong>Responder的职责</strong>有了一些基本的了解，它主要做以下几件事情:</p><ul><li>声明要监听的原生事件(如DOM), 如上面的<code>targetEventTypes</code></li><li>处理和转换合成事件，如上面的<code>onEvent</code></li><li>创建并分发自定义事件。如上面的<code>context.dispatchEvent</code></li></ul><p><br></p><p>和上面的Keyboard模块相比，现实中的很多高级事件，如longPress, 它们的实现则要复杂得多. 它们可能要维持一定的<strong>状态</strong>、也可能要独占响应的<strong>所有权</strong>(即同一时间只能有一个Responder可以对事件进行处理, 这个常用于移动端触摸手势，例如React Native的<a href="https://reactnative.cn/docs/gesture-responder-system/" target="_blank" rel="noopener">GestureResponderSystem</a>)。</p><p>react-events目前都考虑了这些场景, 看一下API概览:</p><p><img src="/images/react-event/react-events.png" alt></p><p><br></p><p>详细可以看react-events<a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener">官方仓库</a></p><p><br></p><h3 id="react-events意义何在"><a href="#react-events意义何在" class="headerlink" title="react-events意义何在?"></a>react-events意义何在?</h3><p>上文提到了React事件内部采用了插件机制，来实现事件处理和合成，比较典型的就是onChange事件。onChange事件其实就是所谓的‘高级事件’，它是通过表单组件的各种原生事件来模拟的。</p><p>也就是说，React通过插件机制本质上是可以实现高级事件的封装的。但是如果读者看过源代码，就会觉得里面逻辑比较绕，而且依赖React的很多内部实现。<strong>所以这种内部的插件机制并不是面向普通开发者的</strong>。</p><p><code>react-events</code>接口就简单很多了，它屏蔽了很多内部细节，面向普通开发者。我们可以利用它来实现高性能的自定义事件分发，更大的意义是通过它可以实现跨平台/设备的事件处理方式.</p><p>目前react-events还是实验阶段，特性是默认关闭，API可能会出现变更, 所以不建议在生产环境使用。可以通过这个<a href="https://github.com/facebook/react/issues/15257" target="_blank" rel="noopener">Issue</a>来关注它的进展。</p><p><br></p><p>最后赞叹一下React团队的创新能力！</p><p><br></p><p>完！</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://segmentfault.com/a/1190000013094932" target="_blank" rel="noopener">input事件中文触发多次问题研究</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">完全理解React Fiber</a></li><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark – A Cartoon Intro to Fiber – React Conf 2017</a></li><li><a href="https://philippspiess.com/scheduling-in-react/" target="_blank" rel="noopener">Scheduling in React</a></li><li><a href="https://github.com/facebook/react/issues/15257" target="_blank" rel="noopener">[Umbrella] React Flare</a></li><li><a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener">react-events</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react-event/sample.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发. &lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端团队Leader，怎么制定前端协作规范?</title>
    <link href="https://bobi.ink/2019/07/19/frontend-standard/"/>
    <id>https://bobi.ink/2019/07/19/frontend-standard/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2019-09-07T02:57:17.101Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢</p></blockquote><p><br></p><p>笔者长期单枪匹马在前端领域厮杀(言外之意就是团队就一个人)，自己就是规范。随着公司业务的扩展，扩充了一些人员，这时候就要开始考虑协作和编码规范问题了。本文记录了笔者在制定<code>前端协作规范</code>时的一些思考，希望能给你们也带来一些帮助.</p><p><strong>一个人走的更快，一群人可以走得更远，前提是统一的策略，还要不断地反省和优化</strong>。</p><p><br></p><p><strong>以下是目录概览, 看出这是一篇浩浩荡荡的长文</strong></p><!-- TOC --><ul><li><a href="#1-工作流规范">1 工作流规范</a><ul><li><a href="#11-开发">1.1 开发</a><ul><li><a href="#111-版本规范">1.1.1 版本规范</a></li><li><a href="#112-版本控制系统规范">1.1.2 版本控制系统规范</a></li><li><a href="#113-提交信息规范">1.1.3 提交信息规范</a></li></ul></li><li><a href="#12-构建规范">1.2 构建规范</a></li><li><a href="#13-发布工作流规范">1.3 发布工作流规范</a></li><li><a href="#14-持续集成">1.4 持续集成</a></li><li><a href="#15-任务管理">1.5 任务管理</a></li></ul></li><li><a href="#2-技术栈规范">2 技术栈规范</a><ul><li><a href="#21-技术选型">2.1 技术选型</a></li><li><a href="#22-迎接新技术">2.2 迎接新技术</a></li></ul></li><li><a href="#3-浏览器兼容规范">3 浏览器兼容规范</a><ul><li><a href="#31-确定兼容策略">3.1 确定兼容策略</a></li><li><a href="#32-确定浏览器分级">3.2 确定浏览器分级</a></li><li><a href="#33-获取统计数据">3.3 获取统计数据</a></li></ul></li><li><a href="#4-项目组织规范">4 项目组织规范</a><ul><li><a href="#41-通用的项目组织规范">4.1 通用的项目组织规范</a></li><li><a href="#42-目录组织的风格">4.2 目录组织的风格</a></li><li><a href="#43-脚手架和项目模板">4.3 脚手架和项目模板</a></li></ul></li><li><a href="#5-编码规范">5 编码规范</a><ul><li><a href="#51-javascript">5.1 Javascript</a></li><li><a href="#52-html">5.2 HTML</a></li><li><a href="#53-css">5.3 CSS</a></li><li><a href="#54-代码格式化">5.4 代码格式化</a></li><li><a href="#55-集大成的">5.5 集大成的</a></li><li><a href="#56-特定框架风格指南">5.6 特定框架风格指南</a></li><li><a href="#57-code-review">5.7 Code Review</a></li></ul></li><li><a href="#6-文档规范">6 文档规范</a><ul><li><a href="#61-建立文档中心">6.1 建立文档中心</a></li><li><a href="#62-文档格式">6.2 文档格式</a></li><li><a href="#63-定义文档的模板">6.3 定义文档的模板</a></li><li><a href="#64-讨论即文档">6.4 讨论即文档</a></li><li><a href="#65-注释即文档">6.5 注释即文档</a></li><li><a href="#66-代码即文档">6.6 代码即文档</a></li></ul></li><li><a href="#7-ui设计规范">7 UI设计规范</a></li><li><a href="#8-测试规范">8 测试规范</a><ul><li><a href="#81-测试的流程">8.1 测试的流程</a></li><li><a href="#82-单元测试">8.2 单元测试</a></li></ul></li><li><a href="#9-异常处理监控和调试规范">9 异常处理、监控和调试规范</a><ul><li><a href="#91-异常处理">9.1 异常处理</a></li><li><a href="#92-日志">9.2 日志</a></li><li><a href="#93-异常监控">9.3 异常监控</a></li></ul></li><li><a href="#10-前后端协作规范">10 前后端协作规范</a><ul><li><a href="#101-协作流程规范">10.1 协作流程规范</a></li><li><a href="#102-接口规范">10.2 接口规范</a></li><li><a href="#103-接口文档规范">10.3 接口文档规范</a></li><li><a href="#104-接口测试与模拟">10.4 接口测试与模拟</a></li></ul></li><li><a href="#11-培训知识管理技术沉淀">11 培训/知识管理/技术沉淀</a><ul><li><a href="#111-新人培训">11.1 新人培训</a></li><li><a href="#112-营造技术氛围">11.2 营造技术氛围</a></li></ul></li><li><a href="#12-反馈">12 反馈</a></li></ul><!-- /TOC --><p><br></p><p><strong>CHANGELOG</strong></p><ul><li>2019.7.28<br>新增<a href="#tech-select">技术选型</a></li><li>2019.7.29<br>新增<a href="#brw-anly">浏览器统计数据获取</a></li><li>2019.9.6<br>建立技术氛围一节 新增面试题库</li></ul><p><br></p><p><strong>什么是规范?</strong></p><p>规范，名词意义上：即明文规定或约定俗成的标准，如：道德规范、技术规范等。 动词意义上：是指按照既定标准、规范的要求进行操作，使某一行为或活动达到或超越规定的标准，如：规范管理、规范操作.</p><p><br></p><p><strong>为什么需要规范?</strong></p><ul><li>降低新成员融入团队的成本, 同时也一定程度避免挖坑</li><li>提高开发效率、团队协作效率, 降低沟通成本</li><li>实现高度统一的代码风格，方便review, 另外一方面可以提高项目的可维护性</li><li>规范是实现自动化的基础</li><li>规范是一个团队知识沉淀的直接输出</li></ul><p><br></p><p><strong>规范包含哪些内容?</strong></p><p>如文章标题，<strong>前端协作规范并不单单指‘编码规范’，这个规范涉及到前端开发活动的方方面面</strong>，例如代码库的管理、前后端协作、代码规范、兼容性规范；</p><p>不仅仅是前端团队内部需要协作，一个完整的软件生命周期内，我们需要和产品/设计、后端(或者原生客户端团队)、测试进行协作, 我们需要覆盖这些内容.</p><p><br></p><p>下面就开始介绍，<strong>如果我是前端团队的Leader，我会怎么制定前端规范，这个规范需要包含哪些内容</strong>?</p><p><br></p><h2 id="1-工作流规范"><a href="#1-工作流规范" class="headerlink" title="1 工作流规范"></a>1 工作流规范</h2><h3 id="1-1-开发"><a href="#1-1-开发" class="headerlink" title="1.1 开发"></a>1.1 开发</h3><h4 id="1-1-1-版本规范"><a href="#1-1-1-版本规范" class="headerlink" title="1.1.1 版本规范"></a>1.1.1 版本规范</h4><p>项目的版本号应该根据某些规则进行迭代, 这里推荐使用<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a>规范, <strong>通过这个规范，用户可以了解版本变更的影响范围</strong>。 规则如下:</p><ul><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h4 id="1-1-2-版本控制系统规范"><a href="#1-1-2-版本控制系统规范" class="headerlink" title="1.1.2 版本控制系统规范"></a>1.1.2 版本控制系统规范</h4><p>大部分团队都使用git作为版本库，管理好代码也是一种学问。尤其是涉及多人并发协作、需要管理多个软件版本的情况下，定义良好的版本库管理规范，可以让大型项目更有组织性，也可以提高成员协作效率.</p><p>比较流行的git分支模型/工作流是<a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" target="_blank" rel="noopener">git-flow</a>, 但是大部分团队会根据自己的情况制定自己的git工作流规范, 例如我们团队的<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/development.md#git-%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">分支规范</a></p><p><strong>Git 有很多工作流方法论，这些工作流的选择可能依赖于项目的规模、项目的类型以及团队成员的结构</strong>.</p><p>比如一个简单的个人项目可能不需要复杂的分支划分，我们的变更都是直接提交到 master 分支;</p><p>再比如开源项目，除了核心团队成员，其他贡献者是没有提交的权限的，而且我们也需要一定的手段来验证和讨论贡献的代码是否合理。 所以对于开源项目 fork 工作流更为适合.</p><p>了解常见的工作流有利于组织或创建适合自己团队的工作流, 提交团队协作的效率:</p><p><img src="/images/frontend-standard/branch.png" alt></p><ul><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/centralized.md" target="_blank" rel="noopener">简单的集中式</a></li><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/feature.md" target="_blank" rel="noopener">基于功能分支的工作流</a></li><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/gitflow.md" target="_blank" rel="noopener">Git Flow</a> 🔥</li><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/fork.md" target="_blank" rel="noopener">Fork/Pull Request 工作流</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h4 id="1-1-3-提交信息规范"><a href="#1-1-3-提交信息规范" class="headerlink" title="1.1.3 提交信息规范"></a>1.1.3 提交信息规范</h4><p><img src="/images/frontend-standard/commit.png" alt></p><p>组织好的提交信息, 可以提高项目的整体质量. 至少具有下面这些优点:</p><ul><li><strong>格式统一的提交信息有助于自动化生成CHANGELOG</strong></li><li><strong>版本库不只是存放代码的仓库, 它记录项目的开发日志, 它应该要清晰表达这次提交的做了什么</strong>. 这些记录应该可以帮助后来者快速地学习和回顾代码, 也应该方便其他协作者review你的代码</li><li><strong>规范化提交信息可以促进提交者提交有意义的、粒度合适的’提交’</strong>. 提交者要想好要怎么描述这个提交，这样被动促进了他们去把控<strong>提交的粒度</strong></li></ul><p><br></p><p>社区上比较流行的提交信息规范是<a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit" target="_blank" rel="noopener">Angular的提交信息规范</a>, 除此之外，这些也很不错:</p><ul><li><a href="https://github.com/atom/atom/blob/master/CONTRIBUTING.md#git-commit-messages" target="_blank" rel="noopener">Atom</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-ember" target="_blank" rel="noopener">Ember</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-eslint" target="_blank" rel="noopener">Eslint</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-jquery" target="_blank" rel="noopener">JQuery</a></li></ul><p><br></p><p>另外这些工具可以帮助你检验提交信息, 以及生成CHANGELOG:</p><ul><li><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener">conventional-changelog</a> - 从项目的提交信息中生成CHANGELOG和发布信息</li><li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">commitlint</a> - 检验提交信息</li><li><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">commitizen</a> - 🔥简单的提交规范和提交帮助工具，推荐</li><li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">standard-changelog</a> - angular风格的提交命令行工具 </li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-2-构建规范"><a href="#1-2-构建规范" class="headerlink" title="1.2 构建规范"></a>1.2 构建规范</h3><p>对于团队、或者需要维护多个项目场景，统一的构建工具链很重要, <strong>这套工具应该强调”约定大于配置”，让开发者更专注于业务的开发</strong>。笔者在<a href="https://juejin.im/post/5d2fcaacf265da1b95708f63" target="_blank" rel="noopener">&lt;为什么要用vue-cli3?&gt;</a>文章中提出了<code>vue-cli3</code>更新有很多亮点，非常适合作为团队构建工具链的基础:</p><ul><li><strong>首先这类工具是推崇’约定大于配置’</strong>。即按照他们的规范，可以实现开箱即用，快速开发业务. 在团队协作中这点很重要，我们不推荐团队成员去关心又臭又长的webpack构建配置</li><li><strong><code>vue-cli3</code>抽离了<code>cli service层</code>，可以独立更新工具链</strong>。也就是说项目的构建脚本和配置在一个独立的service项目中维护，而不是像以前一样在每个项目目录下都有webpack配置和依赖. 这样做的好处是独立地、简单地升级整个构建链</li><li><strong>灵活的插件机制</strong>。对于团队的定制化构建应该封装到插件中，这样也可以实现独立的更新。</li></ul><p><strong>我们可以选择第三方CLI, 当然也定制自己的构建链，按照上面说的这个构建链应该有以下特点</strong>:</p><ul><li><strong>强约定，体现团队的规范</strong>。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 <em>另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能</em>。</li><li><strong>方便升级</strong>。尤其是团队需要维护多个项目场景, 这一点很有意义</li></ul><p>下面是社区上比较流行的构建工具. 当然，你也可以根据自己的团队情况开发自己的CLI, 但是下面的工具依然很有<em>参考价值</em>：</p><ul><li><a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> - 🔥零配置开始React开发</li><li><a href="https://cli.vuejs.org/" target="_blank" rel="noopener">vue-cli</a> - 🔥零配置、渐进增强的项目构建CLI</li><li><a href="https://parceljs.org/" target="_blank" rel="noopener">parcel</a> - 零配置的Web应用打包工具</li><li><a href="https://github.com/fuse-box/fuse-box" target="_blank" rel="noopener">Fusebox</a> - 高速易用的打包工具</li><li><a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> - 零配置, 基于Rollup，适合用于打包‘库’</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-3-发布工作流规范"><a href="#1-3-发布工作流规范" class="headerlink" title="1.3 发布工作流规范"></a>1.3 发布工作流规范</h3><p>发布工作流指的是将‘软件成品’对外发布(如测试或生产)的一套流程, 将这套流程规范化后，可以实现自动化.</p><p>举个例子, 一个典型的发布工作流如下：</p><p><img src="/images/frontend-standard/pub.png" alt></p><ul><li>代码变更</li><li>提交代码变更到远程版本库</li><li>程序通过CI测试(例如Travis变绿)</li><li>提升package.json中的版本</li><li>生成CHANGELOG</li><li>提交package.json和CHANGELOG.md文件</li><li>打上Tag</li><li>推送</li></ul><p>如果你遵循上面的规范，那么就可以利用社区上现有的工具来自动化这个流程. 这些工具有:</p><ul><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli" target="_blank" rel="noopener">conventional-changelog-cli</a></li><li><a href="https://github.com/conventional-changelog/conventional-github-releaser" target="_blank" rel="noopener">conventional-github-releaser</a></li><li>实际上自己开发一个也不是特别难的事情.</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-4-持续集成"><a href="#1-4-持续集成" class="headerlink" title="1.4 持续集成"></a>1.4 持续集成</h3><p>将整套开发工作流确定下来之后, 就可以使用<code>持续集成服务</code>来自动化执行整个流程。比如一个典型的CI流程:</p><p><img src="/images/frontend-standard/ci.png" alt></p><p><strong>持续集成是什么，有什么意义呢</strong>?</p><p>我们需要<code>持续集成</code>拆成两个词分别来理解, 什么是<code>持续</code>? 什么是<code>集成</code>?</p><p><strong>持续(Continuous), 可以理解为’频繁’或者‘连续性’</strong>. 不管是持续集成还是敏捷开发思维、看板，都认为‘持续’是它们的基础。</p><p>举一个通俗的例子，<strong>比如代码检查，‘持续的’的代码检查就是代码一变动(如保存，或者IDE实时检查、或者提交到版本库时)就马上检查代码，而‘非持续’的代码检查就是在完成所有编码后，再进行检查</strong>。对比两者可以发现，持续性的代码检查可以尽早地发现错误，而且错误也比较容易理解和处理，反之非持续性的代码检查，可能会发现一堆的错误，失之毫厘谬以千里，错误相互牵连，最终会变得难以收拾。</p><p><strong>‘持续’的概念，可以用于软件开发的方方面面，本质上就是把传统瀑布式的软件开发流程打碎，形成一个个更小的开发闭环，持续地输出产品，同时产品也持续地给上游反馈和纠正</strong>。</p><p><img src="/images/frontend-standard/continous.png" alt></p><p><strong>那什么是‘集成’呢</strong>？狭义的集成可以简单认为是<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe#heading-26" target="_blank" rel="noopener">‘集成测试’</a>吧. 集成测试可以对代码静态测试、单元测试、通过单元测试后可以进行集成测试，在应用组成一个整体后在模拟环境中跑E2E测试等等。也就是说，在这里进行一系列的自动化测试来验证软件系统。</p><p>广义的持续集成服务，不仅仅是测试，它还衍生出很多概念，例如持续交付、持续部署，如下图</p><p><img src="/images/frontend-standard/devops.png" alt></p><p>OK, <strong>总结一下为什么持续集成的好处</strong>:</p><ul><li>尽早发现错误，快速试错。越早发现错误，处理错误的成本越低</li><li>自动化工作流，减少人工干预。人类比机器容易犯错, 而且机器擅长做重复的事情</li></ul><p><br></p><p><strong>对于持续集成规范一般会定义这些内容</strong>:</p><ul><li>执行的环境. 比如容器、Node版本、操作系统等等</li><li>触发的条件。比如定时触发、在哪个分支触发、会触发什么任务等等</li><li>执行的任务</li><li>划分持续集成的阶段. 比如<ul><li>检查：包括单元测试和代码lint. 所有push到版本库的代码都会跑这个阶段. 一般可以在提交title中包含[ci skip]来跳过这个阶段</li><li>构建: 对前端项目进行构建. 只有打上版本tag的提交或release分支会跑构建任务</li><li>发布: 将前端的构建结果进行交付/发布.  只有打上版本tag的提交或者release分支在构建成功后会跑发布任务</li></ul></li><li>定义持续集成脚本模板</li></ul><p><br></p><p>常用的CI服务:</p><ul><li>Github<ul><li><a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a></li><li><a href="https://github.com/marketplace/circleci" target="_blank" rel="noopener">CircleCI</a></li><li><a href="https://github.com/marketplace/category/continuous-integration" target="_blank" rel="noopener">完整列表</a></li></ul></li><li>GitLab: <a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">Gitlab-CI</a></li><li>通用<ul><li><a href="https://jenkins.io" target="_blank" rel="noopener">Jenkins</a></li></ul></li></ul><p><br></p><p>扩展</p><ul><li><a href="https://juejin.im/post/58f9ee860ce46300611be392" target="_blank" rel="noopener">持续集成是什么</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-5-任务管理"><a href="#1-5-任务管理" class="headerlink" title="1.5 任务管理"></a>1.5 任务管理</h3><p><img src="/images/frontend-standard/kanban.png" alt></p><p>作为前端Leader少不了任务管理。<strong>看板是目前最为流行的任务管理工具，它可以帮助我们了解项目的进度、资源的分配情况、还原开发现场</strong>.</p><p>笔者毕业第一年在一家很小的外包公司中工作，初生牛犊不怕虎，我竟然给老板推销起了看板和敏捷项目管理，想要改善项目管理这块效率低下问题，老板表示很支持，但是其他成员积极性并不高, 结果当然是失败的。</p><p>当时还起草了一份<a href="https://github.com/ivan-94/kanban_enforcement/blob/master/README.md#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%8B%E6%9D%BF" target="_blank" rel="noopener">‘看板实施细则’</a>, 所以任务管理这一块也算小有心得吧.</p><p>说说一些比较好用的工具吧：</p><ul><li><strong>基于issue看板</strong> - 可以基于Gitlab或Github的Issue来做任务管理，它们都支持看板。很Geek，推荐</li><li><a href="https://tower.im/" target="_blank" rel="noopener"><strong>Tower</strong></a> - 专门做看板任务管理的。小团队基本够用。我们现在就使用这款产品</li><li><a href="https://www.teambition.com/" target="_blank" rel="noopener"><strong>teambition</strong></a> - 和Tower差不多，没有深入使用过</li><li><a href="https://trello.com/" target="_blank" rel="noopener"><strong>Trello</strong></a> - 颜值高.</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="2-技术栈规范"><a href="#2-技术栈规范" class="headerlink" title="2 技术栈规范"></a>2 技术栈规范</h2><p>笔者现在所在的公司之前前端技术栈就非常混乱，Vue、React和AngularJS三大框架都有, 而且风格相差也很大. 当时我就想收包裹走人. 关于技术栈不规范的下场可以参考印度的飞机: <a href="https://www.zhihu.com/question/26042167/answer/690035402" target="_blank" rel="noopener">&lt;为什么印度的飞机频繁被摔？&gt;</a></p><p>很少有人能精通这三个框架的，更别说是一个团队。</p><p><strong>三大框架跟编程语言一样都有自己的设计哲学，这跟库是不一样, 一个库的替换成本很低；而框架的背后是一个架构、一个生态。每个框架背后牵涉着开发思维、生态系统、配套工具、最佳实践、性能调优。要精通和熟练一个框架需要付出的成本是很高</strong>。</p><p><strong>所以说团队的开发效率是基于稳定且熟练的技术栈的</strong>。稳定的技术栈规范有利于团队协作和沟通; 另外如果团队精通这个技术栈，当出现问题或者需要深入调优, 会相对轻松。</p><p>前端技术栈规范主要包含下面这些类型:</p><ul><li>编程语言 - Typescript或Javascript</li><li>UI框架及其配套生态, 以及备选方案。其背后的生态非常庞大:<ul><li>UI框架</li><li>路由</li><li>状态管理</li><li>组件库</li><li>国际化</li><li>动画</li><li>服务端渲染</li><li>脚手架、CLI工具</li><li>组件测试</li></ul></li><li>样式. 包含了命名规范、预处理器、方法论等等</li><li>动画引擎</li><li>QA. 包含了测试、Lint、格式化工具、监控</li><li>项目构建工具流. 例如webpack、vue-cli</li><li>包管理器。npm、yarn</li><li>项目管理工具</li><li>时间处理。例如Moment.js</li><li>模板引擎</li><li>开发工具</li><li>后端开发框架</li><li>工具库</li><li>开发/调试工具</li><li>等等</li></ul><p>可以参考一下我们团队的<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/tech-stack.md" target="_blank" rel="noopener">技术栈规范</a></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="2-1-技术选型"><a href="#2-1-技术选型" class="headerlink" title="2.1 技术选型"></a>2.1 技术选型</h3><p><a id="tech-select"></a></p><p><strong>如何从零对团队的技术栈进行规范, 或者说怎么进行选型呢</strong>？举个例子, 先确定备选项, 你现在要选Vue还是选React(一个可能引起论战的主题)？</p><p>恰好前几天在SegmentFault回答了一个问题: <a href="https://segmentfault.com/q/1010000019762657/a-1020000019775888" target="_blank" rel="noopener">&lt;什么时候用vue什么时候用react？&gt;</a>, 我讲了一个我们<strong>几年前</strong>是如何决定要使用React还是Vue的例子(注意结果不重要！)：</p><p><img src="/images/frontend-standard/vue-vs-react.png" alt></p><p><br></p><p><a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a>这篇文章写得非常好，给了我一些启发。结合上面的回答的例子, 来讲一讲在对相关技术进行选型的一些方法(评分项):</p><ul><li><p><strong>选择你最熟悉的技术</strong>。上面说到团队如果熟悉该技术，则可以很好地控制使用过程中的风险，方便对程序进行调优。所以成员熟悉、或至少Leader熟悉程度，是技术选型的一个打分项。</p><p>我们团队最终选择React的一个原因，就是我们熟悉它，它已经在现有的几个应用中良好的运行了，所以 React + 1</p></li><li><p><strong>选择拥有强大生态和社区支撑的开源技术</strong>。有强大的生态和社区意味着，很多东西你不需要重复去造轮子，或者遇到问题可以很快解决，有更多的选择。从公司层面、使用活跃的技术也比较好招人。</p><p>上面的例子也提到了这点，几年前React的生态是强于Vue的，所以 React + 1</p></li><li><p><strong>选择成长期的技术</strong>。<a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a>里面有一句话：’选择一个技术的最低标准是，技术的生命周期必须显著长于项目的生命周期’</p><p> 我们选择的技术应该是向前发展的、面向未来的, 这是选型的基本原则。所以我们一般不会去选择那些’过气’的技术，比如<code>AngularJS</code>(1.x)、<code>Backbone</code>. 因为现在有更好的选择，不必过于保守。</p><p> ‘向前’还意味着Leader要能够预判该技术未来走向，这里有很多参考因素，比如大厂的支撑、目前社区的活跃度、开发活跃度等等</p><p> React、Vue都非常有动力，比如React最近的React Hook、还有未来的ConcurrentMode、Async Rendering… 在这点上Vue和React打成平手吧</p></li><li><p><strong>API的稳定性</strong>。比较典型的例子就是Angular和Python，API不稳定会导致社区的割裂，也会导致项目升级成本变高、或者无法升级, 最终成为技术债。</p><p>不过值得庆幸的是因为有这么多历史教训，现在开源项目在API变更上面是非常谨慎的，参考<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">[译] Vue 最黑暗的一天</a>事件. </p><p>这点上React和Vue依旧打平</p></li><li><p><strong>基础设施配合</strong>。一个技术往往不是孤立存在的，它需要和其他技术相互配合，这种技术之间的融合度也是需要考虑的。</p><p>这个根据团队使用情况来定，比如我们团队统一使用Typescript，Vue跟Typescript配合使用其实不理想，所以 React + 1</p></li><li><p><strong>业务考虑</strong> <a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a> 提到一点就是‘学会从业务端开始思考’. 意思<strong>就是选型需要充分地理解业务，理解用户需求，当下需要解决的首要问题，以及可能的风险有哪些，再将目标进行分解，进行具体的技术选型、模型设计、架构设计</strong>.</p><p>一个典型的例子就是10年前火遍世界的<code>Rails</code>, 后端是使用Rails还是Java/C#/PHP这些传统后端技术? 很多初创公司(如Github、Gitlab、Twitter)选择了前者，他们需要快速开发原型、快速占领市场, Rails开发很爽很快啊, 这种选型就是符合‘业务需求的’。</p><p>那么前端好像跟业务离得有点远? 随着‘大前端’的发展，我们的工作对公司业务的影响只会越来越大。</p><p>比如上面提到的React Native，我们当时有考虑在移动端应用React Native技术，实现客户端的跨平台，这就是业务影响啊。这时候React是不是又要 +1? 同理还有什么服务端渲染、Serverless等等，期待前端的地位会越来越高</p></li></ul><p>综上，在这个案例中，React是胜出的。</p><p>扩展:</p><ul><li><a href="https://www.infoq.cn/article/2017/02/Technology-selection" target="_blank" rel="noopener">谈谈技术选型</a></li><li><a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">谈谈技术选型的注意事项</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="2-2-迎接新技术"><a href="#2-2-迎接新技术" class="headerlink" title="2.2 迎接新技术"></a>2.2 迎接新技术</h3><p>当然，对于团队而言也要鼓励学习新的技术、淘汰旧的技术栈。因为一般而言新的技术或解决方案，是为了更高的生产力而诞生的。<strong>当团队容纳一个新的技术选型需要考虑以下几点</strong>：</p><ul><li><strong>学习成本</strong>。考虑团队成员的接纳能力。如果成本小于收获的利益，在团队里面推行估计阻力会比较大</li><li><strong>收益</strong>。是否能够解决当前的某些痛点</li><li><strong>考虑风险</strong>。一般我们不能将一个实验阶段的技术使用的生产环境中</li></ul><p>就我们团队而言，每个成员都有自己感兴趣的方向和领域，所以我们可以分工合作，探索各自的领域，再将成果分享出来，如果靠谱的话则可以在实验项目中先试验一下，最后才推广到其他项目.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="3-浏览器兼容规范"><a href="#3-浏览器兼容规范" class="headerlink" title="3 浏览器兼容规范"></a>3 浏览器兼容规范</h2><p>前端团队应该根据针对应用所面对的用户情况、应用类型、开发成本、浏览器市场统计数据等因素，来制定自己的浏览器兼容规范，并写入应用使用手册中.</p><p><strong>有了浏览器兼容规范，前端开发和兼容性测试就有理有据，避免争议; 同时它也是前端团队的一种对外声明，除非特殊要求，不符合浏览器兼容规范的浏览器，前端开发人员可以选择忽略</strong>。</p><p><br></p><h3 id="3-1-确定兼容策略"><a href="#3-1-确定兼容策略" class="headerlink" title="3.1 确定兼容策略"></a>3.1 确定兼容策略</h3><p><img src="/images/frontend-standard/g-p.jpg" alt></p><p><strong>渐进增强</strong>还是<strong>优雅降级</strong>. 这是两个不同方向策略，<strong>渐进增强保证低版本浏览器的体验，对于支持新特性的新浏览器提供稍好的体验</strong>；<strong>优雅降级则是相反的，为现代浏览器提供最好的体验，而旧浏览器则退而求之次，保证大概的功能</strong>.</p><p>选择不同的策略对前端开发的影响是比较大的，但是开发者没有选择权。<strong>确定哪种兼容策略，应该取决于用户比重，如果大部分用户使用的是现代浏览器，就应该使用优雅降级，反之选择渐进增强</strong>.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="3-2-确定浏览器分级"><a href="#3-2-确定浏览器分级" class="headerlink" title="3.2 确定浏览器分级"></a>3.2 确定浏览器分级</h3><p><img src="/images/frontend-standard/brw-levl.gif" alt></p><p>YUI就曾提出浏览器分级原则，到今天这个原则依然适用。简单说就是将浏览器划分为多个等级，不同等级表示不同的支持程度. 比如我们团队就将浏览器划分为以下<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/browser-compatibility.md" target="_blank" rel="noopener">三个等级</a>:</p><ul><li><strong>完全兼容</strong>: 保证百分百功能正常</li><li><strong>部分兼容</strong>: 只能保证功能、样式与需求大致一致。对于一些不影响主体需求和功能的bug，会做降低优先级处理或者不处理。</li><li><strong>不兼容</strong>: 不考虑兼容性</li></ul><p>一般而言, 根据浏览器市场分布情况、用户占比、开发成本等因素划分等级.</p><p>举个例子，下面是我们对管理系统的兼容规范:</p><p><img src="/images/frontend-standard/cpt.png" alt></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="3-3-获取统计数据"><a href="#3-3-获取统计数据" class="headerlink" title="3.3 获取统计数据"></a>3.3 获取统计数据</h3><p><a id="brw-anly"></a></p><p><img src="/images/frontend-standard/bdtj.png" alt></p><p><br></p><p><a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>是中文网站使用最为广泛的、免费的流量分析平台. 如上图，通过这些统计平台可以获取到终端真实的浏览器使用情况, 点击<a href="https://tongji.baidu.com/web/demo/visit/client?siteId=5503017" target="_blank" rel="noopener">查看示例</a>。</p><p>如果公司没有开发自己监控服务，还是建议使用这些免费的，有大厂支持的监控工具:</p><ul><li><a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a></li><li><a href="https://web.umeng.com/main.php?spm=a211g2.211692.0.0.3a437d23sjzEPv&amp;c=user&amp;a=index" target="_blank" rel="noopener">友盟</a></li><li><a href="https://analytics.google.com/analytics/web/" target="_blank" rel="noopener">Google Analytics</a> 需要kx上网</li></ul><p><br></p><p><strong>可以从这些地方获取通用的浏览器统计数据</strong>:</p><ul><li><a href="http://tongji.baidu.com/data/browser" target="_blank" rel="noopener">百度流量研究院</a>：主要提供国内浏览器统计</li><li><a href="http://gs.statcounter.com/" target="_blank" rel="noopener">statcounter</a>: 国际浏览器统计</li><li><a href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers" target="_blank" rel="noopener">浏览器发布年份统计</a></li></ul><p><br></p><p><strong>确定浏览器是否支持某个特性</strong>:</p><ul><li><a href="https://caniuse.com" target="_blank" rel="noopener">caniuse</a></li><li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="4-项目组织规范"><a href="#4-项目组织规范" class="headerlink" title="4 项目组织规范"></a>4 项目组织规范</h2><p>项目组织规范定义了如何组织一个前端项目, 例如项目的命名、项目的文件结构、版本号规范等等。尤其对于开源项目，规范化的项目组织就更重要了。</p><h3 id="4-1-通用的项目组织规范"><a href="#4-1-通用的项目组织规范" class="headerlink" title="4.1 通用的项目组织规范"></a>4.1 通用的项目组织规范</h3><p>一个典型的项目组织规范如下:</p><ul><li><strong>README.md</strong>: 项目说明, 这个是最重要。你必须在这里提供关于项目的关键信息或者相关信息的入口. 一般包含下列信息:<ul><li>简要描述、项目主要特性</li><li>运行环境/依赖、安装和构建、测试指南</li><li>简单示例代码</li><li>文档或文档入口, 其他版本或相关资源入口</li><li>联系方式、讨论群</li><li>许可、贡献/开发指南</li></ul></li><li><strong>CHANGELOG.md</strong>: 放置每个版本的变动内容, 通常要描述每个版本变更的内容。方便使用者确定应该使用哪个版本. 关于CHANGELOG的规范可以参考<a href="https://keepachangelog.com/en/1.0.0/" target="_blank" rel="noopener">keep a changelog</a></li><li><strong>package.json</strong>: 前端项目必须. 描述当前的版本、<strong>可用的命令</strong>、包名、依赖、环境约束、项目配置等信息.</li><li><strong>.gitignore</strong>: 忽略不必要的文件，避免将自动生成的文件提交到版本库</li><li><strong>.gitattributes</strong>: git配置，有一些跨平台差异的行为可能需要在这里配置一下，如换行规则</li><li><strong>docs/</strong>: 项目的细化文档, 可选.</li><li><strong>examples/</strong>: 项目的示例代码，可选.</li><li><strong>build</strong>: 项目工具类脚本放置在这里，非必须。如果使用统一构建工具，则没有这个目录</li><li><strong>dist/</strong>: 项目构建结果输出目录</li><li><strong>src/</strong>: 源代码目录</li><li><p><strong><strong>tests</strong>/</strong>: 单元测试目录. 按照<a href="http://jestjs.io" target="_blank" rel="noopener">Jest</a>规范, <code>__tests__</code>目录通常和被测试的模块在同一个父目录下, 例如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/src</span><br><span class="line">  __tests__/</span><br><span class="line">    index.ts</span><br><span class="line">    a.ts</span><br><span class="line">  index.ts</span><br><span class="line">  a.ts</span><br></pre></td></tr></table></figure></li><li><p><strong>tests</strong>: 全局的测试目录，通常放应用的集成测试或E2E测试等用例</p></li><li><p><strong>.env*</strong>: 项目中我们通常会使用<code>环境变量</code>来影响应用在不同运行环境下的行为. 可以通过<a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotEnv</a>来从文件中读取环境变量. 通常有三个文件:</p><ul><li><code>.env</code> 通用的环境变量</li><li><code>.env.development</code> 开发环境的环境变量</li><li><code>.env.production</code> 生成环境的环境变量</li></ul><p>基本上这些文件的变动的频率很少，团队成员应该不要随意变动，以免影响其他成员。所以通常会使用<code>.env.*.local</code>文件来覆盖上述的配置, 另外会设置版本库来忽略<code>*.local</code>文件.</p></li></ul><p><br></p><p><strong>对于开源项目通常还包括这些目录</strong>:</p><ul><li><strong>LICENSE</strong>: 说明项目许可</li><li><strong>.github</strong>: 开源贡献规范和指南<ul><li>CONTRIBUTING: 贡献指南, 这里一般会说明贡献的规范、以及项目的基本组织、架构等信息</li><li>CODE_OF_CONDUCT: 行为准则</li><li>COMMIT_CONVENTION: 提交信息规范，上文已经提及</li><li>ISSUE_TEMPLATE: Issue的模板，github可以自动识别这个模板</li><li>PULL_REQUEST_TEMPLATE: PR模板</li></ul></li></ul><p>任意一个优秀的开源项目都是你的老师，例如<a href="https://github.com/facebook/react" target="_blank" rel="noopener">React</a>、<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue</a>…</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="4-2-目录组织的风格"><a href="#4-2-目录组织的风格" class="headerlink" title="4.2 目录组织的风格"></a>4.2 目录组织的风格</h3><p>上面只是一个通用的项目组织规范，具体源代码如何组织还取决于你们使用的技术栈和团队喜好。网上有很多教程，具体可以搜索<code>怎么组织XX项目</code>. 总结一下项目组织主要有三种风格:</p><ul><li><p><strong>Rails-style</strong>: 按照文件的类型划分为不同的目录，例如<code>components</code>、<code>constants</code>、 <code>typings</code>、<code>views</code>. 这个来源于Ruby-on-Rails框架，它按照MVC架构来划分不同的目录类型，典型的目录结构如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  models # 模型</span><br><span class="line">  views # 视图</span><br><span class="line">  controllers # 控制器</span><br><span class="line">  helpers # 帮助程序</span><br><span class="line">  assets  # 静态资源</span><br><span class="line">config     # 配置</span><br><span class="line">  application.rb</span><br><span class="line">  database.yml</span><br><span class="line">  routes.rb      # 路由控制</span><br><span class="line">  locales        # 国际化配置</span><br><span class="line">  environments/</span><br><span class="line">db        # 数据库相关</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>Domain-style</strong>:  按照一个功能特性或业务创建单独的目录，这个目录就近包含多种类型的文件或目录. 比如一个典型的Redux项目，所有项目的文件就近放置在同一个目录下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Users/</span><br><span class="line">Home/</span><br><span class="line">  components/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  constants.js</span><br><span class="line">  index.js</span><br><span class="line">  model.js</span><br><span class="line">  reducer.js</span><br><span class="line">  selectors.js</span><br><span class="line">  style.css</span><br><span class="line">index.js</span><br><span class="line">rootReducer.js</span><br></pre></td></tr></table></figure></li><li><p><strong>Ducks-style</strong>: 优点类似于Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下。Vue的单文件组件就是一个典型的例子，除此之外Vuex也是使用这种风格:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;My Todo App!&lt;/h1&gt;</span><br><span class="line">    &lt;TodoList/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import TodoList from &apos;./components/TodoList.vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    TodoList</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">@import &apos;./variables.scss&apos;;</span><br><span class="line">/* ... */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>大部分情况下, 我们都是使用混合两种方式的目录结构，例如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/      # 🔴 项目通用的‘展示组件’</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx    # 组件的入口, 导出组件</span><br><span class="line">      Groups.tsx   # 子组件</span><br><span class="line">      loading.svg  # 静态资源</span><br><span class="line">      style.css    # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts       # 到处所有组件</span><br><span class="line">  containers/      # 🔴 包含'容器组件'和'页面组件'</span><br><span class="line">    LoginPage/     # 页面组件, 例如登录</span><br><span class="line">      components/  # 页面级别展示组件，这些组件不能复用与其他页面组件。</span><br><span class="line">        Button.tsx # 组件未必是一个目录形式，对于一个简单组件可以是一个单文件形式. 但还是推荐使用目录，方便扩展</span><br><span class="line">        Panel.tsx</span><br><span class="line">      reducer.ts   # redux reduces</span><br><span class="line">      useLogin.ts  # (可选)放置'逻辑', 按照👆分离逻辑和视图的原则，将逻辑、状态处理抽取到hook文件</span><br><span class="line">      types.ts     # typescript 类型声明</span><br><span class="line">      style.css</span><br><span class="line">      logo.png</span><br><span class="line">      message.ts</span><br><span class="line">      constants.ts</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx      # 🔴应用根组件</span><br><span class="line">  hooks/           # 🔴可复用的hook</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.tsx        # 应用入口, 在这里使用ReactDOM对跟组件进行渲染</span><br><span class="line">  stores.ts        # redux stores</span><br><span class="line">  contants.ts      # 全局常量</span><br></pre></td></tr></table></figure><p><br></p><p>框架官方很少会去干预项目的组织方式，读者可以参考下面这些资源来建立自己项目组织规范:</p><ul><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fcn.redux.js.org%2Fdocs%2Ffaq%2FCodeStructure.html" target="_blank" rel="noopener">Redux 常见问题：代码结构</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Freact-boilerplate%2Freact-boilerplate" target="_blank" rel="noopener">react-boilerplate</a></li><li><a href="https://vuex.vuejs.org/zh/guide/structure.html" target="_blank" rel="noopener">vuex 项目结构</a></li><li><a href="https://juejin.im/post/5cd8fb916fb9a03218556fc1#heading-11" target="_blank" rel="noopener">React组件设计实践总结02 - 组件的组织</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="4-3-脚手架和项目模板"><a href="#4-3-脚手架和项目模板" class="headerlink" title="4.3 脚手架和项目模板"></a>4.3 脚手架和项目模板</h3><p>在将项目结构规范确定下来后，可以创建自己的脚手架工具或者项目模板，用于快速初始化一个项目或代码模板。</p><p>相关资源:</p><ul><li><a href="https://yeoman.io" target="_blank" rel="noopener">yeoman</a> - 老牌的项目脚手架工具</li><li><a href="https://github.com/amwmedia/plop" target="_blank" rel="noopener">plop</a> - 代码生成辅助CLI</li><li><a href="https://github.com/jondot/hygen" target="_blank" rel="noopener">hygen</a> - 类似于plop</li><li><a href="https://github.com/diegohaz/generact" target="_blank" rel="noopener">generact</a> - 生成React组件, 大部分组件的文件结构差不多, 这个工具就是帮助你生成这些重复的代码</li><li><a href="https://babeljs.io/docs/en/babel-generator" target="_blank" rel="noopener">babel-code-generator</a> - 利用babel来实现更高级的代码编辑和自动生成</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="5-编码规范"><a href="#5-编码规范" class="headerlink" title="5 编码规范"></a>5 编码规范</h2><p>网络上大部分‘前端规范’指的都是编码规范, 这是一种‘狭义’的前端规范. </p><p><strong>统一的编码规范对团队项目的长远维护不无裨益. 一致性的代码规范可以增强团队开发协作效率、提高代码质量、减少遗留系统维护的负担</strong>。</p><p>最直接的好处就是避免写出糟糕的代码, 糟糕的代码与新手和老手关系不大，我也见过好处工作很多年的‘资深’工程师写出恶心的代码. 这样的代码随着项目的迭代会变得难以控制。</p><p><strong>现代的Lint工具已经非常先进，几乎可以约束各种编码行为</strong>. 比如约束一个文件的长度、函数的复杂度、命名规范、注释规范、接口黑名单、DeadCode、检查简单的逻辑错误…</p><p>每一个程序员心目中对‘好代码’都有自己的主见，统一的编码规范可以像秦始皇统一战国一样，避免不必要的论战和争议。</p><p><br></p><p><strong>其实与其自己建立前端编码规范，笔者推荐选择社区沉淀下来的规范</strong>. 这方面的资源非常多，所以本文也不武断地提出自己的规范建议. 推荐下面这些资源:</p><p><br></p><h3 id="5-1-javascript"><a href="#5-1-javascript" class="headerlink" title="5.1 Javascript"></a>5.1 Javascript</h3><ul><li>Lint工具<ul><li><a href="https://cn.eslint.org" target="_blank" rel="noopener">ESLint</a> - 🔥目前是社区最流行的、通用的Javascript Lint工具，Lint界的Babel。支持定制插件、preset。如果不想折腾可以选择它的一些预定义配置</li><li><a href="https://github.com/palantir/tslint" target="_blank" rel="noopener">TSLint</a> - Typescript Lint工具。不过即将<a href="https://github.com/palantir/tslint/issues/4534" target="_blank" rel="noopener">废弃</a>了, 推荐使用ESLint</li></ul></li><li>规范<ul><li><a href="https://standardjs.com/readme-zhcn.html#why-should-i-use-javascript-standard-style" target="_blank" rel="noopener">JavaScript Standard Style</a> - 🔥 零配置的、‘标准’的Javascript编码规范. 底层基于Eslint。目前不支持Typescript</li><li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb JavaScript Style Guide</a> - Airbnb的编码规范，业界标杆</li></ul></li><li>类型检查. 暂时将它们归类到这里，因为它们同属于<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe#heading-39" target="_blank" rel="noopener">‘静态测试’</a><ul><li><a href="https://www.typescriptlang.org" target="_blank" rel="noopener">Typescript</a> - 🔥 Javascript语言的超集，这是一门‘新’的语言，而不是简单的类型检查器. 不过<strong>它也支持<a href="https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html" target="_blank" rel="noopener">原生Javascript的类型检查</a></strong></li><li><a href="https://flow.org" target="_blank" rel="noopener">Flow</a> - Facebook出品的类型检查器，语法和Typescript类似. 个人推荐使用Typescript</li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-2-html"><a href="#5-2-html" class="headerlink" title="5.2 HTML"></a>5.2 HTML</h3><ul><li>Lint工具<ul><li><a href="https://htmlhint.io" target="_blank" rel="noopener">HTMLHint</a></li><li><a href="https://github.com/twbs/bootlint" target="_blank" rel="noopener">bootlint</a></li></ul></li><li>规范<ul><li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-3-css"><a href="#5-3-css" class="headerlink" title="5.3 CSS"></a>5.3 CSS</h3><ul><li>Lint工具<ul><li><a href="https://stylelint.docschina.org" target="_blank" rel="noopener">stylelint</a> - 🔥 通用的CSS编码检查工具，支持最新的CSS语法、CSS-in-js、以及其他类CSS语法(如SCSS、Less). 它也有预定义配置，推荐使用</li></ul></li><li>规范<ul><li><a href="https://github.com/airbnb/css" target="_blank" rel="noopener">Airbnb CSS / Sass Styleguide</a></li><li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li><li><a href="https://css-tricks.com/css-style-guides/" target="_blank" rel="noopener">更多</a></li></ul></li><li>方法论<ul><li><a href="https://css-tricks.com/bem-101/" target="_blank" rel="noopener">BEM</a> - 🔥 BEM命名规范</li><li><a href="https://github.com/stubbornella/oocss/wiki" target="_blank" rel="noopener">OOCSS</a></li><li><a href="http://smacss.com" target="_blank" rel="noopener">smacss</a></li></ul></li></ul><p><br></p><p>关于CSS可以学习<a href="http://twitter.github.com/bootstrap/" target="_blank" rel="noopener">Bootstrap</a>这些传统UI框架，他们的代码组织性非常好, 值得学习</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-4-代码格式化"><a href="#5-4-代码格式化" class="headerlink" title="5.4 代码格式化"></a>5.4 代码格式化</h3><p><img src="/images/frontend-standard/prt.png" alt></p><ul><li><a href="https://prettier.io" target="_blank" rel="noopener">Prettier</a> - 🔥 关于代码格式化的所有东西都交给它吧！</li></ul><p>基本上，所有代码格式相关的工作都可以交给Prettier来做，在这个基础上再使用Eslint覆盖语义相关的检查</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-5-集大成的"><a href="#5-5-集大成的" class="headerlink" title="5.5 集大成的"></a>5.5 集大成的</h3><ul><li><a href="https://coderlmn.github.io/code-standards/#_code_reviews" target="_blank" rel="noopener">isobar 前端代码规范及最佳实践</a></li><li><a href="https://guide.aotu.io/index.html" target="_blank" rel="noopener">凹凸实验室代码规范</a></li><li><a href="https://github.com/fex-team/styleguide" target="_blank" rel="noopener">百度FEX规范</a></li><li><a href="http://nec.netease.com/standard" target="_blank" rel="noopener">老牌的NEC规范</a> - 有点老</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-6-特定框架风格指南"><a href="#5-6-特定框架风格指南" class="headerlink" title="5.6 特定框架风格指南"></a>5.6 特定框架风格指南</h3><ul><li><a href="https://vue.docschina.org/v2/style-guide/" target="_blank" rel="noopener">vue-style-guide</a></li><li><a href="https://github.com/airbnb/javascript/tree/master/react" target="_blank" rel="noopener">Airbnb React/JSX Style Guide</a></li><li><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715" target="_blank" rel="noopener">React组件设计实践总结</a> - 自荐一下笔者写的React组件设计相关实践</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-7-code-review"><a href="#5-7-code-review" class="headerlink" title="5.7 Code Review"></a>5.7 Code Review</h3><p><img src="/images/frontend-standard/code-review.png" alt></p><p>上述的Lint工具和类型检查器, 可以约束代码风格、避免低级的语法错误。但是即使通过上面的Lint和类型检查，代码也可能未必是‘好代码’。</p><p><strong>很多代码设计的‘最佳实践’是无法通过具象化的自动化工具或文档覆盖的, 这时候，’经验’或者’群体智慧’就派上用场了</strong>. 比如Code Review阶段会检查这些东西:</p><ul><li>编程原则、设计思想. 例如符合SOLID原则? 是否足够DRY？接口设计是否简洁易扩展、</li><li>模块耦合程度、代码重复</li><li>代码健壮性。是否存在内存泄露、是否线程安全、是否有潜在性能问题和异常、错误是否被处理</li><li>代码的性能和效率。</li><li>是否有没有考虑到的场景？</li></ul><p>如果你们是第一次推行Code Review, 可以建立一个检查列表，对照着进行检查。熟练后，心中自然无码。</p><p><br></p><p>Code Review有很多好处，比如：</p><ul><li><strong>Code Review可以让其他成员都熟悉代码</strong>。这样保证其他人都可以较快地接手你的工作，或者帮你解决某些问题</li><li><strong>提高代码质量</strong>。毫无疑问. 一方面是<em>主动性</em>的代码质量提升，比如你的代码需要被人Review，会自觉尽量的提高代码质量；另一方面，其他成员可以检查提交方的代码质量</li><li><strong>检查或提高新成员的编程水平</strong>。培养新人时，由于不信任它们提交的代码，我们会做一次Review检查代码是否过关。另一方面这是一次真实的案例讲解, 可以较快提高他们的能力</li></ul><p><br></p><p><strong>Code Review有两种方式: 一个<code>提交时</code>、一个是<code>定时</code></strong>:</p><ul><li><code>提交时</code>. 大部分开源项目采用这种方式。通俗讲就是Pull Request。只有代码通过测试、和其他成员的Review才可以合进正式版本库。这种方式也称为‘阻塞式’代码检查，一般配合GitFlow使用。</li><li><code>定时</code>. 在项目完结后、项目的某个里程碑、或者固定的时间(每天、每个星期..). 团队成员聚在一起，回顾自己写的代码, 让其他成员进行审查</li></ul><p>Code Review是比较难以推行的，不过这个也要看你们团队的情况，向我们钱少活多的团队，很少的时间去立马去兼顾其他成员的代码. 这时候<code>定时Review</code>会更有用，因为看起来更‘节省时间’.</p><p>而<code>提交时Review</code>则可以针对新人，比如你不信任他们的代码或者希望帮助他们提高编码能力。</p><p><br></p><p><strong>相关资源</strong>:</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTQwNTA3Nw==&amp;mid=400946871&amp;idx=1&amp;sn=5a125337833768d705f9d87ba8cd9fff&amp;scene=1&amp;srcid=0104FLyeXIS6N0EShgDseIfI&amp;key=41ecb04b051110031290b34976240e650f0169d239c89f125162a89c8d3412f2087198612e71fd7685cae9eebe08e295&amp;ascene=0&amp;uin=MTYyMDMzMTAwMA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C5+OSX+OSX+10.10.5+build(14F1509" target="_blank" rel="noopener">Code Review最佳实践</a>&amp;version=11020201&amp;pass_ticket=dc5bBckt1XSthRKTIsukYHIcAvKfv0jninbMlYQ5TWnE6XS%2FrRkdHKlJjNTI2Wsg)</li><li><a href="https://juejin.im/post/5c9740ba6fb9a071090d6a37" target="_blank" rel="noopener">是否要做Code Review？与BAT资深架构师争论之后的思考</a></li><li><a href="https://richardcao.me/2016/09/30/Talk-About-Codereview/" target="_blank" rel="noopener">一些Code Review工具</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="6-文档规范"><a href="#6-文档规范" class="headerlink" title="6 文档规范"></a>6 文档规范</h2><p>文档对于项目开发和维护、学习、重构、以及知识管理非常重要。</p><p>和写测试一样、大部分开发人员会觉得写文档是一件痛苦的事情，不过只有时间能够证明它的价值。比如对于人员流动比较大的公司，如果有规范的文档体系，转交工作就会变动非常轻松.</p><p><strong>广义的文档不单指‘说明文件’本身，它有很多形式、来源和载体，可以描述一个知识、以及知识形成和迭代的过程</strong>。例如版本库代码提交记录、代码注释、决策和讨论记录、CHANGELOG、示例代码、规范、传统文档等等</p><p><br></p><h3 id="6-1-建立文档中心"><a href="#6-1-建立文档中心" class="headerlink" title="6.1 建立文档中心"></a>6.1 建立文档中心</h3><p>我们公司是做IM的，所以之前我们优先使用’自己的’通讯工具来分享文档，这种方式有很大问题:</p><ol><li>如果没有存档习惯(比如后端的API文档，因为由后端维护，一般不会主动去存档), 文档就可能丢失，而且通讯工具是不会永久保存你的文档的。当丢失文件就需要重新和文档维护者索要</li><li>糟糕的是文档维护者也是自己手动在本地存档的，这样导致的问题是: 如果工作转交，其他开发者需要花费一点时间来查找; 丢失了就真的没了</li><li>每一次文档更新要重新发一份, 这很麻烦，而且可能出现漏发的情况, 导致前后不一致.</li><li>关于知识的学习、以及有意义的讨论记录无法归档。</li></ol><p>上面介绍的是一种非常原始的文档共享方式，很多小团队就是这么干的。</p><p><strong>对于项目本身的文档建议放置在关联项目版本库里面，跟随项目代码进行迭代, 当我们在检索或跟踪文档的历史记录时，这种方式是最方便的</strong>。</p><p>然而很多应用是跨越多个团队的，每个团队都会有自己的文档输出(比如需求文档、系统设计文档、API文档、配置文档等等)，而且通常也不会在一个版本库里。这时候文档就比较分散。所以一个统一的文档中心是很有必要。</p><p>我们公司现在选择的方案是<code>Git+Markdown</code>，也就是说所有的文档都放置在一个git版本库下。之前也考虑过商业的方案，譬如<a href="https://shimo.im/welcome" target="_blank" rel="noopener">石墨文档</a>、<a href="https://docs.qq.com" target="_blank" rel="noopener">腾讯文档</a>, 但管理层并不信任这些服务。</p><p>大概的git项目组织如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">规范/</span><br><span class="line">A应用/</span><br><span class="line">  产品/</span><br><span class="line">  设计/</span><br><span class="line">  API文档/</span><br><span class="line">  测试/</span><br><span class="line">  其他/</span><br><span class="line">B应用/</span><br></pre></td></tr></table></figure><p><strong>Git版本库(例如Gitlab)有很多优势，例如历史记录跟踪、版本化、问题讨论(可以关联issue、或者提交)、多人协作、搜索、权限管理(针对不同的版本库或分组为不同人员设置权限)等等</strong>。</p><p><code>Git+Markdown</code>可以满足开发者的大部分需求。但是<strong>Git最擅长的是处理纯文本文件、对于二进制是无能为力的，无法针对这些类型的文档进行在线预览和编辑</strong>。</p><p>所以<code>Git+Markdown</code>并不能满足多样化的文档处理需求，比如思维导图、图表、表格、PPT、白板等需求. 毕竟它不是专业的文档处理工具。所以对于产品、设计人员这些富文档需求场景，通常会按照传统方式或者更专业的工具对文档进行管理.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-2-文档格式"><a href="#6-2-文档格式" class="headerlink" title="6.2 文档格式"></a>6.2 文档格式</h3><p>毫无疑问，对于开发者来说，<a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown</a>是最适合的、最通用的文档格式。支持版本库在线预览和变更历史跟踪。</p><p>下面这些工具可以提高Markdown的开发效率:</p><ul><li>可视化编辑器<ul><li><strong>Visual Code</strong>: 大部分代码编辑都支持Markdown编辑和预览</li><li><a href="https://link.jianshu.com/?t=http://mouapp.com/" target="_blank" rel="noopener"><strong>Mou</strong></a>: Mac下的老牌编辑器</li><li><a href="https://typora.io" target="_blank" rel="noopener"><strong>typora</strong></a>: 跨平台的Markdown编辑器，推荐</li></ul></li><li><strong>markdownlint</strong>: 编码检查器</li><li>扩展(Visual Studio Code):<ul><li><strong>Markdown All in One</strong>: All you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more)</li><li><strong>Markdown TOC</strong>: markdown 目录生成，我最常用的markdown插件</li></ul></li><li>图表绘制工具:<ul><li><a href="https://www.draw.io" target="_blank" rel="noopener"><strong>drawio</strong></a> 基于Web的图表绘制工具、也有离线客户端</li><li><strong>KeyNote/PPT</strong> 临时绘图也不错</li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-3-定义文档的模板"><a href="#6-3-定义文档的模板" class="headerlink" title="6.3 定义文档的模板"></a>6.3 定义文档的模板</h3><p>关于如何写好文档，很难通过标准或规范来进行约束，因为它的主观性比较强, 好的文档取决于编辑者的逻辑总结能力、表达能力、以及有没有站在读者的角度去思考问题。</p><p>所以大部分情况下，我们可以为不同类型的文档提供一个模板，通过模板来说明一个文档需要包含哪些内容, 对文档的编写者进行引导.</p><p>例如一个API文档可能需要这些内容:</p><ul><li>接口的索引</li><li>接口的版本、变更记录</li><li>用法和整体描述, 认证鉴权等等</li><li>描述具体的接口<ul><li>功能说明</li><li>方法名称或者URI</li><li>参数和返回值定义</li><li>调用示例</li><li>注意事项等等</li></ul></li></ul><p>具体规范内容因团队而异，这里点到为止.</p><p><br></p><p>扩展:</p><ul><li><a href="https://github.com/ruanyf/document-style-guide/blob/master/docs/reference.md" target="_blank" rel="noopener">中文技术文档的写作规范</a></li><li><a href="https://github.com/reactjs/rfcs/blob/master/0000-template.md" target="_blank" rel="noopener">React RFC模板</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-4-讨论即文档"><a href="#6-4-讨论即文档" class="headerlink" title="6.4 讨论即文档"></a>6.4 讨论即文档</h3><p><strong>一般情况下，对于一个开源项目来说除了官方文档，Issues也是一个很重要的信息来源。在Issue中我们可以获取其他开发者遇到的问题和解决方案、给官方反馈/投票、关注官方的最新动态、和其他开发者头脑风暴唇枪舌战等等</strong>。</p><p>所以相对于使用IM，笔者更推荐Issue这种沟通模式，因为<strong>它方便归档组织，索引和查找</strong>。而IM上的讨论就像流水一样，一去不复返。</p><p>当然两种工具的适用场景不一样，你拿IM的使用方式来使用Issue，Issue就会变得很水。<strong>Issue适合做有意义的、目的明确的讨论</strong>。 所以要谴责一下在Github Issue上灌水的开发者。</p><p>关于Issue有很多妙用，推荐阅读这篇文章<a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" rel="noopener">&lt;如何使用 Issue 管理软件项目？&gt;</a></p><p>现在很多开源项目都引入了RFC(请求意见稿)流程(参考<a href="https://www.infoq.cn/article/2017/12/react-rfc-process" target="_blank" rel="noopener">React采用新的RFC流程</a>, 以及<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">Vue 最黑暗的一天</a>), 这让开发者有‘翻身农奴、当家做主’的感觉，任何人都可以参与到一个开源项目重大事件的决策之中。<strong>每个RFC会说明决策的动机、详细设计、优缺点。除了官方文档之外，这些RFC是很有价值的学习资料</strong>。</p><p>我觉得如果不涉及机密，团队应该要让更多人参与到项目的设计和决策中，对于新手可以学到很多东西，而对于发起者也可能有考虑不周的情况。</p><p>那对于企业应用开发, Issue有用吗?</p><p>当然有用, 比如我们可以将这类话题从IM转移到Issue:</p><ul><li>设计方案</li><li>决策/建议<ul><li>新功能、新技术引入</li><li>重构</li><li>性能优化</li><li>规范</li></ul></li><li>问题讨论</li><li>重大事件</li><li>计划或进度跟踪</li><li>…</li></ul><p><br></p><p>另外Issue通常通过标签来进行分类，方便组织和检索:</p><p><img src="/images/frontend-standard/issue.png" alt></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-5-注释即文档"><a href="#6-5-注释即文档" class="headerlink" title="6.5 注释即文档"></a>6.5 注释即文档</h3><p><strong>必要和适量的注释对阅读源代码的人来说就是一个路牌, 可以少走很多弯路</strong>.</p><p>关于注释的一些准则，<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6/%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6.md" target="_blank" rel="noopener">&lt;阿里巴巴Java开发手册&gt;</a>总结得非常好, 推荐基于这个来建立注释规范。另外通过ESlint是可以对注释进行一定程度的规范。</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-6-代码即文档"><a href="#6-6-代码即文档" class="headerlink" title="6.6 代码即文档"></a>6.6 代码即文档</h3><p>现在有很多种工具支持从代码中解析和生成文档, 这可以给开发者简化很多文档维护的工作。</p><p>举个例子，我们经常会遇到修改了代码，但是文档忘记同步的情况。通过‘代码即文档’的方式至少可以<strong>保持文档和代码同步更新</strong>；另外<strong>很多工具会分析代码的数据类型</strong>，自动帮我们生成参数和返回值定义，这也可以减少很多文档编写工作以及出错率。</p><p>比如可以通过下面注释方式来生成组件文档:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Props注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> interface ColumnProps extends React.HTMLAttributes&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">/** prop1 description */</span></span><br><span class="line">  prop1?: string;</span><br><span class="line">  <span class="comment">/** prop2 description */</span></span><br><span class="line">  prop2: number;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * prop3 description</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  prop3: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">/** prop4 description */</span></span><br><span class="line">  prop4: <span class="string">'option1'</span> | <span class="string">'option2'</span> | <span class="string">'option3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对组件进行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Column</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ColumnProps</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>相关的工具有:</p><ul><li>API文档<ul><li>Typescript<ul><li><a href="https://github.com/microsoft/tsdoc" target="_blank" rel="noopener">tsdoc</a> Typescript官方的注释文档标准</li><li><a href="https://github.com/TypeStrong/typedoc" target="_blank" rel="noopener">typedoc</a> 基于tsdoc标准的文档生成器</li></ul></li><li>Javascript<ul><li><a href="https://github.com/jsdoc/jsdoc" target="_blank" rel="noopener">jsdoc</a> Javascript文档注释标准和生成器</li></ul></li></ul></li><li>后端接口文档<ul><li><a href="https://swagger.io" target="_blank" rel="noopener">Swagger</a> Restful接口文档规范</li><li>GraphQL: 这个有很多工具，例如<a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener">graphiql</a>, 集成了Playground和文档，很先进</li><li><a href="https://easy-mock.com/login" target="_blank" rel="noopener">Easy Mock</a> 一个可视化，并且能快速生成模拟数据的服务</li></ul></li><li>组件文档<ul><li><a href="https://storybook.js.org" target="_blank" rel="noopener">StoryBook</a> 通用的组件开发、测试、文档工具</li><li>React<ul><li><a href="http://docz.site" target="_blank" rel="noopener">Docz</a></li><li><a href="https://github.com/styleguidist/react-styleguidist" target="_blank" rel="noopener">Styleguidist</a></li></ul></li><li>Vue<ul><li><a href="https://github.com/vue-styleguidist/vue-styleguidist" target="_blank" rel="noopener">vue-styleguidist</a></li><li>有更好的工具请评论告诉我</li></ul></li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="7-ui设计规范"><a href="#7-ui设计规范" class="headerlink" title="7 UI设计规范"></a>7 UI设计规范</h2><p><img src="/images/frontend-standard/ui-design.png" alt></p><p>这是一个容易被忽略的规范类型。笔者就深受其苦，我们公司初期UI并不专业，没有所谓的设计规范，这就导致他们设计出来的产品都是东借西凑，前后不统一，多个应用之间的组件不能复用。这搞得我们不得不浪费时间，写很多定制化样式和组件，为他们的不专业买单.</p><p>关于UI设计规范的重要性有兴趣的读者可以看这篇文章<a href="https://juejin.im/post/5b766ac56fb9a009aa154c27" target="_blank" rel="noopener">&lt;开发和设计沟通有多难？ - 你只差一个设计规范&gt;</a>. </p><p>简单总结一下UI设计规范的意义：</p><ul><li>提供团队协作效率(产品和开发)</li><li>提高组件的复用率. 统一的组件规范可以让组件更好管理</li><li>保持产品迭代过程中品牌一致性</li></ul><p>建立一个定义良好的设计规范需要<code>UI设计和开发</code>的紧密配合，有时候也可以由我们前端来推动。</p><p>比如很多开源的UI框架，一开始都是开发者YY出来的，并没有设计参与，后来组件库慢慢沉淀成型，UI设计师才介入规范一下。</p><p>如果你们团队不打算制定自己的UI设计规范，则推荐使用现成的开源组件库：</p><ul><li><a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant Design</a></li><li><a href="https://material-ui.com" target="_blank" rel="noopener">Material-UI</a></li><li><a href="https://element.eleme.io" target="_blank" rel="noopener">Element UI</a></li><li><a href="https://weui.io" target="_blank" rel="noopener">WeUI</a></li><li><a href="https://developer.microsoft.com/en-us/fabric#/" target="_blank" rel="noopener">Microsoft Fabric</a></li></ul><p>这些开源组件库都经过良好的设计和沉淀, 而且配套了完善的设计原则、最佳实践和设计资源文件（Sketch 和 Axure），可以帮助业务快速设计出高质量的产品原型。</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="8-测试规范"><a href="#8-测试规范" class="headerlink" title="8 测试规范"></a>8 测试规范</h2><p>测试是保障代码质量的重要手段，但是很少有人愿意在这里花太多时间。</p><p>比如笔者，我很少会去给业务代码和组件写单元测试，除非自己对代码非常没有信心，按照我的理念写测试不如将代码写得更简单一点，比如把一个函数拆分为更小的函数，保持单一职责。</p><p>但是<strong>对于一些底层、共享的代码模块还是有测试的必要的</strong>。</p><p>我在<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe" target="_blank" rel="noopener">不知道测试什么？这些是你需要知道的软件测试类型和常识</a>文章中，列举了一些开发者需要关注的测试类型和常识, 如果按照测试的阶段进行分类，大概是这样子的:</p><p><img src="/images/frontend-standard/testing.png" alt></p><p><br></p><p>其中前端开发者需要关注的主要有以下几种测试类型:</p><ul><li><strong>单元测试</strong>: 对独立的软件模块进行测试<ul><li><strong>UI组件测试</strong>: 包括了快照(Snapshot)测试</li></ul></li><li><strong>集成测试</strong>: 在单元测试的基础上，将模块组合起来，测试它们的组合性</li><li><strong>E2E测试</strong>: 在完整、真实的运行环境下模拟真实用户对应用进行测试。<strong>主要测试前端和后端的协调性</strong></li><li><strong>兼容性测试</strong>: 上面提到了浏览器兼容规范，在将版本提交给测试/发布之前，需要确保能符合兼容性要求</li><li><strong>性能测试</strong>: 测试和分析是否存在性能问题</li><li><strong>其他</strong>:<ul><li>安全测试</li><li>SEO测试</li></ul></li></ul><p>因为对于小公司来说整个软件开发流程可能没有那么规范，比如很难构建一个完整的端对端测试环境，这些都不是前端团队可以操作的范围, 所以自动化测试很难推行。但是可以根据团队和业务情况逐步进行开展。</p><p>可实施性比较高的, 也比较简单是单元测试，所以本文也重点关注单元测试.</p><p><br></p><h3 id="8-1-测试的流程"><a href="#8-1-测试的流程" class="headerlink" title="8.1 测试的流程"></a>8.1 测试的流程</h3><p>首先要定义一个合适的软件测试流程, 合适的测试流程可以降低开发和测试团队之间的沟通协作成本、提高测试效率。例如我们团队目前的测试流程:</p><p><img src="/images/frontend-standard/test-proc.png" alt></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="8-2-单元测试"><a href="#8-2-单元测试" class="headerlink" title="8.2 单元测试"></a>8.2 单元测试</h3><p>单元测试有很多<strong>好处</strong>, 比如:</p><ul><li><strong>提高信心，适应变化和迭代</strong>. 如果现有代码有较为完善的单元测试，在代码重构时，可以检验模块是否依然可以工作, 一旦变更导致错误，单元测试也可以帮助我们快速定位并修复错误</li><li><strong>单元测试是集成测试的基础</strong></li><li><strong>测试即文档</strong>。如果文档不能解决你的问题，在你打算看源码之前，可以查看单元测试。通过这些测试用例，开发人员可以直观地理解程序单元的基础API</li><li><strong>提升代码质量。易于测试的代码，一般都是好代码</strong></li></ul><p><br></p><p><strong>测什么?</strong></p><p>业务代码或业务组件是比较难以实施单元测试的，一方面它们比较多变、另一方面很多团队很少有精力维护这部分单元测试。所以<strong>通常只要求对一些基础/底层的组件、框架或者服务进行测试, 视情况考虑是否要测试业务代码</strong></p><p><br></p><p><strong>测试的准则</strong>:</p><ul><li>推荐Petroware的<a href="https://petroware.no/unittesting.html" target="_blank" rel="noopener">Unit Testing Guidelines</a>, 总结了27条单元测试准则，非常受用.</li><li>另外&lt;阿里巴巴的Java开发手册&gt;中总结的<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.md" target="_blank" rel="noopener">单元测试准则</a>, 也不错，虽然书名是Java，准则是通用的.</li></ul><p><br></p><p><strong>单元测试指标</strong>:</p><p>一般使用<a href="https://zh.wikipedia.org/wiki/代碼覆蓋率" target="_blank" rel="noopener"><code>测试覆盖率</code></a>来量化，尽管对于覆盖率能不能衡量单元测试的有效性存在较多争议。</p><p>大部分情况下还是推荐尽可能提高覆盖率, 比如要求<code>语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%</code>. 视团队情况而定</p><p>扩展:</p><ul><li><a href="https://www.infoq.cn/article/test-coverage-rate-role" target="_blank" rel="noopener">测试覆盖（率）到底有什么用？</a></li></ul><p><br></p><p><strong>相关工具</strong></p><ul><li>Headless Browsers: 无头浏览器是网页自动化的重要运行环境。 常用于功能测试、单元测试、网络爬虫<ul><li><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">puppeteer</a></li><li><a href="https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md" target="_blank" rel="noopener">Headless Chromium</a></li></ul></li><li>测试框架<ul><li><a href="http://jest.io/" target="_blank" rel="noopener">Jest</a> 🔥Facebook的单元测试框架. 零配置, 支持组件快照测试、模块Mock、Spy. 一般场景, 单元测试学它一个就行了<ul><li>组件测试<ul><li><a href="https://github.com/testing-library" target="_blank" rel="noopener">testing-library</a> 🔥</li><li><a href="https://github.com/airbnb/enzyme" target="_blank" rel="noopener">Enzyme</a></li></ul></li></ul></li><li><a href="https://theintern.github.io/" target="_blank" rel="noopener">Intern</a></li></ul></li><li>单元测试<ul><li><a href="https://github.com/avajs/ava" target="_blank" rel="noopener">AVA</a></li><li><a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a></li><li><a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a></li><li><a href="https://github.com/substack/tape" target="_blank" rel="noopener">Tape</a></li></ul></li><li>断言库<ul><li><a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a></li><li><a href="https://github.com/Automattic/expect.js" target="_blank" rel="noopener">expect.js</a></li><li><a href="http://shouldjs.github.io/" target="_blank" rel="noopener">should.js</a></li></ul></li><li>Mock/Stubs/Spies<ul><li><a href="http://sinonjs.org/" target="_blank" rel="noopener">sinon.js</a></li></ul></li><li>代码覆盖率<ul><li><a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a></li></ul></li><li>基准测试<ul><li><a href="http://benchmarkjs.com/" target="_blank" rel="noopener">benchmark.js</a></li><li><a href="https://jsperf.com/" target="_blank" rel="noopener">jsperf.com</a></li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="9-异常处理、监控和调试规范"><a href="#9-异常处理、监控和调试规范" class="headerlink" title="9 异常处理、监控和调试规范"></a>9 异常处理、监控和调试规范</h2><p>很多开发者常常误用或者轻视异常的处理, 合理有效的异常处理可以提高应用的健壮性和可用性，另外还可以帮助开发者快速定位异常.</p><h3 id="9-1-异常处理"><a href="#9-1-异常处理" class="headerlink" title="9.1 异常处理"></a>9.1 异常处理</h3><p>&lt;阿里巴巴的Java开发手册&gt;中总结的<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.md" target="_blank" rel="noopener">异常处理规范</a>对JavaScript的异常处理也很有参考意义，比如:</p><ul><li>异常不要用来做流程控制，条件控制。</li><li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li><li>catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。不要对大段代码进行try-catch</li><li>…</li></ul><p>然后再根据JavaScript本身的异常处理特点总结一些规范行为, 例如:</p><ul><li>不要throw非Error对象</li><li>不要忽略异步异常</li><li>全局监控Javascript异常</li><li>…</li></ul><p><br></p><p>资源:</p><ul><li><a href="https://rollbar.com/blog/top-10-javascript-errors/" target="_blank" rel="noopener">从1000+个项目中总结出来的前10个JavaScript错误, 以及如何避免它们</a></li><li><a href="https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6" target="_blank" rel="noopener">Javascript异常处理‘权威’指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/63698500" target="_blank" rel="noopener">前端异常处理最佳实践</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="9-2-日志"><a href="#9-2-日志" class="headerlink" title="9.2 日志"></a>9.2 日志</h3><p>对于前端来说，日志也不是毫无意义(很多框架性能优化建议在生产环境移除console)。尤其是在<strong>生产现场</strong>调试代码时，这时候可贵的控制台日志可以帮助你快速找到异常的线索.</p><p>不过通常我们<strong>只要保留必要的、有意义的日志输出</strong>，比如你不应该将console.log放到一个React渲染函数中、或者放到一个循环中, <strong>DDos式的日志信息并不能帮助我们定位问题，反而会影响运行的性能</strong>. 所以需要一个规范来约束日志输出行为, 比如:</p><ul><li>避免重复打印日志</li><li>谨慎地记录日志, 划分日志级别。比如生产环境禁止输出debug日志；有选择地输出info日志；</li><li>使用前缀对日志进行分类, 例如: <code>[User] xxxx</code></li><li>只记录关键信息, 这些信息可以帮助你诊断问题</li><li>…</li></ul><p>扩展资源</p><ul><li><a href="https://github.com/visionmedia/debug" target="_blank" rel="noopener">debug</a> 适合Node.js和浏览器的debug日志工具, 支持动态开启日志打印</li><li><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">vConsole</a> 移动端调试利器</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="9-3-异常监控"><a href="#9-3-异常监控" class="headerlink" title="9.3 异常监控"></a>9.3 异常监控</h3><p>因为程序跑在不受控的环境，所以对于客户端应用来说，异常监控在生产环境是非常重要的，它可以收集各种意料之外生产环境问题，帮助开发者快速定位异常。</p><p><br></p><p>异常监控通常会通过三种方式来收集异常数据:</p><ol><li>全局捕获。例如使用window.onerror, 或者<code>unhandledrejection</code></li><li>主动上报。在try/catch中主动上报. </li><li>用户反馈。比如弹窗让用户填写反馈信息.</li></ol><p>和日志一样，<strong>不是所有‘异常’都应该上报给异常监控系统，譬如一些预料之内的‘异常’</strong>，比如用户输入错误、鉴权失败、网络错误等等. <strong>异常监控主要用来上报一些意料之外的、或者致命性的异常</strong>.</p><p><br></p><p>要做好前端的异常监控其实并不容易，它需要处理这些东西:</p><ul><li>浏览器兼容性。</li><li>碎片收集(breadcrumbs)。 收集‘灾难’现场的一些线索，这些线索对问题诊断很重要。例如当前用户信息、版本、运行环境、打印的日志、函数调用栈等等</li><li>调用栈的转换。通常在浏览器运行的压缩优化过的代码，这种调用栈基本没什么可读性，通常需要通过SourceMap映射到原始代码. 可以使用这个库: <a href="https://github.com/mozilla/source-map#sourcemapconsumer" target="_blank" rel="noopener">source-map</a></li><li>数据的聚合。后端监控系统需要对前端上报的信息进行分析和聚合</li></ul><p><br></p><p>对于小团队未必有能力开发这一套系统，所以推荐使用一些第三方工具。例如</p><ul><li><a href="https://sentry.io/welcome/" target="_blank" rel="noopener">Sentry</a> 🔥免费基本够用</li><li><a href="https://www.fundebug.com/price" target="_blank" rel="noopener">FunDebug</a> 付费增强</li></ul><p><strong>扩展</strong>:</p><ul><li><a href="https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/" target="_blank" rel="noopener">前端异常监控解决方案研究</a></li><li><a href="https://www.cnblogs.com/warm-stranger/p/9417084.html" target="_blank" rel="noopener">搭建前端监控系统</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="10-前后端协作规范"><a href="#10-前后端协作规范" class="headerlink" title="10 前后端协作规范"></a>10 前后端协作规范</h2><p>前端是Web的一个细分领域，往往不能脱离后端而存在。所以和后端协作的时间是最长的.</p><h3 id="10-1-协作流程规范"><a href="#10-1-协作流程规范" class="headerlink" title="10.1 协作流程规范"></a>10.1 协作流程规范</h3><p>前后端团队经过长期的合作，一般可以总结出一条对于双方开发效率最优的协作流程. 将这个落实为规范，后面的团队成员都遵循这个步调进行协作。</p><p>一个典型的前后端协作流程如下:</p><p><img src="/images/frontend-standard/f-b.png" alt></p><ol><li>需求分析。参与者一般有前后端、测试、以及产品. 由产品主持，对需求进行宣贯，接受开发和测试的反馈，确保大家对需求有一致的认知</li><li>前后端开发讨论。讨论应用的一些开发设计，沟通技术点、难点、以及分工问题.</li><li>设计接口文档。可以由前后端一起设计；或者由后端设计、前端确认是否符合要求</li><li>并行开发。前后端并行开发，在这个阶段，前端可以先实现静态页面; 或者根据接口文档对接口进行Mock, 来模拟对接后端接口</li><li>在联调之前，要求后端做好接口测试</li><li>真实环境联调。前端将接口请求代理到后端服务，进行真实环境联调。</li></ol><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="10-2-接口规范"><a href="#10-2-接口规范" class="headerlink" title="10.2 接口规范"></a>10.2 接口规范</h3><p>首先应该确定下来的是接口规范。其实使用哪种接口标准是其次，重要的是统一，且要满足前后端的开发效率要求.</p><p>笔者不建议后端去定义自己的接口标准，而应该去选择一些通用的、有标准定义接口形式, 例如:</p><ul><li><p><a href="https://zh.wikipedia.org/zh-hans/表现层状态转换" target="_blank" rel="noopener">RESTful</a>: RESTful是目前使用最为广泛的API设计规范, 基于HTTP本身的机制来实现. </p><p>笔者个人是比较喜欢这个API规范，但是我发现很多开发者并不能真正(或者说没心思)理解它，设计出来的接口，跟我想象的相差甚远。换句话说，对于RESTful，开发者之间很难达成一致的理解，容易产生分歧。</p><p>因为是使用最广泛的API形式，所以社区上有很多工具来对RESTful接口进行文档化、测试和模拟.</p></li><li><p><a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html" target="_blank" rel="noopener">JSONRPC</a> 这是一种非常简单、容易理解的接口规范。相对于RESTful我更推荐这个，简单则不容易产生分歧，新手也可以很快接受.</p></li><li><a href="https://graphql.org/learn/" target="_blank" rel="noopener">GraphQL</a> 🔥更为先进、更有前景的API规范。但是你要说服后端配合你使用这种标准可能很有难度</li></ul><p><br></p><p><strong>接口设计需要注意的点</strong>:</p><ul><li>明确区分是正常还是异常, 严格遵循接口的异常原语. 上述接口形式都有明确的异常原语，比如JSONRPC，当出现异常时应该返回<code>错误对象</code>响应，而不是在正常的响应体中返回错误代码. 另外要规范化的错误码, HTTP响应码就是一个不错的学习对象</li><li>明确数据类型。很多后端写的接口都是string和number不分的，如果妥协的话、前端就需要针对这个属性做特殊处理，这也可能是潜在的bug</li><li>明确空值的意义。比如在做更新操作是，空值是表示重置，还是忽略更新？</li><li>响应避免冗余的嵌套。</li><li>接口版本化，保持向下兼容。就像我们上文的‘语义化版本规范’说的，对于后端来说，API就是公共的接口. 公共暴露的接口应该有一个版本号，来说明当前描述的接口做了什么变动，是否向下兼容。<br>现在前端代码可能会在客户端被缓存，例如小程序。如果后端做了break change，就会影响这部分用户。</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="10-3-接口文档规范"><a href="#10-3-接口文档规范" class="headerlink" title="10.3 接口文档规范"></a>10.3 接口文档规范</h3><p>后端通过接口文档向前端暴露接口相关的信息。通常需要包含这些信息：</p><ul><li>版本号</li><li>文档描述</li><li>服务的入口. 例如基本路径</li><li>测试服务器. 可选</li><li>简单使用示例</li><li>安全和认证</li><li>具体接口定义<ul><li>方法名称或者URL</li><li>方法描述</li><li>请求参数及其描述，必须说明类型(数据类型、是否可选等)</li><li>响应参数及其描述, 必须说明类型(数据类型、是否可选等)</li><li>可能的异常情况、错误代码、以及描述</li><li>请求示例，可选</li></ul></li></ul><p><strong>人工维护导致的问题</strong>:</p><p>上文‘代码即文档’就提到了人工维护接口文档可能导致代码和文档不同步问题。</p><p>如果可以从代码或者规范文档(例如OpenAPI这类API描述规范)中生成接口文档，可以解决实现和文档不一致问题, 同时也可以减少文档编写和维护的投入.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="10-4-接口测试与模拟"><a href="#10-4-接口测试与模拟" class="headerlink" title="10.4 接口测试与模拟"></a>10.4 接口测试与模拟</h3><p>为了做到高效率的前后端并行开发，接口的测试与模拟是必要的。</p><ul><li>前端要求后端在联调之前，需要测试验证好自己的接口是否可以正常工作。而不是在联调期间，把前端当‘接口测试员’，阻塞接口联调进度</li><li>另外前端需要在后端接口未准备好之前，通过接口模拟的方式，来编写业务逻辑代码。</li></ul><p>针对接口测试与模拟，存在下图这样一个理想的模型:</p><p><img src="/images/frontend-standard/api-mock.png" alt></p><p>一切从定义良好的接口文档出发，生成<code>Mock Server</code>和<code>Mock Client</code>, Mock Server给前端提供模拟数据，而Mock Client则辅助后端对它们的接口进行测试.</p><p>资源:</p><ul><li>RESTful<ul><li><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 这是最为接近上面理想模型的一个解决方案</li><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">JSON Server</a> 快速生成JSON mock服务器</li><li><a href="https://easy-mock.com" target="_blank" rel="noopener">Easy Mock</a> 可视化的、在线的接口mock服务</li></ul></li><li>GraphQl<ul><li><a href="https://github.com/APIs-guru/graphql-faker" target="_blank" rel="noopener">GraphQL Faker</a></li><li><a href="https://www.apollographql.com/docs/graphql-tools/mocking/" target="_blank" rel="noopener">graphql-tools</a></li></ul></li><li>模拟数据生成<ul><li><a href="https://github.com/Marak/faker.js" target="_blank" rel="noopener">faker.js</a> 🔥强大的模拟数据生成工具，支持Node和浏览器</li><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">Mock.js</a> 数据生成和模拟工具</li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="11-培训-知识管理-技术沉淀"><a href="#11-培训-知识管理-技术沉淀" class="headerlink" title="11 培训/知识管理/技术沉淀"></a>11 培训/知识管理/技术沉淀</h2><p>我觉得一个团队的知识管理是非常重要的. 你要问一个刚入行的新手加入团队希望得到什么？很多人的回答是’学习’,  希望自己的技术可以更加精进, 钱倒还是其次。</p><p>然而现实是目前很多公司的氛围并不是这样的，一天到晚写业务代码、工作量大、每天做重复的事情，而且还加班，工作多年技术也没感觉有多少进步, 确实会让人非常沮丧。包括笔者也是这样的。</p><p>所以为了改善这种情况，我来聊聊最近在‘小团队’做的一些尝试.</p><h3 id="11-1-新人培训"><a href="#11-1-新人培训" class="headerlink" title="11.1 新人培训"></a>11.1 新人培训</h3><p>如果团队有规范的新成员培训手册，可以节省很多培训的时间，避免每次重复口述一样的内容。培训手册包含以下内容:</p><ul><li><p><strong>产品架构与组织架构</strong>. 介绍公司背景和产品，一般组织的团队结构和产品的架构是相关联的. 以笔者所在公司为例, 主要产品是即时通信:</p><p><img src="/images/frontend-standard/org.png" alt></p></li><li><p><strong>产品研发流程</strong>: 介绍产品开发和迭代会涉及到的流程、以及团队之间的协作衔接，例如:</p><p><img src="/images/frontend-standard/dev-proc.png" alt></p></li><li><p><strong>工作范围</strong>: 团队成员的职责范围</p></li><li><strong>建立资源索引</strong>: 开发需要设计到的资源，比如各种文档地址、研发系统入口(例如gitlab、bug跟踪系统、文件共享、发布平台、开发/测试环境、监控系统)、协作规范等等。将这些资源整理好可以减少不必要的沟通成本</li><li><strong>规范</strong>: 即本文的主体’前端协作规范’。有规范可循，可以让成员以较快的速度入手开发、同时也减少培训成本投入。</li></ul><p>培训手册将可以文档具象化的内容整理为文档，和上文说到的Code Review一样，一些东西无法通过文档来说明，所以我们一般会搭配一个‘培训导师’，在试用期间，一对一辅导。</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="11-2-营造技术氛围"><a href="#11-2-营造技术氛围" class="headerlink" title="11.2 营造技术氛围"></a>11.2 营造技术氛围</h3><ul><li><strong>鼓励成员写技术博客，或者建立自己的团队专栏</strong>. 写一篇好的文章不容易</li><li><strong>鼓励参与开源项目</strong></li><li><strong>建立面试题库</strong> 组织一起解一些面试题或算法题，加深对知识点的理解</li><li><p><strong>定期的专题分享</strong>. 鼓励团队成员定期进行专题学习和研究，编写技术博客，并将学习的成果分享给其他成员. 这是一种抱团取暖的学习方式，旨在帮助团队成员一起学习和成长。</p><p>比如开发老手可以分享自己的经验，研究更深层次的技术；新手则可以研究某些开发技巧、新技术，例如CSS Grid，svg动画等等。推荐团队成员有个明确的研究领域，这样分工合作可以学习到更多东西.</p><p><strong>专题怎么来?</strong></p><ul><li>专题请求. 可以请求其他成员完成专题，比如比较深的知识，可以要求团队比较有经验的进行学习分享</li><li>学习总结.</li><li>项目回顾</li><li>难点攻克</li><li>项目规范</li><li>工具使用</li></ul></li><li><p><strong>落实和完善开发规范</strong>. 规范本身就是团队知识沉淀的一种直接输出</p></li><li><strong>图书分享</strong>. 和离散的文章或教程相比，图书的知识会比较系统，另外很多经典的图书是要静下来好好欣赏的。</li><li><strong>鼓励重构和持续优化代码</strong></li><li><strong>抽象一套基础库或框架，减少重复工作, 提高工作效率</strong>. 不加班先从提高工作效率开始</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="12-反馈"><a href="#12-反馈" class="headerlink" title="12 反馈"></a>12 反馈</h2><p>大家有什么要补充或意见可以在下方评论, 一起来完善这篇文章, 谢谢！</p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;笔者长期单枪匹马在前端领
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[问答] 为什么要用vue-cli3?</title>
    <link href="https://bobi.ink/2019/07/18/why-vue-cli3/"/>
    <id>https://bobi.ink/2019/07/18/why-vue-cli3/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T04:20:32.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>[问答]</code>系列主要整理<a href="https://segmentfault.com/q/1010000019785471" target="_blank" rel="noopener">SegmentFault</a>上面比较有价值的问题，以及我的回答</p></blockquote><h2 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a><a href="https://segmentfault.com/q/1010000019785471/a-1020000019793827" target="_blank" rel="noopener">原问题</a></h2><p>其实这个问题主要是想了解vue-cli3与vue-cli2相比是否存在一些不得不升级的好处和优点？</p><p>产生这个问题的原因是在试用完vue-cli3之后并没有觉得好用，反而觉得束手束脚，我cli2时，webpack想怎么配怎么配为什么到了cli3我要在vue.config.js中配置<br>众所周知vue-cli的通用配置并不适合每种情况, 而在vue.config.js只能做增添和覆盖，所以一直没有用vue-cli3构建项目</p><p>所以想请教下 这个版本有没有值得升级的优点</p><p><br></p><h2 id="我的回答"><a href="#我的回答" class="headerlink" title="我的回答"></a>我的回答</h2><p>好问题，vue-cli3相对vue-cli有很多重要的更新。</p><p>首先说一些vue-cli这些工具的<strong>初衷</strong>吧: 这些工具就是为了让开发者能够<strong>开箱即用</strong>快速地进行应用开发而开发的，<strong>它们秉承的是“约定大于配置”思想，简单说就是”能不配置的就不配置，你就按照我的方式来，也不要去争论这个好不好，快速进行业务开发才是正经事”. 它们不建议你去配置，但也不会拦着你去配置</strong>。</p><p>另外Webpack对初学者并不是十分友好，‘又长又臭’的配置，普通开发者很难写入定义良好，性能优化的配置。不然就不会各种cli工具冒出来了，比如parcel，create-react-app。这些工具都宣称零配置，目的就是让开发者能够愉快的进行代码开发。</p><p><br></p><hr><p><br></p><p>现在来看看Vue-cli v3的改进，以及思考这些有什么意义呢？</p><p><br></p><p><strong>1. 抽离cli service层</strong></p><p>Create-React-App是第一个做这种事情的。vue-cli3库现在包含以下两个模块：</p><ul><li><p>CLI: 即vue全局命令，主要用于项目创建和管理，包含了<code>vue create</code>、<code>vue ui</code>这些命令。CLI命令的做的事情比较少，所以更新不会太频繁(开发者也很少会去更新这些命令)</p></li><li><p>Service层: 负责项目的实际构建，也就是webpack项目构建。这一块是频繁更新的，一般作为项目的局部依赖。</p></li></ul><p><br></p><p>OK，这么做有什么意义呢？考虑这样一个场景，这也是答主之前遇到的一个痛点：</p><p><strong>vue-cli3之前不算是一个构建CLI, 它顶多就是一个模板拷贝器, 做的事情非常少</strong>, 所有webpack配置和构建命令都是耦合在具体的项目里面，package.json会包含一大堆开发依赖。</p><p>如果去跟进webpack或相关工具更新的朋友会有这种体会，升级不是一件容易的事情。比如你升级了babel-loader, 可能要连带webpack都升级，webpack升级后可能其他工具又不兼容了。</p><p>升级方面的痛点是其一。如果你的团队需要维护很多项目，你怎么对这些项目进行维护升级？每个项目都拷贝一下？如果某个项目做了特殊配置呢？</p><p><strong>对于团队而言，项目构建这一块是应该尽量做到的统一和傻瓜化的，没有必要在这方面投入太多的精力，应该把事情外包给擅长这种事情的人去做</strong>。</p><p><strong>另外不要排斥更新，更新可以获得更好的开发体验和构建速度、运行性能, 别人在这方面比你了解的更多</strong>。</p><p><strong>分离了vue-cli-service之后，项目构建更新只是一个命令的事情，除非做了很多特殊化操作</strong>。<strong>特殊化操作应该封装到vue-cli的插件中</strong>。这就引出了vue-cli3的另外一个特色：插件</p><p><br></p><hr><p><br></p><p><strong>2. 插件化</strong></p><p>相比create-react-app, vue-cli是在太仁慈了。vue-cli的插件机制很灵活，通过<code>webpack-chain</code>和<code>webpack-merge</code>可以实现webpack完全定制化。</p><p>可以对比一下市面上流行的cli工具的可扩展性：</p><table><thead><tr><th></th><th>Vue CLI</th><th>create-react-app</th><th>parcel</th></tr></thead><tbody><tr><td>快速原型开发</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>全局模式</td><td>零配置原型开发就是全局的</td><td>-</td><td>支持</td></tr><tr><td>插件</td><td>支持</td><td>-</td><td>支持，扩展文件类型和文件输出</td></tr><tr><td>扩展性</td><td>强，通过插件扩展 wepack 配置</td><td>弱, 强约定, 无法配置 webpack，可以 eject, 然后手工配置；支持 babel-macro;(严格说可以通过<a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">react-app-rewired</a>进行扩展)</td><td>中(可以配置 babel，postcss，Typescript); 提供了 Node API; 支持插件扩展文件类型</td></tr><tr><td>多页面</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>适用范围</td><td>Vue 组件的第一公民。通过扩展可以支持任意前端框架</td><td>针对 React 开发，不支持其他框架</td><td>parcel 是一个通用的打包工具，它的竞争对手是 webpack</td></tr><tr><td>编译速度</td><td>cache-loader,thread-loader 来加速 JS 和 TS 编译</td><td>babel-loader 开启了 cache</td><td>编译速度号称是 webpack 的两倍</td></tr><tr><td>可升级性</td><td>支持升级 cli-service, 插件需要单独升级, 插件需要遵循语义化版本. 太多插件存在升级风险</td><td>支持升级 react-script, 官方维护，且强约定基本可以保障向下兼容</td><td>支持升级 parcel-bundler</td></tr><tr><td>UI</td><td>图形化管理是 CLI 的特色之一</td><td>-</td><td>-</td></tr></tbody></table><p><br></p><p>对于vue-cli的插件实现机制可以看这篇<a href="https://juejin.im/post/5cedb26451882566477b7235" target="_blank" rel="noopener">文章</a>。</p><p>因为vue-cli灵活的扩展性，所以它不仅限于vue本身，可以扩展支持react、anything…</p><p>按照上文说的，<strong>如果你要做深度的vue-cli定制化，不建议直接写在vue.config.js中，而是封装在插件中，独立的维护这个插件，然后项目再依赖这个插件。这样就可以简化升级的成本和复杂度</strong>。</p><p><br></p><hr><p><br></p><p><strong>3. GUI界面</strong></p><p>虽然大部分人都觉得作用不大，因为确实对开发效率并实际的提升效果。就是看着舒服直观，这就够了。</p><p><br></p><hr><p><br></p><p><strong>4. 快速原型开发</strong></p><p>vue-cli3也支持直接将一个vue文件跑起来，快速原型开发或验证某些想法时，挺不错。</p><p><br></p><hr><p><br></p><p><strong>5. <a href="https://cli.vuejs.org/guide/browser-compatibility.html#modern-mode" target="_blank" rel="noopener">现代模式</a></strong></p><p>给先进的浏览器配合先进的代码(ES6之后),同时兼容旧版本的浏览器，先进的代码不管从文件体积还是脚本解析效率、运行效率都有较高的提升。</p><p>体积对比:</p><table><thead><tr><th>Version</th><th>Size (minified)</th><th>Size (minified + gzipped)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>80K</td><td>21K</td></tr><tr><td>ES5 (main.es5.js)</td><td>175K</td><td>43K</td></tr></tbody></table><p><br></p><p>解析效率:</p><table><thead><tr><th>Version</th><th>Parse/eval time (individual runs)</th><th>Parse/eval time (avg)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>184ms, 164ms, 166ms</td><td>172ms</td></tr><tr><td>ES5 (main.es5.js)</td><td>389ms, 351ms, 360ms</td><td>367ms</td></tr></tbody></table><p><br></p><hr><p><br></p><p><strong>6. Standard Tooling for Vue.js Development</strong></p><p>这是vue-cli的官方介绍，vue标准开发工具. 跟进vue-cli就是跟进官方的最佳实践和前沿技术，vue团队已经为你考虑很多应用场景, why not?</p><p><br></p><hr><p><br></p><p><strong>总结一下</strong>：</p><ul><li><p>如果我们喜欢折腾，肯定会觉得vue-cli3束手束脚，这时候我们不是vue-cli3的目标用户；</p><p>就比如我们团队就自己搞了一一个CLI构建工具: <a href="https://github.com/GDJiaMi/jm-cli" target="_blank" rel="noopener">jm-cli</a>, 根据自己的团队需求进行深度定制，不过我们这个工具是强约定的，包括目录结构、编码规范等等. 因为我们不推荐团队成员去搞特殊化定制，而且为了方便进行更新，所以干脆就不让扩展了，<strong>统一和规范对团队来说才是最重要的</strong>.</p><p><strong>如果你有类似的开发经验，你会觉得vue-cli可能是所有构建CLI的最终归宿或者典范</strong>。</p></li><li><p>如果不想折腾，只想写代码, 而且想跟进vue官方最新实践，那就直接拿来用吧；</p></li><li>如果想折腾，又要考虑团队协作和构建工具链的维护成本，vue-cli是很适合的。当然你也可以造轮子</li><li>如果想学webpack的构建项目，也不推荐你使用vue-cli</li></ul><p><br></p><p>最后给vue团队点个赞👍</p><p>欢迎关注我，和我交流</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;[问答]&lt;/code&gt;系列主要整理&lt;a href=&quot;https://segmentfault.com/q/1010000019785471&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SegmentFault&lt;/a&gt;
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>现代脚本的加载</title>
    <link href="https://bobi.ink/2019/07/17/modern-module/"/>
    <id>https://bobi.ink/2019/07/17/modern-module/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-18T23:21:49.165Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址: <a href="https://jasonformat.com/modern-script-loading/" target="_blank" rel="noopener">Modern Script Loading</a>, 文章作者是Preact作者<a href="https://twitter.com/_developit" target="_blank" rel="noopener">Jason Miller</a></p><p><br></p><p><img src="/images/modern-module/modern-script-loading.jpg" alt></p><p><br></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>先简单介绍一下<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener"><code>模块script(Module script)</code></a>, 它指的是<strong>现代浏览器支持通过<code>&lt;script type=module src=main.js&gt;&lt;/script&gt;</code>来加载现代的ES6模块</strong>. 现代浏览器对ES6现代语法有良好的支持，这意味着<strong>我们可以给这些现代浏览器提供更紧凑的‘现代代码’，一方面可以减小打包的体积，减少网络传输的带宽，另外还可以提高脚本解析的效率和运行效率</strong>.</p><p>下图来源于<a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/" target="_blank" rel="noopener"><code>module/nomodule pattern</code></a>, 对比了<strong>模块script</strong>和<strong>传统(legacy) script</strong>的性能:</p><p>体积对比:</p><table><thead><tr><th>Version</th><th>Size (minified)</th><th>Size (minified + gzipped)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>80K</td><td>21K</td></tr><tr><td>ES5 (main.es5.js)</td><td>175K</td><td>43K</td></tr></tbody></table><p><br></p><p>解析效率:</p><table><thead><tr><th>Version</th><th>Parse/eval time (individual runs)</th><th>Parse/eval time (avg)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>184ms, 164ms, 166ms</td><td>172ms</td></tr><tr><td>ES5 (main.es5.js)</td><td>389ms, 351ms, 360ms</td><td>367ms</td></tr></tbody></table><p><br></p><p>Ok，为了兼容旧浏览器, <a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/" target="_blank" rel="noopener">module/nomodule pattern</a>这篇文章介绍了一种<strong>module/nomodule 模式</strong>, 简单说就是<strong>同时提供两个script, 由浏览器来决定加载哪个文件</strong>：</p><p><br></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 支持模块script的浏览器会加载这个文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"main.mjs"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 旧浏览器会加载这个文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为加了nomdule, 所以现代浏览器不会加载该文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"main.es5.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来很美好是吧? 现实是：<strong>中间存在一些浏览器，它们可以识别<code>模块script</code>但是不认识<code>nomodule</code>属性, 这就导致了这些浏览器会同时加载这两个文件(下文统一称为‘双重加载’(over-fetching))</strong>.</p><p><br><br><br></p><blockquote><p>OK，正式进入正文. 给正确的浏览器交付正确代码是一件棘手的事情。本文会介绍几种方式, 来解决上述的问题:</p></blockquote><p>给现代浏览器伺服’现代的代码’对性能有很大的帮助。所以你应该针对现代浏览器提供包含更紧凑和优化的现代语法的Javascript包，同时又可以保持对旧浏览器的支持</p><p>现有的工具链的生态系统基本都是在<code>module/nomodule模式</code>上整合的，它声明式加载现代和传统代码(legacy code)，即给浏览器提供两个源代码，让它来自己来决定用哪个:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"/modern.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"/legacy.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而现实总是给你当头一棒，它没我们期望的那么简单直接。上述基于HTML的加载方式在<a href="https://gist.github.com/jakub-g/5fc11af85a061ca29cc84892f1059fec" target="_blank" rel="noopener"><strong>Edge和Safari中会被同时加载</strong></a>!</p><p><br></p><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办?"></a>怎么办?</h2><p>怎么办？我们想依赖浏览器来交付不同的编译目标，但是一些旧浏览器并不能优雅地支持这种简洁的写法。</p><p>首先，Safari 在10.1开始支持JS模块, 但不支持nomodule属性。值得庆幸的是，Sam找到了一种方法，可以通过Safari 10和11中非标准的beforeload事件来模拟 nomodule, 也就是可以认为Safari 10.1开始是可以支持<code>module/nomodule模式</code></p><p><br></p><h2 id="选项1-动态加载"><a href="#选项1-动态加载" class="headerlink" title="选项1: 动态加载"></a>选项1: 动态加载</h2><p>我们可以实现一个小型script加载器来规避这个问题，工作原理类似于<a href="https://github.com/filamentgroup/loadCSS" target="_blank" rel="noopener">LoadCSS</a>。只不过这里需要依靠浏览器的来实现ES模块和nomodule属性.</p><p>我们首先尝试执行一个模块script进行’石蕊试验’(litmus test), 然后由这个试验的结果来决定加载现代代码还是传统代码:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用一个模块script来检测是否是现代浏览器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  self.modern = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 现在根据这个检测结果来决定加载现代代码还是传统代码: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (self.modern) &#123;</span></span><br><span class="line"><span class="javascript">      s.src = <span class="string">'/modern.js'</span></span></span><br><span class="line"><span class="javascript">      s.type = <span class="string">'module'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      s.src = <span class="string">'/legacy.js'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(s)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，这个解决方案必须等待进行‘石蕊试验’模块script执行完成, 才能开始注入script。这是因为<code>&lt;script type=module&gt;</code>始终是异步的，所以别无它法(延迟到load事件后)。</p><p>另一种实现方式是检查浏览器是否支持<code>nomodule</code>, 这是方式可以避免上述的延迟加载问题, 只不过这意味着像Safari 10.1这些支持模块, 却不支持nomodule的浏览器也会被当做传统浏览器，这也许<a href="https://github.com/web-padawan/polymer3-webpack-starter/issues/33#issuecomment-474993984" target="_blank" rel="noopener">可能</a>是<a href="https://jasonformat.com/modern-script-loading/" target="_blank" rel="noopener">好事</a>(相对于两个脚本都加载以及有一些bug)，代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)  </span><br><span class="line"><span class="keyword">if</span> (<span class="string">'noModule'</span> <span class="keyword">in</span> s) &#123;  <span class="comment">// 注意这里的大小写</span></span><br><span class="line">  s.type = <span class="string">'module'</span></span><br><span class="line">  s.src = <span class="string">'/modern.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">  s.src = <span class="string">'/legacy.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(s)</span><br></pre></td></tr></table></figure><p>现在把它们封装成函数，并确保两种方式都统一使用异步的方式加载(上文提到模块script是异步的，而传统script不是):</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  $loadjs(<span class="string">"/modern.js"</span>,<span class="string">"/legacy.js"</span>)</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">$loadjs</span>(<span class="params">src,fallback,s</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="string">'noModule'</span> <span class="keyword">in</span> s) s.type = <span class="string">'module'</span>, s.src = src</span></span><br><span class="line"><span class="javascript">    <span class="keyword">else</span> s.async = <span class="literal">true</span>, s.src = fallback   <span class="comment">// 统一使用异步方式加载</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(s)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来已经很完美了，还有什么问题呢？<strong>我们还没考虑预加载(preloading)</strong></p><p>这个有点蛋疼， 因为一般浏览器只会静态地扫描HTML，然后查找它可以预加载的资源。 我们上面介绍的模块加载器是完全动态的，所以浏览器在没有运行我们的代码之前，是没办法发现我们要预加载现代还是传统的Javascript资源的。</p><p>不过有一个解决办法，就是不完美：就是使用<code>&lt;link rel=modulepreload&gt;</code>来预加载现代版本的包, 旧浏览器会忽略这条规则，然而目前<a href="https://developers.google.com/web/updates/2017/12/modulepreload" target="_blank" rel="noopener">只有Chrome支持这么做</a>:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"modulepreload"</span> <span class="attr">href</span>=<span class="string">"/modern.js"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">self.modern=1</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- etc --&gt;</span></span><br></pre></td></tr></table></figure><p><strong>其实预加载这种技术是否有效，取决于嵌入你的脚本的HTML文档的大小</strong>。</p><p>如果你的HTML载荷很小, 比如只是一个启动屏或者只是简单启动客户端应用，那么放弃预加载扫描对你的应用性能影响很小。<br>如果你的应用使用服务器渲染大量有意义的HTML, 并以流(stream)的方式传输给浏览器，那么预加载扫描就是你的朋友，但这也未必是最佳方法。</p><blockquote><p>译注: 现代浏览器都支持分块编码传输，等服务端完全输出html可能有一段空闲时间，这时候可以通过预加载技术，让浏览器预先去请求资源</p></blockquote><p>大概代码如下:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"modulepreload"</span> <span class="attr">href</span>=<span class="string">"/modern.js"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">self.modern=1</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  $loadjs(<span class="string">"/modern.js"</span>,<span class="string">"/legacy.js"</span>)</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">$loadjs</span>(<span class="params">e,d,c</span>)</span>&#123;c=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>),self.modern?(c.src=e,c.type=<span class="string">"module"</span>):c.src=d,<span class="built_in">document</span>.head.appendChild(c)&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还要指出的是，支持<a href="https://caniuse.com/#feat=es6-module" target="_blank" rel="noopener">JS模块的浏览器</a>一般也<a href="https://caniuse.com/#feat=link-rel-preload" target="_blank" rel="noopener">支持</a><code>&lt;link rel = preload&gt;</code>。对于某些网站，相比依靠<code>modulepreload</code>, 使用<code>&lt;link rel=preload as=script crossorigin&gt;</code>可能更有意义。不过性能上面可能欠点，因为传统的脚本预加载不会像<code>modulepreload</code>一样随着时间的推移而去展开解析工作(<code>rel=preload</code>只是下载，不会尝试去解析脚本)。</p><p><br></p><h2 id="选项2-用户代理嗅探"><a href="#选项2-用户代理嗅探" class="headerlink" title="选项2: 用户代理嗅探"></a>选项2: 用户代理嗅探</h2><p>我办法拿出一个简洁的代码示例，因为用户代理检测不在本文的范围之内，推荐阅读这篇<a href="https://www.smashingmagazine.com/2018/10/smart-bundling-legacy-code-browsers/" target="_blank" rel="noopener">Smashing Magazine文章</a></p><p>本质上，<strong>这种技术在每个浏览器上都使用<code>&lt;script src=bundle.js&gt;</code>来加载代码，当<code>bundle.js</code>被请求时，服务器会解析浏览器的用户代理，并选择返回现代代码还是传统代码，取决于浏览器是否能被识别为现代浏览器</strong>.</p><p>尽管这种方法比较通用，但它也有一些严重的缺点：</p><ul><li>因为依赖于服务端实现，所以前端资源不能被静态部署(例如静态网站生成器(如github page)，Netlify等等)</li><li>很难进行有效的缓存. 现在这些JavaScript URL的缓存会因用户代理而异，这是非常不稳定的, 而很多缓存机制只是将URL作为缓存键，现在这些缓存中间件可能就没办法工作了。</li><li>UA检测很难，容易出现误报</li><li>用户代理字符串容易被篡改，而且每天都有新的UA出现</li></ul><p>解决这些限制的一种方法就是<strong>将<code>module/nomodule模式</code>与’用户代理区分’结合起来</strong>，首先这可以避免单纯的<code>module/nomodule模式</code>需要发送多个软件包问题，尽管这种方法仍然会降低页面(这时候指HTML，而不是Javascript包)的可缓存性，但是它可以有效地触发预加载，因为生成HTML的服务器根据用户代理知道应该使用<code>modulepreload</code>还是<code>preload</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderPage</span>(<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">`&lt;html&gt;&lt;head&gt;...`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> agent = request.headers.userAgent;</span><br><span class="line">  <span class="keyword">const</span> isModern = userAgent.isModern(agent);</span><br><span class="line">  <span class="keyword">if</span> (isModern) &#123;</span><br><span class="line">    html += <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;link rel=modulepreload href=modern.mjs&gt;</span></span><br><span class="line"><span class="string">      &lt;script type=module src=modern.mjs&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    html += <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;link rel=preload as=script href=legacy.js&gt;</span></span><br><span class="line"><span class="string">      &lt;script src=legacy.js&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  response.end(html);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于那些已经在使用服务端渲染的网站来说，用户代理嗅探是一个比较有效的解决方案</p><p><br></p><h2 id="选项-3-不考虑旧版本浏览器"><a href="#选项-3-不考虑旧版本浏览器" class="headerlink" title="选项 3:不考虑旧版本浏览器"></a>选项 3:不考虑旧版本浏览器</h2><p><strong>注意这里的‘旧版本浏览器’特指那些出现双重加载的浏览器</strong>. 对于<code>module/nomodule模式</code>支持比较差(即双重加载)的主要是一些旧版本的Chrome、Firefox和Safari. 幸运的是这部分浏览器的市场范围通常是比较窄，因为用户会自动升级到最新的版本。Edge 16-18是例外, 但还有希望： 新版本的Edge会使用基于Chromium的渲染器，可以不受该问题的影响.</p><p>对于某些应用程序来说，接受这一点妥协是完全合理的：你可以给90％的浏览器中提供现代代码，让他们获得更好的体验，而极少数旧浏览器不得不抛弃它们，它们只是付出的额外带宽(即双重加载)，并不影响功能。值得注意的是，占据移动端主要市场份额的用户代理不会有双重加载问题，所以这些流量不太可能来自于低速或者高昂流量费的手机。</p><p>如果你的网站用户主要使用移动设备或较新版本的浏览器，那么最简单的<code>module/nomodule</code>模式将适用于你的绝大多数用户, 其他用户就不考虑了，反正也是可以跑起来的, 优先考虑大多数用户的体验。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修复Safari 10.1 不支持 `nomodule` 问题: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;!(<span class="string">"noModule"</span><span class="keyword">in</span>(t=e.createElement(<span class="string">"script"</span>)))&amp;&amp;<span class="string">"onbeforeload"</span><span class="keyword">in</span> t&amp;&amp;(n=!<span class="number">1</span>,e.addEventListener(<span class="string">"beforeload"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">if</span>(e.target===t)n=!<span class="number">0</span>;<span class="keyword">else</span> <span class="keyword">if</span>(!e.target.hasAttribute(<span class="string">"nomodule"</span>)||!n)<span class="keyword">return</span>;e.preventDefault()&#125;,!<span class="number">0</span>),t.type=<span class="string">"module"</span>,t.src=<span class="string">"."</span>,e.head.appendChild(t),t.remove())&#125;(<span class="built_in">document</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 适用于90+% 的浏览器: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">modern.js</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 部分支持module但是不支持nomodule的浏览器，也会加载下面脚本，范围可能很小，我们可以选择忽略它们: --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- IE, Edge &lt;16, Safari &lt;10.1, old desktop: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">legacy.js</span> <span class="attr">nomodule</span> <span class="attr">async</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="选项-4-使用条件包"><a href="#选项-4-使用条件包" class="headerlink" title="选项 4: 使用条件包"></a>选项 4: 使用条件包</h2><p><strong><code>nomodule</code>可以巧妙地用来<em>条件加载</em>那些现代浏览器不需要的代码</strong>， 例如polyfills。通过这种方法，最坏的情况就是polyfill和bundle都会被加载(例如Safari 10.1)，但这毕竟是少数。鉴于目前通行的做法就是在所有浏览器中一致同仁地加载polyfills，相比而言, <em>条件polyfills</em>可以让大部分现代浏览器用户避免加载polyfill代码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- newer browsers won't load this bundle: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"polyfills.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- all browsers load this one: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Angular CLI支持配置这种方式来加载polyfill, 查看<a href="https://blog.mgechev.com/2019/02/06/5-angular-cli-features/#conditional-polyfill-serving" target="_blank" rel="noopener">Minko Gechev的代码示例</a>.<br>了解了这种方式之后，我决定在preact-cli中支持自动polyfill注入，你可以查看这个<a href="https://github.com/preactjs/preact-cli/pull/833/files" target="_blank" rel="noopener">PR</a></p><p>如果你使用Webpack，这里有一个html-webpack-plugin<a href="https://github.com/swimmadude66/webpack-nomodule-plugin" target="_blank" rel="noopener">插件</a>可以方便地为polyfill包添加<code>nomodule</code>属性.</p><p><br></p><h2 id="你应该怎么做"><a href="#你应该怎么做" class="headerlink" title="你应该怎么做?"></a>你应该怎么做?</h2><p>答案取决于你的使用场景, 选择和你们的架构匹配的选项:<br>如果你的应用只是客户端渲染, 而且你的HTML不超过一个<code>&lt;script&gt;</code>，选项1比较合适；<br>如果你的应用使用服务端渲染，而且可以接受缓存问题，那么可以选择选项2；<br>如果你开发的是<a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#rehydration" target="_blank" rel="noopener">同构应用</a>，预加载的功能可能对你很重要，这时你可以考虑选项3和4.</p><p>就我个人而言，相比考虑桌面端浏览器资源下载成本，我更倾向于优化移动设备解析时间. 移动用户体验会受到数据解析、流量费用，电池消耗等因素的影响，而桌面用户往往不需要考虑这些因素。<br>另外这些优化适用于90%的用户，比如我工作面对的大部分用户都是使用现代或移动浏览器的。</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>有兴趣继续深入？可以从下面的文章开始挖掘：</p><ul><li>Phil的<a href="https://github.com/philipwalton/webpack-esnext-boilerplate/issues/1" target="_blank" rel="noopener">webpack-esnext-boilerplate</a>的一些附加的背景.</li><li>Ralph<a href="https://github.com/zeit/next.js/pull/7704" target="_blank" rel="noopener">在Next.js中实现了module/nomodule</a>, 并努力解决了上面的问题.</li></ul><p>感谢<a href="https://twitter.com/philwalton" target="_blank" rel="noopener">Phil</a>, <a href="https://twitter.com/shubhie" target="_blank" rel="noopener">Shubhie</a>, <a href="https://twitter.com/atcastle" target="_blank" rel="noopener">Alex</a>, <a href="https://twitter.com/hdjirdeh" target="_blank" rel="noopener">Houssein</a>, <a href="https://twitter.com/Janicklas" target="_blank" rel="noopener">Ralph</a> 以及 <a href="https://twitter.com/addyosmani" target="_blank" rel="noopener">Addy</a> 的反馈.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址: &lt;a href=&quot;https://jasonformat.com/modern-script-loading/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Modern Script Loading&lt;/a&gt;, 文章作者是Preact作者&lt;a 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript竟然没有标准库?</title>
    <link href="https://bobi.ink/2019/07/16/js-stdlib/"/>
    <id>https://bobi.ink/2019/07/16/js-stdlib/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-08-12T04:27:48.955Z</updated>
    
    <content type="html"><![CDATA[<p>最近在SegmentFault热心解题，一个问题比较让我比较印象深刻：<em>一个初学者试图在浏览器中导入Node.js的net模块。结果在控制台打印后是一个空对象</em>。</p><p>对于有点Javascript经验的人来说，这是一个‘弱智’问题，怎么可以在浏览器端运行Node程序呢？因为这些Node模块经过<a href="http://webpack.docschina.org/configuration/node/#其他-node-js-核心库-node-js-core-libraries-" target="_blank" rel="noopener">Webpack处理</a>, 所以变成了一个空对象，更好的处理方式应该是抛出异常.</p><p><strong>仔细反思一下，对于这些刚入门Javascript的或者从其他语言切换过来的开发者，他们压根就没有概念，比如Python、Ruby、Java这些语言都有强大的标准库，可以满足80%的开发需求，不管它在什么环境、什么平台运行，基本上都可以统一使用这套标准库。而Javascript目前的现状是：不同的运行环境，API结构是割裂的</strong>。</p><p>Javascript这门十几天开发出来的、专供浏览器的语言，可能当初设计是根本就没有考虑标准库这些玩意，比如文件系统，网络等等。<strong>因为这个背景, Javascript长期不具备独立性，它深度依赖于浏览器这个运行环境, 处于一种给浏览器打辅助的角色</strong>, 所以Javascript很多年没有走出浏览器玩具语言这个范围.</p><p>当然这既是劣势，也是优势, 现在没任何语言能撼动Javascript在浏览器中的地位。</p><p>我想很多人跟我当初一样认为<strong>浏览器提供的Web API === Javascript的标准库</strong>, 比如<code>console.log</code>、<code>setTimeout</code>(下文会介绍这些功能都不在Javascript规范里面). 正如当年那些把JQuery当成‘Javascript’的人.</p><p>直到NodeJS的出现，Javascript才挣脱浏览器约束，延伸到服务器领域, 不再是一个’沙盒语言’。NodeJS定义了很多模块来支撑服务端的开发, 如fs、os、Buffer、net。但是这些API一样不是Javascript的标准、也就是说<strong>NodeJS !== Javascript</strong>.</p><p>再到后来，学不动了，NodeJS原作者吐槽了一通NodeJS，又搞出了一个<a href="https://deno.land" target="_blank" rel="noopener">Deno</a>, 它也会有自己标准库，会定义自己的文件系统、网络API。从名字上就暗示着这些API不可能和NodeJS兼容。Ok，现在回到文章开始那个问题，<strong>如果deno发展起来，说不定哪天又有人尝试在浏览器引用Deno的模块</strong>？</p><p><br><br><br></p><h2 id="现有的javascript-api结构"><a href="#现有的javascript-api结构" class="headerlink" title="现有的Javascript API结构"></a>现有的Javascript API结构</h2><p><img src="/images/js-stdlib/outline.png" alt></p><p>如上图, Javascript其实是有一层比较薄全局的、通用的、<strong>标准的</strong>、核心的API层，即<code>标准内置对象</code>，这是一些语言核心的内置对象，可以全局访问。关键的是这些是标准的，它们在<a href="https://tc39.es/ecma262/#sec-global-object" target="_blank" rel="noopener">ECMAScript规范</a>中被定义. 在这个基础之上，不同的运行环境拓展了自己的API。</p><p>以浏览器为例:</p><p><img src="/images/js-stdlib/brw.png" alt></p><p>浏览器端的Web API是一个非常复杂API集合，上图总结了一下，基本就包含两块东西:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" target="_blank" rel="noopener">Core DOM</a>. DOM是一个通用的技术，不仅仅局限于浏览器，这个规范定义了结构化(structured document)文档的解析和操作规范。定义了基本的节点类型和操作方法。不局限于HTML的操作</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM" target="_blank" rel="noopener">HTML DOM</a>. 可以认为是Core DOM的扩展，这里面定义了各种HTML元素对象类型、扩展了元素的操作方法，另外还包含了浏览器相关的接口，如XMLHttpRequest。这一块通常也被统称为BOM</li></ul><p>WebAPI基本概览:</p><p><img src="/images/js-stdlib/webAPI.png" alt></p><p>如果你有留心查看MDN文档下面的规范引用，你会发现有些规范引用了<a href="https://www.w3.org/TR/" target="_blank" rel="noopener">W3C</a>, 有些则引用了<a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="noopener">WHATWG</a>. 到底谁说了算?</p><p>如果你掀开锅盖，就会发现这是一场闹剧. 如果前阵子有关注新闻，会看到这些标题‘<em>WHATWG 击败 W3C，赢得 HTML 和 DOM 的控制权</em>’、’<em>W3C将与WHATWG合作制定最新HTML和DOM规范标准</em>‘. 大概可以猜出这两个组织之间的关系. 本文就不扯这些‘八卦’了，相关背景可以看这篇文章<a href="https://www.infoq.cn/article/bsvFxt96DOh-SBZphBwJ" target="_blank" rel="noopener">WHATWG 击败 W3C，赢得 HTML 和 DOM 的控制权</a></p><p>相对而言, 语言层则由ECMAScript规范定义的，比较独立, 近些年成果也比较显著.</p><p><br></p><h3 id="标准内置对象层主要包含这些东西"><a href="#标准内置对象层主要包含这些东西" class="headerlink" title="标准内置对象层主要包含这些东西"></a>标准内置对象层主要包含这些东西</h3><ul><li>特殊值<ul><li>Infinity</li><li>NaN</li><li>undefined</li><li>null</li><li>globalThis</li></ul></li><li>函数<ul><li>eval()</li><li>uneval() </li><li>isFinite()</li><li>isNaN()</li><li>parseFloat()</li><li>parseInt()</li><li>decodeURI()</li><li>decodeURIComponent()</li><li>encodeURI()</li><li>encodeURIComponent()</li></ul></li><li>基础对象<ul><li>Object</li><li>Function</li><li>Boolean</li><li>Symbol</li><li>Error</li><li>EvalError</li><li>InternalError </li><li>RangeError</li><li>ReferenceError</li><li>SyntaxError</li><li>TypeError</li><li>URIError</li></ul></li><li>数值和时间<ul><li>Number</li><li>BigInt</li><li>Math</li><li>Date</li></ul></li><li>文本处理<ul><li>String</li><li>RegExp</li></ul></li><li>索引容器<ul><li>Array</li><li>‘TypedArray’</li></ul></li><li>键值容器<ul><li>Map</li><li>Set</li><li>WeakMap</li><li>WeakSet</li></ul></li><li>结构化数据<ul><li>ArrayBuffer</li><li>SharedArrayBuffer </li><li>Atomics </li><li>DataView</li><li>JSON</li></ul></li><li>控制抽象化对象<ul><li>Promise</li><li>Generator</li><li>GeneratorFunction</li><li>AsyncFunction </li></ul></li><li>反射<ul><li>Reflect</li><li>Proxy</li></ul></li><li>国际化<ul><li>Intl</li></ul></li><li>WebAssembly</li><li>其他<ul><li>arguments</li></ul></li></ul><p><br></p><p>这些全局基本对象数量很少, 这些对象是每个JavaScript开发者必须掌握的. </p><p>平时我们使用的非常频繁的Timer和Console都不再此列.</p><p>这些对象只能满足很基本开发需求, 根本不能和其他语言的标准库相比. <strong>当然这和语言的定位也有一定关系</strong></p><p><br><br><br></p><h2 id="什么是标准库"><a href="#什么是标准库" class="headerlink" title="什么是标准库?"></a>什么是标准库?</h2><p>标准库没有一个严格的定义，按照Wiki的说法标准库就是<strong>该语言在不同实现中都按例提供的库</strong>, 比如Ruby官方实现cRuby和基于JVM的JRuby都按照官方标准库规范实现了标准库。 <strong>标准库怎么设计，需要包含什么内容取决于语言各自秉持的哲学和定位</strong>。 我认为标准库应该有以下特征:</p><ul><li>标准化的. 有规范明确定义它的内容和行为</li><li>内容经过仔细雕琢和挑选，可以覆盖大部分使用场景或者符合的语言定位</li><li>可选的、按需导入. 标准库不是全局的，需要通过模块导入, 非强制性使用</li></ul><p><br></p><p>至于标准库需要包含什么内容，可以参考其他语言的实现。比如：</p><ul><li><a href="https://golang.org/pkg/" target="_blank" rel="noopener">go</a></li><li><a href="http://ruby-doc.org/stdlib-2.6.3/" target="_blank" rel="noopener">ruby</a></li><li><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">python</a></li></ul><p><br></p><p>大概分析一下，它们标准库大致都有这些内容：</p><ul><li>网络协议</li><li>文件系统<ul><li>文件系统</li><li>流</li><li>标准输入输出</li><li>二进制处理</li></ul></li><li>算法<ul><li>密码算法</li><li>编码</li><li>压缩、归档</li><li>排序</li><li>数学</li><li>字符串、文本</li></ul></li><li>数据结构, 例如树、堆、队列等等</li><li>数据持久化和序列化. 比如JSON序列化，二进制序列化，数据库操作等等</li><li>调试/辅助</li><li>单元测试</li><li>文档处理</li><li>设计模式. 标准库中经常会携带(或辅助设计)该语言的最佳实践和设计模式, 例如go中的context, Ruby中的singleton</li><li>国际化</li><li>时间、日期</li><li>操作系统<ul><li>命令行</li><li>环境变量</li><li>系统资源</li></ul></li><li>并发<ul><li>进程</li><li>线程</li><li>协程</li></ul></li><li>语言或运行时的底层接口</li></ul><p>大部分语言的核心都很小(C++除外)，我们学一门语言，大部分时间是花在标准库上和语言的生态上面，但是你会发现这些标准库一般都是大同小异，这就是为什么有经验的开发者可以很快地入手一门语言.</p><p>显然上面这些功能大部分在NodeJS中已经实现了，<strong>鉴于NodeJS这么广泛的使用率，NodeJS可以算是事实上的标准了</strong></p><p><br></p><h2 id="我们需要标准库"><a href="#我们需要标准库" class="headerlink" title="我们需要标准库?"></a>我们需要标准库?</h2><p><img src="/images/js-stdlib/dep.png" alt></p><p>显然要结合当前的背景来辩证地考虑。</p><p><strong>有标准库有什么好处?</strong></p><ul><li>标准库提供通用、定义良好、优化的功能和行为，减少第三方模块依赖, 而且第三方库很难保证质量</li><li>避免社区割裂, 抚平不同运行环境的差异. 现在有NodeJS、后面有Deno，可能还会有Aeno、Beno, 尽管取代NodeJS的可能性很低，有规范化的标准库可以避免重复造轮子，不然真会学不动</li><li>安全性. <a href="https://mp.weixin.qq.com/s/UEPZwFuousrRVj17zZU80w" target="_blank" rel="noopener">近期npm安全事件频发</a>，投毒、删库(left-pad事件)、npm商业运作, 给社区带了不少麻烦。而标准库由运行环境内置，可以避免引用第三方库导致的安全问题</li><li>今天的Javascript应用会有很多依赖(node_modules hell)，打包出来的体积很大，网络加载和脚本解析需要耗费一定的资源，而且这些资源不能在多个应用之间被缓存. 一个很大的原因是npm的依赖过于零碎(比如几行代码的包)和重复(依赖不同的版本、Dead Code)，使用标准库可以减少这部分依赖</li><li>选择困难症. 没有标准库，可以选择npm上的第三方库，在npm上挑选靠谱、高质量的库是需要一定的时间成本的. 有时候我们就是懒得去比较和选择</li><li>优雅的标准库，是学习的榜样. 网上很多教程都是钻研标准库算法和实现的，对语言的开发者来说标准库是一块宝藏</li><li>学习成本。其他语言的开发者，可以较快入手</li></ul><p><br></p><p><strong>标准库可能会有什么问题?</strong></p><ul><li>标准可能滞后跟不上社区发展. Javascript正处于快速发展阶段，很多规范的定义是由社区驱动的，比如Promise、async/await. 跟不上社区的发展结果可能就是没人用</li><li>想下WebComponent目前的境遇</li><li>标准库不可能满足所有人的口味</li></ul><p><br></p><p><strong>如何设计标准库? 标准库推进进程可能会有什么障碍?</strong></p><ul><li>NodeJS已经是事实上的标准, 怎么兼容现有的生态?</li><li>标准库应该包含什么内容，如何保持和社区同步?</li><li><p>如何把控标准库内容的尺度? </p><p>最小化的标准库容易被维护和升级，但可能出现’没什么卵用’的情况；</p><p>最大化的标准库，例如Java的标准库，几乎包含了所有的东西，开发者可以快速开发一个东西, 但是过了几年很多API就会变得过时，一般为了保持向下兼容，这些API会一直像一根刺一样卡在那里.<br>另一个非常典型的反例就是PHP的标准库，这里可以看到各种风格的API.</p><p>标准库是跟随语言发布的，如果你的项目中使用了过时的API，又想升级语言版本，就需要重构项目。而使用第三方库则可能可以保持不动。</p></li><li><p>Javascript的主要战场还是浏览器, 标准库是否应该有一个’基本版’(用于浏览器或者一些抽象操作系统的运行环境), 还有个’旗舰版’(服务端), 或者只提供一个跨越所有平台的标准库?</p></li><li>如何处理兼容性问题? 老旧浏览器如何Polyfill?</li><li>如何与现有的全局对象或用户模块分离？</li></ul><p><br></p><h2 id="近期的一些尝试"><a href="#近期的一些尝试" class="headerlink" title="近期的一些尝试"></a>近期的一些尝试</h2><ul><li><a href="https://github.com/tc39/proposal-javascript-standard-library" target="_blank" rel="noopener">proposal-javascript-standard-library</a> 这是一个非常早期的语言提议，定义了如何引用标准库(built-in modules)，但是没有定义标准库的内容</li><li><p><a href="https://developers.google.com/web/updates/2019/03/kv-storage" target="_blank" rel="noopener">KV Storage: the Web’s First Built-in Module</a> Chrome在年初推出的实验性功能，尝试实现proposal-javascript-standard-library提议. 它通过下面方式来引用‘标准库’模块:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;storage, StorageArea&#125; <span class="keyword">from</span> <span class="string">'std:kv-storage'</span>; <span class="comment">// std: 前缀，和普通模块区分开来</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从一个SegmentFault上的一个问题开始，对比其他语言，揭露Javascript没有标准库的窘境. 接着介绍现有Javascript的API结构，介绍什么是标准库，辩证考虑标准库的优缺点，以及推行上面可能会遇到的阻碍.</p><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://www.infoworld.com/article/3048833/brendan-eich-javascript-standard-library-will-stay-small.html" target="_blank" rel="noopener">Brendan Eich: JavaScript standard library will stay small</a></li><li><a href="https://medium.com/@thomasfuchs/what-if-we-had-a-great-standard-library-in-javascript-52692342ee3f" target="_blank" rel="noopener">What if we had a great standard library in JavaScript?</a></li><li><a href="https://www.i-programmer.info/news/167-javascript/12608-the-javascript-standard-library.html" target="_blank" rel="noopener">The JavaScript Standard Library</a></li><li><a href="https://www.w3.org/TR/" target="_blank" rel="noopener">W3C</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API" target="_blank" rel="noopener">Web API 索引</a></li><li><a href="https://dev.to/sloan/explain-like-im-five-whats-a-standard-library-4gi" target="_blank" rel="noopener">Explain Like I’m Five: What’s a standard library?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在SegmentFault热心解题，一个问题比较让我比较印象深刻：&lt;em&gt;一个初学者试图在浏览器中导入Node.js的net模块。结果在控制台打印后是一个空对象&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;对于有点Javascript经验的人来说，这是一个‘弱智’问题，怎么可以在浏览器端
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你需要知道的软件测试类型和常识</title>
    <link href="https://bobi.ink/2019/07/10/typeof-testing/"/>
    <id>https://bobi.ink/2019/07/10/typeof-testing/</id>
    <published>2019-07-09T16:00:00.000Z</published>
    <updated>2019-07-14T14:00:23.180Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接: <a href="https://www.softwaretestinghelp.com/types-of-software-testing/" target="_blank" rel="noopener">Types Of Software Testing: Different Testing Types With Details</a></p><blockquote><p>文章为意译，并且在原文的基础之上进行演绎和扩展</p></blockquote><blockquote><p>文章篇幅较长，阅读完大概20min，读完会有收获。欢迎点赞收藏关注</p></blockquote><p><br></p><p><img src="/images/typeof-testing/Types-of-Testing1.jpg" alt></p><p><br></p><p>有多少软件测试类型呢?</p><p>我们作为测试人员了解很多种不同的软件测试类型，例如功能测试(Functional Test)、非功能测试、自动测试、敏捷测试、以及它们的各种子类型. 尽管在我们的测试过程中会接触很多种测试类型, 或者听说过某些测试类型，但是很少人敢说精通所有的测试类型.</p><p>每个测试类型都有自己的特点、优势和劣势。所以我写这篇文章，科普一下我们今天最常用的测试类型.</p><p><br></p><h2 id="不同的软件测试类型"><a href="#不同的软件测试类型" class="headerlink" title="不同的软件测试类型"></a>不同的软件测试类型</h2><p><img src="/images/typeof-testing/Types-of-Software-Testing.jpg" alt></p><p>下面是软件测试的通用类型列表</p><ul><li><p>功能测试类型:</p><ul><li>单元测试(Unit testing)</li><li>集成测试(Integration testing)</li><li>系统测试(System testing)</li><li>健全性测试(Sanity testing)</li><li>冒烟测试(Smoke testing)</li><li>接口测试(Interface testing)</li><li>回归测试(Regression testing)</li><li>Beta/验收测试(Beta/Acceptance testing)</li></ul></li><li><p>非功能测试类型:</p><ul><li>性能测试(Performance Testing)</li><li>负载测试(Load testing)</li><li>压力测试(Stress testing)</li><li>容量测试(Volume testing)</li><li>安全测试(Security testing)</li><li>兼容性测试(Compatibility testing)</li><li>安装测试(Install testing)</li><li>恢复测试(Recovery testing)</li><li>可靠性测试(Reliability testing)</li><li>可用性测试(Usability testing)</li><li>一致性测试(Compliance testing)</li><li>本地化测试(Localization testing)</li></ul></li></ul><p>来看看这些测试类型的细节</p><p><br></p><h2 id="0-a-b测试-a-b-testing"><a href="#0-a-b测试-a-b-testing" class="headerlink" title="0) A/B测试(A/B Testing)"></a>0) A/B测试(A/B Testing)</h2><p><img src="/images/typeof-testing/ab.png" alt></p><p>顾名思义， <a href="https://maxket.com/ab-test-best-practice/" target="_blank" rel="noopener">A/B测试</a>就是准备两个(A/B)或两个以上的版本，让不同的用户来随机访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。如上图，谷歌使用A/B测试来决定导航应该是红色还是蓝色。</p><p><br></p><h2 id="1-alpha测试-alpha-testing"><a href="#1-alpha测试-alpha-testing" class="headerlink" title="1) Alpha测试(Alpha Testing)"></a>1) Alpha测试(Alpha Testing)</h2><p><strong><a href="https://www.softwaretestinghelp.com/what-is-alpha-testing-beta-testing/" target="_blank" rel="noopener">Alpha测试</a>这是软件工程中很常见的测试类型。它的目标就是尽可能地在发布到市场或交付给用户之前找出所有的问题和缺陷</strong>。</p><p>Alpha测试一般在开发的末段且在Beta测试之前进行。在这个测试过程中可能会驱动开发者进行一些小(minor)的设计变动. Alpha测试一般在开发者网站进行，即只对开发者或内部用户开放，一般可以为此类测试创建内部虚拟的用户环境。</p><p><br></p><p>一般大型的软件项目都有规范化的<strong>软件版本周期</strong>:</p><p><img src="/images/typeof-testing/alpha-testing.png" alt></p><ul><li><strong>Pre-alpha</strong>: 有时候软件会在Alpha或Beta版本前先发布Pre-alpha版本, 相比Alpha和Beta，这是一个功能不完整的版本</li><li><strong>Alpha</strong>: Alpha版本功能还没完善，需要进一步测试。Alpha版本通常会发送到开发软件的组织或某群体中的软件测试者进行内部测试。</li><li><strong>Beta</strong>: 一般Beta版本会包含所有功能，但可能又有一些Bug，需要调试反馈。 Beta版本是软件最早对外公开的软件版本，由公众（通常为公司外的第三方开发者和业余玩家）参与测试。</li><li><strong>Release Candidate(rc)</strong>: 发布候选版本，如果没有出现问题则可发布成为正式的版本。这个版本包含完整且比较稳定的功能</li></ul><p>举一个典型的例子, 最近把我<a href="https://juejin.im/pin/5d1ecb656fb9a00259a176a5" target="_blank" rel="noopener">坑得有点惨</a>的iOS13的发布计划:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">June 3: iOS 13 beta 1 and first look at WWDC 2019                 # -&gt; WWDC后就可以装的，相当于pre-alpha或Alpha阶段吧</span><br><span class="line">June 17: iOS 13 beta 2 launched for developers</span><br><span class="line">June 24: iOS 13 public beta release date for adventurous testers  # -&gt; 公开Beta版本，相当于上面说的Beta阶段</span><br><span class="line">July 3: iOS 13 developer beta 3 launch with some new features     </span><br><span class="line">July 8: iOS 13 public beta 2 release date</span><br><span class="line">Early September 2019: iOS 13 Golden Master (final dev beta)       # -&gt; 九月初，该发最终Beta版本了，相当于进入RC阶段了</span><br><span class="line">Mid-September 2019: iOS 13 likely to launch with new 2019 iPhones # -&gt; 正式版本</span><br></pre></td></tr></table></figure><p><br></p><p>现在很多开源项目，已经淡化了瀑布式的软件版本周期，变成一种持续(Continuous)的、常态化的行为, 例如Firefox:</p><p><img src="/images/typeof-testing/firefox.png" alt></p><p><br></p><h2 id="2-验收测试-acceptance-testing"><a href="#2-验收测试-acceptance-testing" class="headerlink" title="2) 验收测试(Acceptance Testing)"></a>2) 验收测试(Acceptance Testing)</h2><p><strong><a href="https://www.softwaretestinghelp.com/what-is-acceptance-testing/" target="_blank" rel="noopener">验收测试</a>通常是部署软件之前的最后一个测试操作, 也称为交付测试, 由最终客户执行，他们会验证端到端(end to end)的系统流程是否符合业务需求，以及功能是否是满足最终用户的需求</strong>。只有当所有的特性和功能按照期望的运行，客户才会接受软件</p><p>这是测试的最后阶段，在验收测试之后，软件将投入生产环境. 所以它也叫用户验收测试(UAT)</p><p><img src="/images/typeof-testing/accept.png" alt></p><p>举个例子，验收测试就相当于收快递, 包裹是软件、你就是客户，是验收方，如果货物不符合你的要求，是要退货的。</p><p><br></p><h2 id="3-临时测试-ad-hoc-testing"><a href="#3-临时测试-ad-hoc-testing" class="headerlink" title="3) 临时测试(Ad-hoc Testing)"></a>3) 临时测试(Ad-hoc Testing)</h2><p>Ad-hoc中文应该理解为临时的意思。顾名思义，这种测试是在临时基础上进行的, 有时候也称为随机测试。即没有参考测试用例、没有针对该测试的任何计划和文档。Ad-hoc测试的目的就是<strong>通过执行随意的流程或任意的功能来找出应用的缺陷和问题</strong></p><p>Ad-hoc测试一种非正式的方法，可以由项目中的任何人执行。尽管没有测试用例很难识别缺陷，但是有些时候在Ad-hoc测试期间发现的缺陷可能无法使用现有的测试用例来识别, <strong>也就是说它一般用来发现‘意外’的缺陷</strong>.</p><p><br></p><h2 id="4-可访问性测试-accessibility-testing"><a href="#4-可访问性测试-accessibility-testing" class="headerlink" title="4) 可访问性测试(Accessibility Testing)"></a>4) 可访问性测试(Accessibility Testing)</h2><p><strong>可访问性测试的目的是确定软件或应用程序是否可供残疾人使用</strong>。残疾是指聋人，色盲，智障人士，失明者，老年人和其他残疾人群体。这里会执行各种检查，例如针对视觉残疾的字体大小测试，针对色盲的颜色和对比度测试等等。</p><p>不同平台、不同应用类型对可访问性支持情况不太一样，比如iOS相比其他操作系统则更重视可访问, 而国外比国内更重视可访问性。</p><p><img src="/images/typeof-testing/acs.png" alt></p><p><br></p><h2 id="5-beta测试-beta-testing"><a href="#5-beta测试-beta-testing" class="headerlink" title="5) Beta测试(Beta Testing)"></a>5) Beta测试(Beta Testing)</h2><p>上文Alpha测试已经提及Beta测试, <strong>Beta测试是一种正式的软件测试类型，在将产品发布到市场或者实际最终用户之前，由客户在真实的应用环境中执行</strong>。</p><p>执行Beta测试目的是确保软件或产品中没有重大故障，并且满足最终用户的业务需求。当客户接受软件时，Beta测试才算通过。</p><p>通常，此类测试由最终用户或其他人完成。这是在将应用发布作为商业用途之前完成的最终测试。通常，发布的软件或产品的Beta版本仅限于特定区域中的特定数量的用户。<br>所以最终用户实际使用软件后会将一些问题反馈给公司。公司可以在全面发布之前采取必要的措施。</p><p>Beta测试在正式版本之前也可能会迭代进行多次.</p><p><br></p><h2 id="6-后端测试-back-end-testing"><a href="#6-后端测试-back-end-testing" class="headerlink" title="6) 后端测试(Back-end Testing)"></a>6) 后端测试(Back-end Testing)</h2><p>前端应用输入的数据，一般都会存储在数据库，所以针对数据库的这类测试称为<strong>数据库测试或者后端测试</strong>. 市面有不同的数据库，如SQL Server，MySQL和Oracle等。数据库测试会涉及表结构，模式，存储过程，数据结构等。</p><p>后端测试一般不会涉及GUI，测试人员通过某些手段直接连接到数据库，从而可以容易地运行一些数据库请求来验证数据。<strong>通过后端测试可以发现一些数据库问题，比如数据丢失、死锁、数据损坏。这些问题在系统投入生产环境之前进行修复至关重要</strong></p><p><br></p><h2 id="7-浏览器兼容测试-browser-compatibility-testing"><a href="#7-浏览器兼容测试-browser-compatibility-testing" class="headerlink" title="7) 浏览器兼容测试(Browser Compatibility Testing)"></a>7) 浏览器兼容测试(Browser Compatibility Testing)</h2><p><img src="/images/typeof-testing/brw.png" alt></p><p>这是兼容性测试的子类型，由测试团队执行. <strong><a href="http://frontend.turing.io/lessons/module-2/cross-browser-compat.html" target="_blank" rel="noopener">浏览器兼容测试</a>主要针对Web应用，用于确保软件可以在不同浏览器或操作系统中运行; 或者验证Web应用程序是否支持在浏览器的所有版本上运行, 以确定应用最终兼容的范围</strong>.</p><p>浏览器兼容测试是前端开发者绕不开的坑。</p><p>我们有很多<strong>策略</strong>来应对浏览器兼容性，比如渐进增强或者优雅降级, 还有制定浏览器兼容规范; </p><p>为了<strong>抚平浏览器之间的差异</strong>，我们会使用各种特性检测工具(Modernizr), 还有各种polyfill(CSS Normaliz, polyfill/shim, css-autoprefixer);</p><p>当然为了<strong>测试跨浏览器兼容性</strong>，还要一些辅助工具，例如<a href="https://www.browserstack.com/" target="_blank" rel="noopener">BrowserStack</a>, 对于我们这些小团队，只能下一堆Portable(<em>Portable浏览器运行时相互隔离的, 所以不会存在配置文件等冲突问题</em>) 浏览器，手工测试了。</p><p><br></p><h2 id="8-后向兼容测试-backward-compatibility-testing"><a href="#8-后向兼容测试-backward-compatibility-testing" class="headerlink" title="8) 后向兼容测试(Backward Compatibility Testing)"></a>8) 后向兼容测试(Backward Compatibility Testing)</h2><p><strong>向后兼容测试, 用于验证新开发或更新的软件是否能在旧版本的环境中运行</strong>。</p><p>比如向后兼容测试会检查新版软件是否可以正确地处理旧版本软件创建的文件格式。例如新版的Office 2016是否可以打开2012创建的文件。</p><p>同理也可以检查新版本是否可以兼容旧版本软件创建的数据表、数据文件、数据结构、配置文件。 </p><p>任何软件更新应该在先前版本的基础之上良好地运行</p><p><br></p><h2 id="9-黑盒测试-black-box-testing"><a href="#9-黑盒测试-black-box-testing" class="headerlink" title="9) 黑盒测试(Black Box Testing)"></a>9) 黑盒测试(Black Box Testing)</h2><p><img src="/images/typeof-testing/black-box.png" alt></p><p>黑盒测试不考虑软件的内部系统设计，它基于需求和功能进行测试, 只关心系统的输入/输出以及功能流程。 </p><p>换句话说<strong>黑盒测试从用户的角度出发针对软件界面、功能及外部结构进行测试，而不考虑程序内部逻辑结构</strong>.</p><p>黑盒测试下面有很多子类，例如集成测试、系统测试、大部分非功能性测试</p><p>关于黑盒测试的优缺点以及测试类型可以看<a href="https://www.softwaretestinghelp.com/black-box-testing/" target="_blank" rel="noopener">这里</a></p><p><br></p><h2 id="10-边界值测试-boundary-value-testing"><a href="#10-边界值测试-boundary-value-testing" class="headerlink" title="10) 边界值测试(Boundary Value Testing)"></a>10) 边界值测试(Boundary Value Testing)</h2><p><strong>边界值测试, 测试应用处于边界条件(boundary level)的行为</strong>。很多边界条件开发者是很难考虑周到的，所以才有一个专门的测试类型来验证这种情况</p><p>边界值测试检查应用处于边界值时是否存在缺陷。边界值测试通常用于测试不同范围的数字, 每个范围都有一个上下边界，边界测试则是针对这些边界值进行测试。</p><p>比如数字范围为1-500, 那么边界值测试会在这些值上进行验证: 0、1、2、499、500、501</p><p><br></p><h2 id="11-分支测试-branch-testing"><a href="#11-分支测试-branch-testing" class="headerlink" title="11) 分支测试(Branch Testing)"></a>11) 分支测试(Branch Testing)</h2><p>这是白盒测试的子类型，在单元测试中实施. 顾名思义，<strong>分支测试表示测试要覆盖程序代码的各种条件分支, 避免遗漏缺陷</strong>。分支覆盖是单元测试覆盖率的一个指标之一</p><p><br></p><h2 id="12-比较测试-comparison-testing"><a href="#12-比较测试-comparison-testing" class="headerlink" title="12) 比较测试(Comparison Testing)"></a>12) 比较测试(Comparison Testing)</h2><p><img src="/images/typeof-testing/wzr.png" alt></p><p><strong>比较测试，将产品的优点和弱点与旧版本或者同类(竞品)产品进行比较.</strong></p><p>比如类似王自如这种数码测评栏目，评测一个手机或者其他数码产品时，一般会横向和友商产品进行比较，有时候也会纵向和上一代产品比较.</p><p>还有一种比较典型的例子就是和行业的领导者比较，比如我们做IM的，会经常和微信比较: ‘你这个应用的启动速度怎么比微信慢这么多?’</p><p><br></p><h2 id="13-兼容性测试-compatibility-testing"><a href="#13-兼容性测试-compatibility-testing" class="headerlink" title="13) 兼容性测试(Compatibility Testing)"></a>13) 兼容性测试(Compatibility Testing)</h2><p>这是一个大类, <strong>兼容性测试用于验证应用在不同环境、web服务器、硬件、网络条件下的行为</strong>。兼容性测试确保软件可以在不同的配置、不同的数据库、不同的浏览器，以及它们不同的版本下运行。兼容性测试由测试团队实施</p><p><br></p><h2 id="14-组件测试-component-testing"><a href="#14-组件测试-component-testing" class="headerlink" title="14) 组件测试(Component Testing)"></a>14) 组件测试(Component Testing)</h2><p><a href="https://www.guru99.com/component-testing.html" target="_blank" rel="noopener">组件测试</a>(此组件非GUI组件, 取组合测试可能更好理解一点)，<strong>一般也称为模块测试(Module Testing), 一般由开发者在完成单元测试后执行。组件测试将多个功能组合起来作为单一的整体进行测试，目的是发现多个功能在相互连接起来之后的缺陷</strong>。</p><p>组件测试可大可小，小到函数级别或者类级别的组合，大可以大到几个单独的页面、模块、子系统的组合。 举一个前端例子，将多个页面路由组合起来，测试它们的流程跳转，就属于组件测试。</p><p><img src="/images/typeof-testing/comp.png" alt></p><p><br></p><h2 id="15-端到端测试-end-to-end-testing"><a href="#15-端到端测试-end-to-end-testing" class="headerlink" title="15) 端到端测试(End-to-End Testing)"></a>15) 端到端测试(End-to-End Testing)</h2><p>端到端测试也是一种黑盒测试类型，类似于系统测试. <strong>端到端测试在模拟的、完整的、真实应用环境下模拟真实用户对应用进行测试，比如应用会和数据库交互、会使用网络通信、或者在适当的情况下和其他硬件、应用、系统进行交互</strong>. 端到端是指从一个端点到另一个端点的意思，所以端到端测试重点用于测试模块和模块之间的协调性。</p><p>当应用是分布式系统或者需要和其他外部系统协同时，端到端测试扮演着非常重要的角色, 它可以全面检查以确保软件在不同平台和环境产品能准确地交互。端到端测试有以下目的:</p><ul><li>确保应用可以和外部系统之间良好的协调。对于前端来说，是确保页面和后端之间良好协调</li><li>检查从源系统到目标系统的所有系统流</li><li>从最终用户角度验证需求</li><li>识别异构环境中的问题</li></ul><p>前端也有很多自动化的端到端测试工具，比如nightwatch，通过它们可以模拟用户对页面进行操作，从而检验整个应用流程是否正常和符合需求:</p><p><img src="/images/typeof-testing/nightwatch.png" alt></p><p>因为和<strong>系统测试</strong>很相似，所以它们也被经常拿来<a href="https://www.softwaretestinghelp.com/system-vs-end-to-end-testing/" target="_blank" rel="noopener">比较</a></p><p><br></p><h2 id="16-等价划分-equivalence-partitioning"><a href="#16-等价划分-equivalence-partitioning" class="headerlink" title="16) 等价划分(Equivalence Partitioning)"></a>16) 等价划分(Equivalence Partitioning)</h2><p>等价划分, 这是一种黑盒测试的测试技术. <strong>通过等价划分，可以将所有的输入数据合理地划分为多个分组，我们只需在每个分组中取一个数据作为测试的输入条件, 这样可以实现用少量代表性的测试数据取得较好的测试结果</strong>.</p><p>所以说这个测试的目的: 是在不导致缺陷的前提下，移除指定分组中的重复的用例, 简化测试的工作</p><p><img src="/images/typeof-testing/part.png" alt></p><p>比如一个程序应用接受-10到+10之间的值，使用等价分区方法可以划分为三个分组: 0、负值、正值. 接下来的测试只需从这个三个分组中取一个成员进行测试, 而不需要-10到+10每个成员都测试一遍.</p><p><br></p><h2 id="17-实例测试-example-testing"><a href="#17-实例测试-example-testing" class="headerlink" title="17) 实例测试(Example Testing)"></a>17) 实例测试(Example Testing)</h2><p>It means real-time testing. Example testing includes the real-time scenario, it also involves the scenarios based on the experience of the testers.</p><p>实例测试意味着实时测试。实例测试包含了实时场景、另外还涉及基于测试人员经验的场景。</p><blockquote><p>🤔 这里不是特别能理解这个测试类型，所以贴上原文。知道的告诉我呀</p></blockquote><p><br></p><h2 id="18-探索测试-exploratory-testing"><a href="#18-探索测试-exploratory-testing" class="headerlink" title="18) 探索测试(Exploratory Testing)"></a>18) 探索测试(Exploratory Testing)</h2><p><img src="/images/typeof-testing/explorer.png" alt></p><p>探索性测试有点类似于Ad-Hoc测试. 探索性测试是由测试团队进行的非正式测试。此测试的目的是探索应用并查找应用中存在的缺陷。像探险一样，在测试期间是有一定几率发现的重大、甚至可能导致系统故障的缺陷.</p><p>在探索性测试期间，建议跟踪记录好测试的流程、以及开始该流程之前的活动记录, 方便复现bug.</p><p>探索测试不需要任何文档和测试用例.</p><p><br></p><h2 id="20-功能测试-functional-testing"><a href="#20-功能测试-functional-testing" class="headerlink" title="20) 功能测试(Functional Testing)"></a>20) 功能测试(Functional Testing)</h2><p>功能测试是一个大类, 又称为行为测试，  <strong>功能测试会忽略内部实现而关注组件的输出，目的是验证是否符合需求，这是一种面向功能需求的黑盒测试类型</strong>。关于功能测试的细节请看<a href="https://www.softwaretestinghelp.com/guide-to-functional-testing/" target="_blank" rel="noopener">这里</a></p><p>功能测试是相对非功能测试而言的, 功能测试需要关心功能或者业务，需要业务耦合程度高；而非功能测试则是通用的，比如压力测试、负载测试，这些测试都有通用的工具来支持，不需要或很少定制化操作.</p><p><br></p><h2 id="21-gui测试-graphical-user-interface-gui-testing"><a href="#21-gui测试-graphical-user-interface-gui-testing" class="headerlink" title="21) GUI测试(Graphical User Interface (GUI) Testing)"></a>21) GUI测试(Graphical User Interface (GUI) Testing)</h2><p>GUI测试的目的是根据业务需求验证GUI。在详细设计文档和GUI模型(UI设计文档)中一般会提到应用期望的GUI.</p><p>常见的GUI测试包括测试屏幕上显示的按钮和输入字段的大小、表格中所有文本、表格或内容的对齐规则等等. 如果团队有UI设计规范，还会验证是否符合设计规范</p><p><br></p><h2 id="22-大猩猩测试-gorilla-testing"><a href="#22-大猩猩测试-gorilla-testing" class="headerlink" title="22) 大猩猩测试(Gorilla Testing)"></a>22) 大猩猩测试(Gorilla Testing)</h2><p><img src="/images/typeof-testing/gr.jpg" alt></p><p>大猩猩测试是由测试人员执行的测试类型，有时也由开发人员执行。在大猩猩测试中，对模块中的一个模块或功能进行了彻底和严格的测试。原文没有说出大猩猩测试的精髓，大猩猩测试会对一个功能或模块进行重复‘上百次’的测试, 人类根本受不了这样子的测试方式，所以大猩猩测试的另一个别名是‘令人沮丧的测试(Frustrating Testing)’</p><p>这种测试的目的是检查应用程序的稳健性(robustness)</p><p><br></p><h2 id="23-乐观路线测试-happy-path-testing"><a href="#23-乐观路线测试-happy-path-testing" class="headerlink" title="23) 乐观路线测试(Happy Path Testing)"></a>23) 乐观路线测试(Happy Path Testing)</h2><p><strong>乐观路线测试</strong>的目标是在正常流程上成功测试应用。它不会考虑各种负面或异常情况。重点只关注于验证应用在有效和合法输入的条件下生成期望的输出. 比如银行付款，只考虑账户有钱的正常状态😂</p><p><br></p><h2 id="24-增量集成测试-incremental-integration-testing"><a href="#24-增量集成测试-incremental-integration-testing" class="headerlink" title="24) 增量集成测试(Incremental Integration Testing)"></a>24) 增量集成测试(Incremental Integration Testing)</h2><p>增量集成测试是一种自下而上的测试方法，即在添加新功能时立即集成应用程序进行连续测试。应用程序功能和模块应该足够独立，以便单独测试。这通常由程序员或测试人员完成。</p><p><br></p><h2 id="25-安装卸载测试-install-uninstall-testing"><a href="#25-安装卸载测试-install-uninstall-testing" class="headerlink" title="25) 安装卸载测试(Install/Uninstall Testing)"></a>25) 安装卸载测试(Install/Uninstall Testing)</h2><p><img src="/images/typeof-testing/blue-screen.jpg" alt></p><p>安装和卸载测试是在不同硬件或软件环境下的不同操作系统上的进行完整/部分的安装、升级、卸载、回滚等测试. 常用于桌面端应用</p><p><br></p><h2 id="26-集成测试-integration-testing"><a href="#26-集成测试-integration-testing" class="headerlink" title="26) 集成测试(Integration Testing)"></a>26) 集成测试(Integration Testing)</h2><p>集成测试是指将所有模块集成之后，验证合并后的功能. 模块通常是代码模块、单个应用、网络上的客户端和服务器应用等等。</p><p><img src="/images/typeof-testing/ingr.png" alt></p><p>集成测试一般在单元测试之后，所以单元测试是集成测试的基础，没有进行单元测试的集成测试是不靠谱的。所以最简单的形式是：’把两个已经测试过的单元组合成一个组件，测试它们之间的接口’。也就是说<strong>集成测试在单元测试的基础之上，将单元测试中独立的单元合并起来，验证它们的协调性, 合并后的组件又是一个新的‘单元’，这样逐步合并测试，最终形成完整的应用程序</strong>。</p><p>这种类型的测试常用于B/S软件和分布式系统。</p><p><br></p><h2 id="27-负载测试-load-testing"><a href="#27-负载测试-load-testing" class="headerlink" title="27) 负载测试(Load Testing)"></a>27) 负载测试(Load Testing)</h2><p>它是一种非功能性测试，负载测试的目的是检查系统可以承受多少负载而不会降低性能, 或者说确定最大工作负载是多少。</p><p>负载测试有助于查找特定负载下系统的最大容量以及导致软件性能下降的任何原因。可以使用JMeter，LoadRunner，WebLoad，Silk执行程序等工具执行负载测试。</p><p><img src="/images/typeof-testing/perf.png" alt></p><p>负载测试经常和性能测试、压力测试、稳定性测试等联系在一起。如上图(来源于淘宝性能白皮书). 其中TPS(Transation Per Second)指的是每秒钟系统可以处理的交易或事务的数量; Server Resource指的是系统资源占有.</p><ul><li><strong>性能测试</strong>. 主要位于a-b之间. 在系统设计初期就会规划一个预期目标, 比如给定资源Ax，a点就是性能期望值。也就是说在给定固定资源Ax的情况下，如果TPS可以达到a点甚至更高，就说明系统性能达到或者好于预期. <strong>通过性能测试可以验证系统的处理能力有没有达到预期</strong></li><li><strong>负载测试</strong>. 位于b-c之间。对系统不断增加并发请求，直到系统的某项或者多项指标达到安全的临界值，如上图中的c，这个c就是所谓的最大负载量。后面再增加请求压力，系统的处理能力不但不能提高，返回会下降. <strong>通过压力测试可以得出系统最大的安全负载值</strong></li><li><strong>压力测试</strong>. 位于c-d之间。在超过安全负载的情况下，继续对系统增加压力，直到达到崩溃点, 即上图的d. <strong>通过压力测试可以得出系统的最大承受能力</strong></li><li><strong>稳定性测试</strong>. 位于a-d之间。在a、b、c、d不同的点(代表特定的硬件、软件和网络环境)，让系统运行一段较长的时间，<strong>检测系统在不同条件下的系统运行的稳定性</strong>。</li></ul><p>另外也推荐阅读&lt;&lt;大型网站技术架构&gt;&gt;这本书</p><p><br></p><h2 id="28-猴子测试-monkey-testing"><a href="#28-猴子测试-monkey-testing" class="headerlink" title="28) 猴子测试(Monkey Testing)"></a>28) 猴子测试(Monkey Testing)</h2><p><img src="/images/typeof-testing/monkey-testing.jpg" alt></p><p>猴子测试是由测试人员进行的，即把自己当成猴子，在没有任何知识背景或者理解应用前提下，随意输入和操作。</p><p>猴子测试的目标是通过提供随机输入值/数据来检查应用程序或系统是否崩溃。 猴子是随机执行的，没有测试用例, 也没有必要了解系统的全部功能</p><p><br></p><h2 id="29-变异测试-mutation-testing"><a href="#29-变异测试-mutation-testing" class="headerlink" title="29) 变异测试(Mutation Testing)"></a>29) 变异测试(Mutation Testing)</h2><p>变异测试(或者说可变性测试)是一种白盒测试，这是一种和单元测试反着来的测试类型。</p><p><img src="/images/typeof-testing/mut.png" alt></p><p><strong>通常单元测试的思路是通过测试用例来验证代码是否有效可靠，而变异测试是反过来. 它首先更改其中一个程序的源代码，再跑单元测试，如果单元测试通过则可能说明测试用例没有效果，或者测试用例没有覆盖到这处代码变异</strong>. </p><p>所以说变异测试可以反过来验证你的测试用例是否有效, 还有可以帮助我们找出一些无法被当前测试所防止的潜在错误.</p><p><br></p><h2 id="30-悲观测试-negative-testing"><a href="#30-悲观测试-negative-testing" class="headerlink" title="30) 悲观测试(Negative Testing)"></a>30) 悲观测试(Negative Testing)</h2><p>悲观测试和乐观路线测试相反, 它要求测试者要具有“打破”常规的态度，考虑各种异常情况, 使用各种邪恶的👿、不怀好意、不合法的操作来测试系统。悲观测试会使用不正确的数据、无效数据或输入来进行验证。它验证系统是否可以识别异常情况，并按预期运行。</p><p><br></p><h2 id="31-非功能测试-non-functional-testing"><a href="#31-非功能测试-non-functional-testing" class="headerlink" title="31) 非功能测试(Non-Functional Testing)"></a>31) 非功能测试(Non-Functional Testing)</h2><p>每个大型的组织都有一个独立的团队，通常称为非功能测试（NFT）团队或性能团队。</p><p>非功能性测试涉及测试非功能性需求，如负载测试、压力测试、安全性、容量，恢复测试等等. NFT测试的目标是确保软件或应用程序的响应时间是否满足业务需求。</p><p>例如加载任何页面或系统都不应该花费太多时间，并且在负载峰值期间应该维持良好运行状态。</p><p><br></p><h2 id="32-性能测试-performance-testing"><a href="#32-性能测试-performance-testing" class="headerlink" title="32) 性能测试(Performance Testing)"></a>32) 性能测试(Performance Testing)</h2><p>这个术语通常与“压力”和“负载”测试互换使用。<a href="https://en.wikipedia.org/wiki/Software_performance_testing" target="_blank" rel="noopener">性能测试</a>用于检查系统是否满足性能要求。它会使用不同的性能和负载工具来执行此测试。</p><p><a href="https://www.softwaretestinghelp.com/introduction-to-performance-testing-loadrunner-training-tutorial-part-1/" target="_blank" rel="noopener">性能测试</a>这个范围比较大，<strong>广义上的性能测试包括了上文提到的负载测试、压力测试、稳定性测试、容量测试等等。狭义的性能测试则是指在特定资源条件下，测试系统能否达到期望值, 也就是基线测试(Baseline Test).</strong></p><p>总结一下性能测试的类型:</p><ul><li><strong>基线测试(Baseline Test)</strong>: 在给定的资源下，测试最佳的性能，用作后续测量的参考‘基线’。注意基线测试和基准测试是有区别的, 这么理解，基准是你想达到的，比如100短跑世界纪录，基线是你的成绩。</li><li><strong>负载测试(Load Test)</strong>: 在预期峰值的生产负载下测量系统的性能。上文负载测试已经大概介绍了</li><li><strong>稳定性测试(Endurance Test)</strong>: 在指定负载下，长时间测量系统的稳定性</li><li><strong>压力测试(Stress Test)</strong>: 测试极端条件下的系统性能</li></ul><p><br></p><h2 id="33-恢复测试-recovery-testing"><a href="#33-恢复测试-recovery-testing" class="headerlink" title="33) 恢复测试(Recovery Testing)"></a>33) 恢复测试(Recovery Testing)</h2><p>恢复测试用于验证应用或系统中崩溃或灾难中恢复的程度. 确定系统是否能够在灾难发生后继续运行。</p><p>比如应用通过网络电缆接收数据，突然断开了网络电缆的连接, 过一段时间，再插上网线, 系统应该开始恢复由于网络电缆拔出而丢失连接的数据</p><p><br></p><h2 id="34-回归测试-regression-testing"><a href="#34-回归测试-regression-testing" class="headerlink" title="34) 回归测试(Regression Testing)"></a>34) 回归测试(Regression Testing)</h2><p>在修改任意模块或者功能后，将应用作为一个整体进行测试，称为回归测试。<strong>回归测试的目的就是验证在软件原有的功能变动后是否保持完整性</strong>. </p><p><img src="/images/typeof-testing/bug-fix.gif" alt></p><p><strong>有观点认为回归测试就是回归测试是指重复执行以前的全部或部分相同的测试工作, 其实不是不无道理。而且因为局部修改而牵一发动全身的意外在平时开发中并不少见，这种意外性就是回归测试的存在的目的</strong>.</p><p>因为在回归测试中很难覆盖所有系统，通常最好使用自动化测试工具进行这些类测试。比如每次修改完代码，跑单元测试来确保不影响确保其他软件单元。</p><p>在前端中<a href="https://jestjs.io/docs/en/snapshot-testing" target="_blank" rel="noopener">组件快照测试(Snapshot Testing)</a>和一些<a href="https://github.com/HuddleEng/PhantomCSS" target="_blank" rel="noopener">CSS UI测试</a>，都是属于回归测试类型,它们的原理都是和上一次测试生成的结果进行比对，以确保没有意外的修改:</p><p><img src="/images/typeof-testing/phantomcss.png" alt></p><p><br></p><h2 id="35-基于风险的测试-risk-based-testing-rbt"><a href="#35-基于风险的测试-risk-based-testing-rbt" class="headerlink" title="35) 基于风险的测试(Risk-Based Testing (RBT))"></a>35) 基于风险的测试(Risk-Based Testing (RBT))</h2><p>在基于风险的测试中，功能或需求将根据其优先级进行测试。基于风险的测试会优先测试高度关键的功能，因为这些功能对业务影响最大或者故障概率非常高. 而优先级由业务需求决定，因此一旦为所有功能设置了优先级，则应该首先执行高优先级功能或测试用例，然后再执行低优先级功能。 低优先级功能可以在时间充裕时测试，或者不测试。</p><p><strong>基于风险的测试应该在‘不够时间来测试整个应用，但是又要按时交付软件’的情况下执行</strong>，通常还需要客户和高级管理层的讨论和批准之后才进行</p><p><br></p><h2 id="36-完整性测试-sanity-testing"><a href="#36-完整性测试-sanity-testing" class="headerlink" title="36) 完整性测试(Sanity Testing)"></a>36) 完整性测试(Sanity Testing)</h2><p>完整性测试用于确定一个新的软件版本是否可以开始进行正式的测试，如果一个应该在一开始使用时就崩溃，那么就说明系统还不够稳定，没有必要进行下一步测试。这种情况应该打回给开发，以免浪费时间</p><p>以我们公司为例:</p><p><img src="/images/typeof-testing/smoke.png" alt></p><ul><li>在软件设计阶段，测试团队就会为编写冒烟测试用例; </li><li>开发团队在提交版本给测试之前会自己跑一下冒烟用例, 确保没有重大故障；</li><li>将版本提交给测试团队后，测试团队就会先跑一下完整性测试，检查一下有没有重大的，影响测试进程的bug，如果有则退回开发</li><li>如果通过了完整性测试, 则进行冒烟测试，如果冒烟测试没有通过也会立即打回开发。</li><li>顺利通过完整性测试和冒烟测试之后才会进入正式测试阶段。</li></ul><p>这么做的目的之一就是为了降低测试团队的工作负担，因为他们要对接多个开发团队的测试任务。</p><p><br></p><h2 id="37-安全测试-security-testing"><a href="#37-安全测试-security-testing" class="headerlink" title="37) 安全测试(Security Testing)"></a>37) 安全测试(Security Testing)</h2><p><img src="/images/typeof-testing/sec.png" alt></p><p>安全也是一个庞大的学科，而且知识每天都在更新，所以安全测试一般由特殊的安全团队执行，他们以各种黑客手段对系统进行渗透测试。</p><p>安全测试旨在确保应用或网站免受内部和外部威胁的侵害。这个测试包括预防恶意程序、病毒； 检验授权和身份验证过程的安全性。</p><p>它还会检查软件对任何黑客攻击和恶意程序的反应方式，以及在遭到黑客攻击后如何维护软件以保护数据安全</p><p><br></p><h2 id="38-冒烟测试-smoke-testing"><a href="#38-冒烟测试-smoke-testing" class="headerlink" title="38) 冒烟测试(Smoke Testing)"></a>38) 冒烟测试(Smoke Testing)</h2><p><img src="/images/typeof-testing/note7.jpg" alt></p><p>冒烟测试，每当开发团队提交新的构建时，软件测试团队就会先验证构建, 并确保不存在重大问题, 如果存在重大问题会直接打回开发团队.</p><p>如何通俗地理解冒烟测试呢？这个属于来源于硬件行业，对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。举个例子，给三星Note7加电，如果没爆炸，就说明通过了‘冒烟测试’(感觉当手机测试者不容易，容易有生命危险😂)?</p><p>测试团队在确保构建稳定后才会进一步执行详细的测试。 冒烟检查会检查构建中是否存在中断缺陷(stopper defect, 即影响继续测试的缺陷)，这将阻止测试团队进一步详细测试。 即如果测试人员发现主要功能不能工作，他们会拒绝这次构建，并退回给开发团队。</p><p>冒烟测试一般在回归测试或其他详细测试之前进行</p><p><br></p><h2 id="39-静态测试-static-testing"><a href="#39-静态测试-static-testing" class="headerlink" title="39) 静态测试(Static Testing)"></a>39) 静态测试(Static Testing)</h2><p><img src="/images/typeof-testing/review.jpg" alt></p><p>静态测试有点类似于代码Review，在不执行任何代码的情况下执行(也就是不运行应用)，它涉及对可交付成果审查(inspection)、review和演练(walkthrough). 比如检查代码语法、命名约定、项目组织。</p><p>静态测试不仅适用于代码, 也适用于测试用例、测试计划和设计文档. 如果在静态测试阶段发现缺陷，可以将缺陷成本降到最低。比如在设计阶段就发现问题，相比到开发阶段甚至到生产环境出现问题要好解决</p><p>举前端的例子，静态测试可能包括:</p><ul><li>使用Lint工具对程序进行规范检查，相关的工具有ESLint、TSLint、Stylint等, 甚至Typescript这些类型检查器也可以归到这个范畴</li><li>代码Review。有一些问题是无法通过Lint工具覆盖的，比如代码逻辑、异常捕获、项目组织、内存泄露等等，这些需要人工进行走查Review</li><li>检查代码是否与设计一致，是否符合软件需求、概要和详细设计，这不仅可以看出代码问题，也可以反过来更早发现需求或设计是否正确。</li></ul><p><br></p><h2 id="40-压力测试-stress-testing"><a href="#40-压力测试-stress-testing" class="headerlink" title="40) 压力测试(Stress Testing)"></a>40) 压力测试(Stress Testing)</h2><p><img src="/images/typeof-testing/str.jpg" alt></p><p><strong>通过压力测试，模拟系统受到超出其规格的压力时失败的方式和时间, 找出系统的崩溃点</strong>. 这个测试在高负载情况下执行的，例如存取超过容量限制的数据、执行复杂的数据库查询、连续暴力输入到系统或加载到数据库。</p><p><br></p><h2 id="41-系统测试-system-testing"><a href="#41-系统测试-system-testing" class="headerlink" title="41) 系统测试(System Testing)"></a>41) 系统测试(System Testing)</h2><p>系统测试在完整的集成系统上进行测试，也就是说<strong>系统测试一般在集成测试之后进行，集成测试之后系统成为了一个整体，系统测试在这个基础上、在真实的运行环境中验证系统是否符合业务需求</strong>。 这是一种黑盒型测试，基于总体需求规范，涵盖系统的所有组合部分。</p><p>系统测试其实不是一个具体的测试技术，而是一个测试阶段。 这个阶段会进行很多种测试，一般公司的测试团队的工作就集中在这一块。 一般包含:</p><ul><li><strong>功能测试</strong>: 即上面讲的，从系统的整体上测试是否符合业务需求</li><li><strong>各种非功能测试</strong>：例如恢复测试、性能测试、压力测试、安全测试等等。</li></ul><p>归纳一下<strong>系统测试的目的</strong>:</p><ul><li>确保应用<strong>作为一个整体</strong>可以良好地运行.</li><li>确保应用符合业务需求</li><li>确保应用在真实的环境可以良好地运行。比如进行一些非功能测试，验证系统的健壮性</li></ul><p>其实系统测试和上文说的端到端测试很像，它们要求系统作为一个整体进行测试。可以简单展开对比一下</p><table><thead><tr><th></th><th>系统测试</th><th>端到端测试</th></tr></thead><tbody><tr><td>测试范围</td><td>一般针对被测应用本身</td><td>一般针对被测应用以及其依赖的其他系统。正如其名，端到端，即从一端点到另一端点。重点关注前端、后端以及中间件之间的处理流程</td></tr><tr><td>测试类型</td><td>包含功能测试和非功能测试</td><td>一般涵盖所有源系统和目标系统之间的接口级别的测试</td></tr><tr><td>测试时机</td><td>一般在集成测试之后</td><td>一般在系统测试之后</td></tr></tbody></table><p><br></p><h2 id="42-单元测试-unit-testing"><a href="#42-单元测试-unit-testing" class="headerlink" title="42) 单元测试(Unit Testing)"></a>42) 单元测试(Unit Testing)</h2><p><img src="/images/typeof-testing/unit-test.png" alt></p><p><strong>测试独立的软件单元或模块称为单元测试</strong>。它通常由开发者完成，而不是由测试人员完成，因为它需要详细了解内部程序设计和代码。</p><p>单元测试是和我们开发者最密切相关的测试类型。它的测试对象是软件单元。<strong>软件单元可以是一个函数/方法、一个类或者一个GUI组件等</strong>。</p><p>这是一种白盒测试，所以要求由开发者自己进行，因为只有开发者才知道单元的内部实现。<strong>单元测试一般会使用测试覆盖率来验证单元测试的完成度</strong>. </p><p>前端常见的单元测试工具有Jest、Mocha、Jasmine等等. 下面是典型的BDD风格的单元测试组织:</p><p><img src="/images/typeof-testing/bdd.png" alt></p><p><br></p><h2 id="43-可用性测试-usability-testing"><a href="#43-可用性测试-usability-testing" class="headerlink" title="43) 可用性测试(Usability Testing)"></a>43) 可用性测试(Usability Testing)</h2><p>可用性测试用于检测应用的用户友好程度(User-friendliness). 它会验证新用户受可以轻松理解应用流程，如果用户陷入麻烦，测试人员要记录好并提供帮助。可以认为可用性测试是在检查系统的导航性(navigation)</p><p><br></p><h2 id="44-漏洞测试-vulnerability-testing"><a href="#44-漏洞测试-vulnerability-testing" class="headerlink" title="44) 漏洞测试(Vulnerability Testing)"></a>44) 漏洞测试(Vulnerability Testing)</h2><p>漏洞测试，涉及识别软件、硬件和网络中的漏洞。如果漏洞容易受到攻击，或者容易受到病毒和蠕虫感染，黑客或恶意程序就可以控制系统。</p><p>因此有必要在投入生产环境之前检查这些系统是否存在漏洞。</p><p><br></p><h2 id="45-容量测试-volume-testing"><a href="#45-容量测试-volume-testing" class="headerlink" title="45) 容量测试(Volume Testing)"></a>45) 容量测试(Volume Testing)</h2><p>容量测试是由性能测试团队执行的一种非功能测试。容量测试会检查应用程序遇到大量的数据时的系统行为和响应时间。这种大量数据可能会影响系统的性能和处理时间的速度。</p><p><br></p><h2 id="46-白盒测试-white-box-testing"><a href="#46-白盒测试-white-box-testing" class="headerlink" title="46) 白盒测试(White Box Testing)"></a>46) 白盒测试(White Box Testing)</h2><p><img src="/images/typeof-testing/glassbox.jpg" alt></p><p>白盒测试, 它也被称为玻璃盒测试、结构测试、逻辑驱动测试或基于代码的测试, 基于应用程序代码的内部逻辑。即测试人员应该知道内部软件和代码是如何工作的, 对所有的逻辑路径进行覆盖测试。上面提到的单元测试和静态测试就是典型的白盒测试, 基本上白盒测试可以等价于单元测试</p><p><strong>逻辑路径包括语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖等等</strong>.</p><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/typeof-testing/all.png" alt></p><p>上面提到的软件测试类型只是测试中的一部分，实际有超过100种的测试类型，但是并非所有测试类型都会被所有项目使用，所以我这里只是列举一些比较常见的软件测试类型。</p><p>另外不同的组织中可能会有不同的定义或过程，但是基本概念在任何地方都是相同的。当项目、需求和范围发生变化时，这些测试类型、过程及其实现方法会不断演变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接: &lt;a href=&quot;https://www.softwaretestinghelp.com/types-of-software-testing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Types Of Software Testing: 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你可能不知道的浏览器实时通信方案</title>
    <link href="https://bobi.ink/2019/07/07/sockjs/"/>
    <id>https://bobi.ink/2019/07/07/sockjs/</id>
    <published>2019-07-06T16:00:00.000Z</published>
    <updated>2019-07-10T08:30:04.800Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。</p><p>这里以<a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="noopener"><code>sockjs</code></a>作为切入点，这是一个流行的浏览器实时通信库，提供了’类Websocket’、一致性、跨平台的API，旨在浏览器和服务器之间创建一个低延迟、全双工、支持跨域的实时通信信道. <strong>主要特点就是仿生Websocket，它会优先使用Websocket作为传输层，在不支持WebSocket的环境回退使用其他解决方案，例如XHR-Stream、轮询</strong>. </p><p>所以<code>sockjs</code>本身就是浏览器实时通信方案的编年史, 本文也是按照由新到老这样的顺序来介绍这些解决方案. </p><blockquote><p>类似sockjs的解决方案还有 <a href="https://socket.io/" target="_blank" rel="noopener">socket.io</a></p></blockquote><blockquote><p>如果你觉得文章不错，请不要吝惜你的点赞👍，鼓励笔者写出更精彩的文章</p></blockquote><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#websocket">WebSocket</a></li><li><a href="#xhr-streaming">XHR-streaming</a></li><li><a href="#eventsource">EventSource</a></li><li><a href="#htmlfile">HtmlFile</a></li><li><a href="#polling">Polling</a></li><li><a href="#long-polling">Long polling</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="websocket"><a href="#websocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket其实不是本文的主角，而且网上已经有很多教程，本文的目的是介绍WebSocket之外的一些回退方案，在浏览器不支持Websocket的情况下, 可以选择回退到这些方案.</p><p>在此介绍Websocket之前，先来了解一些HTTP的基础知识，毕竟WebSocket本身是借用HTTP协议实现的。</p><p>HTTP协议是基于TCP/IP之上的应用层协议，也就是说HTTP在TCP连接中进行请求和响应的，<strong>浏览器会为每个请求建立一个TCP连接，请求等待服务端响应，在服务端响应后关闭连接</strong>:</p><p><img src="/images/sockjs/base-http.png" alt></p><p>后来人们发现为每个HTTP请求都建立一个TCP连接，太浪费资源了，能不能不要着急关闭TCP连接，而是将它复用起来, 在一个TCP连接中进行多次请求。</p><p><strong>这就有了HTTP持久连接(HTTP persistent connection, 也称为HTTP keep-alive), 它利用同一个TCP连接来发送和接收多个HTTP请求/响应。持久连接的方式可以大大减少等待时间, 双方不需要重新运行TCP握手，这对前端静态资源的加载也有很大意义</strong>:</p><p><img src="/images/sockjs/http-keep-alive.png" alt></p><p>Ok, 现在回到WebSocket, <strong>浏览器端用户程序并不支持和服务端直接建立TCP连接，但是上面我们看到每个HTTP请求都会建立TCP连接, TCP是可靠的、全双工的数据通信通道，那我们何不直接利用它来进行实时通信？ 这就是Websocket的原理!</strong> </p><p>我们这里通过一张图，通俗地理解一下Websocket的原理:</p><p><img src="/images/sockjs/websocket.png" alt></p><p>通过上图可以看到，<strong>WebSocket除最初建立连接时需要借助于现有的HTTP协议，其他时候直接基于TCP完成通信</strong>。这是浏览器中最靠近套接字的API，可以实时和服务端进行全双工通信. WebSocket相比传统的浏览器的<a href="https://en.wikipedia.org/wiki/Comet_(programming" target="_blank" rel="noopener">Comet</a>)(下文介绍)技术, 有很多优势：</p><ul><li>更强的实时性。基于TCP协议的全双工通信</li><li>更高效。一方面是数据包相对较小，另一方面相比传统XHR-Streaming和轮询方式更加高效，不需要重复建立TCP连接</li><li>更好的二进制支持。 Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容</li><li>保持连接状态。 相比HTTP无状态的协议，WebSocket只需要在建立连接时携带认证信息，后续的通信都在这个会话内进行</li><li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等</li></ul><p><br></p><p>它的接口也非常简单：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/socket'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">ws.onerror = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123; ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接关闭</span></span><br><span class="line">ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接建立</span></span><br><span class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 向服务端发送消息</span></span><br><span class="line">  ws.send(<span class="string">"ping"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端发送的消息</span></span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span>(msg.data <span class="keyword">instanceof</span> Blob) &#123; </span><br><span class="line">  <span class="comment">// 处理二进制信息</span></span><br><span class="line">    processBlob(msg.data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文本信息</span></span><br><span class="line">    processText(msg.data); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文不会深入解析Websocket的协议细节，有兴趣的读者可以看下列文章:</p><ul><li><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a></li><li><a href="https://mp.weixin.qq.com/s/7aXMdnajINt0C5dcJy2USg?" target="_blank" rel="noopener">WebSocket 浅析</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">阮一峰：WebSocket 教程</a></li></ul><p><br></p><p>如果不考虑低版本IE，基本上WebSocket不会有什么兼容性上面的顾虑. 下面列举了Websocket一些常见的问题, 当无法正常使用Websocket时，可以利用sockjs或者socket.io这些方案回退到传统的Comet技术方案.</p><ol><li>浏览器兼容性。<ul><li>IE10以下不支持</li><li>Safari 下不允许使用非标准接口建立连接</li></ul></li><li>心跳. WebSocket本身不会维护心跳机制，一些Websocket实现在空闲一段时间会自动断开。所以sockjs这些库会帮你维护心跳</li><li>一些负载均衡或代理不支持Websocket。</li><li>会话和消息队列维护。这些不是Websocket协议的职责，而是应用的职责。sockjs会为每个Websocket连接维护一个会话，且这个会话里面会维护一个消息队列，当Websocket意外断开时，不至于丢失数据</li></ol><p><br></p><hr><p><br></p><h2 id="xhr-streaming"><a href="#xhr-streaming" class="headerlink" title="XHR-streaming"></a>XHR-streaming</h2><p>XHR-Streming, 中文名称‘XHR流’, 这是WebSocket的最佳替补方案. XHR-streaming的原理也比较简单：<strong>服务端使用分块传输编码(Chunked transfer encoding)的HTTP传输机制进行响应，并且服务器端不终止HTTP响应流，让HTTP始终处于持久连接状态，当有数据需要发送给客户端时再进行写入数据</strong>。</p><p>没理解？没关系，我们一步一步来, 先来看一下正常的HTTP请求处理是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node.js代码</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>, <span class="comment">// 设置内容格式</span></span><br><span class="line">    <span class="string">'Content-Length'</span>: <span class="number">11</span>, <span class="comment">// 设置内容长度</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.end(<span class="string">'hello world'</span>) <span class="comment">// 响应 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端会立即接收到响应:</p><p><img src="/images/sockjs/http-req.png" alt></p><p><br></p><p>那么什么是<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener"><strong>分块传输编码</strong></a>呢?</p><p><strong>在HTTP/1.0之前, 响应是必须作为一整块数据返回客户端的(如上例)，这要求服务端在发送响应之前必须设置<code>Content-Length</code>, 浏览器知道数据的大小后才能确定响应的结束时间</strong>。这让服务器响应动态的内容变得非常低效，它必须等待所有动态内容生成完，再计算Content-Length, 才可以发送给客户端。如果响应的内容体积很大，需要占用很多内存空间.</p><p><strong>HTTP/1.1引入了<code>Transfer-Encoding: chunked;</code>报头。 它允许服务器发送给客户端应用的数据可以分为多个部分, 并以一个或多个块发送，这样服务器可以发送数据而不需要提前计算发送内容的总大小</strong>。</p><p><strong>有了分块传输机制后，动态生成内容的服务器就可以维持HTTP长连接, 也就是说服务器响应流不结束，TCP连接就不会断开</strong>. </p><p><br></p><p>现在我们切换为分块传输编码模式， 且我们不终止响应流，看会有什么情况:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    <span class="comment">// 'Content-Length': 11, // 🔴将Content-Length报头去掉，Node.js默认就是使用分块编码传输的</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.write(<span class="string">'hello world'</span>)</span><br><span class="line">  <span class="comment">// res.end() // 🔴不终止输出流</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们会发现请求会一直处于Pending状态(绿色下载图标)，<strong>除非出现异常、服务器关闭或显式关闭连接(比如设置超时机制)，请求是永远不会终止的。但是即使处于Pending状态客户端还是可以接收数据，不必等待请求结束</strong>:</p><p><img src="/images/sockjs/http-pending-req.png" alt></p><p><br></p><p>基于这个原理我们再来创建一个简单的ping-pong服务器:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/ping'</span>) &#123;</span><br><span class="line">    <span class="comment">// ping请求</span></span><br><span class="line">    <span class="keyword">if</span> (pendingResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">500</span>);</span><br><span class="line">      res.write(<span class="string">'session not found'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.writeHead(<span class="number">200</span>)</span><br><span class="line">    res.end()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给客户端推流</span></span><br><span class="line">    pendingResponse.write(<span class="string">'pong\n'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存句柄</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="string">'welcome to ping\n'</span>);</span><br><span class="line">    pendingResponse = res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>测试一下，在另一个窗口访问<code>/ping</code>路径：</p><p><img src="/images/sockjs/http-stream-ping.png" alt></p><p>Ok! 这就是XHR-Streaming!</p><p><br></p><p>那么Ajax怎么接收这些数据呢？ ①一种做法是在<code>XMLHttpRequest</code>的<code>onreadystatechange</code>事件处理器中判断<code>readyState</code>是否等于<code>XMLHttpRequest.LOADING</code>；②另外一种做法是在<code>xhr.onprogress</code>事件处理器中处理。下面是ping客户端实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.onprogress = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意responseText是获取服务端发送的所有数据，如果要获取未读数据，则需要进行划分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'progress'</span>, xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(<span class="string">'POST'</span>, HOST);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ping</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'POST'</span>, HOST + <span class="string">'/ping'</span>);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen();</span><br><span class="line">setInterval(ping, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p><br></p><p>慢着，不要高兴得太早😰. 如果运行上面的代码会发现<code>onprogress</code>并没有被正常的触发, 具体原因笔者也没有深入研究，我发现sockjs的服务器源码里面会预先写入2049个字节，这样就可以正常触发onprogress事件了:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/ping'</span>) &#123;</span><br><span class="line">    <span class="comment">// ping请求</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存句柄</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">Array</span>(<span class="number">2049</span>).join(<span class="string">'h'</span>) + <span class="string">'\n'</span>);</span><br><span class="line">    pendingResponse = res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>最后再图解一下XHR-streaming的原理:</p><p><img src="/images/sockjs/xhr-stream.png" alt></p><p>总结一下XHR-Streaming的特点:</p><ul><li>利用分块传输编码机制实现持久化连接(persistent connection): 服务器不关闭响应流，连接就不会关闭</li><li>单工(unidirectional): 只允许服务器向浏览器单向的推送数据</li></ul><p><strong>通过XHR-Streaming，可以允许服务端连续地发送消息，无需每次响应后再去建立一个连接, 所以它是除了Websocket之外最为高效的实时通信方案. 但它也并不是完美无缺</strong>。</p><p>比如XHR-streaming连接的时间越长，浏览器会占用过多内存，而且在每一次新的数据到来时，需要对消息进行划分，剔除掉已经接收的数据. 因此sockjs对它进行了一点优化, 例如sockjs默认只允许每个xhr-streaming连接输出128kb数据，超过这个大小时会关闭输出流，让浏览器重新发起请求.</p><p><br></p><hr><p><br></p><h2 id="eventsource"><a href="#eventsource" class="headerlink" title="EventSource"></a>EventSource</h2><p>了解了XHR-Streaming, 就会觉得<a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/EventSource" target="_blank" rel="noopener"><code>EventSource</code></a>并不是什么新鲜玩意: 它就是上面讲的<code>XHR-streaming</code>, 只不过浏览器给它提供了标准的API封装和协议, 你抓包一看和XHR-streaming没有太大的区别:</p><p><img src="/images/sockjs/eventsource.png" alt></p><p><br></p><p>上面可以看到请求的<code>Accept</code>为<code>text/event-stream</code>, 且服务端写入的数据都有标准的约定, 即载荷需要这样组织:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="string">`data: <span class="subst">$&#123;payload&#125;</span>\r\n\r\n`</span></span><br></pre></td></tr></table></figure><p><br></p><p>EventSource的API和Websocket类似, 实例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">'sse.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接打开</span></span><br><span class="line">evtSource.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受消息</span></span><br><span class="line">evtSource.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"message: "</span> + e.data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭流</span></span><br><span class="line">  evtSource.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常</span></span><br><span class="line">evtSource.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>因为是标准的，浏览器调试也比较方便，不需要借助第三方抓包工具:</p><p><img src="/images/sockjs/eventsource-inspect.png" alt></p><p><br></p><hr><p><br></p><h2 id="htmlfile"><a href="#htmlfile" class="headerlink" title="HtmlFile"></a>HtmlFile</h2><p>这是一种古老的‘秘术’😂，虽然我们可能永远都不会再用到它，但是它的实现方式比较有意思(类似于JSONP这种黑科技), 所以还是值得讲一下。</p><p>HtmlFile的另一个名字叫做<code>永久帧(forever-frame)</code>, 顾名思义, 浏览器会打开一个隐藏的iframe，这个iframe会请求一个分块传输编码的html文件(Transfer-Encoding: chunked), 和XHR-Streaming一样，这个请求永远都不会结束，服务器会不断在这个文档上输出内容。<strong>这里面的要点是现代浏览器都会增量渲染html文件，所以服务器可以通过添加script标签在客户端执行某些代码</strong>，先来看个抓包的实例:</p><p><img src="/images/sockjs/htmlfile.png" alt></p><p><br></p><p>从上图可以看出:</p><ul><li>① 这里会给服务器传递一个callback，通过这个callback将数据传递给父文档</li><li>② 服务器每当有新的数据，就向文档追加一个<code>&lt;script&gt;</code>标签，script的代码就是将数据传递给callback。利用浏览器会被下载边解析HTML文档的特性，新增的script会马上被执行</li></ul><p><br></p><p>最后还是用流程图描述一下：</p><p><img src="/images/sockjs/htmlfile-progress.png" alt></p><p>除了IE6、7以下不支持，大部分浏览器都支持这个方案，当浏览器不支持<code>XHR-streaming</code>时，可以作为最佳备胎。</p><p><br></p><hr><p><br></p><h2 id="polling"><a href="#polling" class="headerlink" title="Polling"></a>Polling</h2><p>轮询是最粗暴(或者说最简单)，也是效率最低下的‘实时’通信方案，这种方式的原理就是定期向服务器发起请求, 拉取最新的消息队列:</p><p><img src="/images/sockjs/polling2.png" alt></p><p>这种轮询方式比较合适<strong>服务器的信息定期更新</strong>的场景，如天气和股票行情信息。举个例子股票信息每隔5分钟更新一次，这时候客户端定期轮询, 且轮询间隔和服务端更新频率保持一致是一种理想的方式。</p><p>但是如果追求实时性，轮询会导致一些严重的问题:</p><ul><li>资源浪费。比如轮询的间隔小于服务器信息更新的频率，这会浪费很多HTTP请求, 消耗宝贵的CPU时间和带宽</li><li>容易导致请求轰炸。比如当服务器负载比较高时，第一个请求还没处理完成，这时候第二、第三个请求接踵而来，无用的额外请求对服务端进行了轰炸。</li></ul><p><br></p><hr><p><br></p><h2 id="long-polling"><a href="#long-polling" class="headerlink" title="Long polling"></a>Long polling</h2><p>还有一种优化的轮询方法，称为长轮询(Long Polling)，sockjs就是使用这种轮询方式, <strong>长轮询指的是浏览器发送一个请求到服务器，服务器只有在有可用的新数据时才响应</strong>：</p><p><img src="/images/sockjs/polling.png" alt></p><p>客户端向服务端发起一个消息获取请求，服务端会将当前的消息队列返回给客户端，然后关闭连接。<strong>当消息队列为空时，服务端不会立即关闭连接，而是等待指定的时间间隔，如果在这个时间间隔内没有新的消息，则由客户端主动超时关闭连接</strong>。</p><p>另外一个要点是，<strong>客户端的轮询请求只有在上一个请求连接关闭后才会重新发起</strong>。这就解决了上文的请求轰炸问题。服务端可以控制客户端的请求时序，因为在服务端未响应之前，客户端不会发送额外的请求(在超时期间内)。</p><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="noopener">WebRTC</a> 这是浏览器的实时通信技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。</li><li><a href="https://github.com/meteor/meteor/tree/devel/packages/ddp" target="_blank" rel="noopener">metetor DDP</a> DDP(Distributed Data Protocol), 这是一个’有状态的’实时通信协议，这个是<a href="https://github.com/meteor/meteor" target="_blank" rel="noopener">Meteor</a>框架的基础, 它就是使用这个协议来进行客户端和服务端通信. 他只是一个协议，而不是通信技术，比如它的底层可以基于Websocket、XHR-Streaming、长轮询甚至是WebRTC</li><li><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">Server-Sent Events 教程</a></li><li><a href="https://medium.com/@chijianqiang/程序员怎么会不知道-c10k-问题呢-d024cb7880f3" target="_blank" rel="noopener">程序员怎么会不知道C10K 问题呢？ - 池建强- Medium</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。&lt;/p&gt;
&lt;p&gt;这里以&lt;a href=&quot;https://github.com/sockjs/sockjs-client&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;sockjs
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[译] 不容错过的CSS变量</title>
    <link href="https://bobi.ink/2019/07/06/css-variable/"/>
    <id>https://bobi.ink/2019/07/06/css-variable/</id>
    <published>2019-07-05T16:00:00.000Z</published>
    <updated>2019-07-06T04:54:51.625Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接: <a href="https://dev.to/timdeschryver/don-t-miss-out-on-css-variables-4708" target="_blank" rel="noopener">Don’t miss out on css variables</a></p><p>当我第一次听说<a href="https://www.w3.org/TR/css-variables/" target="_blank" rel="noopener">CSS变量</a>时，我是抱着怀疑太多的。scss、sass、less和stylus这些CSS预处理器不是都有变量机制吗? 为什么还要使用它？过了几年，我发现越来越多的人开始讨论和使用它，我觉得我是错过了什么…… 虽然花费了一点功夫，但在使用后，我确实被它吸引住了。这篇文章我会阐述到底是什么推动我进一步去探索CSS变量，并在实际项目中使用它。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>在选择器里面声明变量，变量名以<code>--</code>作为前缀:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">--bgColor</span>: deeppink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个流行的方式是在<code>:root</code>选择器中定义变量，这相当于定于全局变量:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--bgColor</span>: teal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>var()</code>函数来引用变量:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--bgColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>var()</code>函数还可以接受一个参数，用作变量的默认值，当变量未定义时回退到这个默认值:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--bgColor);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color, beige);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的运行结果如下:</p><p><img src="/images/css-variable/0.png" alt></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>利用CSS变量，可以很容易地实现主题机制.</p><p>在body元素上为不同的主题创建不同的类名，并定义合适的变量值:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-class">.sunrise</span> &#123;</span><br><span class="line">  <span class="attribute">--background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">--text-color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.sunset</span> &#123;</span><br><span class="line">  <span class="attribute">--background-color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">--text-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这些变量:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--background-color);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--text-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在切换body元素的类名到sunrise或sunse，CSS变量会叠层应用到所有选择器. 效果如下:</p><p><img src="/images/css-variable/1.gif" alt></p><h2 id="javascript-api"><a href="#javascript-api" class="headerlink" title="Javascript API"></a>Javascript API</h2><p>我觉得这是CSS变量最好的部分 —— CSS变量可以通过Javascript API来获取和设置。SCSS/Less这些预处理器的变量可做不到(部分预处理器已支持编译到到CSS变量)。</p><p>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/getPropertyValue" target="_blank" rel="noopener"><code>getPropertyValue</code></a>方法来获取变量:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getComputedStyle(<span class="built_in">document</span>.documentElement).getPropertyValue(<span class="string">'--color'</span>)</span><br></pre></td></tr></table></figure><p>如果要获取具体元素的的变量值, 先通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector" target="_blank" rel="noopener"><code>querySelector</code></a>获取元素：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getComputedStyle(<span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>)).getPropertyValue(<span class="string">'--color'</span>)</span><br></pre></td></tr></table></figure><p>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/setProperty" target="_blank" rel="noopener"><code>style.setProperty</code></a>来设置变量值：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(<span class="string">'--color'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>设置具体元素的变量值:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>).style.setProperty(<span class="string">'--color'</span>, <span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure><p>这个API提供了一个简洁的方式来使用CSS变量.</p><p>几天前, 我通过<a href="https://twitter.com/DavidKPiano" target="_blank" rel="noopener">David K</a>的<a href="https://codepen.io/davidkpiano/pen/zWrRye" target="_blank" rel="noopener">XState DEMO</a>接触到了这个使用场景: 当用户鼠标拖拽时, 通过CSS变量来确定选择框的定位(基于鼠标的开始位置和当前位置):</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.selectbox</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(var(--mouse-x1));</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">calc</span>(var(--mouse-y1));</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>((var(--mouse-x2) - <span class="built_in">var</span>(--mouse-x1)));</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>((var(--mouse-y2) - <span class="built_in">var</span>(--mouse-y1)));</span><br><span class="line"></span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.5);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(0, 0, 0, 0.1);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid currentColor;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.3s</span> ease-in-out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在鼠标事件处理器中更新CSS变量：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(</span><br><span class="line">  <span class="string">'--mouse-x1'</span>,</span><br><span class="line">  ctx.selectArea.x1 + <span class="string">'px'</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(</span><br><span class="line">  <span class="string">'--mouse-y1'</span>,</span><br><span class="line">  ctx.selectArea.y1 + <span class="string">'px'</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(</span><br><span class="line">  <span class="string">'--mouse-x2'</span>,</span><br><span class="line">  ctx.selectArea.x2 + <span class="string">'px'</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(</span><br><span class="line">  <span class="string">'--mouse-y2'</span>,</span><br><span class="line">  ctx.selectArea.y2 + <span class="string">'px'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/images/css-variable/2.gif" alt></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你像我一样觉得CSS变量没有用，或者压根不知道它的存在，我希望这篇文章可以为你开启一扇门，来探索它的使用场景。</p><p>Javascript API让我踩了不少坑，但是它确实让我开了眼界，我期待未来能够更多使用和了解它们。</p><blockquote><p>译者注:<br><br>本文并非完全照搬原文，即意译. 另外女朋友也给我校验过了，确保大体没有搞错😂<br><br>因为笔者自己原创的文章阅读量比较惨淡，所以笔者近期会尝试翻译一些文章，学习这些文章是怎么写的，也积攒点人气，以便后面原创文章有更多阅读量</p></blockquote><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties" target="_blank" rel="noopener">使用CSS变量</a></li><li><a href="https://caniuse.com/#feat=css-variables" target="_blank" rel="noopener">Caniuse: CSS Variables (Custom Properties)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接: &lt;a href=&quot;https://dev.to/timdeschryver/don-t-miss-out-on-css-variables-4708&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Don’t miss out on css va
      
    
    </summary>
    
      <category term="前端,CSS" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF-CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] CodeSandbox 如何工作? 上篇</title>
    <link href="https://bobi.ink/2019/06/20/codesandbox/"/>
    <id>https://bobi.ink/2019/06/20/codesandbox/</id>
    <published>2019-06-19T16:00:00.000Z</published>
    <updated>2019-07-04T14:28:21.865Z</updated>
    
    <content type="html"><![CDATA[<p>这期来关注一下<a href="https://codesandbox.io" target="_blank" rel="noopener"><code>CodeSandbox</code></a>, 这是一个浏览器端的沙盒运行环境，支持多种流行的构建模板，例如 <code>create-react-app</code>、 <code>vue-cli</code>、<code>parcel</code>等等。 可以用于快速原型开发、DEMO 展示、Bug 还原等等.</p><p>相似的产品有很多，例如<a href="https://codepen.io/pen" target="_blank" rel="noopener"><code>codepen</code></a>、<a href="https://jsfiddle.net" target="_blank" rel="noopener"><code>JSFiddle</code></a>、<a href="https://webpackbin-prod.firebaseapp.com" target="_blank" rel="noopener"><code>WebpackBin</code></a>(已废弃).</p><p>CodeSandbox 则更加强大，可以视作是浏览器端的 Webpack 运行环境, 甚至在 V3 版本已经支持 VsCode 模式，支持 Vscode 的插件和 Vim 模式、还有主题.</p><p>另外 CodeSandbox 支持离线运行(PWA)。基本上可以接近本地 VSCode 的编程体验. 有 iPad 的同学，也可以尝试基于它来进行开发。所以快速的原型开发我一般会直接使用 CodeSandbox</p><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#引">引</a></li><li><a href="#基本目录结构">基本目录结构</a></li><li><a href="#项目构建过程">项目构建过程</a><ul><li><a href="#packager">Packager</a><ul><li><a href="#webpackdllplugin">WebpackDllPlugin</a></li><li><a href="#在线打包服务">在线打包服务</a></li><li><a href="#回退方案">回退方案</a></li></ul></li><li><a href="#transpilation">Transpilation</a><ul><li><a href="#基本对象">基本对象</a></li><li><a href="#manager">Manager</a></li><li><a href="#transpiledmodule">TranspiledModule</a></li><li><a href="#transpiler">Transpiler</a></li><li><a href="#babeltranspiler">BabelTranspiler</a></li></ul></li><li><a href="#evaluation">Evaluation</a></li></ul></li><li><a href="#技术地图">技术地图</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><center><br>  <img src="/images/08/codesandbox.png" width="800"><br></center><p><br></p><p>笔者对 CodeSandbox 的第一印象是这玩意是运行在服务器的吧？ 比如 <code>create-react-app</code> 要运行起来需要 node 环境，需要通过 npm 安装一大堆依赖，然后通过 Webpack 进行打包，最后运行一个开发服务器才能在浏览器跑起来.</p><p><strong>实际上 CodeSandbox 打包和运行并不依赖于服务器, 它是完全在浏览器进行的</strong>. 大概的结构如下:</p><center><br> <img src="/images/08/codesandbox-arch.png" width="600"><br></center><ul><li><strong>Editor</strong>: 编辑器。主要用于修改文件，CodeSandbox这里集成了 <code>VsCode</code>, 文件变动后会通知 <code>Sandbox</code> 进行转译. 计划会有文章专门介绍CodeSandbox的编辑器实现</li><li><strong>Sandbox</strong>: 代码运行器。<strong>Sandbox 在一个单独的 iframe 中运行, 负责代码的转译(Transpiler)和运行(Evalation)</strong>. 如最上面的图，左边是Editor，右边是Sandbox</li><li><strong>Packager</strong> 包管理器。类似于yarn和npm，负责拉取和缓存 npm 依赖</li></ul><p><br></p><p>CodeSandbox 的作者 <a href="https://twitter.com/CompuIves" target="_blank" rel="noopener">Ives van Hoorne</a> 也尝试过将 <code>Webpack</code> 移植到浏览器上运行，因为现在几乎所有的 CLI 都是使用 Webpack 进行构建的，如果能将 Webpack 移植到浏览器上, 可以利用 Webpack 强大的生态系统和转译机制(loader/plugin)，低成本兼容各种 CLI.</p><p>然而 Webpack 太重了😱，压缩过后的大小就得 3.5MB，这还算勉强可以接受吧；更大的问题是要在浏览器端模拟 Node 运行环境，这个成本太高了，得不偿失。</p><p>所以 CodeSandbox 决定自己造个打包器，这个打包器更轻量，并且针对 CodeSandbox 平台进行优化. 比如 CodeSandbox 只关心开发环境的代码构建, 目标就是能跑起来就行了, 跟 Webpack 相比裁剪掉了以下特性:</p><ul><li>生产模式. CodeSandbox 只考虑 development 模式，不需要考虑 production一些特性，比如<ul><li>代码压缩，优化</li><li>Tree-shaking</li><li>性能优化</li><li>代码分割</li></ul></li><li>文件输出. 不需要打包成chunk</li><li>服务器通信. Sandbox直接原地转译和运行, 而Webpack 需要和开发服务器建立一个长连接用于接收指令，例如 HMR.</li><li>静态文件处理(如图片). 这些图片需要上传到 CodeSandbox 的服务器</li><li>插件机制等等.</li></ul><p>所以可以认为<strong>CodeSandbox是一个简化版的Webpack, 且针对浏览器环境进行了优化，比如使用worker来进行并行转译</strong></p><p>CodeSandbox 的打包器使用了接近 <code>Webpack Loader</code> 的 API, 这样可以很容易地将 Webpack 的一些 loader 移植过来. 举个例子，下面是 <code>create-react-app</code> 的实现(查看<a href="https://github.com/codesandbox/codesandbox-client/blob/84972fd027fe36c53652c22f6775e1e6d3c51145/packages/app/src/sandbox/eval/presets/create-react-app/index.js#L1" target="_blank" rel="noopener">源码</a>):</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> stylesTranspiler <span class="keyword">from</span> <span class="string">"../../transpilers/style"</span>;</span><br><span class="line"><span class="keyword">import</span> babelTranspiler <span class="keyword">from</span> <span class="string">"../../transpilers/babe"</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> sassTranspiler <span class="keyword">from</span> <span class="string">"../../transpilers/sass"</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> preset = <span class="keyword">new</span> Preset(</span><br><span class="line">  <span class="string">"create-react-app"</span>,</span><br><span class="line">  [<span class="string">"web.js"</span>, <span class="string">"js"</span>, <span class="string">"json"</span>, <span class="string">"web.jsx"</span>, <span class="string">"jsx"</span>, <span class="string">"ts"</span>, <span class="string">"tsx"</span>],</span><br><span class="line">  &#123;</span><br><span class="line">    hasDotEnv: <span class="literal">true</span>,</span><br><span class="line">    setup: <span class="function"><span class="params">manager</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> babelOptions = &#123;</span><br><span class="line">        <span class="comment">/*..*/</span></span><br><span class="line">      &#125;;</span><br><span class="line">      preset.registerTranspiler(</span><br><span class="line">        <span class="built_in">module</span> =&gt;</span><br><span class="line">          /\.(t|j)sx?$/.test(<span class="built_in">module</span>.path) &amp;&amp; !<span class="built_in">module</span>.path.endsWith(<span class="string">".d.ts"</span>),</span><br><span class="line">        [</span><br><span class="line">          &#123;</span><br><span class="line">            transpiler: babelTranspiler,</span><br><span class="line">            options: babelOptions</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      );</span><br><span class="line">      preset.registerTranspiler(</span><br><span class="line">        <span class="built_in">module</span> =&gt; <span class="regexp">/\.svg$/</span>.test(<span class="built_in">module</span>.path),</span><br><span class="line">        [</span><br><span class="line">          &#123; <span class="attr">transpiler</span>: svgrTranspiler &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            transpiler: babelTranspiler,</span><br><span class="line">            options: babelOptions</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br></p><p>可以看出, CodeSandbox的Preset和Webpack的配置长的差不多. <strong>不过, 目前你只能使用 CodeSandbox 预定义的 Preset, 不支持像 Webpack 一样进行配置, 个人觉得这个是符合 CodeSandbox 定位的，这是一个快速的原型开发工具，你还折腾 Webpack 干嘛？</strong></p><p>目前支持这些Preset:</p><center><br> <img src="/images/08/presets.png" width="600"><br></center><p><br></p><hr><p><br></p><h2 id="基本目录结构"><a href="#基本目录结构" class="headerlink" title="基本目录结构"></a>基本目录结构</h2><p>CodeSandbox 的客户端是开源的，不然就没有本文了，它的基本目录结构如下:</p><ul><li><strong>packages</strong><ul><li><strong>app</strong> CodeSandbox应用<ul><li><strong>app</strong> 编辑器实现</li><li><strong>embed</strong> 网页内嵌运行 codesandbox</li><li><strong>sandbox</strong> 运行沙盒，在这里执行代码构建和预览，相当于一个缩略版的 Webpack. 运行在单独的 iframe 中<ul><li>eval<ul><li>preset<ul><li>create-react-app</li><li>parcel</li><li>vue-cli</li><li>…</li></ul></li><li>transpiler<ul><li>babel</li><li>sass</li><li>vue</li><li>…</li></ul></li></ul></li><li>compile.ts 编译器</li></ul></li></ul></li><li><strong>common</strong> 放置通用的组件、工具方法、资源</li><li><strong>codesandbox-api</strong>: 封装了统一的协议，用于 sandbox 和 editor 之间通信(基于postmessage)</li><li><strong>codesandbox-browserfs</strong>: 这是一个浏览器端的‘文件系统’，模拟了 NodeJS 的文件系统 API，支持在本地或从多个后端服务中存储或获取文件.</li><li><strong>react-sandpack</strong>: codesandbox公开的SDK，可以用于自定义自己的codesandbox</li></ul></li></ul><p><a href="https://github.com/codesandbox/codesandbox-client" target="_blank" rel="noopener">源码在这</a></p><p><br></p><hr><p><br></p><h2 id="项目构建过程"><a href="#项目构建过程" class="headerlink" title="项目构建过程"></a>项目构建过程</h2><p><code>packager -&gt; transpilation -&gt; evaluation</code></p><p>Sandbox 构建分为三个阶段:</p><ul><li><strong>Packager</strong> 包加载阶段，下载和处理所有npm模块依赖</li><li><strong>Transpilation</strong> 转译阶段，转译所有变动的代码, 构建模块依赖图</li><li><strong>Evaluation</strong> 执行阶段，使用 <code>eval</code> 运行模块代码进行预览</li></ul><p>下面会按照上述的步骤来描述其中的技术点</p><p><br><br><br></p><h3 id="packager"><a href="#packager" class="headerlink" title="Packager"></a>Packager</h3><p>尽管 npm 是个’黑洞’，我们还是离不开它。 其实大概分析一下前端项目的 <code>node_modules</code>，80%是各种开发依赖组成的. </p><p>由于 CodeSandbox 已经包揽了代码构建的部分，所以我们并不需要<code>devDependencies</code>, 也就是说 <strong>在CodeSandbox 中我们只需要安装所有实际代码运行需要的依赖，这可以减少成百上千的依赖下载. 所以暂且不用担心浏览器会扛不住</strong>.</p><p><br></p><h4 id="webpackdllplugin"><a href="#webpackdllplugin" class="headerlink" title="WebpackDllPlugin"></a>WebpackDllPlugin</h4><p>CodeSandbox 的依赖打包方式受 <code>WebpackDllPlugin</code> 启发，DllPlugin 会将所有依赖都打包到一个<code>dll</code>文件中，并创建一个 <code>manifest</code> 文件来描述dll的元数据(如下图).</p><p>Webpack 转译时或者 运行时可以根据 manifest 中的模块索引(例如<code>__webpack_require__(&#39;../node_modules/react/index.js&#39;)</code>)来加载 dll 中的模块。 因为<code>WebpackDllPlugin</code>是在运行或转译之前预先对依赖的进行转译，所以在项目代码转译阶段可以忽略掉这部分依赖代码，这样可以提高构建的速度(真实场景对npm依赖进行Dll打包提速效果并不大):</p><center><br>  <img src="/images/08/dll.png"><br></center><p>manifest文件</p><center><br>  <img src="/images/08/webpack-dll-manifest.png" width="500"><br></center><p><br></p><h4 id="在线打包服务"><a href="#在线打包服务" class="headerlink" title="在线打包服务"></a>在线打包服务</h4><p>基于这个思想, CodeSandbox 构建了自己的在线打包服务, 和WebpackDllPlugin不一样的是，CodeSandbox是在服务端预先构建Manifest文件的, 而且不区分Dll和manifest文件。 具体思路如下:</p><center><br> <img src="/images/08/packager1.png" width="800"><br></center><p>简而言之，CodeSandbox 客户端拿到<code>package.json</code>之后，将<code>dependencies</code>转换为一个由依赖和版本号组成的<code>Combination</code>(标识符, 例如 <a href="https://d1jyvh0kxilfa7.cloudfront.net/v1/combinations/babel-runtime@7.3.1%2Bcsbbust@1.0.0%2Breact@16.8.4%2Breact-dom@16.8.4%2Breact-router@5.0.1%2Breact-router-dom@5.0.1%2Breact-split-pane@0.1.87.json" target="_blank" rel="noopener"><code>v1/combinations/babel-runtime@7.3.1&amp;csbbust@1.0.0&amp;react@16.8.4&amp;react-dom@16.8.4&amp;react-router@5.0.1&amp;react-router-dom@5.0.1&amp;react-split-pane@0.1.87.json</code></a>), 再拿这个 Combination 到服务器请求。服务器会根据 Combination 作为缓存键来缓存打包结果，如果没有命中缓存，则进行打包.</p><p><strong>打包实际上还是使用<code>yarn</code>来下载所有依赖，只不过这里为了剔除 npm 模块中多余的文件，服务端还遍历了所有依赖的入口文件(package.json#main), 解析 AST 中的 require 语句，递归解析被 require 模块. 最终形成一个依赖图, 只保留必要的文件</strong>. </p><p>最终输出 Manifest 文件，它的结构大概如下, 他就相当于WebpackDllPlugin的dll.js+manifest.json的结合体:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 模块内容</span></span><br><span class="line">  <span class="string">"contents"</span>: &#123;</span><br><span class="line">    <span class="string">"/node_modules/react/index.js"</span>: &#123;</span><br><span class="line">      <span class="string">"content"</span>: <span class="string">"'use strict';↵↵if ...."</span>, <span class="comment">// 代码内容</span></span><br><span class="line">      <span class="string">"requires"</span>: [                        <span class="comment">// 依赖的其他模块</span></span><br><span class="line">        <span class="string">"./cjs/react.development.js"</span>,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"/node_modules/react-dom/index.js"</span>: &#123;<span class="comment">/*..*/</span>&#125;,</span><br><span class="line">    <span class="string">"/node_modules/react/package.json"</span>: &#123;<span class="comment">/*...*/</span>&#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 模块具体安装版本号</span></span><br><span class="line">  <span class="string">"dependencies"</span>: [&#123;<span class="attr">name</span>: <span class="string">"@babel/runtime"</span>, <span class="attr">version</span>: <span class="string">"7.3.1"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"csbbust"</span>, <span class="attr">version</span>: <span class="string">"1.0.0"</span>&#125;,<span class="comment">/*…*/</span>],</span><br><span class="line">  <span class="comment">// 模块别名, 比如将react作为preact-compat的别名</span></span><br><span class="line">  <span class="string">"dependencyAliases"</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 依赖的依赖, 即间接依赖信息. 这些信息可以从yarn.lock获取</span></span><br><span class="line">  <span class="string">"dependencyDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"object-assign"</span>: &#123;</span><br><span class="line">      <span class="string">"entries"</span>: [<span class="string">"object-assign"</span>], <span class="comment">// 模块入口</span></span><br><span class="line">      <span class="string">"parents"</span>: [<span class="string">"react"</span>, <span class="string">"prop-types"</span>, <span class="string">"scheduler"</span>, <span class="string">"react-dom"</span>], <span class="comment">// 父模块</span></span><br><span class="line">      <span class="string">"resolved"</span>: <span class="string">"4.1.1"</span>,</span><br><span class="line">      <span class="string">"semver"</span>: <span class="string">"^4.1.1"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p><strong>Serverless 思想</strong><br><br><br>值得一提的是 CodeSandbox 的 Packager 后端使用了 Serverless(基于 AWS Lambda)，基于 Serverless 的架构让 Packager 服务更具伸缩性，可以灵活地应付高并发的场景。使用 Serverless 之后 Packager 的响应时间显著提高，而且费用也下去了。</p></blockquote><blockquote><p>Packager 也是开源的, <a href="https://github.com/codesandbox/dependency-packager" target="_blank" rel="noopener">围观</a></p></blockquote><p><br></p><h4 id="回退方案"><a href="#回退方案" class="headerlink" title="回退方案"></a>回退方案</h4><p>AWS Lambda函数是有局限性的, 比如<code>/tmp</code>最多只能有 500MB 的空间. 尽管大部分依赖打包场景不会超过这个限额, 为了增强可靠性(比如上述的方案可能出错，也可能漏掉一些模块), Packager还有回退方案.</p><p>后来CodeSanbox作者开发了新的Sandbox，支持把包管理的步骤放置到浏览器端, 和上面的打包方式结合着使用。原理也比较简单: <strong>在转译一个模块时，如果发现模块依赖的npm模块未找到，则惰性从远程下载回来</strong>. 来看看它是怎么处理的:</p><center><br> <img src="/images/08/packager2.png"><br></center><p>在回退方案中CodeSandbox 并不会将 package.json 中所有的包都下载下来，而是在模块查找失败时，惰性的去加载。比如在转译入口文件时，发现 react 这个模块没有在本地缓存模块队列中，这时候就会到远程将它下载回来，然后接着转译。</p><p>也就是说，因为在转译阶段会静态分析模块的依赖，只需要将真正依赖的文件下载回来，而不需要将整个npm包下载回来，节省了网络传输的成本.</p><p>CodeSandbox 通过 <code>unpkg.com</code> 或 <code>cdn.jsdelivr.net</code> 来获取模块的信息以及下载文件, 例如</p><ul><li>获取 package.json: <code>https://unpkg.com/react@latest/package.json</code></li><li>包目录结构获取: <code>https://unpkg.com/antd@3.17.0/?meta</code> 这个会递归返回该包的所有目录信息</li><li>具体文件下载: <code>https://unpkg.com/react@16.8.6/cjs/react.production.min.js</code> 或者 <code>https://cdn.jsdelivr.net/npm/@babel/runtime@7.3.1/helpers/interopRequireDefault.js</code></li></ul><p><br></p><hr><p><br></p><h3 id="transpilation"><a href="#transpilation" class="headerlink" title="Transpilation"></a>Transpilation</h3><p>讲完 Packager 现在来看一下 Transpilation, 这个阶段<strong>从应用的入口文件开始, 对源代码进行转译, 解析AST，找出下级依赖模块，然后递归转译，最终形成一个’依赖图’</strong>:</p><center><br>  <img src="/images/08/transpile-dependency-graph.png"><br></center><p>CodeSandbox 的整个转译器是在一个单独的 iframe 中运行的：</p><center><br>  <img src="/images/08/editor-vs-compiler.png"><br></center><p>Editor 负责变更源代码，源代码变更会通过 postmessage 传递给 Compiler，这里面会携带 <code>Module+template</code></p><ul><li><strong>Module</strong> 中包含所有源代码内容和模块路径，其中还包含 package.json, Compiler 会根据 package.json 来读取 npm 依赖;</li><li><strong>template</strong> 表示 Compiler 的 Preset，例如<code>create-react-app</code>、<code>vue-cli</code>, 定义了一些 loader 规则，用来转译不同类型的文件, 另外preset也决定了应用的模板和入口文件。 通过上文我们知道, 这些 template 目前的预定义的.</li></ul><p><br></p><h4 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h4><p>在详细介绍 Transpilation 之前先大概看一些基本对象，了解这些对象之间的关系：</p><center><br> <img src="/images/08/baseobj.png"><br></center><ul><li><strong>Manager</strong> 这是 Sandbox 的核心对象，负责管理配置信息(Preset)、项目依赖(Manifest)、以及维护项目所有模块(TranspilerModule)</li><li><strong>Manifest</strong> 通过上文的 Packager 我们知道，Manifest 维护所有依赖的 npm 模块信息</li><li><strong>TranspiledModule</strong> 表示模块本身。这里面维护转译的结果、代码执行的结果、依赖的模块信息，负责驱动具体模块的转译(调用 Transpiler)和执行</li><li><strong>Preset</strong> 一个项目构建模板，例如 <code>vue-cli</code>、<code>create-react-app</code>. 配置了项目文件的转译规则, 以及应用的目录结构(入口文件)</li><li><strong>Transpiler</strong> 等价于 Webpack 的 loader，负责对指定类型的文件进行转译。例如 babel、typescript、pug、sass 等等</li><li><strong>WorkerTranspiler</strong> 这是 Transpiler 的子类，调度一个 Worker池来执行转译任务，从而提高转译的性能</li></ul><p><br></p><h4 id="manager"><a href="#manager" class="headerlink" title="Manager"></a>Manager</h4><p>Manager是一个管理者的角色，从大局上把控整个转译和执行的流程. 现在来看看整体的转译流程：</p><center><br> <img src="/images/08/compiler.png"><br></center><p>大局上基本上可以划分为以下四个阶段:</p><ul><li><strong>配置阶段</strong>：配置阶段会创建 Preset 对象，确定入口文件等等. CodeSandbox 目前只支持限定的几种应用模板，例如 vue-cli、create-react-app。不同模板之间目录结构的约定是不一样的，例如入口文件和 html 模板文件。另外文件处理的规则也不一样，比如 vue-cli 需要处理<code>.vue</code>文件。</li><li><strong>依赖下载阶段</strong>： 即 Packager 阶段，下载项目的所有依赖，生成 Manifest 对象</li><li><strong>变动计算阶段</strong>：根据 Editor 传递过来的源代码，计算新增、更新、移除的模块。</li><li><strong>转译阶段</strong>：真正开始转译了，首先重新转译上个阶段计算出来的需要更新的模块。接着从入口文件作为出发点，转译和构建新的依赖图。这里不会重复转译没有变化的模块以及其子模块</li></ul><p><br><br><br></p><h4 id="transpiledmodule"><a href="#transpiledmodule" class="headerlink" title="TranspiledModule"></a>TranspiledModule</h4><p>TranspiledModule用于管理某个具体的模块，这里面会维护转译和运行的结果、模块的依赖信息，并驱动模块的转译和执行：</p><center><br> <img src="/images/08/transpiled-module.png"><br></center><p>TranspiledModule 会从Preset中获取匹配当前模块的Transpiler列表的，遍历Transpiler对源代码进行转译，转译的过程中会解析AST，分析模块导入语句, 收集新的依赖; 当模块转译完成后，会递归转译依赖列表。 来看看大概的代码：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> transpile(manager: Manager) &#123;</span><br><span class="line">  <span class="comment">// 已转译</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.source)  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 避免重复转译, 一个模块只转译一次</span></span><br><span class="line">  <span class="keyword">if</span> (manager.transpileJobs[<span class="keyword">this</span>.getId()]) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  manager.transpileJobs[<span class="keyword">this</span>.getId()] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...重置状态 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴从Preset获取Transpiler列表</span></span><br><span class="line">  <span class="keyword">const</span> transpilers = manager.preset.getLoaders(<span class="keyword">this</span>.module, <span class="keyword">this</span>.query);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 链式调用Transpiler</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; transpilers.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> transpilerConfig = transpilers[i];</span><br><span class="line">    <span class="comment">// 🔴构建LoaderContext，见下文</span></span><br><span class="line">    <span class="keyword">const</span> loaderContext = <span class="keyword">this</span>.getLoaderContext(</span><br><span class="line">      manager,</span><br><span class="line">      transpilerConfig.options || &#123;&#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔴调用Transpiler转译源代码</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      transpiledCode,</span><br><span class="line">      sourceMap,</span><br><span class="line">    &#125; = <span class="keyword">await</span> transpilerConfig.transpiler.transpile(code, loaderContext); <span class="comment">// eslint-disable-line no-await-in-loop</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.errors.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">this</span>.errors[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.logWarnings();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    <span class="keyword">this</span>.asyncDependencies.map(<span class="keyword">async</span> p =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> tModule = <span class="keyword">await</span> p;</span><br><span class="line">        <span class="keyword">this</span>.dependencies.add(tModule);</span><br><span class="line">        tModule.initiators.add(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">/* let this handle at evaluation */</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">this</span>.asyncDependencies = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴递归转译依赖的模块</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    flattenDeep([</span><br><span class="line">      ...Array.from(<span class="keyword">this</span>.transpilationInitiators).map(<span class="function"><span class="params">t</span> =&gt;</span></span><br><span class="line">        t.transpile(manager)</span><br><span class="line">      ),</span><br><span class="line">      ...Array.from(<span class="keyword">this</span>.dependencies).map(<span class="function"><span class="params">t</span> =&gt;</span> t.transpile(manager)),</span><br><span class="line">    ])</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="transpiler"><a href="#transpiler" class="headerlink" title="Transpiler"></a>Transpiler</h4><p>Transpiler等价于webpack的loader，它配置方式以及基本API也和webpack(查看<a href="https://webpack.docschina.org/api/loaders/" target="_blank" rel="noopener">webpack的loader API</a>)大概保持一致，比如链式转译和loader-context. 来看一下Transpiler的基本定义：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Transpiler &#123;</span><br><span class="line">  initialize() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  dispose() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  cleanModule(loaderContext: LoaderContext) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 代码转换</span></span><br><span class="line">  transpile(</span><br><span class="line">    code: <span class="built_in">string</span>,</span><br><span class="line">    loaderContext: LoaderContext</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;TranspilerResult&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doTranspilation(code, loaderContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 抽象方法，由具体子类实现</span></span><br><span class="line">  <span class="keyword">abstract</span> doTranspilation(</span><br><span class="line">    code: <span class="built_in">string</span>,</span><br><span class="line">    loaderContext: LoaderContext</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;TranspilerResult&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Transpiler的接口很简单，<code>transpile</code>接受两个参数: </p><ul><li><code>code</code>即源代码.</li><li><p><code>loaderContext</code> 由TranspiledModule提供, 可以用来访问一下转译上下文信息，比如Transpiler的配置、 模块查找、注册依赖等等。大概外形如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> LoaderContext = &#123;</span><br><span class="line">  <span class="comment">// 🔴 信息报告</span></span><br><span class="line">  emitWarning: <span class="function">(<span class="params">warning: WarningStructure</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  emitError: <span class="function">(<span class="params">error: <span class="built_in">Error</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  emitModule: <span class="function">(<span class="params">title: <span class="built_in">string</span>, code: <span class="built_in">string</span>, currentPath?: <span class="built_in">string</span>, overwrite?: <span class="built_in">boolean</span>, isChild?: <span class="built_in">boolean</span></span>) =&gt;</span> TranspiledModule;</span><br><span class="line">  emitFile: <span class="function">(<span class="params">name: <span class="built_in">string</span>, content: <span class="built_in">string</span>, sourceMap: SourceMap</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 🔴 配置信息</span></span><br><span class="line">  options: &#123;</span><br><span class="line">    context: <span class="built_in">string</span>;</span><br><span class="line">    config?: object;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  sourceMap: <span class="built_in">boolean</span>;</span><br><span class="line">  target: <span class="built_in">string</span>;</span><br><span class="line">  path: <span class="built_in">string</span>;</span><br><span class="line">  addTranspilationDependency: <span class="function">(<span class="params">depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; isEntry?: <span class="built_in">boolean</span>; &#125;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  resolveTranspiledModule: <span class="function">(<span class="params"> depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; ignoredExtensions?: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;; &#125;</span>) =&gt;</span> TranspiledModule;</span><br><span class="line">  resolveTranspiledModuleAsync: <span class="function">(<span class="params"> depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; ignoredExtensions?: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;; &#125;</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;TranspiledModule&gt;;</span><br><span class="line">   <span class="comment">// 🔴 依赖收集</span></span><br><span class="line">  addDependency: <span class="function">(<span class="params"> depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; isEntry?: <span class="built_in">boolean</span>; &#125;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  addDependenciesInDirectory: <span class="function">(<span class="params"> depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; isEntry?: <span class="built_in">boolean</span>; &#125;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  _module: TranspiledModule;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><p>先从简单的开始，来看看JSON模块的Transpiler实现, 每个Transpiler子类需要实现doTranspilation，接收源代码，并异步返回处理结果：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> JSONTranspiler <span class="keyword">extends</span> Transpiler &#123;</span><br><span class="line">  doTranspilation(code: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">      module.exports = JSON.parse(<span class="subst">$&#123;JSON.stringify(code || '')&#125;</span>)</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">      transpiledCode: result,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="babeltranspiler"><a href="#babeltranspiler" class="headerlink" title="BabelTranspiler"></a>BabelTranspiler</h4><p>并不是所有模块都像JSON这么简单，比如Typescript和Babel。 为了提高转译的效率，Codesandbox会利用Worker来进行多进程转译，多Worker的调度工作由<code>WorkerTranspiler</code>完成，这是Transpiler的子类，维护了一个Worker池。Babel、Typescript、Sass这类复杂的转译任务都是基于WorkerTranspiler实现的：</p><center><br> <img src="/images/08/transpiler.png"><br></center><p><br></p><p>其中比较典型的实现是BabelTranspiler, 在Sandbox启动时就会预先fork三个worker，来提高转译启动的速度, BabelTranspiler会优先使用这三个worker来初始化Worker池：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用worker-loader fork三个loader，用于处理babel编译</span></span><br><span class="line"><span class="keyword">import</span> BabelWorker <span class="keyword">from</span> <span class="string">'worker-loader?publicPath=/&amp;name=babel-transpiler.[hash:8].worker.js!./eval/transpilers/babel/worker/index.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.babelworkers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">window</span>.babelworkers.push(<span class="keyword">new</span> BabelWorker());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>这里面使用到了webpack的<a href="https://github.com/webpack-contrib/worker-loader" target="_blank" rel="noopener">worker-loader</a>, 将指定模块封装为 Worker 对象。让 Worker 更容易使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> Worker <span class="keyword">from</span> <span class="string">"./file.worker.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">worker.postMessage(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">worker.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>BabelTranpiler具体的流程如下:</p><center><br><img src="/images/08/babel-transpiler.png"><br></center><p>WorkerTranspiler会维护<code>空闲的Worker队列</code>和一个<code>任务队列</code>, 它的工作就是驱动Worker来消费任务队列。具体的转译工作在Worker中进行：</p><center><br><img src="/images/08/babel-worker.png"><br></center><p><br></p><hr><p><br></p><h3 id="evaluation"><a href="#evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>虽然称为打包器(bundler), 但是 CodeSandbox 并不会进行打包，也就是说他不会像 Webpack 一样，将所有的模块都打包合并成 chunks 文件.</p><p><code>Transpilation</code>从<code>入口文件</code>开始转译, 再分析文件的模块导入规则，递归转译依赖的模块. 到<code>Evaluation</code>阶段，CodeSandbox 已经构建出了一个完整的<strong>依赖图</strong>. 现在要把应用跑起来了🏃</p><p><img src="/images/08/dependency-graph.png" alt></p><p>Evaluation 的原理也比较简单，和 Transpilation 一样，也是从入口文件开始: <strong>使用<code>eval</code>执行入口文件，如果执行过程中调用了<code>require</code>，则递归 eval 被依赖的模块</strong>。</p><p>如果你了解过 Node 的模块导入原理，你可以很容易理解这个过程：</p><p><img src="/images/08/evaluation.png" alt></p><ul><li>① 首先要初始化 html，找到<code>index.html</code>文件，将 document.body.innerHTML 设置为 html 模板的 body 内容.</li><li>② 注入外部资源。用户可以自定义一些外部静态文件，例如 css 和 js，这些需要 append 到 head 中</li><li>③ evaluate 入口模块</li><li><p>④ 所有模块都会被转译成 CommonJS 模块规范。所以需要模拟这个模块环境。大概看一下代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现require方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... 拦截一些特殊模块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Manager对象中查找模块</span></span><br><span class="line">  <span class="keyword">const</span> requiredTranspiledModule = manager.resolveTranspiledModule(</span><br><span class="line">    path,</span><br><span class="line">    localModule.path</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块缓存, 如果存在缓存则说明不需要重新执行</span></span><br><span class="line">  <span class="keyword">const</span> cache = requiredTranspiledModule.compilation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache</span><br><span class="line">    ? cache.exports</span><br><span class="line">    : <span class="comment">// 🔴递归evaluate</span></span><br><span class="line">      manager.evaluateTranspiledModule(</span><br><span class="line">        requiredTranspiledModule,</span><br><span class="line">        transpiledModule</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现require.resolve</span></span><br><span class="line"><span class="built_in">require</span>.resolve = <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> manager.resolveModule(path, localModule.path).path;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一些全局变量</span></span><br><span class="line"><span class="keyword">const</span> globals = &#123;&#125;;</span><br><span class="line">globals.__dirname = pathUtils.dirname(<span class="keyword">this</span>.module.path);</span><br><span class="line">globals.__filename = <span class="keyword">this</span>.module.path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴放置执行结果，即CommonJS的module对象</span></span><br><span class="line"><span class="keyword">this</span>.compilation = &#123;</span><br><span class="line">  id: <span class="keyword">this</span>.getId(),</span><br><span class="line">  exports: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴eval</span></span><br><span class="line"><span class="keyword">const</span> exports = evaluate(</span><br><span class="line">  <span class="keyword">this</span>.source.compiledCode,</span><br><span class="line">  <span class="built_in">require</span>,</span><br><span class="line">  <span class="keyword">this</span>.compilation,</span><br><span class="line">  manager.envVariables,</span><br><span class="line">  globals</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>⑤ 使用 eval 来执行模块。同样看看代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">code, require, module, env = &#123;&#125;, globals = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> exports = <span class="built_in">module</span>.exports;</span><br><span class="line">  <span class="keyword">const</span> global = g;</span><br><span class="line">  <span class="keyword">const</span> process = buildProcess(env);</span><br><span class="line">  g.global = global;</span><br><span class="line">  <span class="keyword">const</span> allGlobals = &#123;</span><br><span class="line">    <span class="built_in">require</span>,</span><br><span class="line">    <span class="built_in">module</span>,</span><br><span class="line">    exports,</span><br><span class="line">    process,</span><br><span class="line">    setImmediate: requestFrame,</span><br><span class="line">    global,</span><br><span class="line">    ...globals</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allGlobalKeys = <span class="built_in">Object</span>.keys(allGlobals);</span><br><span class="line">  <span class="keyword">const</span> globalsCode = allGlobalKeys.length ? allGlobalKeys.join(<span class="string">", "</span>) : <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">const</span> globalsValues = allGlobalKeys.map(<span class="function"><span class="params">k</span> =&gt;</span> allGlobals[k]);</span><br><span class="line">  <span class="comment">// 🔴将代码封装到一个函数下面，全局变量以函数形式传入</span></span><br><span class="line">  <span class="keyword">const</span> newCode = <span class="string">`(function evaluate(`</span> + globalsCode + <span class="string">`) &#123;`</span> + code + <span class="string">`\n&#125;)`</span>;</span><br><span class="line">  (<span class="number">0</span>, <span class="built_in">eval</span>)(newCode).apply(<span class="keyword">this</span>, globalsValues);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Ok！到这里 Evaluation 就解释完了，实际的代码比这里要复杂得多，比如 HMR(hot module replacement)支持, 有兴趣的读者，可以自己去看 CodeSandbox 的源码.</p><p><br></p><hr><p><br></p><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><p>一不小心又写了一篇长文，要把这么复杂代码讲清楚真是一个挑战, 我还做的不够好，按照以往的经验，这又是一篇无人问津的文章, 别说是你们, 我自己都不怎么有耐心看这类文章, 后面还是尽量避免吧!</p><ul><li>worker-loader: 将指定模块封装为Worker</li><li>babel: JavaScript代码转译，支持ES, Flow, Typescript</li><li>browserfs: 在浏览器中模拟Node环境</li><li>localForage: 客户端存储库，优先使用(IndexedDB or WebSQL)这些异步存储方案，提供类LocalStorage的接口</li><li>lru-cache: least-recently-used缓存</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://hackernoon.com/how-i-created-a-parallel-offline-extensible-browser-based-bundler-886db508cc31" target="_blank" rel="noopener">Creating a parallel, offline, extensible, browser based bundler for CodeSandbox</a></li><li><a href="https://www.youtube.com/watch?v=qURPenhndYA" target="_blank" rel="noopener">year of CodeSandbox - Ives van Hoorne aka @CompuIves at @ReactEurope 2018</a></li><li><a href="https://hackernoon.com/how-we-make-npm-packages-work-in-the-browser-announcing-the-new-packager-6ce16aa4cee6" target="_blank" rel="noopener">How we make npm packages work in the browser</a></li><li><a href="https://github.com/codesandbox/dependency-packager" target="_blank" rel="noopener">codesandbox/dependency-packager</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这期来关注一下&lt;a href=&quot;https://codesandbox.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;CodeSandbox&lt;/code&gt;&lt;/a&gt;, 这是一个浏览器端的沙盒运行环境，支持多种流行的构建模板，例如 &lt;code
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React性能测量和分析</title>
    <link href="https://bobi.ink/2019/06/16/react-performance-analyze/"/>
    <id>https://bobi.ink/2019/06/16/react-performance-analyze/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T23:00:08.422Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">文章</a>讲了 React 性能优化的一些方向和手段，这篇文章再补充说一下如何进行性能测量和分析, 介绍 React 性能分析的一些工具和方法.</p><p>进行任何性能优化的前提是你要找出’性能问题‘，这样才能针对性地进行优化。我觉得对于 React 的性能优化可以分两个阶段:</p><ul><li><p><strong>1. 分析阶段</strong></p><ul><li>通过分析器(Profiler)找出重新渲染的组件、重新渲染的次数、以及重新渲染耗费的资源与时间</li><li>变动检测. 通过分析器我们可以知道’什么被重新渲染, 重新渲染的代价’，那么变动检测回答的问题就是： ’为什么这些进行了重新渲染?’</li></ul></li><li><p><strong>2. 优化阶段</strong>. 优化阶段我们针对分析阶段抛出的问题进行解决，解决的方法有很多，可以参考本文的姊妹篇&lt;<a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">浅谈React性能优化的方向</a>&gt;</p></li></ul><p><br></p><p><strong>本文大纲</strong></p><!-- TOC --><ul><li><a href="#分析器">分析器</a><ul><li><a href="#react-devtool">React Devtool</a><ul><li><a href="#高亮更新">高亮更新</a></li><li><a href="#分析器-1">分析器</a></li></ul></li><li><a href="#chrome-performance-工具">Chrome Performance 工具</a></li><li><a href="#其他工具">其他工具</a></li></ul></li><li><a href="#变动检测">变动检测</a><ul><li><a href="#props-变动检测">props 变动检测</a></li><li><a href="#mobx-变动检测">mobx 变动检测</a></li><li><a href="#context-变更检测">Context 变更检测</a></li><li><a href="#react-devtool-的-interactions">React Devtool 的 Interactions</a></li></ul></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><p>下面本文测试的样板代码.</p><blockquote><p>推荐点击 Preview 面板的<code>Open In New Window</code>, 或者直接点击该<a href="https://igz9h.codesandbox.io/" target="_blank" rel="noopener">链接</a>，在线动手实践</p></blockquote><iframe src="https://codesandbox.io/embed/react-performance-analyze-demo-igz9h?autoresize=1&fontsize=14" title="React-Performance-Analyze-Demo" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p><a href="https://codesandbox.io/s/react-performance-analyze-demo-igz9h?fontsize=14" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit React-Performance-Analyze-Demo"></a></p><p><br><br><br></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>分析哪些组件进行了渲染，以及渲染消耗的时间以及资源。主要工具有 React 官方的开发者工具以及 Chrome 的 Performance 工具。</p><h3 id="react-devtool"><a href="#react-devtool" class="headerlink" title="React Devtool"></a>React Devtool</h3><p>最先应该使用的肯定是官方提供的开发者工具，React v16.5 引入了新的 Profiler 功能，让分析组件渲染过程变得更加简单，而且可以很直观地查看哪些组件被渲染.</p><h4 id="高亮更新"><a href="#高亮更新" class="headerlink" title="高亮更新"></a>高亮更新</h4><p><strong>首先最简单也是最方便的判断组件是否被重新渲染的方式是’高亮更新(Hightlight Updates)’</strong>.</p><p>① 开启高亮更新:</p><center><br> <img src="/images/10/hightlight-update.png"><br></center><p>② 运行效果如下:</p><center><br>  <img src="/images/10/hightlight-update.gif"><br></center><p>③ 通过高亮更新，基本上可以确定哪些组件被重新渲染. 所以现在我们给 ListItem 加上 React.memo(查看 PureList 示例), 看一下效果:</p><center><br> <img src="/images/10/hightlight-update-pure.gif"><br></center><p>效果非常明显，现在只有递增的 ListItem 会被更新，而且当数组排序时只有 List 组件会被刷新. 所以说‘纯组件’是 React 优化的第一张牌, 也是最有效的一张牌.</p><p><br><br><br></p><h4 id="分析器-1"><a href="#分析器-1" class="headerlink" title="分析器"></a>分析器</h4><p>如果<code>高亮更新</code>无法满足你的需求，比如<strong>你需要知道具体哪些组件被渲染、渲染消耗多少时间、进行了多少次的提交(渲染)等等</strong>, 这时候就需要用到分析器了.</p><p>① 首先选择需要收集测量信息的节点(一般默认选中根节点，有一些应用可能存在多个组件树，这时候需要手动选择):</p><center><br> <img src="/images/10/select-profile.png"><br></center><p>② Ok，点击 Record 开始测量</p><center><br> <img src="/images/10/start-record.gif"><br></center><p><br></p><p>③ 看看测量的结果，先来了解一下 Profiler 面板的基本结构:</p><center><br> <img src="/images/10/profile-outline.png"><br></center><ul><li><p><strong>1️⃣ 这是一个 commit 列表</strong>。commit 列表表示录制期间发生的 commit(可以认为是渲染) 操作，要理解 commit 的意思还需要了解 React 渲染的基本原理.</p><p>在 v16 后 React 组件渲染会分为两个阶段，即 render 和 commit 阶段。</p><ul><li><strong>render 阶段决定需要进行哪些变更，比如 DOM</strong>。顾名思义, 这个阶段 React 会调用 render 函数，并将结果和上一次 render 的结果进行 diff, 计算出需要进行变更的操作队列</li><li><strong>commit 阶段</strong>。或者称为提交阶段, 在这个阶段会执行 render 阶段 diff 出来的变更请求。比如 DOM 插入、更新、删除、排序等等。在这个阶段 React 还会调用 componentDidMount 和 componentDidUpdate 生命周期函数.</li></ul><p>在 v16 之前，或者在 Preact 这些’类 React’ 框架中，并不区分 render 阶段和 commit 阶段，也就说这两个阶段糅合在一起，一边 diff 一边 commit。有兴趣的读者可以看笔者之前写的<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">从 Preact 中了解组件和 hooks 基本原理</a><br><br></p><p>切换 commit:</p><p><img src="/images/10/profile-commit.gif" alt><br><br></p></li><li><p><strong>2️⃣ 选择其他图形展示形式</strong>，例如 <code>Ranked 视图</code>，这个视图按照渲染消耗时间对组件进行排序：</p><p><img src="/images/10/ranked.png" alt></p><p><br></p></li><li><p><strong>3️⃣ 火焰图</strong> 这个图其实就是<strong>组件树</strong>，Profiler 使用颜色来标记哪些组件被重新渲染。<strong>和 commit 列表以及 Ranked 图一样，颜色在这里是有意义的，比如灰色表示没有重新渲染；从渲染消耗的时间上看的话: <code>黑色 &gt; 黄色 &gt; 蓝色</code>, 通过 👆Ranked 图可以直观感受到不同颜色之间的意义</strong></p><p><img src="/images/10/profile-framegraph.gif" alt></p><p><br></p></li><li><p><strong>4️⃣ 当前选中组件或者 Commit 的详情</strong>, 可以查看该组件渲染时的 props 和 state</p><p><img src="/images/10/profile-props.gif" alt></p><p>双击具体组件可以详细比对每一次 commit 消耗的时间:</p><p><img src="/images/10/profile-component-detail.png" alt></p><p><br></p></li><li><p><strong>5️⃣ 设置</strong></p><p>另外可以通过设置，筛选 Commit，以及是否显示原生元素:</p><p><img src="/images/10/profile-settings.png" alt></p></li></ul><p><br></p><p>④ 现在使用 Profiler 来分析一下 PureList 的渲染过程:</p><p><img src="/images/10/profile-demo.png" alt></p><p><br></p><blockquote><p>关于 Profiler 的详细介绍可以看这篇官方博客&lt;<a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">Introducing the React Profiler</a>&gt;</p></blockquote><p><br><br><br></p><h3 id="chrome-performance-工具"><a href="#chrome-performance-工具" class="headerlink" title="Chrome Performance 工具"></a>Chrome Performance 工具</h3><p>在 v16.5 之前，我们一般都是利用 Chrome 自带的 Performance 来进行 React 性能测量:</p><p><img src="/images/10/chrome-performance.png" alt></p><p><br></p><p>React 使用标准的<code>User Timing API</code>(所有支持该标准的浏览器都可以用来分析 React)来记录操作，所以我们在 Timings 标签中查看 React 的渲染过程。React 还特意使用 emoji 标记.</p><p>相对 React Devtool 而言 Performance 工具可能还不够直观，但是它非常强大，举个例子，<strong>如果说 React-Devtool 是<a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a>, 那么 Performance 就是<a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a>. 使用 Performance 可以用来定位一些比较深层次的问题，这可能需要你对 React 的实现原理有一定了解, 就像使用 Wireshark 你需要懂点网络协议一样</strong></p><p>所以说使用 Performance 工具有以下优势:</p><ul><li>可以测量分析整个渲染的过程细节. 它可以定位某些具体方法的调用过程和消耗, 方便定位一些深层次问题.</li><li>可以测量分析底层 DOM 的绘制、布局、合成等细节。方便定位浏览器性能问题</li></ul><p>其实 Performance 是一个通用的性能检测工具，所以其细节不在本文讨论访问。 详细参考</p><ul><li><a href="https://calibreapp.com/blog/react-performance-profiling-optimization/" target="_blank" rel="noopener">Profiling React performance with React 16 and Chrome Devtools</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Chrome 官方的 Performance 使用文档</a></li></ul><p><br></p><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><p>上面介绍的这些工具基本上已经够用了。社区上还有一些比较流行的工具，不过这些工具迟早/已经要被官方取代(招安)，而且它们也跟不上 React 的更新。</p><ul><li><a href="https://reactjs.org/docs/perf.html" target="_blank" rel="noopener">react-addons-perf</a> React v16 不支持了，不说了。老版本可用</li><li><a href="https://github.com/nitin42/react-perf-devtool" target="_blank" rel="noopener">react-perf-devtool</a> 也不活跃了，不推荐使用</li></ul><p><br></p><hr><p><br></p><h2 id="变动检测"><a href="#变动检测" class="headerlink" title="变动检测"></a>变动检测</h2><p>OK, 我们通过分析工具已经知道我们的应用存在哪些问题了，诊断出了哪些组件被无意义的渲染。下一步操作就是找出组件重新渲染的元凶, 检测为什么组件进行了更新.</p><p><strong>我们先假设我们的组件是一个’纯组件‘，也就是说我们认为只有组件依赖的状态变更时，组件才会重新渲染</strong>. 非纯组件没有讨论的意义，因为只要状态变更或父级变更他都会重新渲染。</p><p><strong>那么对于一个’纯组件‘来说，一般会有下面这些因素都可能导致组件重新渲染</strong>:</p><ul><li><strong>props + state</strong> 毫无疑问. 这里我们只需要关注<strong>来源于外部的 props</strong>. 内部 state 变动一般是人为触发的，比较容易发现</li><li><strong>Mobx observable value</strong>. 如果访问了 mobx 传进来的响应式数据，就会建立一个状态依赖关系，这个相对于 props 和 context 来说是隐式的，检测它的变动我们可能需要利用 mobx 提供的一些工具</li><li><strong>Context</strong>。 Context 的 value 的变更会强制重新渲染组件</li></ul><p><br></p><h3 id="props-变动检测"><a href="#props-变动检测" class="headerlink" title="props 变动检测"></a>props 变动检测</h3><p>在上一篇文章中我就建议简化 props，简单组件的 props 的变更很容易预测, 甚至你肉眼都可以察觉出来。另外如果你使用 Redux，如果严格按照 Redux 的最佳实践，配合 Redux 的开发者工具，也可以很直观地判断哪些状态发生了变更。</p><p>如果你没办法满足以上条件，可能就得依赖工具了。之前有一个<a href="https://github.com/maicki/why-did-you-update" target="_blank" rel="noopener">why-did-you-update</a>的库，<strong>很可惜现在已经没怎么维护了(旧版本可以使用它)</strong>。这个库使用猴补丁(monkey patches)来扩展 React，比对检测哪些 props 和 state 发生了变化：</p><p><img src="/images/10/wdyu.png" alt></p><p>后面也有人借鉴 why-did-you-update 写了个<a href="https://github.com/welldone-software/why-did-you-render" target="_blank" rel="noopener">why-did-you-render</a>. 不过笔者还是不看好这些通过猴补丁扩展 React 的实现，依赖于 React 的内部实现细节，维护成本太高了，跟不上 React 更新基本就废了.</p><p>如果你现在使用 hook 的话，自己手写一个也很简单, 这个 idea 来源于<a href="https://github.com/devhubapp/devhub/blob/master/packages/components/src/hooks/use-why-did-you-update.ts" target="_blank" rel="noopener">use-why-did-you-update</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useWhyDidYouUpdate</span>(<span class="params">name: <span class="built_in">string</span>, props: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️保存上一个props</span></span><br><span class="line">  <span class="keyword">const</span> latestProps = useRef(props);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> allKeys = <span class="built_in">Object</span>.keys(&#123; ...latestProps.current, ...props &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changesObj: Record&lt;<span class="built_in">string</span>, &#123; <span class="keyword">from</span>: <span class="built_in">any</span>; to: <span class="built_in">any</span> &#125;&gt; = &#123;&#125;;</span><br><span class="line">    allKeys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (latestProps.current[key] !== props[key]) &#123;</span><br><span class="line">        changesObj[key] = &#123; <span class="keyword">from</span>: latestProps.current[key], to: props[key] &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(changesObj).length) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[why-did-you-update]'</span>, name, changesObj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他原因导致组件渲染</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latestProps.current = props;</span><br><span class="line">  &#125;, <span class="built_in">Object</span>.values(props));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter = React.memo(props =&gt; &#123;</span><br><span class="line">  useWhyDidYouUpdate(&apos;Counter&apos;, props);</span><br><span class="line">  return &lt;div style=&#123;props.style&#125;&gt;&#123;props.count&#125;&lt;/div&gt;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果是类组件，可以在<code>componentDidUpdate</code>使用类似上面的方式来比较 props</p><p><br></p><h3 id="mobx-变动检测"><a href="#mobx-变动检测" class="headerlink" title="mobx 变动检测"></a>mobx 变动检测</h3><p>排除了 props 变更导致的重新渲染，现在来看看是否是 mobx 响应式数据导致的变更. 如果你们团队不使用 mobx，可以跳过这一节。</p><p><strong>首先不管是 Redux 和 Mobx，我们都应该让状态的变动变得可预测</strong>. 因为 Mobx 没有 Redux 那样固化的数据变更模式，Mobx 并不容易自动化地监测数据是如何被变更的。在 mobx 中我们使用<code>@action</code> 来标志状态的变更操作，但是它拿异步操作没办法。好在后面 mobx 推出了 <code>flow</code> API👏。</p><p>对于 Mobx 首先建议开启严格模式, 要求所有数据变更都放在@action 或 flow 中:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line">configure(&#123; <span class="attr">enforceActions</span>: <span class="string">'always'</span> &#125;);</span><br></pre></td></tr></table></figure><p>定义状态变更操作</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, action, flow &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterStore</span> </span>&#123;</span><br><span class="line">  @observable count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步操作</span></span><br><span class="line">  @action(<span class="string">'increment count'</span>)</span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">  <span class="comment">// 这是一个生成器，类似于saga的机制</span></span><br><span class="line">  fetchCount = flow(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="keyword">yield</span> getCount();</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok 有了上面的约定，现在可以在控制台(通过 mobx-logger)或者 <a href="https://github.com/mobxjs/mobx-devtools" target="_blank" rel="noopener">Mobx 开发者工具</a>中跟踪 Mobx 响应式数据的变动了。</p><p><img src="/images/10/mobx-devtool.png" alt></p><p><br></p><p>如果不按照规范来，出现问题会比较浪费时间, 但也不是没办法解决。Mobx 还提供了一个<a href="https://mobx.js.org/best/trace.html" target="_blank" rel="noopener">trace</a>函数, 用来检测为什么会执行 SideEffect:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ListItem = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; item, onShiftDown &#125; = props;</span><br><span class="line">  trace();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"list-item"</span>&gt;</span>&#123;/*...*/&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行效果(递增了 value 值):</p><p><img src="/images/10/mobx-trace.png" alt="mobx-trace"></p><p><br></p><h3 id="context-变更检测"><a href="#context-变更检测" class="headerlink" title="Context 变更检测"></a>Context 变更检测</h3><p>Ok, 如果排除了 props 和 mobx 数据变更还会重新渲染，那么 100%是 Context 导致的，因为一旦 Context 数据变动，组件就会被强制渲染。笔者在<a href="https://juejin.im/post/5d045350f265da1b695d5bf2#heading-14" target="_blank" rel="noopener">浅谈 React 性能优化的方向</a>提到了 ContextAPI 的一些陷阱。先排除一下是否是这些原因导致的.</p><p>现在并没有合适的跟踪 context 变动的机制，我们可以采取像上文的<code>useWhyDidYouUpdate</code>一样的方式来比对 Context 的值：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useIsContextUpdate</span>(<span class="params">contexts: object = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> latestContexts = useRef(contexts);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> changedContexts: string[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> contexts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (contexts[key] !== latestContexts.current[key]) &#123;</span><br><span class="line">        changedContexts.push(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changedContexts.length) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`[is-context-update]: <span class="subst">$&#123;changedContexts.join(<span class="string">', '</span>)&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latestContexts.current = contexts;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = useRouter();</span><br><span class="line"><span class="keyword">const</span> myContext = useContext(MyContext);</span><br><span class="line"></span><br><span class="line">useIsContextUpdate(&#123;</span><br><span class="line">  router,</span><br><span class="line">  myContext,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="react-devtool-的-interactions"><a href="#react-devtool-的-interactions" class="headerlink" title="React Devtool 的 Interactions"></a>React Devtool 的 Interactions</h3><p>这是 React Devtool 的一个实验性功能，Interactions 翻译为中文是‘交互’？这个东西目的其实就是为了跟踪‘什么导致了更新’，也就是我们上面说的变动检测。React希望提供一个通用的API给开发者或第三方工具，方便开发者直观地定位更新的原因:</p><p><img src="/images/10/interaction.png" alt></p><p>上图表示在记录期间跟踪到了四个交互，以及交互触发的时间和耗时。因为还是一个Idea阶段，所以我们就挑选一些API代码随便看看：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 跟踪状态变更 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; unstable_trace <span class="keyword">as</span> trace &#125; <span class="keyword">from</span> <span class="string">"scheduler/tracing"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleLoginButtonClick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 跟踪setState</span></span><br><span class="line">    trace(<span class="string">"Login button click"</span>, performance.now(), () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">isLoggingIn</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// render ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 跟踪异步操作 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  unstable_trace <span class="keyword">as</span> trace,</span><br><span class="line">  unstable_wrap <span class="keyword">as</span> wrap</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"scheduler/tracing"</span>;</span><br><span class="line"></span><br><span class="line">trace(<span class="string">"Some event"</span>, performance.now(), () =&gt; &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    wrap(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Do some async work</span></span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 跟踪初始化渲染 **/</span></span><br><span class="line">trace(<span class="string">"initial render"</span>, performance.now(), () =&gt; render(<span class="xml"><span class="tag">&lt;<span class="name">Application</span> /&gt;</span>));</span></span><br></pre></td></tr></table></figure><p>好了行文结束，如果觉得可以就点个 👍 吧</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">Introducing the React Profiler</a></li><li><a href="https://calibreapp.com/blog/react-performance-profiling-optimization/" target="_blank" rel="noopener">Profiling React performance with React 16 and Chrome Devtools.</a></li><li><a href="https://www.youtube.com/watch?v=nl8VVig_9aM" target="_blank" rel="noopener">Tools For Measuring React Performance - Brenda Jimenez @ ReactNYC</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇&lt;a href=&quot;https://juejin.im/post/5d045350f265da1b695d5bf2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;讲了 React 性能优化的一些方向和手段，这篇文章再补充说一下如何进行性能测
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈React性能优化的方向</title>
    <link href="https://bobi.ink/2019/06/14/react-performance/"/>
    <id>https://bobi.ink/2019/06/14/react-performance/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-06-16T01:03:44.939Z</updated>
    
    <content type="html"><![CDATA[<p>本文来源于公司内部的一次闪电分享，稍作润色分享出来。主要讨论 React 性能优化的主要方向和一些小技巧。<strong>如果你觉得可以，请多点赞，鼓励我写出更精彩的文章</strong>🙏。</p><p><br></p><p>React 渲染性能优化的三个方向，其实也适用于其他软件开发领域，这三个方向分别是:</p><ul><li><strong>减少计算的量</strong>。 -&gt; 对应到 React 中就是<strong>减少渲染的节点 或者 降低组件渲染的复杂度</strong></li><li><strong>利用缓存</strong>。-&gt; 对应到 React 中就是<strong>如何避免重新渲染，利用函数式编程的 memo 方式来避免组件重新渲染</strong></li><li><strong>精确重新计算的范围</strong>。 对应到 React 中就是<strong>绑定组件和状态关系, 精确判断更新的’时机’和’范围’. 只重新渲染’脏’的组件，或者说降低渲染范围</strong></li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#减少渲染的节点降低渲染计算量复杂度">减少渲染的节点/降低渲染计算量(复杂度)</a><ul><li><a href="#0️⃣-不要在渲染函数都进行不必要的计算">0️⃣ 不要在渲染函数都进行不必要的计算</a></li><li><a href="#1️⃣-减少不必要的嵌套">1️⃣ 减少不必要的嵌套</a></li><li><a href="#2️⃣-虚拟列表">2️⃣ 虚拟列表</a></li><li><a href="#3️⃣-惰性渲染">3️⃣ 惰性渲染</a></li><li><a href="#4️⃣-选择合适的样式方案">4️⃣ 选择合适的样式方案</a></li></ul></li><li><a href="#避免重新渲染">避免重新渲染</a><ul><li><a href="#0️⃣-简化-props">0️⃣ 简化 props</a></li><li><a href="#1️⃣-不变的事件处理器">1️⃣ 不变的事件处理器</a></li><li><a href="#2️⃣-不可变数据">2️⃣ 不可变数据</a></li><li><a href="#3️⃣-简化-state">3️⃣ 简化 state</a></li><li><a href="#4️⃣-使用-recompose-精细化比对">4️⃣ 使用 recompose 精细化比对</a></li></ul></li><li><a href="#精细化渲染">精细化渲染</a><ul><li><a href="#0️⃣-响应式数据的精细化渲染">0️⃣ 响应式数据的精细化渲染</a></li><li><a href="#1️⃣-不要滥用-context">1️⃣ 不要滥用 Context</a></li></ul></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="减少渲染的节点-降低渲染计算量-复杂度"><a href="#减少渲染的节点-降低渲染计算量-复杂度" class="headerlink" title="减少渲染的节点/降低渲染计算量(复杂度)"></a>减少渲染的节点/降低渲染计算量(复杂度)</h2><p>首先从计算的量上下功夫，减少节点渲染的数量或者降低渲染的计算量可以显著的提高组件渲染性能。</p><p><br></p><h3 id="0️⃣-不要在渲染函数都进行不必要的计算"><a href="#0️⃣-不要在渲染函数都进行不必要的计算" class="headerlink" title="0️⃣ 不要在渲染函数都进行不必要的计算"></a>0️⃣ 不要在渲染函数都进行不必要的计算</h3><p>比如不要在渲染函数(render)中进行数组排序、数据转换、订阅事件、创建事件处理器等等. <strong>渲染函数中不应该放置太多副作用</strong></p><p><br></p><h3 id="1️⃣-减少不必要的嵌套"><a href="#1️⃣-减少不必要的嵌套" class="headerlink" title="1️⃣ 减少不必要的嵌套"></a>1️⃣ 减少不必要的嵌套</h3><center><br> <img src="/images/09/styled-components.png"><br></center><p>我们团队是重度的 <code>styled-components</code> 用户，<strong>其实大部分情况下我们都不需要这个玩意</strong>，比如纯静态的样式规则，以及需要重度性能优化的场景。除了性能问题，另外一个困扰我们的是它带来的节点嵌套地狱(如上图)。</p><p>所以我们需要理性地选择一些工具，比如使用原生的 CSS，减少 React 运行时的负担.</p><p><strong>一般不必要的节点嵌套都是滥用高阶组件/RenderProps 导致的。所以还是那句话‘只有在必要时才使用 xxx’</strong>。 有很多种方式来代替高阶组件/RenderProps，例如优先使用 props、React Hooks</p><p><br></p><h3 id="2️⃣-虚拟列表"><a href="#2️⃣-虚拟列表" class="headerlink" title="2️⃣ 虚拟列表"></a>2️⃣ 虚拟列表</h3><p>虚拟列表是常见的‘长列表’和’复杂组件树’优化方式，它优化的本质就是减少渲染的节点。</p><p>虚拟列表只渲染当前视口可见元素:</p><center><br> <img src="/images/09/vl.png" width="500"><br></center><p>虚拟列表渲染性能对比:</p><center><br> <img src="/images/09/vl-compare.png" width="500"><br></center><p>虚拟列表常用于以下组件场景:</p><ul><li>无限滚动列表，grid, 表格，下拉列表，spreadsheets</li><li>无限切换的日历或轮播图</li><li>大数据量或无限嵌套的树</li><li>聊天窗，数据流(feed), 时间轴</li><li>等等</li></ul><p>相关组件方案:</p><ul><li><a href="https://github.com/bvaughn/react-virtualized" target="_blank" rel="noopener">react-virtualized</a></li><li><a href="https://github.com/bvaughn/react-window" target="_blank" rel="noopener">react-window</a> 更轻量的 react-virtualized, 同出一个作者</li><li><a href="https://github.com/bvaughn/react-virtualized#friends" target="_blank" rel="noopener">更多</a></li></ul><p>扩展：</p><ul><li><a href="https://bvaughn.github.io/forward-js-2017/#/0/0" target="_blank" rel="noopener">Creating more efficient React views with windowing</a></li><li><a href="https://addyosmani.com/blog/react-window/" target="_blank" rel="noopener">Rendering large lists with react-window</a></li></ul><p><br><br><br></p><h3 id="3️⃣-惰性渲染"><a href="#3️⃣-惰性渲染" class="headerlink" title="3️⃣ 惰性渲染"></a>3️⃣ 惰性渲染</h3><p><strong>惰性渲染的初衷本质上和虚表一样，也就是说我们只在必要时才去渲染对应的节点</strong>。</p><p>举个典型的例子，我们常用 Tab 组件，我们没有必要一开始就将所有 Tab 的 panel 都渲染出来，而是等到该 Tab 被激活时才去惰性渲染。</p><p>还有很多场景会用到惰性渲染，例如树形选择器，模态弹窗，下拉列表，折叠组件等等。</p><p>这里就不举具体的代码例子了，留给读者去思考.</p><p><br></p><h3 id="4️⃣-选择合适的样式方案"><a href="#4️⃣-选择合适的样式方案" class="headerlink" title="4️⃣ 选择合适的样式方案"></a>4️⃣ 选择合适的样式方案</h3><center><br>  <img src="/images/09/style-compare.png" width="500"><br></center><p>如图(图片来源于<a href="https://blog.primehammer.com/the-performance-of-styled-react-components/" target="_blank" rel="noopener">THE PERFORMANCE OF STYLED REACT COMPONENTS</a>), 这个图片是17年的了，但是大抵的趋势还是这样。</p><p>所以在样式运行时性能方面大概可以总结为：<code>CSS &gt; 大部分CSS-in-js &gt; inline style</code></p><p><br></p><hr><p><br></p><h2 id="避免重新渲染"><a href="#避免重新渲染" class="headerlink" title="避免重新渲染"></a>避免重新渲染</h2><p>减少不必要的重新渲染也是 React 组件性能优化的重要方向. 为了避免不必要的组件重新渲染需要在做到两点:</p><ol><li>保证组件纯粹性。即控制组件的副作用，如果组件有副作用则无法安全地缓存渲染结果</li><li>通过<code>shouldComponentUpdate</code>生命周期函数来比对 state 和 props, 确定是否要重新渲染。对于函数组件可以使用<code>React.memo</code>包装</li></ol><p>另外这些措施也可以帮助你更容易地优化组件重新渲染:</p><p><br></p><h3 id="0️⃣-简化-props"><a href="#0️⃣-简化-props" class="headerlink" title="0️⃣ 简化 props"></a>0️⃣ 简化 props</h3><p><strong>① 如果一个组件的 props 太复杂一般意味着这个组件已经违背了‘单一职责’，首先应该尝试对组件进行拆解</strong>.<br><strong>② 另外复杂的 props 也会变得难以维护, 比如会影响<code>shallowCompare</code>效率, 还会让组件的变动变得难以预测和调试</strong>.</p><p>下面是一个典型的例子, 为了判断列表项是否处于激活状态，这里传入了一个当前激活的 id:</p>  <center><br>    <img src="/images/09/list.png" width="500"><br>  </center><p>这是一个非常糟糕的设计，一旦激活 id 变动，所有列表项都会重新刷新. 更好的解决办法是使用类似<code>actived</code>这样的布尔值 prop. actived 现在只有两种变动情况，也就是说激活 id 的变动，最多只有两个组件需要重新渲染.</p><p><strong>简化的 props 更容易理解, 且可以提高组件缓存的命中率</strong></p><p><br></p><h3 id="1️⃣-不变的事件处理器"><a href="#1️⃣-不变的事件处理器" class="headerlink" title="1️⃣ 不变的事件处理器"></a>1️⃣ 不变的事件处理器</h3><p>①<strong>避免使用箭头函数形式的事件处理器</strong>, 例如:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ComplexComponent onClick=&#123;evt =&gt; onClick(evt.id)&#125; otherProps=&#123;values&#125; /&gt;</span><br></pre></td></tr></table></figure><p>假设 ComplexComponent 是一个复杂的 PureComponent, 这里使用箭头函数，其实每次渲染时都会创建一个新的事件处理器，这会导致 ComplexComponent 始终会被重新渲染.</p><p>更好的方式是使用实例方法:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;ComplexComponent onClick=&#123;<span class="keyword">this</span>.handleClick&#125; otherProps=&#123;values&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <br></p><p>② 即使现在使用<code>hooks</code>，我依然会<strong>使用<code>useCallback</code>来包装事件处理器</strong>，尽量给下级组件暴露一个静态的函数:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ComplexComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> <span class="attr">otherProps</span>=<span class="string">&#123;values&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>但是如果<code>useCallback</code>依赖于很多状态，你的<code>useCallback</code>可能会变成这样:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="comment">// 🤭</span></span><br><span class="line">&#125;, [foo, bar, baz, bazz, bazzzz]);</span><br></pre></td></tr></table></figure><p>这种写法实在让人难以接受，这时候谁还管什么函数式非函数式的。我是这样处理的:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRefProps</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef &lt; T &gt; props;</span><br><span class="line">  <span class="comment">// 每次渲染更新props</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = props;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsRef = useRefProps(props);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在handleClick是始终不变的</span></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; foo, bar, baz, bazz, bazzzz &#125; = propsRef.current;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>③<strong>设计更方便处理的 Event Props</strong>. 有时候我们会被逼的不得不使用箭头函数来作为事件处理器：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;List&gt;</span><br><span class="line">  &#123;list.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">    &lt;Item key=&#123;i.id&#125; onClick=&#123;() =&gt; handleDelete(i.id)&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;<span class="regexp">/List&gt;</span></span><br></pre></td></tr></table></figure><p>上面的 onClick 是一个糟糕的实现，它没有携带任何信息来标识事件来源，所以这里只能使用闭包形式，更好的设计可能是这样的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onClick传递事件来源信息</span></span><br><span class="line"><span class="keyword">const</span> handleDelete = useCallback(<span class="function">(<span class="params">id: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*删除操作*/</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;List&gt;</span><br><span class="line">    &#123;list.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">      &lt;Item key=&#123;i.id&#125; id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/List&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>如果是第三方组件或者 DOM 组件呢? 实在不行，看能不能传递<code>data-*</code>属性:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleDelete = useCallback(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = event.dataset.id;</span><br><span class="line">  <span class="comment">/*删除操作*/</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;list.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">      &lt;li key=&#123;i.id&#125; data-id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="2️⃣-不可变数据"><a href="#2️⃣-不可变数据" class="headerlink" title="2️⃣ 不可变数据"></a>2️⃣ 不可变数据</h3><p>不可变数据可以让状态变得可预测，也让 shouldComponentUpdate ‘浅比较’变得更可靠和高效. 笔者在<a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-8" target="_blank" rel="noopener">React 组件设计实践总结 04 - 组件的思维</a>介绍过不可变数据，有兴趣读者可以看看.</p><p>相关的工具有<a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">Immutable.js</a>、<a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">Immer</a>、immutability-helper 以及 seamless-immutable。</p><p><br></p><h3 id="3️⃣-简化-state"><a href="#3️⃣-简化-state" class="headerlink" title="3️⃣ 简化 state"></a>3️⃣ 简化 state</h3><p><strong>不是所有状态都应该放在组件的 state 中</strong>. 例如缓存数据。按照我的原则是：<strong>如果需要组件响应它的变动, 或者需要渲染到视图中的数据才应该放到 state 中。这样可以避免不必要的数据变动导致组件重新渲染.</strong></p><p><br></p><h3 id="4️⃣-使用-recompose-精细化比对"><a href="#4️⃣-使用-recompose-精细化比对" class="headerlink" title="4️⃣ 使用 recompose 精细化比对"></a>4️⃣ 使用 recompose 精细化比对</h3><p>尽管 hooks 出来后，recompose 宣称不再更新了，但还是不影响我们使用 recompose 来控制<code>shouldComponentUpdate</code>方法, 比如它提供了以下方法来精细控制应该比较哪些 props:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 相当于React.memo */</span></span><br><span class="line">pure()</span><br><span class="line"><span class="comment">/* 自定义比较 */</span></span><br><span class="line">shouldUpdate(test: <span class="function">(<span class="params">props: <span class="built_in">Object</span>, nextProps: <span class="built_in">Object</span></span>) =&gt;</span> <span class="built_in">boolean</span>): HigherOrderComponent</span><br><span class="line"><span class="comment">/* 只比较指定key */</span></span><br><span class="line">onlyUpdateForKeys( propKeys: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;): HigherOrderComponent</span><br></pre></td></tr></table></figure><p>其实还可以再扩展一下，比如<code>omitUpdateForKeys</code>忽略比对某些 key.</p><p><br><br><br></p><h2 id="精细化渲染"><a href="#精细化渲染" class="headerlink" title="精细化渲染"></a>精细化渲染</h2><p>所谓精细化渲染指的是<strong>只有一个数据来源导致组件重新渲染</strong>, 比如说 A 只依赖于 a 数据，那么只有在 a 数据变动时才渲染 A, 其他状态变化不应该影响组件 A。</p><p>Vue 和 Mobx 宣称自己性能好的一部分原因是它们的’响应式系统’, <strong>它允许我们定义一些‘响应式数据’，当这些响应数据变动时，依赖这些响应式数据视图就会重新渲染</strong>. 来看看 Vue 官方是如何描述的:</p><center><br>  <img src="/images/09/vue-compare.png" width="500"><br></center><p><br></p><h3 id="0️⃣-响应式数据的精细化渲染"><a href="#0️⃣-响应式数据的精细化渲染" class="headerlink" title="0️⃣ 响应式数据的精细化渲染"></a>0️⃣ 响应式数据的精细化渲染</h3><p><strong>大部分情况下，响应式数据可以实现视图精细化的渲染, 但它还是不能避免开发者写出低效的程序</strong>. <strong>本质上还是因为组件违背‘单一职责’</strong>.</p><p>举个例子，现在有一个 MyComponent 组件，依赖于 A、B、C 三个数据源，来构建一个 vdom 树。现在的问题是什么呢？现在只要 A、B、C 任意一个变动，那么 MyComponent 整个就会重新渲染:</p><center><br>  <img src="/images/09/my-component1.png" width="300"><br></center><p>更好的做法是让组件的职责更单一，精细化地依赖响应式数据，或者说对响应式数据进行‘隔离’. 如下图, A、B、C 都抽取各自的组件中了，现在 A 变动只会渲染 A 组件本身，而不会影响父组件和 B、C 组件:</p><center><br>  <img src="/images/09/my-component2.png" width="480"><br></center><p><br></p><p>举一个典型的例子，列表渲染:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react-lite'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialList = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  initialList.push(&#123; <span class="attr">id</span>: i, <span class="attr">name</span>: <span class="string">`name-<span class="subst">$&#123;i&#125;</span>`</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = observable(&#123;</span><br><span class="line">  list: initialList,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> List = observer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> list = store.list;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'List渲染'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"list-container"</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map(<span class="function">(<span class="params">i, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;div className=<span class="string">"list-item"</span> key=&#123;i.id&#125;&gt;</span><br><span class="line">            &#123;<span class="comment">/* 假设这是一个复杂的组件 */</span>&#125;</span><br><span class="line">            &#123;<span class="built_in">console</span>.log(<span class="string">'render'</span>, i.id)&#125;</span><br><span class="line">            &lt;span className=<span class="string">"list-item-name"</span>&gt;&#123;i.name&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span className="list-item-value"&gt;&#123;i.value&#125; &lt;/</span>span&gt;</span><br><span class="line">            &lt;button</span><br><span class="line">              className=<span class="string">"list-item-increment"</span></span><br><span class="line">              onClick=&#123;() =&gt; &#123;</span><br><span class="line">                i.value++;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'递增'</span>);</span><br><span class="line">              &#125;&#125;</span><br><span class="line">            &gt;</span><br><span class="line">              递增</span><br><span class="line">            &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button</span></span><br><span class="line"><span class="regexp">              className="list-item-increment"</span></span><br><span class="line"><span class="regexp">              onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                if (idx &lt; list.length - 1) &#123;</span></span><br><span class="line"><span class="regexp">                  console.log('移位');</span></span><br><span class="line"><span class="regexp">                  let t = list[idx];</span></span><br><span class="line"><span class="regexp">                  list[idx] = list[idx + 1];</span></span><br><span class="line"><span class="regexp">                  list[idx + 1] = t;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">              &#125;&#125;</span></span><br><span class="line"><span class="regexp">            &gt;</span></span><br><span class="line"><span class="regexp">              下移</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><p><br></p><p>上述的例子是存在性能问题的，单个 list-item 的递增和移位都会导致整个列表的重新渲染:</p><center><br>  <img src="/images/09/list-demo.png" width="380"><br></center><p>原因大概能猜出来吧? 对于 Vue 或者 Mobx 来说，<strong>一个组件的渲染函数就是一个依赖收集的上下文</strong>。上面 List 组件渲染函数内’访问’了所有的列表项数据，那么 Vue 或 Mobx 就会认为你这个组件依赖于所有的列表项，这样就导致，只要任意一个列表项的属性值变动就会重新渲染整个 List 组件。</p><p>解决办法也很简单，就是将数据隔离抽取到单一职责的组件中。<strong>对于 Vue 或 Mobx 来说，越细粒度的组件，可以收获更高的性能优化效果</strong>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ListItem = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; item, onShiftDown &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"list-item"</span>&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'render'</span>, item.id)&#125;</span><br><span class="line">      &#123;<span class="comment">/* 假设这是一个复杂的组件 */</span>&#125;</span><br><span class="line">      &lt;span className=<span class="string">"list-item-name"</span>&gt;&#123;item.name&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span className="list-item-value"&gt;&#123;item.value&#125; &lt;/</span>span&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        className=<span class="string">"list-item-increment"</span></span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          item.value++;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'递增'</span>);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        递增</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button className="list-item-increment" onClick=&#123;() =&gt; onShiftDown(item)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        下移</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export const List = observer(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const list = store.list;</span></span><br><span class="line"><span class="regexp">  const handleShiftDown = useCallback(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const idx = list.findIndex(i =&gt; i.id === item.id);</span></span><br><span class="line"><span class="regexp">    if (idx !== -1 &amp;&amp; idx &lt; list.length - 1) &#123;</span></span><br><span class="line"><span class="regexp">      console.log('移位');</span></span><br><span class="line"><span class="regexp">      let t = list[idx];</span></span><br><span class="line"><span class="regexp">      list[idx] = list[idx + 1];</span></span><br><span class="line"><span class="regexp">      list[idx + 1] = t;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ eslint-disable-next-line react-hooks/</span>exhaustive-deps</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'List 渲染'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"list-container"</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map(<span class="function">(<span class="params">i, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;ListItem key=&#123;i.id&#125; item=&#123;i&#125; onShiftDown=&#123;handleShiftDown&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果很明显, list-item 递增只会重新渲染本身; 而移位只会重新渲染 List， 因为列表项没有变动, 所以下级 list-item 也不需要重新渲染:</p><center><br>  <img src="/images/09/list-demo2.png" width="380"><br></center><p><br><br><br></p><h3 id="1️⃣-不要滥用-context"><a href="#1️⃣-不要滥用-context" class="headerlink" title="1️⃣ 不要滥用 Context"></a>1️⃣ 不要滥用 Context</h3><p><strong>其实 Context 的用法和响应式数据正好相反</strong>。笔者也看过不少滥用 Context API 的例子, 说到底还是没有处理好‘状态的作用域问题’.</p><p>首先要理解 Context API 的更新特点，<strong>它是可以穿透<code>React.memo</code>或者<code>shouldComponentUpdate</code>的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate</strong>.</p><p><strong>这个和 Mobx 和 Vue 的响应式系统不同，Context API 并不能细粒度地检测哪些组件依赖哪些状态，所以说上节提到的‘精细化渲染’组件模式，在 Context 这里就成为了‘反模式’</strong>.</p><p>总结一下使用 Context API 要遵循一下原则:</p><p><br></p><ul><li><p><strong>明确状态作用域, Context 只放置必要的，关键的，被大多数组件所共享的状态</strong>。比较典型的是鉴权状态</p><p>举一个简单的例子:</p><center><br>  <img src="/images/09/use-context1.png" width="400"><br></center><center><br>  <img src="/images/09/use-context2.png" width="650"><br></center><p>扩展：Context其实有个实验性或者说非公开的选项<code>observedBits</code>, 可以用于控制ContextConsumer是否需要更新. 详细可以看这篇文章&lt;<a href="https://zhuanlan.zhihu.com/p/51073183" target="_blank" rel="noopener">ObservedBits: React Context的秘密功能</a>&gt;. 不过不推荐在实际项目中使用，而且这个API也比较难用，不如直接上mobx。</p></li><li><p><strong>粗粒度地订阅 Context</strong></p><p>如下图. 细粒度的 Context 订阅会导致不必要的重新渲染, 所以这里推荐粗粒度的订阅. 比如在父级订阅 Context，然后再通过 props 传递给下级。</p><center><br>  <img src="/images/09/context-vs-props.png" width="600"><br></center></li></ul><p><br></p><p>另外程墨 Morgan 在<a href="https://zhuanlan.zhihu.com/p/50336226" target="_blank" rel="noopener">避免 React Context 导致的重复渲染</a>一文中也提到 ContextAPI 的一个陷阱:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Context.Provider</span><br><span class="line">  value=&#123;&#123; <span class="attr">theme</span>: <span class="keyword">this</span>.state.theme, <span class="attr">switchTheme</span>: <span class="keyword">this</span>.switchTheme &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &lt;Content /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Context.Provider&gt;</span><br></pre></td></tr></table></figure><p>上面的组件会在 state 变化时重新渲染整个组件树，至于为什么留给读者去思考。</p><p>所以我们一般都不会裸露地使用 Context.Provider, 而是封装为独立的 Provider 组件:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 顺便暴露useTheme, 让外部必须直接使用Context</span></span><br><span class="line"><span class="regexp">export function useTheme() &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(Context);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>现在 theme 变动就不会重新渲染整个组件树，因为 props.children 由外部传递进来，并没有发生变动。</p><p><strong>其实上面的代码还有另外一个比较难发现的陷阱(官方文档也有<a href="https://zh-hans.reactjs.org/docs/context.html#caveats" target="_blank" rel="noopener">提到</a>)</strong>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;<span class="comment">/* 👇 💣这里每一次渲染ThemeProvider, 都会创建一个新的value(即使theme和switchTheme没有变动),</span></span><br><span class="line"><span class="comment">        从而导致强制渲染所有依赖该Context的组件 */</span>&#125;</span><br><span class="line">    &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>所以<strong>传递给 Context 的 value 最好做一下缓存</strong>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  <span class="keyword">const</span> value = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; theme, switchTheme &#125;), [theme]);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://react.docschina.org/docs/optimizing-performance.html" target="_blank" rel="noopener">Optimizing Performance</a> React 官方文档，最好的教程, 利用好 React 的性能分析工具。</li><li><a href="https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3" target="_blank" rel="noopener">Twitter Lite and High Performance React Progressive Web Apps at Scale</a> 看看 Twitter 如何优化的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文来源于公司内部的一次闪电分享，稍作润色分享出来。主要讨论 React 性能优化的主要方向和一些小技巧。&lt;strong&gt;如果你觉得可以，请多点赞，鼓励我写出更精彩的文章&lt;/strong&gt;🙏。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;React 渲染性能优化的三个方向，其实
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] Preact</title>
    <link href="https://bobi.ink/2019/06/02/preact-map/"/>
    <id>https://bobi.ink/2019/06/02/preact-map/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-06-07T23:04:38.874Z</updated>
    
    <content type="html"><![CDATA[<p>React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路).</p><p>Preact 是 React 的缩略版, 体积非常小, 但五脏俱全. 如果你想了解 React 的基本原理, 可以去学习学习 Preact 的源码, 这也正是本文的目的。</p><p>关于 React 原理的优秀的文章已经非常多, 本文就是老酒装新瓶, 算是自己的一点总结，也为后面的文章作一下铺垫吧.</p><p>文章篇幅较长，阅读时间约 20min，主要被代码占据，另外也画了流程图配合理解代码。</p><blockquote><p>注意：代码有所简化，忽略掉 svg、replaceNode、context 等特性<br>本文代码基于 Preact v10 版本</p></blockquote><p><br></p><!-- TOC --><ul><li><a href="#virtual-dom">Virtual-DOM</a></li><li><a href="#从-createelement-开始">从 createElement 开始</a></li><li><a href="#component-的实现">Component 的实现</a></li><li><a href="#diff-算法">diff 算法</a><ul><li><a href="#diffchildren">diffChildren</a></li><li><a href="#diff">diff</a></li><li><a href="#diffelementnodes">diffElementNodes</a></li><li><a href="#diffprops">diffProps</a></li></ul></li><li><a href="#hooks-的实现">Hooks 的实现</a><ul><li><a href="#usestate">useState</a></li><li><a href="#useeffect">useEffect</a></li></ul></li><li><a href="#技术地图">技术地图</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="Virtual-DOM"></a>Virtual-DOM</h2><center><br> <img src="/images/07/vd.png" width="500"><br></center><p>Virtual-DOM 其实就是一颗对象树，没有什么特别的，这个对象树最终要映射到图形对象. Virtual-DOM 比较核心的是它的<code>diff算法</code>.</p><p>你可以想象这里有一个<code>DOM映射器</code>，见名知义，<strong>这个’DOM 映射器‘的工作就是将 Virtual-DOM 对象树映射浏览器页面的 DOM，只不过为了提高 DOM 的’操作性能’. 它不是每一次都全量渲染整个 Virtual-DOM 树，而是支持接收两颗 Virtual-DOM 对象树(一个更新前，一个更新后), 通过 diff 算法计算出两颗 Virtual-DOM 树差异的地方，然后只应用这些差异的地方到实际的 DOM 树, 从而减少 DOM 变更的成本.</strong></p><p>Virtual-DOM 是比较有争议性，推荐阅读<a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noopener">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a> 。切记永远都不要离开场景去评判一个技术的好坏。当初网上把 React 吹得多么牛逼, 一些小白就会觉得 Virtual-DOM 很吊，JQuery 弱爆了。</p><p>我觉得两个可比性不大，从性能上看, <strong>框架再怎么牛逼它也是需要操作原生 DOM 的，而且它未必有你使用 JQuery 手动操作 DOM 来得’精细’</strong>. 框架不合理使用也可能出现修改一个小状态，导致渲染雪崩(大范围重新渲染)的情况; 同理 JQuery 虽然可以精细化操作 DOM, 但是不合理的 DOM 更新策略可能也会成为应用的性能瓶颈. 所以关键还得看你怎么用.</p><p>那为什么需要 Virtual-DOM？</p><p><strong>我个人的理解就是为了解放生产力。现如今硬件的性能越来越好，web 应用也越来越复杂，生产力也是要跟上的</strong>. 尽管手动操作 DOM 可能可以达到更高的性能和灵活性，但是这样对大部分开发者来说太低效了，我们是可以接受牺牲一点性能换取更高的开发效率的.</p><p>所以说 Virtual-DOM 更大的意义在于开发方式的改变: 声明式、 数据驱动, 让开发者不需要关心 DOM 的操作细节(属性操作、事件绑定、DOM 节点变更)，也就是说应用的开发方式变成了<code>view=f(state)</code>, 这对生产力的解放是有很大推动作用的.</p><p>当然 Virtual-DOM 不是唯一，也不是第一个的这样解决方案. 比如 AngularJS, Vue1.x 这些基于模板的实现方式, 也可以说实现这种开发方式转变的. 那相对于他们 Virtual-DOM 的买点可能就是更高的性能了, 另外 Virtual-DOM 在渲染层上面的抽象更加彻底, 不再耦合于 DOM 本身，比如可以渲染为 ReactNative，PDF，终端 UI 等等。</p><p><br></p><hr><p><br></p><h2 id="从-createelement-开始"><a href="#从-createelement-开始" class="headerlink" title="从 createElement 开始"></a>从 createElement 开始</h2><p>很多小白将 <code>JSX</code> 等价为 Virtual-DOM，其实这两者并没有直接的关系, 我们知道 <strong>JSX 不过是一个语法糖</strong>.</p><p>例如<code>&lt;a href=&quot;/&quot;&gt;&lt;span&gt;Home&lt;/span&gt;&lt;/a&gt;</code>最终会转换为<code>h(&#39;a&#39;, { href:&#39;/&#39; }, h(&#39;span&#39;, null, &#39;Home&#39;))</code>这种形式, <code>h</code>是 JSX Element 工厂方法.</p><p><code>h</code> 在 React 下约定是<code>React.createElement</code>, 而大部分 Virtual-DOM 框架则使用<code>h</code>. <code>h</code> 是 <code>createElement</code> 的别名, Vue 生态系统也是使用这个惯例, 具体为什么没作考究(比较简短？)。</p><p>可以使用<code>@jsx</code>注解或 babel 配置项来配置 JSX 工厂：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @jsx h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello jsx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, el);</span><br></pre></td></tr></table></figure><p>本文不是 React 或 Preact 的入门文章，所以点到为止，更多内容可以查看<a href="https://preactjs.com/guide/getting-started" target="_blank" rel="noopener">官方教程</a>.</p><p>现在来看看<code>createElement</code>, <strong>createElement 不过就是构造一个对象(VNode)</strong>:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️type 节点的类型，有DOM元素(string)和自定义组件，以及Fragment, 为null时表示文本节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  props.children = children;</span><br><span class="line">  <span class="comment">// ⚛️应用defaultProps</span></span><br><span class="line">  <span class="keyword">if</span> (type != <span class="literal">null</span> &amp;&amp; type.defaultProps != <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> type.defaultProps)</span><br><span class="line">      <span class="keyword">if</span> (props[i] === <span class="literal">undefined</span>) props[i] = type.defaultProps[i];</span><br><span class="line">  <span class="keyword">let</span> ref = props.ref;</span><br><span class="line">  <span class="keyword">let</span> key = props.key;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️构建VNode对象</span></span><br><span class="line">  <span class="keyword">return</span> createVNode(type, props, key, ref);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createVNode</span>(<span class="params">type, props, key, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; type, props, key, ref, <span class="comment">/* ... 忽略部分内置字段 */</span> <span class="keyword">constructor</span>: undefined &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>通过 JSX 和组件, 可以构造复杂的对象树:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;SideBar /&gt;</span><br><span class="line">    &lt;Body /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  root,</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="component-的实现"><a href="#component-的实现" class="headerlink" title="Component 的实现"></a>Component 的实现</h2><p>对于一个视图框架来说，组件就是它的灵魂, 就像函数之于函数式语言，类之于面向对象语言, 没有组件则无法组成复杂的应用.</p><p>组件化的思维推荐将一个应用分而治之, 拆分和组合不同级别的组件，这样可以简化应用的开发和维护，让程序更好理解. 从技术上看<strong>组件是一个自定义的元素类型，可以声明组件的输入(props)、有自己的生命周期和状态以及方法、最终输出 Virtual-DOM 对象树, 作为应用 Virtual-DOM 树的一个分支存在</strong>.</p><p>Preact 的自定义组件是基于 Component 类实现的. 对组件来说最基本的就是状态的维护, 这个通过 setState 来实现:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️setState实现</span></span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">update, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 克隆下一次渲染的State, _nextState会在一些生命周期方式中用到(例如shouldComponentUpdate)</span></span><br><span class="line">  <span class="keyword">let</span> s = (<span class="keyword">this</span>._nextState !== <span class="keyword">this</span>.state &amp;&amp; <span class="keyword">this</span>._nextState) ||</span><br><span class="line">    (<span class="keyword">this</span>._nextState = assign(&#123;&#125;, <span class="keyword">this</span>.state));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// state更新</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> update !== <span class="string">'function'</span> || (update = update(s, <span class="keyword">this</span>.props)))</span><br><span class="line">    assign(s, update);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._vnode) &#123; <span class="comment">// 已挂载</span></span><br><span class="line">    <span class="comment">// 推入渲染回调队列, 在渲染完成后批量调用</span></span><br><span class="line">    <span class="keyword">if</span> (callback) <span class="keyword">this</span>._renderCallbacks.push(callback);</span><br><span class="line">    <span class="comment">// 放入异步调度队列</span></span><br><span class="line">    enqueueRender(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p><code>enqueueRender</code> 将组件放进一个异步的批执行队列中，这样可以归并频繁的 setState 调用，实现也非常简单:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> q = [];</span><br><span class="line"><span class="comment">// 异步调度器，用于异步执行一个回调</span></span><br><span class="line"><span class="keyword">const</span> defer = <span class="keyword">typeof</span> <span class="built_in">Promise</span> == <span class="string">'function'</span></span><br><span class="line">    ? <span class="built_in">Promise</span>.prototype.then.bind(<span class="built_in">Promise</span>.resolve()) <span class="comment">// micro task</span></span><br><span class="line">    : setTimeout; <span class="comment">// 回调到setTimeout</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueRender</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不需要重复推入已经在队列的Component</span></span><br><span class="line">  <span class="keyword">if</span> (!c._dirty &amp;&amp; (c._dirty = <span class="literal">true</span>) &amp;&amp; q.push(c) === <span class="number">1</span>)</span><br><span class="line">    defer(process); <span class="comment">// 当队列从空变为非空时，开始调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量清空队列, 调用Component的forceUpdate</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p;</span><br><span class="line">  <span class="comment">// 排序队列，从低层的组件优先更新?</span></span><br><span class="line">  q.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b._depth - a._depth);</span><br><span class="line">  <span class="keyword">while</span> ((p = q.pop()))</span><br><span class="line">    <span class="keyword">if</span> (p._dirty) p.forceUpdate(<span class="literal">false</span>); <span class="comment">// false表示不要强制更新，即不要忽略shouldComponentUpdate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>Ok, 上面的代码可以看出 <code>setState</code> 本质上是调用 <code>forceUpdate</code> 进行组件重新渲染的，来往下挖一挖 forceUpdate 的实现.</p><blockquote><p>这里暂且忽略 diff, <strong>将 diff 视作一个黑盒，他就是一个 DOM 映射器, 像上面说的 diff 接收两棵 VNode 树, 以及一个 DOM 挂载点, 在比对的过程中它可以会创建、移除或更新组件和 DOM 元素，触发对应的生命周期方法</strong>.</p></blockquote><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; <span class="comment">// callback放置渲染完成后的回调</span></span><br><span class="line">  <span class="keyword">let</span> vnode = <span class="keyword">this</span>._vnode, dom = <span class="keyword">this</span>._vnode._dom, parentDom = <span class="keyword">this</span>._parentDom;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentDom) &#123; <span class="comment">// 已挂载过</span></span><br><span class="line">    <span class="keyword">const</span> force = callback !== <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> mounts = [];</span><br><span class="line">    <span class="comment">// 调用diff对当前组件进行重新渲染和Virtual-DOM比对</span></span><br><span class="line">    <span class="comment">// ⚛️暂且忽略这些参数, 将diff视作一个黑盒，他就是一个DOM映射器，</span></span><br><span class="line">    dom = diff(parentDom, vnode, vnode, mounts, <span class="keyword">this</span>._ancestorComponent, force, dom);</span><br><span class="line">    <span class="keyword">if</span> (dom != <span class="literal">null</span> &amp;&amp; dom.parentNode !== parentDom)</span><br><span class="line">      parentDom.appendChild(dom);</span><br><span class="line">    commitRoot(mounts, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (callback) callback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>在看看 <code>render</code> 方法, 实现跟 forceUpdate 差不多, 都是调用 diff 算法来执行 DOM 更新，只不过由外部指定一个 DOM 容器:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, parentDom</span>) </span>&#123;</span><br><span class="line">  vnode = createElement(Fragment, <span class="literal">null</span>, [vnode]);</span><br><span class="line">  parentDom.childNodes.forEach(<span class="function"><span class="params">i</span> =&gt;</span> i.remove())</span><br><span class="line">  <span class="keyword">let</span> mounts = [];</span><br><span class="line">  diffChildren(parentDom, <span class="literal">null</span> oldVNode, mounts, vnode, EMPTY_OBJ);</span><br><span class="line">  commitRoot(mounts, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>梳理一下上面的流程:</p><center><br>  <img src="/images/07/setState.png" width="800"><br></center><p>到目前为止没有看到组件的其他功能，如初始化、生命周期函数。这些特性在 diff 函数中定义，也就是说在组件挂载或更新的过程中被调用。下一节就会介绍 diff</p><p><br></p><hr><p><br></p><h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p>千呼万唤始出来，通过上文可以看出，<code>createElement</code> 和 <code>Component</code> 逻辑都很薄， 主要的逻辑还是集中在 diff 函数中. React 将这个过程称为 <code>Reconciliation</code>, 在 Preact 中称为 <code>Differantiate</code>.</p><p>为了简化程序 Preact 的实现将 diff 和 DOM 杂糅在一起, 但逻辑还是很清晰，看下目录结构就知道了:</p><p><br></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/diff</span><br><span class="line">├── children.js # 比对children数组</span><br><span class="line">├── index.js    # 比对两个节点</span><br><span class="line">└── props.js    # 比对两个DOM节点的props</span><br></pre></td></tr></table></figure><center><br>  <img src="/images/07/diff.png" width="600"><br></center><p><br></p><p>在深入 diff 程序之前，先看一下基本的对象结构, 方便后面理解程序流程. 先来看下 VNode 的外形:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type ComponentFactory&lt;P&gt; = preact.ComponentClass&lt;P&gt; | FunctionalComponent&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">interface VNode&lt;P = &#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="comment">// 节点类型, 内置DOM元素为string类型，而自定义组件则是Component类型，Preact中函数组件只是特殊的Component类型</span></span><br><span class="line">  type: string | ComponentFactory&lt;P&gt; | <span class="literal">null</span>;</span><br><span class="line">  props: P &amp; &#123; <span class="attr">children</span>: ComponentChildren &#125; | string | number | <span class="literal">null</span>;</span><br><span class="line">  key: Key</span><br><span class="line">  ref: Ref&lt;any&gt; | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 内部缓存信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// VNode子节点</span></span><br><span class="line">  _children: <span class="built_in">Array</span>&lt;VNode&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 关联的DOM节点, 对于Fragment来说第一个子节点</span></span><br><span class="line">  _dom: PreactElement | Text | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// Fragment, 或者组件返回Fragment的最后一个DOM子节点，</span></span><br><span class="line">  _lastDomChild: PreactElement | Text | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// Component实例</span></span><br><span class="line">  _component: Component | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="diffchildren"><a href="#diffchildren" class="headerlink" title="diffChildren"></a>diffChildren</h3><p>先从最简单的开始, 上面已经猜出 diffChildren 用于比对两个 VNode 列表.</p><center><br>  <img src="/images/07/diffChildren-base.png" width="600"><br></center><p>如上图, 首先这里需要维护一个表示当前插入位置的变量 oldDOM, 它一开始指向 DOM childrenNode 的第一个元素, 后面每次插入更新或插入 newDOM，都会指向 newDOM 的下一个兄弟元素.</p><p>在遍历 newChildren 列表过程中, 会尝试找出相同 key 的旧 VNode，和它进行 diff. 如果新 VNode 和旧 VNode 位置不一样，这就需要移动它们;对于新增的 DOM，如果插入位置(oldDOM)已经到了结尾，则直接追加到父节点, 否则插入到 oldDOM 之前。</p><p>最后卸载旧 VNode 列表中未使用的 VNode.</p><p>来详细看看源码:</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentDom,         <span class="regexp">//</span> children的父DOM元素</span></span></span><br><span class="line"><span class="function"><span class="params">  newParentVNode,    <span class="regexp">//</span> children的新父VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  oldParentVNode,    <span class="regexp">//</span> children的旧父VNode，diffChildren主要比对这两个Vnode的children</span></span></span><br><span class="line"><span class="function"><span class="params">  mounts,            <span class="regexp">//</span> 保存在这次比对过程中被挂载的组件实例，在比对后，会触发这些组件的componentDidMount生命周期函数</span></span></span><br><span class="line"><span class="function"><span class="params">  ancestorComponent, <span class="regexp">//</span> children的直接父<span class="string">'组件'</span>, 即渲染(render</span>)<span class="title">VNode</span>的组件实例</span></span><br><span class="line"><span class="function">  <span class="title">oldDom</span>,            // 当前挂载的<span class="title">DOM</span>，对于<span class="title">diffChildren</span>来说，<span class="title">oldDom</span>一开始指向第一个子节点</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newChildren = newParentVNode._children || toChildArray(newParentVNode.props.children, (newParentVNode._children = []), coerceToVNode, <span class="literal">true</span>,);</span><br><span class="line">  <span class="keyword">let</span> oldChildren = (oldParentVNode &amp;&amp; oldParentVNode._children) || EMPTY_ARR;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️遍历新children</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">    childVNode = newChildren[i] = coerceToVNode(newChildren[i]); <span class="comment">// 规范化VNode</span></span><br><span class="line">    <span class="keyword">if</span> (childVNode == <span class="literal">null</span>) <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">// ⚛️查找oldChildren中是否有对应的元素，如果找到则通过设置为undefined，从oldChildren中移除</span></span><br><span class="line">    <span class="comment">// 如果没有找到则保持为null</span></span><br><span class="line">    oldVNode = oldChildren[i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; oldChildrenLength; j++) &#123;</span><br><span class="line">      oldVNode = oldChildren[j];</span><br><span class="line">      <span class="keyword">if</span> (oldVNode &amp;&amp; childVNode.key == oldVNode.key &amp;&amp; childVNode.type === oldVNode.type) &#123;</span><br><span class="line">        oldChildren[j] = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      oldVNode = <span class="literal">null</span>; <span class="comment">// 没有找到任何旧node，表示是一个新的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⚛️ 递归比对VNode</span></span><br><span class="line">    newDom = diff(parentDom, childVNode, oldVNode, mounts, ancestorComponent, <span class="literal">null</span>, oldDom);</span><br><span class="line">    <span class="comment">// vnode没有被diff卸载掉</span></span><br><span class="line">    <span class="keyword">if</span> (newDom != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (childVNode._lastDomChild != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ⚛️当前VNode是Fragment类型</span></span><br><span class="line">        <span class="comment">// 只有Fragment或组件返回Fragment的Vnode会有非null的_lastDomChild, 从Fragment的结尾的DOM树开始比对:</span></span><br><span class="line">        <span class="comment">// &lt;A&gt;                               &lt;A&gt;</span></span><br><span class="line">        <span class="comment">//  &lt;&gt;                                 &lt;&gt;   👈 Fragment类型，diff会递归比对它的children，所以最后我们只需要将newDom指向比对后的最后一个子节点即可</span></span><br><span class="line">        <span class="comment">//    &lt;a&gt;a&lt;/a&gt;           &lt;- diff -&gt;      &lt;b&gt;b&lt;/b&gt;</span></span><br><span class="line">        <span class="comment">//    &lt;b&gt;b&lt;/b&gt;                           &lt;a&gt;a&lt;/a&gt; ----+</span></span><br><span class="line">        <span class="comment">//  &lt;/&gt;                                &lt;/&gt;             \</span></span><br><span class="line">        <span class="comment">//                                     &lt;div&gt;x&lt;/div&gt;     👈oldDom会指向这里</span></span><br><span class="line">        <span class="comment">// &lt;/A&gt;                              &lt;/A&gt;</span></span><br><span class="line">        newDom = childVNode._lastDomChild;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVNode == <span class="literal">null</span> || newDom != oldDom || newDom.parentNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ newDom和当前oldDom不匹配，尝试新增或修改位置</span></span><br><span class="line">        outer: <span class="keyword">if</span> (oldDom == <span class="literal">null</span> || oldDom.parentNode !== parentDom) &#123;</span><br><span class="line">          <span class="comment">// ⚛️oldDom指向了结尾, 即后面没有更多元素了，直接插入即可; 首次渲染一般会调用到这里</span></span><br><span class="line">          parentDom.appendChild(newDom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 这里是一个优化措施，去掉也不会影响正常程序. 为了便于理解可以忽略这段代码</span></span><br><span class="line">          <span class="comment">// 尝试向后查找oldChildLength/2个元素，如果找到则不需要调用insertBefore. 这段代码可以减少insertBefore的调用频率</span></span><br><span class="line">          <span class="keyword">for</span> (sibDom = oldDom, j = <span class="number">0</span>; (sibDom = sibDom.nextSibling) &amp;&amp; j &lt; oldChildrenLength; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sibDom == newDom)</span><br><span class="line">              <span class="keyword">break</span> outer;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ⚛️insertBefore() 将newDom移动到oldDom之前 </span></span><br><span class="line">          parentDom.insertBefore(newDom, oldDom);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ⚛️其他情况，newDom === oldDOM不需要处理</span></span><br><span class="line">      <span class="comment">// ⚛️ oldDom指向下一个DOM节点</span></span><br><span class="line">      oldDom = newDom.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 卸载掉没有被置为undefined的元素</span></span><br><span class="line">  <span class="keyword">for</span> (i = oldChildrenLength; i--; )</span><br><span class="line">    <span class="keyword">if</span> (oldChildren[i] != <span class="literal">null</span>) unmount(oldChildren[i], ancestorComponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>配图理解一下 diffChilrend 的调用过程:</p><center><br>  <img src="/images/07/diffChildren.png" width="600"><br></center><p><br></p><p>总结一下流程图</p><center><br>  <img src="/images/07/diffChildren-process.png" width="800"><br></center><p><br></p><hr><p><br></p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>diff 用于比对两个 VNode 节点. diff 函数比较冗长, 但是这里面并没有特别复杂逻辑，主要是一些自定义组件生命周期的处理。所以先上流程图，代码不感兴趣可以跳过.</p><center><br>  <img src="/images/07/diff-process.png" width="800"><br></center><p><br></p><p>源代码解析：</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentDom,         <span class="regexp">//</span> 父DOM节点</span></span></span><br><span class="line"><span class="function"><span class="params">  newVNode,          <span class="regexp">//</span> 新VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  oldVNode,          <span class="regexp">//</span> 旧VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  mounts,            <span class="regexp">//</span> 存放已挂载的组件, 将在diff结束后批量处理</span></span></span><br><span class="line"><span class="function"><span class="params">  ancestorComponent, <span class="regexp">//</span> 直接父组件</span></span></span><br><span class="line"><span class="function"><span class="params">  force,             <span class="regexp">//</span> 是否强制更新, 为true将忽略掉shouldComponentUpdate</span></span></span><br><span class="line"><span class="function"><span class="params">  oldDom,            <span class="regexp">//</span> 当前挂载的DOM节点</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    outer: <span class="keyword">if</span> (oldVNode.type === Fragment || newType === Fragment) &#123;</span><br><span class="line">      <span class="comment">// ⚛️ Fragment类型，使用diffChildren进行比对</span></span><br><span class="line">      diffChildren(parentDom, newVNode, oldVNode, mounts, ancestorComponent, oldDom);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️记录Fragment的起始DOM和结束DOM</span></span><br><span class="line">      <span class="keyword">let</span> i = newVNode._children.length;</span><br><span class="line">      <span class="keyword">if</span> (i &amp;&amp; (tmp = newVNode._children[<span class="number">0</span>]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        newVNode._dom = tmp._dom;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">          tmp = newVNode._children[i];</span><br><span class="line">          <span class="keyword">if</span> (newVNode._lastDomChild = tmp &amp;&amp; (tmp._lastDomChild || tmp._dom))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newType === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️自定义组件类型</span></span><br><span class="line">      <span class="keyword">if</span> (oldVNode._component) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ ️已经存在组件实例</span></span><br><span class="line">        c = newVNode._component = oldVNode._component;</span><br><span class="line">        newVNode._dom = oldVNode._dom;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️初始化组件实例</span></span><br><span class="line">        <span class="keyword">if</span> (newType.prototype &amp;&amp; newType.prototype.render) &#123;</span><br><span class="line">          <span class="comment">// ⚛️类组件</span></span><br><span class="line">          newVNode._component = c = <span class="keyword">new</span> newType(newVNode.props, cctx); <span class="comment">// eslint-disable-line new-cap</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️函数组件</span></span><br><span class="line">          newVNode._component = c = <span class="keyword">new</span> Component(newVNode.props, cctx);</span><br><span class="line">          c.constructor = newType;</span><br><span class="line">          c.render = doRender;</span><br><span class="line">        &#125;</span><br><span class="line">        c._ancestorComponent = ancestorComponent;</span><br><span class="line">        c.props = newVNode.props;</span><br><span class="line">        <span class="keyword">if</span> (!c.state) c.state = &#123;&#125;;</span><br><span class="line">        isNew = c._dirty = <span class="literal">true</span>;</span><br><span class="line">        c._renderCallbacks = [];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      c._vnode = newVNode;</span><br><span class="line">      <span class="keyword">if</span> (c._nextState == <span class="literal">null</span>) c._nextState = c.state;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️getDerivedStateFromProps 生命周期方法</span></span><br><span class="line">      <span class="keyword">if</span> (newType.getDerivedStateFromProps != <span class="literal">null</span>)</span><br><span class="line">        assign(c._nextState == c.state</span><br><span class="line">            ? (c._nextState = assign(&#123;&#125;, c._nextState)) <span class="comment">// 惰性拷贝</span></span><br><span class="line">            : c._nextState,</span><br><span class="line">          newType.getDerivedStateFromProps(newVNode.props, c._nextState),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isNew) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 调用挂载前的一些生命周期方法</span></span><br><span class="line">        <span class="comment">// ⚛️ componentWillMount</span></span><br><span class="line">        <span class="keyword">if</span> (newType.getDerivedStateFromProps == <span class="literal">null</span> &amp;&amp; c.componentWillMount != <span class="literal">null</span>) c.componentWillMount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ componentDidMount</span></span><br><span class="line">        <span class="comment">// 将组件推入mounts数组，在整个组件树diff完成后批量调用, 他们在commitRoot方法中被调用</span></span><br><span class="line">        <span class="comment">// 按照先进后出(栈)的顺序调用, 即子组件的componentDidMount会先调用</span></span><br><span class="line">        <span class="keyword">if</span> (c.componentDidMount != <span class="literal">null</span>) mounts.push(c);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 调用重新渲染相关的一些生命周期方法</span></span><br><span class="line">        <span class="comment">// ⚛️ componentWillReceiveProps</span></span><br><span class="line">        <span class="keyword">if</span> (newType.getDerivedStateFromProps == <span class="literal">null</span> &amp;&amp; force == <span class="literal">null</span> &amp;&amp; c.componentWillReceiveProps != <span class="literal">null</span>)</span><br><span class="line">          c.componentWillReceiveProps(newVNode.props, cctx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ shouldComponentUpdate</span></span><br><span class="line">        <span class="keyword">if</span> (!force &amp;&amp; c.shouldComponentUpdate != <span class="literal">null</span> &amp;&amp; c.shouldComponentUpdate(newVNode.props, c._nextState, cctx) === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="comment">// shouldComponentUpdate返回false，取消渲染更新</span></span><br><span class="line">          c.props = newVNode.props;</span><br><span class="line">          c.state = c._nextState;</span><br><span class="line">          c._dirty = <span class="literal">false</span>;</span><br><span class="line">          newVNode._lastDomChild = oldVNode._lastDomChild;</span><br><span class="line">          <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ componentWillUpdate</span></span><br><span class="line">        <span class="keyword">if</span> (c.componentWillUpdate != <span class="literal">null</span>) c.componentWillUpdate(newVNode.props, c._nextState, cctx);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️至此props和state已经确定下来，缓存和更新props和state准备渲染</span></span><br><span class="line">      oldProps = c.props;</span><br><span class="line">      oldState = c.state;</span><br><span class="line">      c.props = newVNode.props;</span><br><span class="line">      c.state = c._nextState;</span><br><span class="line">      <span class="keyword">let</span> prev = c._prevVNode || <span class="literal">null</span>;</span><br><span class="line">      c._dirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️渲染</span></span><br><span class="line">      <span class="keyword">let</span> vnode = (c._prevVNode = coerceToVNode(c.render(c.props, c.state)));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️getSnapshotBeforeUpdate</span></span><br><span class="line">      <span class="keyword">if</span> (!isNew &amp;&amp; c.getSnapshotBeforeUpdate != <span class="literal">null</span>) snapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️组件层级，会影响更新的优先级</span></span><br><span class="line">      c._depth = ancestorComponent ? (ancestorComponent._depth || <span class="number">0</span>) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// ⚛️递归diff渲染结果</span></span><br><span class="line">      c.base = newVNode._dom = diff(parentDom, vnode, prev, mounts, c, <span class="literal">null</span>, oldDom);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (vnode != <span class="literal">null</span>) &#123;</span><br><span class="line">        newVNode._lastDomChild = vnode._lastDomChild;</span><br><span class="line">      &#125;</span><br><span class="line">      c._parentDom = parentDom;</span><br><span class="line">      <span class="comment">// ⚛️应用ref</span></span><br><span class="line">      <span class="keyword">if</span> ((tmp = newVNode.ref)) applyRef(tmp, c, ancestorComponent);</span><br><span class="line">      <span class="comment">// ⚛️调用renderCallbacks，即setState的回调</span></span><br><span class="line">      <span class="keyword">while</span> ((tmp = c._renderCallbacks.pop())) tmp.call(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️componentDidUpdate</span></span><br><span class="line">      <span class="keyword">if</span> (!isNew &amp;&amp; oldProps != <span class="literal">null</span> &amp;&amp; c.componentDidUpdate != <span class="literal">null</span>) c.componentDidUpdate(oldProps, oldState, snapshot);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️比对两个DOM元素</span></span><br><span class="line">      newVNode._dom = diffElementNodes(oldVNode._dom, newVNode, oldVNode, mounts, ancestorComponent);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((tmp = newVNode.ref) &amp;&amp; oldVNode.ref !== tmp) applyRef(tmp, newVNode._dom, ancestorComponent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ⚛️捕获渲染错误，传递给上级组件的didCatch生命周期方法</span></span><br><span class="line">    catchErrorInComponent(e, ancestorComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newVNode._dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><hr><p><br></p><h3 id="diffelementnodes"><a href="#diffelementnodes" class="headerlink" title="diffElementNodes"></a>diffElementNodes</h3><p>比对两个 DOM 元素, 流程非常简单:</p><center><br>  <img src="/images/07/diffElementNodes-process.png" width="600"><br></center><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffElementNodes</span>(<span class="params">dom, newVNode, oldVNode, mounts, ancestorComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️创建DOM节点</span></span><br><span class="line">  <span class="keyword">if</span> (dom == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVNode.type === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️文本节点, 没有属性和子级，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(newProps);</span><br><span class="line">    &#125;</span><br><span class="line">    dom = <span class="built_in">document</span>.createElement(newVNode.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newVNode.type === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ⚛️文本节点更新</span></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps) dom.data = newProps;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVNode !== oldVNode) &#123;</span><br><span class="line">      <span class="comment">// newVNode !== oldVNode 这说明是一个静态节点</span></span><br><span class="line">      <span class="keyword">let</span> oldProps = oldVNode.props || EMPTY_OBJ;</span><br><span class="line">      <span class="keyword">let</span> newProps = newVNode.props;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ dangerouslySetInnerHTML处理</span></span><br><span class="line">      <span class="keyword">let</span> oldHtml = oldProps.dangerouslySetInnerHTML;</span><br><span class="line">      <span class="keyword">let</span> newHtml = newProps.dangerouslySetInnerHTML;</span><br><span class="line">      <span class="keyword">if</span> (newHtml || oldHtml)</span><br><span class="line">        <span class="keyword">if</span> (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html)</span><br><span class="line">          dom.innerHTML = (newHtml &amp;&amp; newHtml.__html) || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️递归比对子元素</span></span><br><span class="line">      diffChildren(dom, newVNode, oldVNode, context, mounts, ancestorComponent, EMPTY_OBJ);</span><br><span class="line">      <span class="comment">// ⚛️递归比对DOM属性</span></span><br><span class="line">      diffProps(dom, newProps, oldProps, isSvg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><hr><p><br></p><h3 id="diffprops"><a href="#diffprops" class="headerlink" title="diffProps"></a>diffProps</h3><p>diffProps 用于更新 DOM 元素的属性</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">dom, newProps, oldProps, isSvg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(newProps).sort();</span><br><span class="line">  <span class="comment">// ⚛️比较并设置属性</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> k = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (k !== <span class="string">'children'</span> &amp;&amp; k !== <span class="string">'key'</span> &amp;&amp;</span><br><span class="line">      (!oldProps || (k === <span class="string">'value'</span> || k === <span class="string">'checked'</span> ? dom : oldProps)[k] !== newProps[k])) </span><br><span class="line">      setProperty(dom, k, newProps[k], oldProps[k], isSvg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️清空属性</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> oldProps)</span><br><span class="line">    <span class="keyword">if</span> (i !== <span class="string">'children'</span> &amp;&amp; i !== <span class="string">'key'</span> &amp;&amp; !(i <span class="keyword">in</span> newProps))</span><br><span class="line">      setProperty(dom, i, <span class="literal">null</span>, oldProps[i], isSvg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>diffProps 实现比较简单，就是遍历一下属性有没有变动，有变动则通过 setProperty 设置属性。对于失效的 props 也会通过 setProperty 置空。这里面稍微有点复杂的是 setProperty. 这里涉及到事件的处理, 命名的转换等等:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>(<span class="params">dom, name, value, oldValue, isSvg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'style'</span>) &#123;</span><br><span class="line">    <span class="comment">// ⚛️样式设置</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = assign(assign(&#123;&#125;, oldValue), value);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">      <span class="comment">// 样式属性没有变动</span></span><br><span class="line">      <span class="keyword">if</span> ((value || EMPTY_OBJ)[i] === (oldValue || EMPTY_OBJ)[i]) <span class="keyword">continue</span>;</span><br><span class="line">      dom.style.setProperty(</span><br><span class="line">        i[<span class="number">0</span>] === <span class="string">'-'</span> &amp;&amp; i[<span class="number">1</span>] === <span class="string">'-'</span> ? i : i.replace(CAMEL_REG, <span class="string">'-$&amp;'</span>),</span><br><span class="line">        value &amp;&amp; i <span class="keyword">in</span> value</span><br><span class="line">          ? <span class="keyword">typeof</span> <span class="keyword">set</span>[i] === 'number' &amp;&amp; IS_NON_DIMENSIONAL.test(i) === false</span><br><span class="line">            ? <span class="keyword">set</span>[i] + 'px'</span><br><span class="line">            : <span class="keyword">set</span>[i]</span><br><span class="line">          : '', // 清空</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (name[0] === 'o' &amp;&amp; name[1] === 'n') &#123;</span><br><span class="line">    <span class="comment">// ⚛️事件绑定</span></span><br><span class="line">    <span class="keyword">let</span> useCapture = name !== (name = name.replace(<span class="regexp">/Capture$/</span>, <span class="string">''</span>));</span><br><span class="line">    <span class="keyword">let</span> nameLower = name.toLowerCase();</span><br><span class="line">    name = (nameLower <span class="keyword">in</span> dom ? nameLower : name).slice(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      <span class="comment">// ⚛️首次添加事件, 注意这里是eventProxy为事件处理器</span></span><br><span class="line">      <span class="comment">// preact统一将所有事件处理器收集在dom._listeners对象中，统一进行分发</span></span><br><span class="line">      <span class="comment">// function eventProxy(e) &#123;</span></span><br><span class="line">      <span class="comment">//   return this._listeners[e.type](options.event ? options.event(e) : e);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">if</span> (!oldValue) dom.addEventListener(name, eventProxy, useCapture);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      dom.removeEventListener(name, eventProxy, useCapture);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存事件队列</span></span><br><span class="line">    (dom._listeners || (dom._listeners = &#123;&#125;))[name] = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name !== <span class="string">'list'</span> &amp;&amp; name !== <span class="string">'tagName'</span> &amp;&amp; name <span class="keyword">in</span> dom) &#123;</span><br><span class="line">    <span class="comment">// ⚛️DOM对象属性</span></span><br><span class="line">    dom[name] = value == <span class="literal">null</span> ? <span class="string">''</span> : value;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> value !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    name !== <span class="string">'dangerouslySetInnerHTML'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ⚛️DOM元素属性</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">      dom.removeAttribute(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dom.setAttribute(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>OK 至此 Diff 算法介绍完毕，其实这里面的逻辑并不是特别复杂, 当然 Preact 只是一个极度精简的框架，React 复杂度要高得多，尤其 React Fiber 重构之后。你也可以把 Preact 当做 React 的历史回顾，有兴趣再深入了解 React 的最新架构。</p><p><br></p><hr><p><br></p><h2 id="hooks-的实现"><a href="#hooks-的实现" class="headerlink" title="Hooks 的实现"></a>Hooks 的实现</h2><p>React16.8 正式引入的 hooks，这玩意带来了全新的 React 组件开发方式，让代码变得更加简洁。 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a>这篇文章已经揭示了 hooks 的基本实现原理, 它不过是基于数组实现的。preact 也实现了 hooks 机制，实现代码也就百来行，让我们来体会体会.</p><p>hooks 功能本身是没有集成在 Preact 代码库内部的，而是通过<code>preact/hooks</code>导入</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'preact'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'preact/hooks'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mounted'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello hooks<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>那 Preact 是如何扩展 diff 算法来实现 hooks 的呢？ 实际上 Preact 提供了<code>options</code>对象来对 Preact diff 进行扩展，options 类似于 Preact 生命周期钩子，在 diff 过程中被调用(为了行文简洁，上面的代码我忽略掉了)。例如:</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"><span class="regexp">/*...*/</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️开始diff</span></span><br><span class="line">  <span class="keyword">if</span> ((tmp = options.diff)) tmp(newVNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    outer: <span class="keyword">if</span> (oldVNode.type === Fragment || newType === Fragment) &#123;</span><br><span class="line">      <span class="comment">// Fragment diff</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newType === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 自定义组件diff</span></span><br><span class="line">      <span class="comment">// ⚛️开始渲染</span></span><br><span class="line">      <span class="keyword">if</span> ((tmp = options.render)) tmp(newVNode);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        c.render(c.props, c.state, c.context),</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// ⚛️捕获异常</span></span><br><span class="line">        <span class="keyword">if</span> ((tmp = options.catchRender) &amp;&amp; tmp(e, c)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// DOM element diff</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⚛️diff结束</span></span><br><span class="line">    <span class="keyword">if</span> ((tmp = options.diffed)) tmp(newVNode);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    catchErrorInComponent(e, ancestorComponent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newVNode._dom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><h3 id="usestate"><a href="#usestate" class="headerlink" title="useState"></a>useState</h3><p>先从最常用的 useState 开始:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️OK只是数组，没有Magic，每个hooks调用都会递增currenIndex, 从当前组件中取出状态</span></span><br><span class="line">  <span class="keyword">const</span> hookState = getHookState(currentIndex++);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!hookState._component) &#123;</span><br><span class="line">    hookState._component = currentComponent; <span class="comment">// 当前组件实例</span></span><br><span class="line">    hookState._value = [</span><br><span class="line">      <span class="comment">// ⚛️state, 初始化state</span></span><br><span class="line">      <span class="keyword">typeof</span> initialState === <span class="string">'function'</span> ? initialState() : initialState,</span><br><span class="line">      <span class="comment">// ⚛️dispatch</span></span><br><span class="line">      value =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> nextValue = <span class="keyword">typeof</span> value === <span class="string">'function'</span> ? value(hookState._value[<span class="number">0</span>]) : value;</span><br><span class="line">        <span class="keyword">if</span> (hookState._value[<span class="number">0</span>] !== nextValue) &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 保存状态并调用setState强制更新</span></span><br><span class="line">          hookState._value[<span class="number">0</span>] = nextValue;</span><br><span class="line">          hookState._component.setState(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hookState._value; <span class="comment">// [state, dispatch]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>从代码可以看到，关键在于<code>getHookState</code>的实现</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; options &#125; <span class="keyword">from</span> <span class="string">'preact'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentIndex; <span class="comment">// 保存当前hook的索引</span></span><br><span class="line"><span class="keyword">let</span> currentComponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️render 钩子, 在组件开始渲染之前调用</span></span><br><span class="line"><span class="comment">// 因为Preact是同步递归向下渲染的，而且Javascript是单线程的，所以可以安全地引用当前正在渲染的组件实例</span></span><br><span class="line">options.render = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  currentComponent = vnode._component; <span class="comment">// 保存当前正在渲染的组件</span></span><br><span class="line">  currentIndex = <span class="number">0</span>;                    <span class="comment">// 开始渲染时index重置为0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暂时忽略，下面讲到useEffect就能理解</span></span><br><span class="line">  <span class="comment">// 清空上次渲染未处理的Effect(useEffect)，只有在快速重新渲染时才会出现这种情况，一般在异步队列中被处理</span></span><br><span class="line">  <span class="keyword">if</span> (currentComponent.__hooks) &#123;</span><br><span class="line">    currentComponent.__hooks._pendingEffects = handleEffects(</span><br><span class="line">      currentComponent.__hooks._pendingEffects,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️no magic!, 只是一个数组, 状态保存在组件实例的_list数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHookState</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取或初始化列表</span></span><br><span class="line">  <span class="keyword">const</span> hooks = currentComponent.__hooks ||</span><br><span class="line">    (currentComponent.__hooks = &#123;</span><br><span class="line">      _list: [],                  <span class="comment">// 放置状态</span></span><br><span class="line">      _pendingEffects: [],        <span class="comment">// 放置待处理的effect，由useEffect保存</span></span><br><span class="line">      _pendingLayoutEffects: [],  <span class="comment">// 放置待处理的layoutEffect，有useLayoutEffect保存</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建状态</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= hooks._list.length) &#123;</span><br><span class="line">    hooks._list.push(&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hooks._list[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>大概的流程如下:</p><center><br>  <img src="/images/07/useState.png" width="800"><br></center><p><br></p><h3 id="useeffect"><a href="#useeffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>再看看 useEffect 和 useLayoutEffect. useEffect 和 useLayouteEffect 差不多, 只是触发 effect 的时机不一样，useEffect 在完成渲染后绘制触发，而 useLayoutEffect 在 diff 完成后触发:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123;</span><br><span class="line">    <span class="comment">// ⚛️状态变化</span></span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    currentComponent.__hooks._pendingEffects.push(state); <span class="comment">// ⚛️推进_pendingEffects队列</span></span><br><span class="line">    afterPaint(currentComponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLayoutEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123;</span><br><span class="line">    <span class="comment">// ⚛️状态变化</span></span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    currentComponent.__hooks._pendingLayoutEffects.push(state); <span class="comment">// ⚛️推进_pendingLayoutEffects队列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>看看如何触发 effect. useEffect 和上面看到的<code>enqueueRender</code>差不多，放进一个异步队列中，由<code>requestAnimationFrame</code>进行调度，批量处理:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个类似于上面提到的异步队列</span></span><br><span class="line">afterPaint = <span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!component._afterPaintQueued &amp;&amp; <span class="comment">// 避免组件重复推入</span></span><br><span class="line">    (component._afterPaintQueued = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">    afterPaintEffects.push(component) === <span class="number">1</span> <span class="comment">// 开始调度</span></span><br><span class="line">  )</span><br><span class="line">    requestAnimationFrame(scheduleFlushAfterPaint);  <span class="comment">// 由requestAnimationFrame调度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleFlushAfterPaint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(flushAfterPaintEffects);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushAfterPaintEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  afterPaintEffects.some(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    component._afterPaintQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (component._parentDom)</span><br><span class="line">      <span class="comment">// 清空_pendingEffects队列</span></span><br><span class="line">      component.__hooks._pendingEffects = handleEffects(component.__hooks._pendingEffects);</span><br><span class="line">  &#125;);</span><br><span class="line">  afterPaintEffects = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEffects</span>(<span class="params">effects</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先清除后调用effect</span></span><br><span class="line">  effects.forEach(invokeCleanup); <span class="comment">// 请调用清理</span></span><br><span class="line">  effects.forEach(invokeEffect);  <span class="comment">// 再调用effect</span></span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCleanup</span>(<span class="params">hook</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hook._cleanup) hook._cleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeEffect</span>(<span class="params">hook</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = hook._value();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">'function'</span>) hook._cleanup = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>再看看如何触发 LayoutEffect, 很简单，在 diff 完成后触发, 这个过程是同步的.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options.diffed = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c = vnode._component;</span><br><span class="line">  <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> hooks = c.__hooks;</span><br><span class="line">  <span class="keyword">if</span> (hooks) &#123;</span><br><span class="line">    hooks._pendingLayoutEffects = handleEffects(hooks._pendingLayoutEffects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>👌，hooks 基本原理基本了解完毕, 最后还是用一张图来总结一下吧。</p><center><br>  <img src="/images/07/hooks.png" width="800"><br></center><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><p>文章篇幅很长，主要是太多代码了, 我自己也不喜欢看这种文章，所以没期望读者会看到这里. 后面文章再想办法改善改善. 谢谢你阅读到这里。</p><p>本期的主角本身是一个小而美的视图框架，没有其他技术栈. 这里就安利一下 Preact 作者<a href="https://github.com/developit" target="_blank" rel="noopener">developit</a>的另外一些小而美的库吧.</p><ul><li><a href="https://github.com/developit/workerize" target="_blank" rel="noopener">Workerize</a> 优雅地在 webWorker 中执行和调用程序</li><li><a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> 零配置的库打包工具</li><li><a href="https://github.com/developit/greenlet" target="_blank" rel="noopener">greenlet</a> 和 workerize 差不多，这个将单个异步函数放到 webworker 中执行，而 workerize 是将一个模块</li><li><a href="https://github.com/developit/mitt" target="_blank" rel="noopener">mitt</a> 200byte 的 EventEmitter</li><li><a href="https://github.com/developit/dlv" target="_blank" rel="noopener">dlv</a> 安全地访问深嵌套的对象属性，类似于 lodash 的 get 方法</li><li><a href="https://github.com/developit/snarkdown" target="_blank" rel="noopener">snarkdown</a> 1kb 的 markdown parser</li><li><a href="https://github.com/developit/unistore" target="_blank" rel="noopener">unistore</a> 简洁类 Redux 状态容器，支持 React 和 Preact</li><li><a href="https://github.com/developit/stockroom" target="_blank" rel="noopener">stockroom</a> 在 webWorker 支持状态管理器</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://juejin.im/entry/59b9284a5188257e6571b9b4" target="_blank" rel="noopener">Preact：Into the void 0（译）</a></li><li><a href="https://auth0.com/blog/face-off-virtual-dom-vs-incremental-dom-vs-glimmer/" target="_blank" rel="noopener">React Virtual DOM vs Incremental DOM vs Ember’s Glimmer: Fight</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路).&lt;/p&gt;
&lt;p&gt;Preact 是 R
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] 💅styled-components 💅</title>
    <link href="https://bobi.ink/2019/05/29/styled-components-map/"/>
    <id>https://bobi.ink/2019/05/29/styled-components-map/</id>
    <published>2019-05-28T16:00:00.000Z</published>
    <updated>2019-06-01T09:18:28.099Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://juejin.im/post/5cdad9c7f265da039b08915d" target="_blank" rel="noopener">React 组件设计实践总结 03 - 样式的管理</a>一文中吹了一波 <a href="https://www.styled-components.com" target="_blank" rel="noopener">styled-components</a> 后，本文想深入来了解一下 styled-components 的原理. 如果你对 styled-components 还不了解，建议先阅读一下官方<a href="http://styled-components.com" target="_blank" rel="noopener">文档</a>或前面的文章.</p><blockquote><p>本文基于 styled-components v4.13 版本</p></blockquote><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#从-tagged-template-literals-说起">从 Tagged Template Literals 说起</a></li><li><a href="#源码导读">源码导读</a><ul><li><a href="#1-处理标签模板字面量">1. 处理标签模板字面量</a></li><li><a href="#2-react-组件的封装">2. React 组件的封装</a></li><li><a href="#3-样式和类名的生成">3. 样式和类名的生成</a></li><li><a href="#4-dom-层操作">4. DOM 层操作</a></li><li><a href="#5-总结">5. 总结</a></li></ul></li><li><a href="#技术地图">技术地图</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="从-tagged-template-literals-说起"><a href="#从-tagged-template-literals-说起" class="headerlink" title="从 Tagged Template Literals 说起"></a>从 Tagged Template Literals 说起</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener"><strong>标签模板字面量(Tagged Template Literals)</strong></a>是 ES6 新增的特性，它允许你<strong>自定义字符串的内插(interpolation)规则</strong>, styled-components 正是基于这个特性构建:</p><center><br>  <img src="/images/06/styled-sample.png" width="400"><br></center><p>它的原理非常简单，所有静态字符串会被拆分出来合并成为数组, 作为第一个参数传入到目标函数，而内插(interpolation)表达式的值则会作为 rest 参数传入:</p><center><br>  <img src="/images/06/tag-template.png" width="400"><br></center><p><strong>标签模板字面量相比普通的模板字面量更加灵活. 普通模板字符串会将所有内插值转换为字符串，而<code>标签模板字面量</code>则由你自己来控制</strong>:</p><center><br>  <img src="/images/06/tag-template-pros.png" width="600"><br></center><p>因为标签模板字符串简洁的语法和灵活性，它比较适用于作为<code>DSL</code>, 不需要在语言层面进行支持，比如前阵子<a href="https://github.com/preactjs/preact" target="_blank" rel="noopener">preact</a>作者开发的<a href="https://github.com/developit/htm" target="_blank" rel="noopener">htm</a>, 口号就是”取代 JSX，而且不需要编译器支持”, 通过这种方式是可以优雅地实现<a href="https://juejin.im/post/5ceacf09e51d454f73356cc4" target="_blank" rel="noopener">‘你的网站或许不需要前端构建’</a>.</p><center><br>  <img src="/images/06/htm.png" width="700"><br></center><p>另一个典型的例子就是 <code>jest</code> 的<a href="https://jestjs.io/docs/en/api#testeachtable-name-fn-timeout" target="_blank" rel="noopener"><code>表格测试</code></a>, 这样形式可读性更高:</p><center><br>  <img src="/images/06/jest.png" width="700"><br></center><p>标签模板字面量的脑洞还在继续，比如可以用来写 markdown，再生成 react 组件。限于篇幅就不啰嗦了</p><p>扩展:</p><ul><li><a href="https://mxstbr.blog/2016/11/styled-components-magic-explained/" target="_blank" rel="noopener">The magic behind 💅 styled-components</a></li></ul><p><br></p><hr><p><br></p><h2 id="源码导读"><a href="#源码导读" class="headerlink" title="源码导读"></a>源码导读</h2><p>现在来看一下 styled-components 的实现。为了行文简洁，我们只关心 styled-components 的核心逻辑，所以我对源代码进行了大量的简化，比如忽略掉服务端渲染、ReactNative 实现、babel 插件等等.</p><h3 id="1-处理标签模板字面量"><a href="#1-处理标签模板字面量" class="headerlink" title="1. 处理标签模板字面量"></a>1. 处理标签模板字面量</h3><p>先从 <code>styled</code> 构造函数看起:</p><center><br>  <img src="/images/06/styled-code.png" width="500"><br></center><p>styled 构造函数接收一个包装组件 target，而标签模板字面量则由<a href="https://www.styled-components.com/docs/api#css" target="_blank" rel="noopener"><code>css</code></a>函数进行处理的. 这个函数在 styled-components 中非常常用，类似于 <code>SCSS</code> 的 <code>mixin</code> 角色. <code>css</code> 函数会标签模板字面量规范化, 例如:</p><center><br>  <img src="/images/06/css.png" width="750"><br></center><p> css 实现也非常简单:</p><center><br>  <img src="/images/06/css-code.png" width="700"><br></center><p><code>interleave</code>函数将将静态字符串数组和内插值’拉链式‘交叉合并为单个数组, 比如[1, 2] + [a, b]会合并为[1, a, 2, b]</p><p>关键在于如何将数组进行扁平化, 这个由 <code>flatten</code> 函数实现. flatten 函数会将嵌套的 css(数组形式)递归 concat 在一起，将 StyledComponent 组件转换为类名引用、还有处理 keyframe 等等. 最终剩下静态字符串和函数, 输出结果如上所示。</p><p><strong>实际上 styled-components 会进行两次 flatten，第一次 flatten 将能够静态化的都转换成字符串，将嵌套的 css 结构打平, 只剩下一些函数，这些函数只能在运行时(比如在组件渲染时)执行；第二次是在运行时，拿到函数的运行上下文(props、theme 等等)后, 执行所有函数，将函数的执行结果进行递归合并，最终生成的是一个纯字符串数组</strong>. 对于标签模板字面量的处理大概都是这个过程. 看看 flatten 的实现:</p><center><br>  <img src="/images/06/flatten-code.png" width="700"><br></center><p>总结一下标签模板字面量的处理流程大概是这样子:</p><center><br><img src="/images/06/flatten.png" width="700"><br></center><p><br></p><hr><p><br></p><h3 id="2-react-组件的封装"><a href="#2-react-组件的封装" class="headerlink" title="2. React 组件的封装"></a>2. React 组件的封装</h3><p>现在看看如何构造出 React 组件。styled-components 通过 createStyledComponent 高阶组件将组件封装为 StyledComponent 组件:</p><center><br><img src="/images/06/create-component.png" width="800"><br></center><p>createStyledComponent 是一个典型的高阶组件，它在执行期间会生成一个唯一的组件 id 和创建<code>ComponentStyle</code>对象. ComponentStyle 对象用于维护 css 函数生成的 cssRules, 在运行时(组件渲染时)得到执行的上下文后生成最终的样式和类名。</p><p>再来看看 StyledComponent 的实现, StyledComponent 在组件渲染时，将当前的 props+theme 作为 context 传递给 ComponentStyle，生成类名.</p><center><br><img src="/images/06/StyledComponent.png" width="800"><br></center><p><br></p><hr><p><br></p><h3 id="3-样式和类名的生成"><a href="#3-样式和类名的生成" class="headerlink" title="3. 样式和类名的生成"></a>3. 样式和类名的生成</h3><p>上面看到 StyleComponent 通过 ComponentStyle 类来构造样式表并生成类名, ComponentStyle 拿到 context 后，再次调用 flatten 将 css rule 扁平化，得到一个纯字符串数组。通过使用 hash 算法生成类名, 并使用stylis 对样式进行预处理. 最后通过 StyleSheet 对象将样式规则插入到 DOM 中</p><center><br><img src="/images/06/ComponentStyle.png" width="800"><br></center><p><a href="https://github.com/thysultan/stylis.js/blob/master/README.md" target="_blank" rel="noopener">stylis</a>是一个 3kb 的轻量的 CSS 预处理器, styled-components 所有的 CSS 特性都依赖于它， 例如嵌套规则(<code>a {&amp;:hover{}}</code>)、厂商前缀、压缩等等.</p><p><br></p><hr><p><br></p><h3 id="4-dom-层操作"><a href="#4-dom-层操作" class="headerlink" title="4. DOM 层操作"></a>4. DOM 层操作</h3><p>现在来看一下 StyleSheet, StyleSheet 负责收集所有组件的样式规则，并插入到 DOM 中</p><center><br><img src="/images/06/StyleSheet.png" width="800"><br></center><p>看看简化版的 makeTag</p><center><br><img src="/images/06/makeTag.png" width="800"><br></center><p><br></p><hr><p><br></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>代码可能看晕了，通过流程图来梳理一下过程.</p><blockquote><p>上一篇文章<a href="https://juejin.im/post/5cedb26451882566477b7235" target="_blank" rel="noopener">技术地图 - vue-cli</a>一点代码也没有罗列，只有一个流程图, 读者可能一下子就傻眼了, 不知道在说些什么; 而且这个流程图太大，在移动端不好阅读. 这期稍微改进一下，新增’源码导读‘一节，代码表达能力毫无疑问是胜于流程图的，但是代码相对比较细节琐碎，所以第一是将代码进行简化，留下核心的逻辑，第二是使用流程图表示大概的程序流程，以及流程主体之间的关系.</p></blockquote><p><img src="/images/06/process.png" alt></p><p><br></p><p>如上图 styled-components 主要有四个核心对象:</p><ul><li><strong>WrappedComponent</strong>: 这是 createStyledComponent 创建的包装组件，这个组件保存的被包装的 target、并生成组件 id 和 ComponentStyle 对象</li><li><strong>StyledComponent</strong>: 这是样式组件，在它 render 时会将 props 作为 context 传递给 ComponentStyle，并生成类名</li><li><strong>ComponentStyle</strong>: 负责生成最终的样式表和唯一的类名，并调用 StyleSheet 将生成的样表注入到文档中</li><li><strong>StyleSheet</strong>: 负责管理已生成的样式表, 并注入到文档中</li></ul><p><br></p><p><strong>styled-components 性能优化建议</strong></p><p>styled-components 每次渲染都会重新计算 cssRule，并进行 hash 计算出 className，如果已经对应的 className 还没插入到样式表中，则使用 stylis 进行预处理，并插入到样式表中; </p><p>另外 styled-components 对静态 cssRule(没有任何内插函数)进行了优化，它们不会监听 ThemeContext 变化, 且在渲染时不会重新计算。</p><p>通过这些规则可以得出以下性能优化的建议:</p><ul><li><strong>静态化的 cssRule 性能是最好的</strong></li><li><p><strong>降低 StyledComponent 状态复杂度</strong>. styled-components 并不会对已有的不变的样式规则进行复用，一旦状态变化 styled-component 会生成一个全新的样式规则和类名. 这是最简单的一种实现, 避免了样式复用的复杂性，同时保持样式的隔离性, 问题就是会产生样式冗余。 例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo = styled.div&lt;&#123; active: boolean &#125;&gt;`</span><br><span class="line">  color: red;</span><br><span class="line">  background: $&#123;props =&gt; (props.active ? &apos;blue&apos; : &apos;red&apos;)&#125;;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>active 切换之间会生成两个类名:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cQAOKL</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.kklCtT</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把 StyledComponent 看做是一个状态机，那么 styled-components 可能会为每一个可能的状态生成独立的样式. 如果 StyledComponent 样式很多, 而且状态比较复杂，那么会生成很多冗余的样式.</p></li><li><p>❌ <strong>不要用于动画</strong>。上面了解到 styled-component 会为每个状态生成一个样式表. 动画一般会有很多中间值，在短时间内进行变化，如果动画值通过props传入该StyledComponent来应用样式，这样会生成很多样式，性能非常差:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Bar = styled.div&lt;&#123; width: boolean &#125;&gt;`</span><br><span class="line">  color: red;</span><br><span class="line">  // 千万别这么干</span><br><span class="line">  width: $&#123;props =&gt; props.width&#125;;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>这种动画场景最好使用 style 内联样式来做</p></li></ul><p><br></p><p>OK, 行文结束。styled-components 不过如此是吧？</p><p><br></p><hr><p><br></p><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><ul><li><strong>CSS 相关</strong><ul><li>@emotion/unitless 判断属性值是否需要单位</li><li>css-to-react-native 将 css 转换为 ReactNative style 属性</li><li>✨<a href="https://www.npmjs.com/package/bundlesize" target="_blank" rel="noopener">stylis</a> 轻量的 CSS 预处理器</li></ul></li><li><strong>React 相关</strong><ul><li>@emotion/is-prop-valid 判断是否是合法的 DOM 属性</li><li><a href="https://www.npmjs.com/package/hoist-non-react-statics" target="_blank" rel="noopener">hoist-non-react-statics</a> 提升React组件的静态属性，用于高阶组件场景</li><li>✨<a href="https://www.npmjs.com/package/react-is" target="_blank" rel="noopener">react-is</a>: 判断各种 React 组件类型</li><li><a href="https://github.com/lelandrichardson/react-primitives#readme" target="_blank" rel="noopener">react-primitives</a> 这是一个有意思的库，这个库试图围绕着构建 React 应用提出一套理想的原语，通俗的说就是通过它可以导入不同平台的组件。</li><li><a href="https://github.com/ryanseddon/react-frame-component" target="_blank" rel="noopener">react-frame-component</a> 将react渲染到iframe中。也是一个比较有意思的库</li><li><a href="https://www.npmjs.com/package/react-live" target="_blank" rel="noopener">react-live</a> react实时编辑器和展示，主要用于文档</li></ul></li><li><strong>构建相关</strong><ul><li><a href="https://github.com/siddharthkp/bundlesize#readme" target="_blank" rel="noopener">bundlesize</a> 检查包大小</li><li><a href="https://github.com/codemod-js/codemod/blob/master/packages/cli/README.md" target="_blank" rel="noopener">codemod</a> 使用babel-plugin来重写Javascript或Typescript代码， 一般用于制作升级脚本</li><li>✨<a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> 一个零配置的打包器，基于Rollup，可以用于库的打包和开发, preact作者开发必属精品</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://juejin.im/post/5cdad9c7f265da039b08915d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React 组件设计实践总结 03 - 样式的管理&lt;/a&gt;一文中吹了一波 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] vue-cli</title>
    <link href="https://bobi.ink/2019/05/26/vue-cli-map/"/>
    <id>https://bobi.ink/2019/05/26/vue-cli-map/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2019-06-01T08:15:46.354Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个新开的’实验性’文章系列，如其名‘技术地图’，这个系列计划剖析一些前端开源项目，可能会探讨这些项目的<strong>设计和组织</strong>、整理他们使用到<strong>技术栈</strong>。 首先拿<code>vue-cli</code>小试牛刀，再决定后续要不要继续这个系列.</p><p><br></p><p>我一直在思考我们编程主要在做什么？我们有一大部分工作就是选择各种工具/库/框架，来黏合业务. 工具和场景越匹配、原理了解越多，运用越娴熟，我们效率可能就越高. 这种说法很有争议，就像<code>程序=算法+数据结构</code>不能完全表达现今的软件工程一样, 说我们的工作就是堆砌工具，黏合业务, 一定程度上有自贬的意思。 但这确实是大部分程序员的真实写照。</p><p>这系列文章其实有点类似于 github 上面的<code>Awesome</code>项目. 这些 Awesome 项目就是一个<strong>生态展览馆</strong>, 里面项目琳琅满目. 因为数量太多了，而且缺少评分机制，大部分情况我们不可能一个个去查看，很难从中选择符合需求的项目(当然你带着明确的目的，且目标范围非常小，可能比较有用)。</p><center><br><img src="/images/05/awesome.png" width="400"><br></center><p>是否可以尝试换个角度，<strong>选取一些有趣的开源项目，看看它是怎么应用这些工具的, 有序的罗列出来? 对于有相同场景的项目, 参考或者模仿价值可能会更大一些</strong>. 这些开源项目就是巨人，站在巨人肩膀上显然省事多了</p><p>只是技术栈罗列未免过于简单，笔者还希望从这些项目中学点东西，比如他的设计和项目组织. 我会尝试简化和通俗解释里面的关键知识或亮点, 但是不求甚解。为了避免陷入细节泥潭，我会尽量使用图形化方式展示他们程序流程，避免拘泥于细节。你也可以把这些文章作为深入阅读这些项目源码的引导</p><p>我也希望读者同我交流反馈，共同学习和进步。</p><p><br></p><hr><p><br></p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>说到 CLI, 不得不提<a href="https://ruby-china.github.io/rails-guides/getting_started.html" target="_blank" rel="noopener">Rails</a>框架，它可能是<em>框架提供 CLI 的先祖</em>(具体历史没有深入考究). Rails 有一个重要的指导思想，即<strong>约定大于配置</strong>, <strong>它为 Web 应用的大多数需求都提供了最好的解决方法，并且默认使用这些约定，而不是在长长的配置文件中设置每个细节</strong>。</p><p><strong>CLI 也是这个指导思想下的产物</strong>, 例如通过它提供的 CLI，可以在<a href="https://ruby-china.github.io/rails-guides/getting_started.html" target="_blank" rel="noopener">15 分钟内构建一个简易的博客</a>, 可以通过 CLI 启动服务器和 REPL、生成项目脚手架、生成代码文件、路由、数据库迁移等等:</p><center><br>  <img src="/images/05/rails-cli.png" width="500"><br></center><p>Rails 的很多设计在那个年代就是就是一个明星(闪瞎 PHP、JSP、 ASP…, 想想要配置各种服务器，各种 xml 文件)，它的很多设计模式深刻影响了后面的 web 框架，比如 Django、Laravel, 甚至很多模仿 Rails 命名的，如 Sails、Grails.</p><p>Rails 对于前端开发影响也很深远，比如在 Nodejs 出来之前，Rails 社区就开始使用 <code>coffeescript + sass</code>预编译语言进行前端开发了, <a href="https://ruby-china.github.io/rails-guides/asset_pipeline.html" target="_blank" rel="noopener">Asset Pipeline</a>可以说是最早的’前端工程化’, 配合<a href="https://github.com/turbolinks/turbolinks" target="_blank" rel="noopener">Turbolink</a>可以让传统后端渲染页面拥有不亚于单页应用的用户体验…</p><p>当初 Rails 给我带来的各种震撼还历历在目, <a href="https://ruby-china.org" target="_blank" rel="noopener">Ruby China 社区</a>也是国内最好社区之一. 但是目前 Rails 的关注度不如从前, 在前端社区像 Rails 这种集大成的框架也早已不吃香(参考 Ember, 某种程度上 Angular 也算吧?).</p><p>说实在话如果一生只学一门语言，我会选 Ruby，如果选一个 web 框架，那就是 Rails。</p><p>推荐大家阅读<a href="https://ruby-china.org/wiki/the-rails-doctrine" target="_blank" rel="noopener">The Rails Doctrine - Rails 信条</a> 这篇文章里面有一句话笔者非常喜欢: <strong>“只要放下了自负的个人喜好，便可以跳过无谓的世俗决定，专注在最重要的地方下更快的决定。”</strong>。为人写程序，而不是为了机器写程序.</p><p><strong>约定大于配置</strong>可以减少我们做决定的数量，减少无谓的争论和考虑，让我们可以专注于更重要的事情. 这个原则可以提高开发和团队协作效率, 甚至可以凝聚一个社区.</p><p>以 Webpack 为例，恶心复杂的配置被人诟病，所以才需要 vue-cli 或者 create-react-app 这些工具.</p><blockquote><p>没有用 Ruby/Rails 工作过, 默默写了个 Ruby China 小程序(微信搜<code>Ruby CN</code>)，算是感恩回馈社区吧</p></blockquote><p><br></p><p>Ok, 忍不住吹了一波 Rails, 回到正题.</p><p>笔者是使用 React 作为主力开发的，Vue 也是我非常喜欢的一个开源项目，不说别的，在开发者的’用户体验’方面 Vue 是我见过最好之一，主要体现在 API 的简洁性和易用性、文档还有项目构建工具(今天的主角).</p><p>vue-cli-ui 是我想写这系列文章的动机之一. 前阵子用了一下<code>vue-cli-ui</code>, 感觉很不错, 支持可视化配置和任务运行，比我在终端下一个项目一个项目跑 task 清爽多了. 很想在我们自家的构建工具上也搞一套，怎搞？ 学习它的源码, 我觉得可以作为博客记录下来.</p><p>现在前端工程师也有‘webpack 配置工程师’的戏称，这能说明 webpack 配置是费时费力的苦事(Angular 例外). 这不后来就有了<code>parcel</code>宣称零配置的轮子, 还有 React 社区的<code>create-react-app</code>, vue-cli 前期是基于模板的创建项目, 不算此列。</p><p>后来 vue-cli 汲取着前者的很多优点，把这块做大做优了(看来 vue 很擅长做这些事情). 我们可以来对比一下这些工具:</p><p><br></p><table><thead><tr><th></th><th>Vue CLI</th><th>create-react-app</th><th>parcel</th></tr></thead><tbody><tr><td>快速原型开发</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>全局模式</td><td>零配置原型开发就是全局的</td><td>-</td><td>支持</td></tr><tr><td>插件</td><td>支持</td><td>-</td><td>支持，扩展文件类型和文件输出</td></tr><tr><td>扩展性</td><td>强，通过插件扩展 wepack 配置</td><td>弱, 强约定, 无法配置 webpack，可以 eject, 然后手工配置；支持 babel-macro;(严格说可以通过<a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">react-app-rewired</a>进行扩展)</td><td>中(可以配置 babel，postcss，Typescript); 提供了 Node API; 支持插件扩展文件类型</td></tr><tr><td>多页面</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>适用范围</td><td>Vue 组件的第一公民。通过扩展可以支持任意前端框架</td><td>针对 React 开发，不支持其他框架</td><td>parcel 是一个通用的打包工具，它的竞争对手是 webpack</td></tr><tr><td>编译速度</td><td>cache-loader,thread-loader 来加速 JS 和 TS 编译</td><td>babel-loader 开启了 cache</td><td>编译速度号称是 webpack 的两倍</td></tr><tr><td>可升级性</td><td>支持升级 cli-service, 插件需要单独升级, 插件需要遵循语义化版本. 太多插件存在升级风险</td><td>支持升级 react-script, 官方维护，且强约定基本可以保障向下兼容</td><td>支持升级 parcel-bundler</td></tr><tr><td>UI</td><td>图形化管理是 CLI 的特色之一</td><td>-</td><td>-</td></tr></tbody></table><p><br></p><p>通过上面的对比，可以看出 <strong>vue-cli 是一个扩展性非常强的构建工具，以致于它不仅限于 Vue，也可以用来构建 React 甚至其他前端框架</strong>。</p><p>相比而言 <code>create-react-app</code> 就是一个非常 Opinionated(坚持己见) 的工具，强约定. 一个典型的例子就是它不内置开启 babel 装饰器转译，CRA 团队认为已经废弃(或者不成熟)的语言特性不应该带到 CRA 中; 后面为了给‘优雅’地给 babel 扩展插件，就捣鼓出来了<code>babel-macro</code>, 这是一种’免配置’的 babel 插件规范.</p><p>这种强约定也是有好处的，比如不需要管理配置; 而且 CRA 团队谨慎可靠地维护着 CRA，这使得开发者可以一般无痛地升级 CRA. 如果要扩展 webpack，一般只有 eject，这就走回了手动配置 webpack 的老路, 不可取.</p><p>vue-cli 也是一个’渐进式’的 cli，vue-cli 提供了默认的 preset，但不阻止你对其进行扩展. vue-cli 的扩展接口也非常简洁(合理, 不多不少), 还有 UI 管理界面，可视化管理项目的配置和插件，用户体验很棒，计划在下一篇文章介绍 vue ui. 唯一比较不舒服的是如果滥用这种扩展性，装 N 多插件，而且插件之间还存在依赖关系时，也会成为升级维护的负担.</p><p><br></p><hr><p><br></p><h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>注意，本文不是 vue-cli 的教程，最好的教程是<a href="https://cli.vuejs.org/zh/dev-guide/plugin-dev.html#prompts" target="_blank" rel="noopener">官方文档</a>.</p><p><br></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>下面是 vue-cli 的基本目录结构. 大部分大型的前端项目都使用 lerna 实现 mono-repo 模式, 然后统一分发到 npm. 这种模式有利于项目模块组织</p><center><br>  <img src="/images/05/vue-cli-struct.png" width="700"><br></center><p><br></p><h3 id="分离-cli-层和-service-层"><a href="#分离-cli-层和-service-层" class="headerlink" title="分离 CLI 层和 Service 层"></a><strong>分离 CLI 层和 Service 层</strong></h3><p>这个设计是借鉴<code>create-react-app</code>的, CLI 层只是一些基础的命令一般不需要频繁升级，而且是全局安装; 而 Service 层是多变的, 作为项目的局部依赖，不应该硬编码在 CLI 里面. CLI 和 Service 的职责划分如下:</p><p><br></p><ul><li><p>CLI: 用于项目创建和管理</p><ul><li>全局安装</li><li><code>vue create</code> 创建项目脚手架. 拉取最新的 Service，并选择配置需要的插件</li><li><code>vue ui</code>. 启动 UI 管理界面</li><li>快速原型开发: <code>vue serve</code> | <code>vue build</code>, 直接伺服和编译一个 Vue 文件</li><li>插件管理: <code>vue add</code> | <code>vue invoke</code> 安装插件和调用插件生成器</li></ul></li><li><p>Service: 负责项目的实际构建</p><ul><li>局部安装</li><li>集成 webpack 构建环境，<strong>Service 本身只有一个插件机制, 所有构建相关逻辑都由内置插件和外部插件提供</strong></li><li>内置插件(命令): serve, build, inspect</li></ul></li></ul><p><br><br><br></p><h3 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a><strong>插件系统</strong></h3><p>vue-cli 提供了类似 babel、eslint 的插件机制。</p><center><br>  <img src="/images/05/plugins.png" width="400"><br></center><p><br></p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a><strong>插件</strong></h4><p>插件机制是 vue-cli 的核心, 用于扩展 Service. Service 的<code>命令</code>和 webpack 配置都由插件提供.</p><p>其实插件机制本身并没有什么技术难度, 换句话说<strong>插件其实就是一个协议的设计</strong>. vue-cli 插件的协议如下:</p><ul><li><strong>命名</strong>: <code>@vue/cli-plugin-*</code>或<code>vue-cli-plugin-*</code>. package.json 中按着这个命名约定的依赖会被识别为 vue-cli 插件，另外命名约定也有利于在 github 或 npm 上筛选</li><li><strong>生命周期</strong>:<br>一个插件的生命周期可以分为<code>安装阶段</code>和<code>运行阶段</code>. <code>vue create</code>命令创建项目脚手架、<code>vue add</code>以及<code>vue invoke</code>插件安装命令都属于安装阶段; 而 cli-service 命令执行时属于运行阶段.</li><li><p><strong>基本结构</strong>: 区分了生命周期后，插件的结构就比较清晰了:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── generator.js  # generator (可选)</span><br><span class="line">├── prompts.js    # prompt 文件 (可选)</span><br><span class="line">├── index.js      # service 插件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><ul><li>安装阶段:<ul><li>prompts: 收集用户意见和配置</li><li>gernerator: 在安装阶段生成模板文件</li></ul></li><li>运行时: index.js<ul><li>注入 service 命令</li><li>扩展和修改 webpack 配置. vue-cli 通过<code>webpack-chain</code>和<code>webpack-merge</code>来实现 webpack 可配置化</li></ul></li></ul></li></ul><p><br></p><p>一个简单的插件结构是这样子的:</p><center><br>  <img src="/codes/vue-plugin.png" width="600"><br></center><p><br></p><h4 id="preset"><a href="#preset" class="headerlink" title="preset"></a><strong>preset</strong></h4><p>这个 preset 和 babel 的 preset 概念实际上是不一样的:</p><p><strong>vue-cli 的 preset 一个脚手架创建方案</strong>, 也就是说它只作用于<code>vue create</code>阶段。比如<code>vue create</code>时默认使用的就是 babel+eslint preset. preset 可以简化项目脚手架的创建。<strong>团队可以共享一个 preset 来创建脚手架</strong>。</p><p><strong>而 babel 中的 preset 是一个插件集合，他可以统一收纳和管理一组插件方案</strong>. 例如<code>babel-preset-react</code>、 <code>babel-preset-env</code>. 上文说到如果扩展性被滥用，装 N 多插件，而且插件之间还存在依赖关系时，也会成为升级维护的负担. 而 ‘babel 式’的 preset 可以让插件更方便维护和和<strong>一键式升级</strong>。</p><p>尽管目前 vue 也提供了<code>vue upgrade</code>对插件进行升级，这个是基于语义化版本约定的, 且当插件之间存在依赖关系时, 不排除升级存在风险. 尤其对于团队项目还是推荐有统一地管理这些插件, 实现傻瓜化的升级。 实际上这种 ‘babel 式’的 preset 是可以通过 vue-plugin 实现和转发的。</p><p><br></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h4><p>vue 支持在 package.json 的 <code>vue</code> 字段或<code>vue.config.js</code>中进行配置。这里可以对 Service 核心功能和插件进行配置, 也可以直接修改 webpack 配置. 另外部分构建行为是通过环境变量进行影响的，这些可以通过<code>.env.*</code>文件进行配置</p><p><br></p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a><strong>基本流程</strong></h3><p>现在来看看一个 vue-cli 内部的基本流程, Service 的插件实现是 vue-cli 比较有意思的点. 以<code>vue serve</code>为例:</p><center><br>  <img src="/images/05/vue-cli.png"><br></center><p>Service 对象是 vue-cli 的核心对象，负责管理和应用插件，所有命令和 webpack 配置都是以插件的形式存在:</p><center><br>  <img src="/images/05/vue-service-struct.png" width="700"><br></center><p><strong>首先划分为配置阶段和运行阶段</strong>。 配置阶段 vue-cli 会加载配置文件，并查找和应用所有插件。将 PluginAPI 实例和项目配置传递给插件运行时, 插件运行时通过 PluginAPI 注入命令(registerCommand)和 扩展 webpack 配置(chainWebpack, configureWebpack).</p><p>运行阶段则根据用户传入的命令名调用插件注入命令。在命令实现函数中，可以调用 resolveWebpackConfig()来生成最终的 webpack 配置。以 serve 命令为例，获取到 webpackConfig 后会创建一个 webpack 编译器，并开启 webpack-dev-server 开发服务器.</p><p><br></p><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><ul><li><strong>组织</strong><ul><li><a href="http://lernajs.io" target="_blank" rel="noopener">lerna</a></li></ul></li><li><strong>cli 命令行相关工具</strong><ul><li><a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a>: 命令行字体颜色样式</li><li><a href="https://www.npmjs.com/package/cli-highlight" target="_blank" rel="noopener">cli-highlight</a>: 终端语法高亮输出, 类似于 Highlight.js</li><li><a href="https://www.npmjs.com/package/cliui" target="_blank" rel="noopener">cliui</a>: 在终端中进行多列输出</li><li><a href="https://github.com/dcporter/didyoumean.js" target="_blank" rel="noopener">didyoumean</a>: 根据单词相似度，来对用户输入纠正提示</li><li><a href="https://www.npmjs.com/package/semver" target="_blank" rel="noopener">semver</a>: 提供语义化版本号相关的工具函数。 例如比较，规范化</li><li><a href="https://github.com/tj/commander.js#readme" target="_blank" rel="noopener">commander</a> TJ 写的命令行选项和参数解析器，支持子命令，选项校验和类型转换，帮组信息生成等等. API 简单优雅</li><li><a href="https://www.npmjs.com/package/minimist" target="_blank" rel="noopener">minimist</a>: 一个极简的命令行参数解析器。如果只是简单的选项解析，可以用这个库</li><li><a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noopener">inquirer</a> 命令行询问</li><li><a href="https://github.com/sindresorhus/ora" target="_blank" rel="noopener">ora</a> 命令行 spinner</li><li><a href="https://github.com/yyx990803/launch-editor" target="_blank" rel="noopener">launch-editor</a> 打开编辑器. 通过 node 打开编辑器，前端可以 express 暴露接口调用打开</li><li><a href="https://www.npmjs.com/package/open" target="_blank" rel="noopener">open</a> 打开 URL、文件、可执行文件</li><li><a href="https://www.npmjs.com/package/execa" target="_blank" rel="noopener">execa</a> 更好的 child_process，修复了原生 exec 的一些问题</li><li>validate-npm-package-name: 验证 npm 包名称，比如创建的项目名是否合法</li><li><a href="https://www.npmjs.com/package/dotenv" target="_blank" rel="noopener">dotenv</a> &amp; <a href="https://www.npmjs.com/package/dotenv-expand" target="_blank" rel="noopener">dotenv-expand</a>: 从.env 文件中加载配置，环境变量</li></ul></li><li><strong>网络相关</strong><ul><li><a href="https://www.npmjs.com/package/portfinder" target="_blank" rel="noopener">portfinder</a>: 获取可用的端口</li><li><a href="https://www.npmjs.com/package/address" target="_blank" rel="noopener">address</a>: 获取当前主机的 ip，MAC 和 DNS 服务器</li></ul></li><li><strong>文件处理相关</strong><ul><li><a href="https://www.npmjs.com/package/slash" target="_blank" rel="noopener">slash</a> 一致化处理路径中的分隔符</li><li><a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="noopener">fs-extra</a> node fs 模块扩展</li><li>globby: glob 模式匹配</li><li>rimraf 跨平台文件删除命令</li><li><a href="https://www.npmjs.com/package/memfs" target="_blank" rel="noopener">memfs</a> 兼容 Node fs API 的内存文件系统</li></ul></li><li><strong>数据检验</strong><ul><li><a href="https://www.npmjs.com/package/@hapi/joi" target="_blank" rel="noopener">@hapi/joi</a> JSON schema 校验</li></ul></li><li><strong>调试</strong><ul><li><a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">debug</a>: 这是一个 debug 日志利器, 支持通过环境变量或动态设置来确定是否需要输出; 支持 printf 风格格式化</li></ul></li><li><strong>算法</strong><ul><li>hash-sum: 散列值计算</li><li>deepmerge 深合并</li></ul></li><li><strong>其他</strong><ul><li><a href="https://github.com/benjamn/recast" target="_blank" rel="noopener">recast</a> Javascript 语法树转换器，支持非破坏性的格式化输出. 常用于扩展 js 代码</li><li><a href="https://www.npmjs.com/package/javascript-stringify" target="_blank" rel="noopener">javascript-stringify</a>: 类似于 JSON.stringify, 将对象字符串化。</li></ul></li><li><strong>webpack</strong><ul><li>配置定义<ul><li>webpack-merge: 合并 webpack 配置对象</li><li>webpack-chain: 链式配置 webpack. 这两个库是 vue-cli 插件的重要成员</li></ul></li><li>webpack-dev-server: webpack 开发服务器，支持代码热重载，错误信息展示，接口代理等等</li><li>webpack-bundle-analyzer: webpack 包分析器</li></ul></li><li><strong>扩展(一些相关的技术栈)</strong><ul><li>http-server 快速伺服静态文件</li><li>plop 模板生成器</li><li>yeoman 项目脚手架工具</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个新开的’实验性’文章系列，如其名‘技术地图’，这个系列计划剖析一些前端开源项目，可能会探讨这些项目的&lt;strong&gt;设计和组织&lt;/strong&gt;、整理他们使用到&lt;strong&gt;技术栈&lt;/strong&gt;。 首先拿&lt;code&gt;vue-cli&lt;/code&gt;小试牛刀，再决定
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
