<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2019-05-13T05:06:10.732Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React组件设计实践总结02 - 组件的组织</title>
    <link href="https://bobi.ink/2019/05/11/react-component-design-02/"/>
    <id>https://bobi.ink/2019/05/11/react-component-design-02/</id>
    <published>2019-05-10T16:00:00.000Z</published>
    <updated>2019-05-13T05:06:10.732Z</updated>
    
    <content type="html"><![CDATA[<p>一个复杂的应用都是由简单的应用发展而来的, 随着越来越多的功能加入项目, 代码就会变得越来越难以控制. 本文章主要探讨在大型项目中如何对组件进行组织, 让项目具备可维护性.</p><p><strong>系列目录</strong></p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="./">02 组件的组织</a></li><li>03 样式的管理 待更新</li><li>04 组件的思维 待更新</li><li>05 状态管理 待更新</li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-组件设计的基本原则">1. 组件设计的基本原则</a><ul><li><a href="#基本原则"><strong>基本原则</strong></a></li><li><a href="#高质量组件的特征"><strong>高质量组件的特征</strong></a></li></ul></li><li><a href="#2-基本技巧">2. 基本技巧</a></li><li><a href="#3-组件的分类">3. 组件的分类</a><ul><li><a href="#1️⃣-容器组件和展示组件分离">1️⃣ <strong>容器组件</strong>和<strong>展示组件</strong>分离</a></li><li><a href="#2️⃣-分离逻辑和视图">2️⃣ 分离逻辑和视图</a></li><li><a href="#3️⃣-有状态组件和无状态组件">3️⃣ 有状态组件和无状态组件</a></li><li><a href="#4️⃣-纯组件和非纯组件">4️⃣ 纯组件和非纯组件</a></li><li><a href="#5️⃣-按照-ui-划分为布局组件和内容组件">5️⃣ 按照 UI 划分为<code>布局组件</code>和<code>内容组件</code></a></li><li><a href="#6️⃣-接口一致的数据录入组件">6️⃣ 接口一致的数据录入组件</a></li></ul></li><li><a href="#4-目录划分">4. 目录划分</a><ul><li><a href="#1️⃣-基本目录结构">1️⃣ 基本目录结构</a></li><li><a href="#2️⃣-多页应用的目录划分">2️⃣ 多页应用的目录划分</a></li><li><a href="#3️⃣-多页应用的目录划分-monorepo-模式">3️⃣ 多页应用的目录划分: monorepo 模式</a></li><li><a href="#4️⃣-跨平台应用">4️⃣ 跨平台应用</a></li><li><a href="#5️⃣-跨平台的另外一种方式-taro">5️⃣ 跨平台的另外一种方式: taro</a></li></ul></li><li><a href="#5-模块">5. 模块</a><ul><li><a href="#1️⃣-创建严格的模块边界">1️⃣ 创建严格的模块边界</a></li><li><a href="#2️⃣-named-export-vs-default-export">2️⃣ <code>Named export</code> vs <code>default export</code></a></li><li><a href="#3️⃣-避免循环依赖">3️⃣ 避免循环依赖</a></li><li><a href="#4️⃣-相对路径不要超过两级">4️⃣ 相对路径不要超过两级</a></li></ul></li><li><a href="#6-拆分">6. 拆分</a><ul><li><a href="#1️⃣-拆分-render-方法">1️⃣ 拆分 render 方法</a></li><li><a href="#2️⃣-拆分为组件">2️⃣ 拆分为组件</a></li></ul></li><li><a href="#7-组件划分示例">7. 组件划分示例</a><ul><li><a href="#1️⃣-划分页面">1️⃣ 划分页面</a></li><li><a href="#2️⃣-划分基础-ui-组件">2️⃣ 划分基础 UI 组件</a></li><li><a href="#3️⃣-设计组件的状态">3️⃣ 设计组件的状态</a></li></ul></li><li><a href="#8-文档">8. 文档</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="1-组件设计的基本原则"><a href="#1-组件设计的基本原则" class="headerlink" title="1. 组件设计的基本原则"></a>1. 组件设计的基本原则</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a><strong>基本原则</strong></h3><p><strong>单一职责(Single Responsibility Principle)</strong>. 这原本来源于面向对象编程, 规范定义是”一个类应该只有一个发生变化的原因”, 白话说”一个类只负责一件事情”. 不管是什么编程范式, 只要是模块化的程序设计都适用单一职责原则. 在 React 中, 组件就是模块.</p><p>单一职责要求将组件限制在一个’合适’的粒度. 这个粒度是比较主观的概念, 换句话说’单一’是一个相对的概念. 我个人觉得单一职责并不是追求职责粒度的’最小’化, 粒度最小化是一个极端, 可能会导致大量模块, 模块离散化也会让项目变得难以管理. <strong>单一职责要求的是一个适合被复用的粒度</strong>.</p><p>往往一开始我们设计的组件都可能复合多个职责, 后来出现了代码重复或者模块边界被打破(比如一个模块依赖另一个模块的’细节’), 我们才会惰性将可复用的代码抽离. 随着越来越多的重构和迭代, 模块职责可能会越来越趋于’单一’(😂 看谁, 也可能变成面条).</p><p>当然有经验的开发者可以一开始就能考虑组件的各种应用场景, 可以观察到模块的重合边界. <strong>对于入门者来说<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener"><code>Don&#39;t repeat yourself</code></a>原则更有用, 不要偷懒/多思考/重构/消除重复代码, 你的能力就会慢慢提升</strong></p><p>单一职责的收益:</p><ul><li>降低组件的复杂度. 职责单一组件代码量少, 容易被理解, 可读性高</li><li>降低对其他组件的耦合. 当变更到来时可以降低对其他功能的影响, 不至于牵一发而动全身</li><li>提高可复用性. 功能越单一可复用性越高, 就比如一些基础组件</li></ul><p><br></p><h3 id="高质量组件的特征"><a href="#高质量组件的特征" class="headerlink" title="高质量组件的特征"></a><strong>高质量组件的特征</strong></h3><p><strong>一个高质量的组件一定是<code>高内聚, 低耦合</code>的</strong>, 这两个原则或者特征是组件独立性的一个判断标准.</p><p><strong>高内聚</strong>, 要求一个组件有一个明确的组件边界, 将紧密相关的内容聚集在一个组件下, 实现”专一”的功能. 和传统的前端编程不一样, 一个组件是一个<strong>自包含</strong>的单元, 它包含了逻辑/样式/结构, 甚至是依赖的静态资源. 这也使得组件天然就是一个比较独立的个体. 当然这种独立性是相对的, 为了最大化这种独立性, 需要根据<strong>单一职责</strong>将组件拆分为更小粒度的组件, 这样可以被更灵活的组合和复用.</p><p>虽然组件是独立的, 但是他需要和其他组件进行组合才能实现应用, 这就有了’关联’. <strong>低耦合</strong>要求最小化这种关联性, 比如明确模块边界不应该访问其他组件的内部细节, 组件的接口最小化, 单向数据流等等</p><p>文章后续内容主要讨论实现<em>高内聚/低耦合</em>主要措施</p><p><br></p><hr><p><br></p><h2 id="2-基本技巧"><a href="#2-基本技巧" class="headerlink" title="2. 基本技巧"></a>2. 基本技巧</h2><p>这些技巧来源于<a href="https://vasanthk.gitbooks.io/react-bits/ux-variations/" target="_blank" rel="noopener">react-bits</a>:</p><ul><li>如果组件不需要状态, 则使用<strong>无状态组件</strong></li><li>性能上比较: <strong>无状态函数 &gt; 有状态函数 &gt; class 组件</strong></li><li>最小化 props(接口). 不要传递超过要求的 props</li><li>如果组件内部存在较多条件控制流, 这通常意味着需要对组件进行抽取</li><li>不要过早优化. 只要求组件在当前需求下可被复用, 然后’随机应变’</li></ul><p><br></p><hr><p><br></p><h2 id="3-组件的分类"><a href="#3-组件的分类" class="headerlink" title="3. 组件的分类"></a>3. 组件的分类</h2><h3 id="1️⃣-容器组件和展示组件分离"><a href="#1️⃣-容器组件和展示组件分离" class="headerlink" title="1️⃣ 容器组件和展示组件分离"></a>1️⃣ <strong>容器组件</strong>和<strong>展示组件</strong>分离</h3><p><em>容器组件和展示组件分离</em>是 React 开发的重要思想, 它影响的 React 应用项目的组织和架构. 下面总结一下两者的区别:</p><p><br></p><table><thead><tr><th></th><th>容器组件</th><th>展示组件</th></tr></thead><tbody><tr><td>关注点</td><td>业务</td><td>UI</td></tr><tr><td>数据源</td><td>状态管理器/后端</td><td>props</td></tr><tr><td>组件形式</td><td>高阶组件</td><td>普通组件</td></tr></tbody></table><p><br></p><ul><li><p><strong>展示组件</strong>是一个只关注展示的’元件’, 为了可以在多个地方被复用, 它不应该耦合’业务/功能’, 或者说不应该过渡耦合. 像<code>antd</code>这类组件库提供通用组件显然就是’展示组件’</p><p>下面是一个典型的应用目录结构, 我们可以看到<strong>展示组件与业务/功能是可能有不同的耦合程度的, 和业务的耦合程度越低, 通用性/可复用性越强</strong>:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node_modules/antd/     🔴 通用的组件库, 不能和任何项目的业务耦合</span><br><span class="line">src/</span><br><span class="line">  components/          🔴 项目通用的组件库, 可以被多个容器/页面组件共享</span><br><span class="line">  containers/</span><br><span class="line">    Foo/</span><br><span class="line">      components/      🔴 容器/页面组件特有的组件库, 和一个业务/功能深度耦合. 以致于不能被其他容器组件共享</span><br><span class="line">      index.tsx</span><br><span class="line">    Bar/</span><br><span class="line">      components/</span><br><span class="line">      index.tsx</span><br></pre></td></tr></table></figure><p>对于展示组件，我们要以一种’第三方组件库’的标准来考虑组件的设计, 减少与业务的耦合度, 考虑各种应用的场景, 设计好公开的接口.</p><p><br></p></li><li><p><strong>容器组件</strong>主要关注业务处理. 容器组件一般以’高阶组件’形式存在, 它一般 ① 从外部数据源(redux 这些状态管理器或者直接请求服务端数据)获取数据, 然后 ② 组合<em>展示组件</em>来构建完整的视图.</p><p><img src="/images/04/container.png" width="400"></p><p><em>容器组件</em>通过组合<em>展示组件</em>来构建完整视图, 但两者未必是简单的包含与被包含的关系.</p><p><br></p></li></ul><p><code>容器组件和展示组件的分离</code>可以带来好处主要是<strong>可复用性</strong>和<strong>可维护性</strong>:</p><ul><li>可复用性: 展示组件可以用于多个不同的数据源(容器组件). 容器组件(业务逻辑)也可以被复用于不同’平台’的展示组件</li><li>展示和容器组件更好的分离，有助于更好的理解应用和 UI, 两者可以被独立地维护</li><li>展示组件变得轻量(无状态/或局部状态), 更容易被测试</li></ul><p><br></p><p>了解更多<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">Presentational and Container Components</a></p><p><br></p><hr><p><br></p><h3 id="2️⃣-分离逻辑和视图"><a href="#2️⃣-分离逻辑和视图" class="headerlink" title="2️⃣ 分离逻辑和视图"></a>2️⃣ 分离逻辑和视图</h3><p><code>容器组件和展示组件</code>的分离本质上是<code>逻辑和视图</code>的分离. 在<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener"><code>React Hooks</code></a>出现后, 容器组件可以被 Hooks 形式取代, Hooks 可以和视图层更自然的分离, 为视图层提供纯粹的数据来源.</p><p>抽离的后业务逻辑可以复用于不同的’展示平台’, 例如 web 版和 native 版:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Login/</span><br><span class="line">  useLogin.ts   // 可复用的业务逻辑</span><br><span class="line">  index.web.tsx</span><br><span class="line">  index.tsx</span><br></pre></td></tr></table></figure><p>上面使用了<code>useLogin.tsx</code>来单独维护业务逻辑. 可以被 web 平台和 native 平台的代码复用.</p><p><br></p><p>  <img src="/images/04/demo.png" width="300"></p><p>不仅仅是<strong>业务逻辑</strong>, 展示<strong>组件逻辑</strong>也可以分离. 例如上图, <code>FilePicker</code>和<code>ImagePicker</code>两个组件的’文件上传’逻辑是共享的, 这部分逻辑可以抽取到高阶组件或者 hooks, 甚至是 Context 中(可以统一配置文件上传行为)</p><p>分离逻辑和视图的主要方式有:</p><ul><li>hooks</li><li>高阶组件</li><li>Render Props</li><li>Context</li></ul><p><br></p><hr><p><br></p><h3 id="3️⃣-有状态组件和无状态组件"><a href="#3️⃣-有状态组件和无状态组件" class="headerlink" title="3️⃣ 有状态组件和无状态组件"></a>3️⃣ 有状态组件和无状态组件</h3><p><strong>无状态组件内部不存储状态, 完全由外部的 props 来映射</strong>. 这类组件以函数组件形式存在, 作为低级/高复用的底层展示型组件.<br>无状态组件天然就是’纯组件’, 如果无状态组件的映射需要一点成本, 可以使用 React.memo 包裹避免重复渲染</p><p><br></p><hr><p><br></p><h3 id="4️⃣-纯组件和非纯组件"><a href="#4️⃣-纯组件和非纯组件" class="headerlink" title="4️⃣ 纯组件和非纯组件"></a>4️⃣ 纯组件和非纯组件</h3><p>纯组件的’纯’来源于函数式编程. 指的是<strong>对于一个函数而言, 给定相同的输入, 它总是返回相同的输出, 过程没有副作用, 没有额外的状态依赖</strong>. 对应到 React 中, 纯组件指的是 props(严格上说还有 state 和 context, 它们也是组件的输入)没有变化, 组件的输出就不会变动.</p><center><br>  <img src="/images/04/input-output.png" width="450"><br></center><p>和 React 组件的输出输出模型相比, <a href="http://cyclejs.cn" target="_blank" rel="noopener">Cyclejs</a>对组件输入/输出的抽象则做的更加彻底，更加‘函数式’👇。它的组件就是一个普通的函数，只有’单向’的输入和输出:</p><center><br>  <img src="/images/04/cyclejs.png" width="400"><br></center><p>函数式编程和组件式编程思想某种意义上是一致的, 它们都是’组合’的艺术. 一个大的函数可以有多个职责单一函数组合而成. 组件也是如此. <strong>我们将一个大的组件拆分为子组件, 对组件做更细粒度的控制, 保持它们的纯净性, 让它们的职责更单一, 更独立. 这带来的好处就是可复用性, 可测试性和可预测性.</strong></p><p><strong>纯组件对 React 的性能优化也有重要意义</strong>. 如果一个组件是一个纯组件, 如果’输入’没有变动, 那么这个组件就不需要重新渲染. 组件树越大, 纯组件带来的性能优化收益就越高.</p><p>我们可以很容易地保证一个底层组件的纯净性, 因为它本来就很简单. 但是对于一个复杂的组件树, 则需要花点心思进行构建, 所以就有了’状态管理’的需求. <strong>这些状态管理器通常都在组件树的<em>外部</em>维护一个或多个状态库, 然后通过依赖注入形式, 将局部的状态注入到子树中. 通过视图和逻辑分离的原则, 来维持组件树的纯净性</strong>.</p><p>Redux 就是一个典型的解决方案, 在 Redux 的世界里可以认为<strong>一个复杂的组件树就是一颗状态树的映射</strong>, 只要状态树(需要依靠不可变数据来保证状态的可预测性)不变, 组件树就不变. Redux 建议保持组件的纯净性, 将组件状态交给 Redux 和配套的异步处理工具来维护, 这样就将整个应用抽象成了一个”单向的数据流”, 这是一种简单的”输入/输出”关系</p><center><br>  <img src="/images/04/redux.png" width="400"><br></center><p>不管是 Cyclejs 还是 Redux，抽象是需要付出一点代价的，就比如 redux 代码可能会很罗嗦; 一个复杂的状态树, 如果缺乏良好的组织，整个应用会变得很难理解。实际上, 并不是所有场景都能够顺利/优雅通过’数据驱动’进行表达(可以看一下这篇文章<a href="https://zhuanlan.zhihu.com/p/54492049" target="_blank" rel="noopener">Modal.confirm 违反了 React 的模式吗？</a>), 例如文本框焦点, 或者模态框. 所以不必极端追求无副作用或者数据驱动</p><p>后续会专门写篇文章来回顾总结状态管理.</p><p>扩展:</p><ul><li><a href="https://hackernoon.com/redesigning-redux-b2baee8b8a38" target="_blank" rel="noopener">Redesigning Redux</a></li><li><a href="http://cyclejs.cn/#-组件化" target="_blank" rel="noopener">Cyclejs</a></li></ul><p><br></p><hr><p><br></p><h3 id="5️⃣-按照-ui-划分为布局组件和内容组件"><a href="#5️⃣-按照-ui-划分为布局组件和内容组件" class="headerlink" title="5️⃣ 按照 UI 划分为布局组件和内容组件"></a>5️⃣ 按照 UI 划分为<code>布局组件</code>和<code>内容组件</code></h3><ul><li>布局组件用于控制页面的布局，为内容组件提供占位。通过 props 传入组件来进行填充. 比如<code>Grid</code>, <code>Layout</code>, <code>HorizontalSplit</code></li><li>内容组件会包含一些内容，而不仅有布局。内容组件通常被布局组件约束在占位内. 比如<code>Button</code>, <code>Label</code>, <code>Input</code></li></ul><p>例如下图, List/List.Item 就是布局组件，而 Input，Address 则是内容组件</p><center><br>  <img src="/images/04/layout-vs-content.png" lazyload width="500"><br></center><p>将布局从内容组件中抽取出来，分离布局和内容，可以让两者更好维护，比如布局变动不会影响内容，内容组件可以被应用不同的布局; 另一方面组件是一个自包含内聚的隔离单元, 不应该影响其外部的状态, 例如一个按钮不应该修改外部的布局, 另外也要避免影响全局的样式</p><p><br></p><hr><p><br></p><h3 id="6️⃣-接口一致的数据录入组件"><a href="#6️⃣-接口一致的数据录入组件" class="headerlink" title="6️⃣ 接口一致的数据录入组件"></a>6️⃣ 接口一致的数据录入组件</h3><p>数据录入组件, 或者称为表单, 是客户端开发必不可少的元素. 对于自定义表单组件, 我认为应该保持一致的 API:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props&lt;T&gt; &#123;</span><br><span class="line">  value?: T;</span><br><span class="line">  onChange: <span class="function">(<span class="params">value?: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处:</p><ul><li>接近原生表单元素原语. 自定义表单组件一般不需要封装到 event 对象中</li><li>几乎所有组件库的自定义表单都使用这种 API. 这使得我们的自定义组件可以和第三方库兼容, 比如<a href="https://ant.design/components/form-cn/#components-form-demo-validate-other" target="_blank" rel="noopener">antd 的表单验证机制</a></li><li>更容易被动态渲染. 因为接口一致, 可以方便地进行动态渲染或集中化处理, 减少代码重复</li><li><p>回显问题. 状态回显是表单组件的功能之一, 我个人的最佳实践是<code>value</code>应该是自包含的:</p><p>比如一个支持搜索的用户选择器, option 都是异步从后端加载, 如果 value 只保存用户 id, 那么回显的时候就无法显示用户名, 按照我的实践的 value 的结构应该为: <code>{id: string, name: string}</code>, 这样就解决了回显问题. 回显需要的数据都是由父节点传递进来, 而不是组件自己维护</p></li><li><p>组件都是受控的. 在实际的 React 开发中, 非受控组件的场景非常少, 我认为自定义组件都可以忽略这种需求, 只提供完全受控表单组件, 避免组件自己维护缓存状态</p></li></ul><p><br></p><hr><p><br></p><h2 id="4-目录划分"><a href="#4-目录划分" class="headerlink" title="4. 目录划分"></a>4. 目录划分</h2><h3 id="1️⃣-基本目录结构"><a href="#1️⃣-基本目录结构" class="headerlink" title="1️⃣ 基本目录结构"></a>1️⃣ 基本目录结构</h3><p>关于项目目录结构的划分有两种流行的模式:</p><ul><li><strong><a href="https://ruby-china.github.io/rails-guides/getting_started.html#say-hello-rails" target="_blank" rel="noopener">Rails-style</a>/by-type</strong>: 按照文件的类型划分为不同的目录，例如<code>components</code>、<code>constants</code>、 <code>typings</code>、<code>views</code></li><li><strong>Domain-style/by-feature</strong>: 按照一个功能特性或业务创建单独的文件夹，包含多种类型的文件或目录</li></ul><p>实际的项目环境我们一般使用的是<strong>混合模式</strong>，下面是一个典型的 React 项目结构:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/      # 🔴 项目通用的‘展示组件’</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx    # 组件的入口, 导出组件</span><br><span class="line">      Groups.tsx   # 子组件</span><br><span class="line">      loading.svg  # 静态资源</span><br><span class="line">      style.css    # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts       # 到处所有组件</span><br><span class="line">  containers/      # 🔴 包含'容器组件'和'页面组件'</span><br><span class="line">    LoginPage/     # 页面组件, 例如登录</span><br><span class="line">      components/  # 页面级别展示组件，这些组件不能复用与其他页面组件。</span><br><span class="line">        Button.tsx # 组件未必是一个目录形式，对于一个简单组件可以是一个单文件形式. 但还是推荐使用目录，方便扩展</span><br><span class="line">        Panel.tsx</span><br><span class="line">      reducer.ts   # redux reduces</span><br><span class="line">      useLogin.ts  # (可选)放置'逻辑', 按照👆分离逻辑和视图的原则，将逻辑、状态处理抽取到hook文件</span><br><span class="line">      types.ts     # typescript 类型声明</span><br><span class="line">      style.css</span><br><span class="line">      logo.png</span><br><span class="line">      message.ts</span><br><span class="line">      constants.ts</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx      # 🔴应用根组件</span><br><span class="line">  hooks/           # 🔴可复用的hook</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.tsx        # 应用入口, 在这里使用ReactDOM对跟组件进行渲染</span><br><span class="line">  stores.ts        # redux stores</span><br><span class="line">  contants.ts      # 全局常量</span><br></pre></td></tr></table></figure><p>上面使用<code>Domain-style</code>风格划分了<code>LoginPage</code>和<code>HomePage</code>目录, 将所有该业务或者页面相关的文件聚合在一起; 这里也使用<code>Rails-style</code>模式根据文件<strong>类型/职责</strong>划分不同的目录, 比如<code>components</code>, <code>hooks</code>, <code>containers</code>; 你会发现在<code>LoginPage</code>内部也有类似<code>Rails-Style</code>的结构, 如<code>components</code>, 只不过它的<strong>作用域</strong>不同, 它只归属于<code>LoginPage</code>, 不能被其他 Page 共享</p><p>前端项目一般按照页面路由来拆分组件, 这些组件我们暂且称为‘页面组件’, 这些组件是和业务功能耦合的，而且每个页面之间具有一定的独立性.</p><p>这里将页面组件放置在<code>containers</code>, 如其名，这个目录原本是用来放置容器组件的, 实际项目中通常是将‘容器组件’和‘页面组件’混合在了一起, 现阶段如果要实现纯粹的逻辑分离，我个人觉得还是应该抽取到 hook 中. 这个目录也可以命名为 views, pages…(whatever), 命名为 containers 只是一种习惯(来源于 Redux).</p><p>扩展:</p><ul><li><a href="https://github.com/react-boilerplate/react-boilerplate" target="_blank" rel="noopener">react-boilerplate</a></li></ul><p><br></p><hr><p><br></p><h3 id="2️⃣-多页应用的目录划分"><a href="#2️⃣-多页应用的目录划分" class="headerlink" title="2️⃣ 多页应用的目录划分"></a>2️⃣ 多页应用的目录划分</h3><p>对于大型应用可能有多个应用入口, 例如很多 electron 应用有多个 windows; 再比如很多应用除了 App 还有后台管理界面. 我一般会这样组织多页应用:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/       # 共享组件</span><br><span class="line">  containers/</span><br><span class="line">    Admin/          # 后台管理页面</span><br><span class="line">      components/   # 后台特定的组件库</span><br><span class="line">      LoginPage/</span><br><span class="line">      index.tsx</span><br><span class="line">      ...</span><br><span class="line">    App/</span><br><span class="line">      components/  # App特定的组件库</span><br><span class="line">      LoginPage/   # App页面</span><br><span class="line">      index.tsx</span><br><span class="line">      stores.ts    # redux stores</span><br><span class="line">    AnotherApp/    # 另外一个App页面</span><br><span class="line">  hooks/</span><br><span class="line">  ...</span><br><span class="line">  app.tsx          # 应用入口</span><br><span class="line">  anotherApp.tsx   # 应用入口</span><br><span class="line">  admin.tsx        # 后台入口</span><br></pre></td></tr></table></figure><p>webpack 支持多页应用的构建, 我一般会将应用入口文件命名为<code>*.page.tsx</code>, 然后在 src 自动扫描匹配的文件作为入口.</p><p>利用 webpack 的<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener"><code>SplitChunksPlugin</code></a>可以自动为多页应用抽取共享的模块, 这个对于功能差不多和有较多共享代码的多页应用很有意义. 意味着资源被一起优化, 抽取共享模块, 有利于减少编译文件体积, 也便于共享浏览器缓存.</p><blockquote><p><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener"><code>html-webpack-plugin</code></a>4.0 开始支持注入共享 chunk. 在此之前需要通过 SplitChunksPlugin 显式定义共享的 chunk, 然后也要 html-webpack-plugin 显式注入该 chunk, 比较挫.</p></blockquote><p><br></p><hr><p><br></p><h3 id="3️⃣-多页应用的目录划分-monorepo-模式"><a href="#3️⃣-多页应用的目录划分-monorepo-模式" class="headerlink" title="3️⃣ 多页应用的目录划分: monorepo 模式"></a>3️⃣ 多页应用的目录划分: monorepo 模式</h3><p>上面的方式, 所有页面都聚集在一个项目下面, 共享一样的依赖和 npm 模块. 这可能会带了一些问题:</p><ol><li>不能允许不同页面有不同版本的依赖</li><li>对于毫无相关的应用, 这种组织方式会让代码变得混乱, 例如 App 和后台, 他们使用的技术栈/组件库/交互体验都可能相差较大, 而且容易造成命名冲突.</li><li>构建性能. 你希望单独对某个页面进行构建和维护, 而不是所有页面混合在一起构建</li></ol><p>这种场景可以利用<a href="https://lernajs.io" target="_blank" rel="noopener">lerna</a>或者 <a href="https://yarnpkg.com/zh-Hans/docs/workspaces" target="_blank" rel="noopener">yarn workspace</a> 这里 monorepo 机制, 将多页应用隔离在不同的 npm 模块下, 以 yarn workspace 为例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">yarn.lock</span><br><span class="line">node_modules/      # 所有依赖都会安装在这里, 方便yarn对依赖进行优化</span><br><span class="line">share/             # 🔴 共享模块</span><br><span class="line">  hooks/</span><br><span class="line">  utils/</span><br><span class="line">admin/             # 🔴 后台管理应用</span><br><span class="line">  components/</span><br><span class="line">  containers/</span><br><span class="line">  index.tsx</span><br><span class="line">  package.json     # 声明自己的模块以及share模块的依赖</span><br><span class="line">app/               # 🔴 后台管理应用</span><br><span class="line">  components/</span><br><span class="line">  containers/</span><br><span class="line">  index.tsx</span><br><span class="line">  package.json     # 声明自己的模块以及share模块的依赖</span><br></pre></td></tr></table></figure><p>扩展:</p><ul><li><a href="https://juejin.im/post/5cd8c1d6e51d456e55623bf2" target="_blank" rel="noopener">精读《Monorepo 的优势》</a></li></ul><p><br></p><hr><p><br></p><h3 id="4️⃣-跨平台应用"><a href="#4️⃣-跨平台应用" class="headerlink" title="4️⃣ 跨平台应用"></a>4️⃣ 跨平台应用</h3><p>使用 ReactNative 可以将 React 衍生到原生应用的开发领域. 尽管也有<a href="https://github.com/necolas/react-native-web" target="_blank" rel="noopener"><code>react-native-web</code></a>这样的解决方案, Web 和 Native 的 API/功能/开发方式, 甚至产品需求上可能会相差很大, 久而久之就可能出现大量无法控制的适配代码; 另外 react-native-web 本身也可能成为风险点。 所以一些团队需要针对不同平台进行开发, 一般按照下面风格来组织跨平台应用:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx     # 🔴 ReactNative 组件</span><br><span class="line">      index.web.tsx # 🔴 web组件, 以web.tsx为后缀</span><br><span class="line">      loading.svg   # 静态资源</span><br><span class="line">      style.css     # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts</span><br><span class="line">    index.web.ts</span><br><span class="line">  containers/</span><br><span class="line">    LoginPage/</span><br><span class="line">      components/</span><br><span class="line">      ....</span><br><span class="line">      useLogin.ts   # 🔴 存放分离的逻辑，可以在React Native和Web组件中共享</span><br><span class="line">      index.web.tsx</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx</span><br><span class="line">  hooks/</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.web.tsx        # web应用入口</span><br><span class="line">  index.tsx            # React Native 应用入口</span><br></pre></td></tr></table></figure><p>可以通过 webpack 的<code>resolve.extensions</code>来配置扩展名补全的优先级. 早期的<a href="https://github.com/ant-design/ant-design-mobile" target="_blank" rel="noopener">antd-mobile</a>就是这样组织的.</p><p><br></p><hr><p><br></p><h3 id="5️⃣-跨平台的另外一种方式-taro"><a href="#5️⃣-跨平台的另外一种方式-taro" class="headerlink" title="5️⃣ 跨平台的另外一种方式: taro"></a>5️⃣ 跨平台的另外一种方式: taro</h3><p>对于国内的开发者来说，跨平台可不只 Native 那么简单，我们还有各种各样的小程序、小应用。终端的<strong>碎片化</strong>让前端的开发工作越来越有挑战性.</p><p>Taro 就这样诞生了, Taro 基于 React 的标准语法(DSL), 结合编译原理的思想, 将一套代码转换为多种终端的目标代码, 并提供一套统一的内置组件库和 SDK 来抹平多端的差异</p><center><br>  <img src="/images/04/taro.png" width="500"><br></center><p>因为 Taro 使用 React 的标准语法和 API，这使得我们按照原有的 React 开发约定和习惯来开发多端应用，且只保持一套代码. 但是不要忘了抽象都是有代价的</p><blockquote><p>可以查看 Taro 官方文档<a href="https://github.com/NervJS/taro" target="_blank" rel="noopener">了解更多</a> <br></p></blockquote><blockquote><p><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter</a>是近期比较或的跨平台方案，但是跟本文主题无关</p></blockquote><p><br></p><hr><p><br></p><h2 id="5-模块"><a href="#5-模块" class="headerlink" title="5. 模块"></a>5. 模块</h2><h3 id="1️⃣-创建严格的模块边界"><a href="#1️⃣-创建严格的模块边界" class="headerlink" title="1️⃣ 创建严格的模块边界"></a>1️⃣ 创建严格的模块边界</h3><p>下图是一个某页面的模块导入，相当混乱，这还算可以接受，笔者还见过上千行的组件，其中模块导入语句就占一百多行. 这有一部分原因可能是 VsCode 自动导入功能导致(可以使用 tslint 规则对导入语句进行排序和分组规范)，更大的原因是这些模块缺乏组织。</p><center><br>  <img src="/images/04/imports.png" width="600"><br></center><p>我觉得应该创建严格的模块边界，<strong>一个模块只有一个统一的’出口’</strong>。例如一个复杂的组件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ComplexPage/</span><br><span class="line">  components/</span><br><span class="line">    Foo.tsx</span><br><span class="line">    Bar.tsx</span><br><span class="line">  constants.ts</span><br><span class="line">  reducers.ts</span><br><span class="line">  style.css</span><br><span class="line">  types.ts</span><br><span class="line">  index.tsx # 出口</span><br></pre></td></tr></table></figure><p>可以认为<strong>一个‘目录’就是一个模块边界</strong>. 你<em>不应该</em>这样子导入模块:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComplexPage <span class="keyword">from</span> <span class="string">'../ComplexPage'</span>;</span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../ComplexPage/components/Foo'</span>;</span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../ComplexPage/components/Bar'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; XXX &#125; <span class="keyword">from</span> <span class="string">'../ComplexPage/components/constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User, ComplexPageProps &#125; <span class="keyword">from</span> <span class="string">'../ComplexPage/components/type'</span>;</span><br></pre></td></tr></table></figure><p><strong>一个模块/目录应该由一个‘出口’文件来统一管理模块的导出，限定模块的可见性</strong>. 比如上面的模块，<code>components/Foo</code>、 <code>components/Bar</code>和<code>constants.ts</code>这些文件其实是 <code>ComplexPage</code> 组件的’实现细节’. 这些是外部模块不应该去耦合实现细节，但这个在语言层面并没有一个限定机制，只能依靠规范约定.</p><blockquote><p>当其他模块依赖某个模块的’细节’时, 可能是一种重构的信号: 比如依赖一个模块的一个工具函数或者是一个对象类型声明, 这时候可能应该将其抬升到父级模块, 让兄弟模块共享它.</p></blockquote><p>在前端项目中 <code>index</code> 文件最适合作为一个’出口’文件, 当导入一个目录时，模块查找器会查找该目录下是否存在的 index 文件. 开发者设计一个模块的 API 时, 需要考虑模块各种使用方式, 并使用 index 文件控制模块可见性:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入外部模块需要使用的类型</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./type'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不暴露外部不需要关心的实现细节</span></span><br><span class="line"><span class="comment">// export * from './components/Foo'</span></span><br><span class="line"><span class="comment">// export * from './components/Bar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块的默认导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; ComplexPage <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./ComplexPage'</span>;</span><br></pre></td></tr></table></figure><p>现在导入语句可以更加简洁:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComplexPage, &#123; ComplexPageProps, User, XXX &#125; <span class="keyword">from</span> <span class="string">'../ComplexPage'</span>;</span><br></pre></td></tr></table></figure><p><br></p><p>这条规则也可以用于组件库. 在 webpack 的 Tree-shaking 特性还不成熟之前， 我们都使用了各种各样的技巧来实现<code>按需导入</code>. 例如<a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener"><code>babel-plugin-import</code></a>或直接子路径导入:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> TextField <span class="keyword">from</span> <span class="string">'~/components/TextField'</span>;</span><br><span class="line"><span class="keyword">import</span> SelectField <span class="keyword">from</span> <span class="string">'~/components/SelectField'</span>;</span><br><span class="line"><span class="keyword">import</span> RaisedButton <span class="keyword">from</span> <span class="string">'~/components/RaisedButton'</span>;</span><br></pre></td></tr></table></figure><p>现在可以使用<code>Named import</code>直接导入，让 webpack 来帮你优化:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TextField, SelectField, RaisedButton &#125; <span class="keyword">from</span> <span class="string">'~/components'</span>;</span><br></pre></td></tr></table></figure><p><strong>但不是所有目录都有出口文件, 这时候目录就不是模块的边界了</strong>. 典型的有<code>utils/</code>, <code>utils</code> 只是一个模块命名空间, <code>utils</code> 下面的文件都是一些互不相关或者不同类型的文件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">utils/</span><br><span class="line">  common.ts</span><br><span class="line">  dom.ts</span><br><span class="line">  sdk.ts</span><br></pre></td></tr></table></figure><p>我们习惯直接引用这些文件, 而不是通过一个入口文件, 这样可以更明确导入的是什么类型的:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'./utils/dom'</span>; <span class="comment">// 通过文件名可以知道, 这可能是隐藏某个DOM元素</span></span><br><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'./utils/sdk'</span>; <span class="comment">// webview sdk 提供的的某个方法</span></span><br></pre></td></tr></table></figure><p>最后再总结一下:</p><p>  <img src="/images/04/module-boundary.png" width="600"></p><p>根据模块边界原则(如上图): <strong>一个模块可以访问兄弟(同个作用域下)、 祖先及祖先的兄弟模块</strong>. 例如:</p><ul><li>Bar 可以访问 Foo, 但不能再向下访问它的细节, 即不能访问<code>../Foo/types.ts</code>, 但可以访问它的出口文件<code>../Foo</code></li><li>src/types.ts 不能访问 containers/HomePage</li><li>LoginPage 和访问 HomePage</li><li>LoginPage 可以访问 utils/sdk</li></ul><p><br></p><hr><p><br></p><h3 id="2️⃣-named-export-vs-default-export"><a href="#2️⃣-named-export-vs-default-export" class="headerlink" title="2️⃣ Named export vs default export"></a>2️⃣ <code>Named export</code> vs <code>default export</code></h3><p>这两种导出方式都有各自的适用场景，这里不应该一棒子打死就不使用某种导出方式. 首先看一下<strong>named export 有什么优点</strong>:</p><ul><li><p>命名确定</p><ul><li>方便 Typescript 进行重构</li><li>方便智能提醒和自动导入(auto-import)识别</li><li><p>方便 reexport</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// named</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./named-export'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Foo &#125; <span class="keyword">from</span> <span class="string">'./default-export'</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一个模块支持多个<code>named export</code></p></li></ul><p><br></p><p><strong>再看一下<code>default export</code>有什么优点?</strong>:</p><ul><li><p><code>default export</code>一般代表‘模块本身’, 当我们使用‘默认导入’导入一个模块时, 开发者是自然而然知道这个默认导入的是一个什么对象。</p><p>例如 react 导出的是一个 React 对象; LoginPage 导出的是一个登录页面; somg.png 导入的是一张图片. 这类模块总有一个确定的’主体对象’. 所以默认导入的名称和模块的名称一般是保持一致的(Typescript 的 auto-import 就是基于文件名).</p><p>当然’主体对象’是一种隐式的概念, 你只能通过规范去约束它</p></li><li><p><code>default export</code>的导入语句更加简洁。例如<code>lazy(import(&#39;./MyPage&#39;))</code></p></li></ul><p><code>default export</code>也有一些缺点:</p><ul><li>和其他模块机制(commonjs)互操作时比较难以理解. 例如我们会这样子导入<code>default export</code>: <code>require(&#39;./xx&#39;).default</code></li><li><code>named import</code> 优点就是<code>default export</code>的缺点</li></ul><p>所以总结一下:</p><ol><li>对于’主体对象’明确的模块需要有默认导出, 例如页面组件，类</li><li>对于’主体对象’不明确的模块不应该使用默认导出，例如组件库、utils(放置各种工具方法)、contants 常量</li></ol><p>按照这个规则可以这样子组织 components 目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">  Foo/</span><br><span class="line">    Foo.tsx</span><br><span class="line">    types.ts</span><br><span class="line">    constants.ts</span><br><span class="line">    index.ts         # 导出Foo组件</span><br><span class="line">  Bar/</span><br><span class="line">    Bar.tsx</span><br><span class="line">    index.tsx</span><br><span class="line">  index.ts           # 导出所有组件</span><br></pre></td></tr></table></figure><p>对于 Foo 模块来说， 存在一个主体对象即 Foo 组件, 所以这里使用<code>default export</code>导出的 Foo 组件， 代码为:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="comment">// 这三个文件全部使用named export导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./contants'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./types'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入主体对象</span></span><br><span class="line"><span class="keyword">export</span> &#123; Foo <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br></pre></td></tr></table></figure><p>现在假设 Bar 组件依赖于 Foo:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/Bar/Bar.tsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入Foo组件, 根据模块边界规则, 不能直接引用../Foo/Foo.tsx</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Bar;</span></span><br></pre></td></tr></table></figure><p>对于<code>components</code>模块来说，它的所有子模块都是平等的，所以不存在一个主体对象，<code>default export</code>在这里不适用。 <code>components/index.ts</code>代码:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/index.ts</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./Bar'</span>;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="3️⃣-避免循环依赖"><a href="#3️⃣-避免循环依赖" class="headerlink" title="3️⃣ 避免循环依赖"></a>3️⃣ 避免循环依赖</h3><p><strong>循环依赖是模块糟糕设计的一个表现</strong>, 这时候你需要考虑拆分和设计模块文件, 例如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- Foo.tsx ---</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./Bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">Foo.Bar = Bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Bar.tsx ----</span></span><br><span class="line"><span class="keyword">import</span> &#123; SomeType &#125; <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面 Foo 和 Bar 组件就形成了一个简单循环依赖, 尽管它不会造成什么运行时问题. 解决方案就是将 SomeType 抽取到单独的文件:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- types.ts ---</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Foo.tsx ---</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./Bar'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;SomeType&#125; <span class="keyword">from</span> <span class="string">'./types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">...</span><br><span class="line">Foo.Bar = Bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Bar.tsx ----</span></span><br><span class="line"><span class="keyword">import</span> &#123;SomeType&#125; <span class="keyword">from</span> <span class="string">'./types'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="4️⃣-相对路径不要超过两级"><a href="#4️⃣-相对路径不要超过两级" class="headerlink" title="4️⃣ 相对路径不要超过两级"></a>4️⃣ 相对路径不要超过两级</h3><p>当项目越来越复杂, 目录可能会越来越深, 这时候会出现这样的导入路径:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'../../../utils/dom'</span>;</span><br></pre></td></tr></table></figure><p>首先这种导入语句非常不优雅, 而且可读性很差. 当你在不清楚当前文件的目录上下文时, 你不知道具体模块在哪; 即使你知道当前文件的位置, 你也需要跟随导入路径在目录树中向上追溯在能定位到具体模块. 所以这种相对路径是比较反人类的.</p><p>另外这种导入路径不方便模块迁移(尽管 Vscode 支持移动文件时重构导入路径), 文件迁移需要重写这些相对导入路径.</p><p><strong>所以一般推荐相对路径导入不应该超过两级, 即只能是<code>../</code>和<code>./</code></strong>. 可以尝试将<strong>相对路径转换成绝对路径形式</strong>, 例如<code>webpack</code>中可以配置<code>resolve.alias</code>属性来实现:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">resolve: &#123;</span><br><span class="line">  ...</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="comment">// 可以直接使用~访问相对于src目录的模块</span></span><br><span class="line">    <span class="comment">// 如 ~/components/Button</span></span><br><span class="line">    <span class="string">'~'</span>: context,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以这样子导入相对于<code>src</code>的模块:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'~/utils/dom'</span>;</span><br></pre></td></tr></table></figure><p>扩展</p><ul><li>对于 Typescript 可以配置<a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping" target="_blank" rel="noopener">paths</a>选项;</li><li>对于 babel 可以使用<a href="https://www.npmjs.com/package/babel-plugin-module-resolver" target="_blank" rel="noopener"><code>babel-plugin-module-resolver</code></a>插件来转换为相对路径</li></ul><p><br></p><hr><p><br></p><h2 id="6-拆分"><a href="#6-拆分" class="headerlink" title="6. 拆分"></a>6. 拆分</h2><h3 id="1️⃣-拆分-render-方法"><a href="#1️⃣-拆分-render-方法" class="headerlink" title="1️⃣ 拆分 render 方法"></a>1️⃣ 拆分 render 方法</h3><p>当 render 方法的 JSX 结构非常复杂的时候, 首先应该尝试分离这些 JSX, 最简单的做法的就是拆分为多个子 render 方法:</p><p>  <img src="/images/04/sub-render.png" width="600"></p><p>当然这种方式只是暂时让 render 方法看起来没有那么复杂, 它并没有拆分组件本身, 所有输入和状态依然聚集在一个组件下面. 所以通常拆分 render 方法只是重构的第一步: 随着组件越来越复杂, 表现为文件越来越长, 笔者一般将 300 行作为一个阈值, <strong>超过 300 行则说明需要对这个组件进进一步拆分</strong></p><p><br></p><hr><p><br></p><h3 id="2️⃣-拆分为组件"><a href="#2️⃣-拆分为组件" class="headerlink" title="2️⃣ 拆分为组件"></a>2️⃣ 拆分为组件</h3><p>如果已经按照 👆 上述方法对组件的 render 拆分为多个子 render, 当一个组件变得臃肿时, 就可以方便地将这些子 render 方法拆分为组件. 一般组件抽离有以下几种方式:</p><ol><li>纯渲染拆分: 子 render 方法一般是纯渲染的, 他们可以很直接地抽离为<em>无状态组件</em></li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; visible &#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Modal</span><br><span class="line">      visible=&#123;visible&#125;</span><br><span class="line">      title=&#123;<span class="keyword">this</span>.getLocale(<span class="string">'title'</span>)&#125;</span><br><span class="line">      width=&#123;<span class="keyword">this</span>.width&#125;</span><br><span class="line">      maskClosable=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">      onOk=&#123;<span class="keyword">this</span>.handleOk&#125;</span><br><span class="line">      onCancel=&#123;<span class="keyword">this</span>.handleCancel&#125;</span><br><span class="line">      footer=&#123;&lt;Footer &#123;...&#125;&gt;&lt;<span class="regexp">/Footer&gt;&#125;</span></span><br><span class="line"><span class="regexp">    &gt;</span></span><br><span class="line"><span class="regexp">    &lt;Body &#123;...&#125;&gt;&lt;/</span>Body&gt;</span><br><span class="line">  &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>纯逻辑拆分: 按照<code>逻辑和视图分离</code>的原则, 将逻辑控制部分抽离到 hooks 或高阶组件中</li><li>逻辑和渲染拆分: 将相关的视图和逻辑抽取出去形成一个独立的组件, 这是更为彻底的拆分方式, 贯彻单一职责原则.</li></ol><p><br></p><hr><p><br></p><h2 id="7-组件划分示例"><a href="#7-组件划分示例" class="headerlink" title="7. 组件划分示例"></a>7. 组件划分示例</h2><p>我们一般会从 UI 原型图中分析和划分组件, 在 React 官方的<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">Thinking in react</a>也提到通过 UI 来划分组件层级: “<em>这是因为 UI 和数据模型往往遵循着相同的信息架构，这意味着将 UI 划分成组件的工作往往是很容易的。只要把它划分成能准确表示你数据模型的一部分的组件就可以</em>“. 组件划分除了需要遵循上文 👆 提到的一些原则, 他还依赖于你的开发经验.</p><p>本节通过一个简单的应用讲述划分组件的过程. 这是某政府部门的服务申报系统, 一共由四个页面组成:</p><center><br>  <img src="/images/04/demo-all.png" width="800"><br></center><h3 id="1️⃣-划分页面"><a href="#1️⃣-划分页面" class="headerlink" title="1️⃣ 划分页面"></a>1️⃣ 划分页面</h3><p>页面通常是最顶层的组件单元, 划分页面非常简单, 我们根据原型图就可以划分四个页面: <code>ListPage</code>, <code>CreatePage</code>, <code>PreviewPage</code>, <code>DetailPage</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  containers/</span><br><span class="line">    ListPage/</span><br><span class="line">    CreatePage/</span><br><span class="line">    PreviewPage/</span><br><span class="line">    DetailPage/</span><br><span class="line">    index.tsx     # 根组件, 一般在这里定义路由</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="2️⃣-划分基础-ui-组件"><a href="#2️⃣-划分基础-ui-组件" class="headerlink" title="2️⃣ 划分基础 UI 组件"></a>2️⃣ 划分基础 UI 组件</h3><p>首先看<code>ListPage</code></p><p>  <img src="/images/04/ListPage.png" width="400"></p><p>ListPage 根据 UI 可以划分为下面这些组件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ScrollView        # 滚动视图, 提供下拉刷新, 无限加载等功能</span><br><span class="line">  List            # 列表容器, 布局组件</span><br><span class="line">    Item          # 列表项, 布局组件, 提供header, body等占位符</span><br><span class="line">      props - header</span><br><span class="line">         Title       # 渲染标题</span><br><span class="line">      props - after</span><br><span class="line">         Time        # 渲染时间</span><br><span class="line">      props - body</span><br><span class="line">         Status      # 渲染列表项的状态</span><br></pre></td></tr></table></figure><p>再看看<code>CreatePage</code></p><p>  <img src="/images/04/CreatePage.png" width="400"></p><p>这是一个表单填写页面, 为了提高表单填写体验, 这里划分为多个步骤; 每个步骤里有还有多个表单分组; 每个表单的结构都差不多, 左边是 label 展示, 右边是实际表单组件, 所以根据 UI 可以对组件进行这样的划分:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CreatePage</span><br><span class="line">  Steps            # 步骤容器, 提供了步骤布局和步骤切换等功能</span><br><span class="line">    Step           # 单一步骤容器</span><br><span class="line">      List         # 表单分组</span><br><span class="line">        List.Item  # 表单容器, 支持设置label</span><br><span class="line">          Input    # 具体表单类型</span><br><span class="line">          Address</span><br><span class="line">          NumberInput</span><br><span class="line">          Select</span><br><span class="line">          FileUpload</span><br></pre></td></tr></table></figure><blockquote><p>组件命名的建议: 对于集合型组件, 一般会使用单复数命名, 例如上面的 Steps/Step; List/Item 这种形式也比较常见, 例如 Form/Form.Item, 这种形式比较适合作为子组件形式. 可以学习一下第三方组件库是怎么给组件命名的.</p></blockquote><p>再看一下<code>PreviewPage</code>, PreviewPage 是创建后的数据预览页面, 数据结构和页面结构和 CreatePage 差不多. 将Steps 对应到 Preview 组件, Step 对应到 Preview.Item. Input 对应到 Input.Preview:</p><p>  <img src="/images/04/PreviewPage.png" width="400"></p><p><br></p><hr><p><br></p><h3 id="3️⃣-设计组件的状态"><a href="#3️⃣-设计组件的状态" class="headerlink" title="3️⃣ 设计组件的状态"></a>3️⃣ 设计组件的状态</h3><p>对于 ListPage 来说状态比较简单, 这里主要讨论 CreatePage 的状态. CreatePage 的特点:</p><ul><li>表单组件使用受控模式, 本身不会存储表单的状态. 另外表单之间的状态可能是联动的</li><li>状态需要在 CreatePage 和 PreviewPage 之间共享</li><li>需要对表单进行统一校验</li><li>草稿保存</li></ul><p>由于需要在 CreatePage 和 PreviewPage 中共享数据, 表单的状态应该抽取和提升到父级. 在这个项目的实际开发中, 我的做法是创建一个 FormStore 的 Context 组件, 下级组件通过这个 context 来统一存储数据. 另外我决定使用配置的方式, 来渲染动态这些表单. 大概的结构如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// CreatePage/index.tsx</span><br><span class="line">&lt;FormStore defaultValue=&#123;draft&#125; onChange=&#123;saveDraft&#125;&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&quot;/create/preview&quot; component=&#123;Preview&#125; /&gt;</span><br><span class="line">    &lt;Route path=&quot;/create&quot; component=&#123;Create&#125; /&gt;</span><br><span class="line">  &lt;/Switch&gt;</span><br><span class="line">&lt;/FormStore&gt;</span><br><span class="line"></span><br><span class="line">// CreatePage/Create.tsx</span><br><span class="line">&lt;Steps&gt;</span><br><span class="line">  &#123;steps.map(i =&gt;</span><br><span class="line">    &lt;Step key=&#123;i.name&#125;&gt;</span><br><span class="line">      &lt;FormRenderer forms=&#123;i.forms&#125;  /&gt; &#123;/* forms为表单配置, 根据配置的表单类型渲染表单组件, 从FormStore的获取和存储值 */&#125;</span><br><span class="line">    &lt;/Step&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/Steps&gt;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="8-文档"><a href="#8-文档" class="headerlink" title="8. 文档"></a>8. 文档</h2><p>组件的文档化推荐使用<a href="https://storybook.js.org" target="_blank" rel="noopener">Storybook</a>, 这是一个组件 <code>Playground</code>, 有以下特性</p><ul><li>可交互的组件示例</li><li>可以用于展示组件的文档. 支持 props 生成和 markdown</li><li>可以用于组件测试. 支持组件结构测试, 交互测试, 可视化测试, 可访问性或者手动测试</li><li>丰富的插件生态</li></ul><p><a href="https://storybooks-official.netlify.com" target="_blank" rel="noopener">React 示例</a>. 由于篇幅原因, Storybook 就不展开细节, 有兴趣的读者可以参考官方文档.</p><p><br></p><hr><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://jaysoo.ca/2016/02/28/organizing-redux-application/#rule-2-create-strict-module-boundaries" target="_blank" rel="noopener">Three Rules For Structuring (Redux) Applications</a></li><li><a href="https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/" target="_blank" rel="noopener">How To Scale React Applications</a></li><li><a href="http://cn.redux.js.org/docs/faq/CodeStructure.html" target="_blank" rel="noopener">Redux 常见问题：代码结构</a></li><li><a href="https://basarat.gitbooks.io/typescript/docs/tips/defaultIsBad.html" target="_blank" rel="noopener">export default considered harmful</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html" target="_blank" rel="noopener">JavaScript 模块的循环加载</a></li><li><a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">thinking-in-react</a></li><li><a href="https://speakerdeck.com/vasa/building-multitenant-ui-with-react-dot-js?slide=16" target="_blank" rel="noopener">Building Multitenant UI with React.js</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个复杂的应用都是由简单的应用发展而来的, 随着越来越多的功能加入项目, 代码就会变得越来越难以控制. 本文章主要探讨在大型项目中如何对组件进行组织, 让项目具备可维护性.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系列目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结01 - 类型检查</title>
    <link href="https://bobi.ink/2019/05/10/react-component-design-01/"/>
    <id>https://bobi.ink/2019/05/10/react-component-design-01/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-12T11:42:24.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系列引言"><a href="#系列引言" class="headerlink" title="系列引言"></a>系列引言</h2><p>最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对<strong>React 组件设计的相关实践和规范</strong>整理了一些文档, 将部分章节分享了出来. 由于经验有限, 文章可能会有某些错误, 希望大家指出, 互相交流.</p><p>由于篇幅太长, 所以拆分为几篇文章. 主要有以下几个主题:</p><ul><li><a href="./">01 类型检查</a></li><li>02 组件的组织 待更新</li><li>03 样式的管理 待更新</li><li>04 组件的思维 待更新</li><li>05 状态管理 待更新</li></ul><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>静态类型检查对于当今的前端项目越来越不可或缺, 尤其是大型项目. <strong>它可以在开发时就避免许多类型问题, 减少低级错误的; 另外通过类型智能提示, 可以提高编码的效率; 有利于书写自描述的代码(类型即文档); 方便代码重构(配合 IDE 可以自动重构)</strong>. 对于静态类型检查的好处这里就不予赘述, 读者可以查看这个回答<a href="https://www.zhihu.com/question/28016252/answer/39056940" target="_blank" rel="noopener">flow.js/typescript 这类定义参数类型的意义何在？</a>.</p><p>Javascript 的类型检查器主要有<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">Typescript</a>和<a href="https://flow.org" target="_blank" rel="noopener">Flow</a>, 笔者两者都用过, Typescript 更强大一些, 可以避免很多坑, 有更好的生态(例如第三方库类型声明), 而且 VSCode 内置支持. 而对于 Flow, 连 Facebook 自己的开源项目(如 Yarn, Jest)都抛弃了它, 所以不建议入坑. 所以本篇文章使用 Typescript(v3.3) 对 React 组件进行类型检查声明</p><p>建议通过官方文档来<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">学习 Typescript</a>. 笔者此前也整理了 Typescript 相关的<a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">思维导图(mindnode)</a></p><blockquote><p>当然 Flow 也有某些 Typescript 没有的特性: <a href="https://github.com/niieani/typescript-vs-flowtype" target="_blank" rel="noopener">typescript-vs-flowtype</a></p></blockquote><blockquote><p>React 组件类型检查依赖于<code>@types/react</code>和<code>@types/react-dom</code></p></blockquote><blockquote><p>直接上手使用试用 <br> <a href="https://codesandbox.io/s/5vx5wwmkvx?fontsize=14" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit typescript-react-playground"></a></p></blockquote><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#系列引言">系列引言</a></li><li><a href="#类型检查">类型检查</a><ul><li><a href="#1-函数组件">1. 函数组件</a><ul><li><a href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出">1️⃣ <strong>使用<code>ComponentNameProps</code> 形式命名 Props 类型, 并导出</strong></a></li><li><a href="#2️⃣-优先使用fc类型来声明函数组件">2️⃣ <strong>优先使用<code>FC</code>类型来声明函数组件</strong></a></li><li><a href="#3️⃣-不要直接使用export-default导出组件">3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</a></li><li><a href="#4️⃣-默认-props-声明">4️⃣ <strong>默认 props 声明</strong></a></li><li><a href="#5️⃣-泛型函数组件">5️⃣ <strong>泛型函数组件</strong></a></li><li><a href="#6️⃣-子组件声明">6️⃣ <strong>子组件声明</strong></a></li><li><a href="#7️⃣-forwarding-refs">7️⃣ <strong>Forwarding Refs</strong></a></li></ul></li><li><a href="#2-类组件">2. 类组件</a><ul><li><a href="#1️⃣-继承-component-或-purecomponent">1️⃣ <strong>继承 Component 或 PureComponent</strong></a></li><li><a href="#2️⃣-使用static-defaultprops定义默认-props">2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></a></li><li><a href="#3️⃣-子组件声明">3️⃣ <strong>子组件声明</strong></a></li><li><a href="#4️⃣-泛型">4️⃣ <strong>泛型</strong></a></li></ul></li><li><a href="#3-高阶组件">3. 高阶组件</a></li><li><a href="#4-render-props">4. Render Props</a></li><li><a href="#5-context">5. Context</a></li><li><a href="#6-杂项">6. 杂项</a><ul><li><a href="#1️⃣-使用handleevent命名事件处理器">1️⃣ <strong>使用<code>handleEvent</code>命名事件处理器</strong>.</a></li><li><a href="#2️⃣-内置事件处理器的类型">2️⃣ <strong>内置事件处理器的类型</strong></a></li><li><a href="#3️⃣-自定义组件暴露事件处理器类型">3️⃣ <strong>自定义组件暴露事件处理器类型</strong></a></li><li><a href="#4️⃣-获取原生元素-props-定义">4️⃣ <strong>获取原生元素 props 定义</strong></a></li><li><a href="#5️⃣-不要使用-proptypes">5️⃣ <strong>不要使用 PropTypes</strong></a></li><li><a href="#6️⃣-styled-components">6️⃣ <strong>styled-components</strong></a></li><li><a href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明">7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></a></li><li><a href="#8️⃣-为文档生成做好准备">8️⃣ <strong>为文档生成做好准备</strong></a></li><li><a href="#9️⃣-开启-strict-模式">9️⃣ <strong>开启 strict 模式</strong></a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h3 id="1-函数组件"><a href="#1-函数组件" class="headerlink" title="1. 函数组件"></a>1. 函数组件</h3><p>React Hooks 出现后, 函数组件有了更多出镜率. 由于函数组件只是普通函数, 它非常容易进行类型声明</p><p><br></p><h4 id="1️⃣-使用componentnameprops-形式命名-props-类型-并导出"><a href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出" class="headerlink" title="1️⃣ 使用ComponentNameProps 形式命名 Props 类型, 并导出"></a>1️⃣ <strong>使用<code>ComponentNameProps</code> 形式命名 Props 类型, 并导出</strong></h4><p><br></p><h4 id="2️⃣-优先使用fc类型来声明函数组件"><a href="#2️⃣-优先使用fc类型来声明函数组件" class="headerlink" title="2️⃣ 优先使用FC类型来声明函数组件"></a>2️⃣ <strong>优先使用<code>FC</code>类型来声明函数组件</strong></h4><p><code>FC</code>是<code>FunctionComponent</code>的简写, 这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Props类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyComponent: FC&lt;MyComponentProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>你也可以直接使用普通函数来进行组件声明, 下文会看到这种形式更加灵活:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  <span class="comment">// 手动声明children</span></span><br><span class="line">  children?: React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props: MyComponentProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="3️⃣-不要直接使用export-default导出组件"><a href="#3️⃣-不要直接使用export-default导出组件" class="headerlink" title="3️⃣ 不要直接使用export default导出组件."></a>3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</h4><p>这种方式导出的组件在<code>React Inspector</code>查看时会显示为<code>Unknown</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (props: &#123;&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>如果非得这么做, 请使用<code>命名 function</code> 定义:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">props: &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;xxx&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-默认-props-声明"><a href="#4️⃣-默认-props-声明" class="headerlink" title="4️⃣ 默认 props 声明"></a>4️⃣ <strong>默认 props 声明</strong></h4><p>实际上截止目前对于上面的使用<code>FC</code>类型声明的函数组件并<a href="https://github.com/Microsoft/TypeScript/issues/27425" target="_blank" rel="noopener">不能完美支持 defaultProps</a>:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ❌! missing name</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure><p>笔者一般喜欢这样子声明默认 props:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>; <span class="comment">// 声明为可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用对象默认属性值语法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name = 'TJ' &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br></pre></td></tr></table></figure><p>如果非得使用 defaultProps, 可以这样子声明 👇. Typescript 可以推断和在函数上定义的属性, 这个特性在 Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#properties-declarations-on-functions" target="_blank" rel="noopener">3.1</a>开始支持.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用函数参数声明</span></span><br><span class="line"><span class="comment">// PropsWithChildren只是扩展了children, 完全可以自己声明</span></span><br><span class="line"><span class="comment">// type PropsWithChildren&lt;P&gt; = P &amp; &#123;</span></span><br><span class="line"><span class="comment">//    children?: ReactNode;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">const</span> Hello = <span class="function">(<span class="params">&#123; name &#125;: PropsWithChildren&lt;HelloProps&gt;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ✅ ok!</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure><p>这种方式也非常简洁, 只不过 defaultProps 的类型和组件本身的 props 没有关联性, 这会使得 defaultProps 无法得到类型约束, 所以必要时进一步显式声明 defaultProps 的类型:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Hello.defaultProps = &#123; name: <span class="string">'TJ'</span> &#125; <span class="keyword">as</span> Partial&lt;HelloProps&gt;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5️⃣-泛型函数组件"><a href="#5️⃣-泛型函数组件" class="headerlink" title="5️⃣ 泛型函数组件"></a>5️⃣ <strong>泛型函数组件</strong></h4><p>泛型在一下列表型或容器型的组件中比较常用, 直接使用<code>FC</code>无法满足需求:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ListProps&lt;T&gt; &#123;</span><br><span class="line">  visible: <span class="built_in">boolean</span>;</span><br><span class="line">  list: T[];</span><br><span class="line">  renderItem: <span class="function">(<span class="params">item: T, index: <span class="built_in">number</span></span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: ListProps&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;List</span><br><span class="line">      list=&#123;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">      renderItem=&#123;<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/*自动推断i为number类型*/</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="6️⃣-子组件声明"><a href="#6️⃣-子组件声明" class="headerlink" title="6️⃣ 子组件声明"></a>6️⃣ <strong>子组件声明</strong></h4><p>使用<code>Parent.Child</code>形式的 JSX 可以让节点父子关系更加直观, 它类似于一种命名空间的机制, 可以避免命名冲突. 相比<code>ParentChild</code>这种命名方式, <code>Parent.Child</code>更为优雅些. 当然也有可能让代码变得啰嗦.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutProps &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutHeaderProps &#123;&#125; <span class="comment">// 采用ParentChildProps形式命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutFooterProps &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">props: PropsWithChildren&lt;LayoutProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 作为父组件的属性</span></span><br><span class="line"><span class="regexp">Layout.Header = (props: PropsWithChildren&lt;LayoutHeaderProps&gt;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;div className="header"&gt;&#123;props.children&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Layout.Footer = <span class="function">(<span class="params">props: PropsWithChildren&lt;LayoutFooterProps&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"footer"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Test</span></span><br><span class="line"><span class="regexp">&lt;Layout&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Layout.Header&gt;header&lt;/</span>Layout.Header&gt;</span><br><span class="line">  &lt;Layout.Footer&gt;footer&lt;<span class="regexp">/Layout.Footer&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Layout&gt;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="7️⃣-forwarding-refs"><a href="#7️⃣-forwarding-refs" class="headerlink" title="7️⃣ Forwarding Refs"></a>7️⃣ <strong>Forwarding Refs</strong></h4><p><code>React.forwardRef</code> 在 16.3 新增, 可以用于转发 ref, 适用于 HOC 和函数组件.</p><p>函数组件在 16.8.4 之前是不支持 ref 的, 配合 forwardRef 和 useImperativeHandle 可以让函数组件向外暴露方法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment"> * MyModal.tsx</span></span><br><span class="line"><span class="comment"> ****************************/</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useImperativeHandle, FC, useRef, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalProps &#123;</span><br><span class="line">  title?: React.ReactNode;</span><br><span class="line">  onOk?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onCancel?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露的方法, 适用`&#123;ComponentName&#125;Methods`形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalMethods &#123;</span><br><span class="line">  show(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyModal = React.forwardRef&lt;MyModalMethods, MyModalProps&gt;<span class="function">(<span class="params">(<span class="params">props, ref</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> [visible, setVisible] = useState(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 初始化ref暴露的方法</span></span></span></span><br><span class="line"><span class="function"><span class="params">  useImperativeHandle(<span class="params">ref, (<span class="params"></span>) =&gt; (<span class="params">&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">    show: (<span class="params"></span>) =&gt; setVisible(<span class="params"><span class="literal">true</span></span>),</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">  &#125;</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> &lt;Modal visible=&#123;visible&#125;&gt;...&lt;/Modal&gt;;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/*******************</span></span><br><span class="line"><span class="function"> * <span class="params">Test</span>.<span class="params">tsx</span></span></span><br><span class="line"><span class="function"> *******************/</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">Test</span>: <span class="params">FC</span>&lt;&#123;&#125;&gt; = <span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 引用</span></span><br><span class="line">  <span class="keyword">const</span> modal = useRef&lt;MyModalMethods | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> confirm = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modal.current) &#123;</span><br><span class="line">      modal.current.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleOk = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;confirm&#125;&gt;show&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MyModal ref=&#123;modal&#125; onOk=&#123;handleOk&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="2-类组件"><a href="#2-类组件" class="headerlink" title="2. 类组件"></a>2. 类组件</h3><p>相比函数, 基于类的类型检查可能会更好理解(例如那些熟悉传统面向对象编程语言的开发者).</p><h4 id="1️⃣-继承-component-或-purecomponent"><a href="#1️⃣-继承-component-或-purecomponent" class="headerlink" title="1️⃣ 继承 Component 或 PureComponent"></a>1️⃣ <strong>继承 Component 或 PureComponent</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先导出Props声明, 同样是&#123;ComponentName&#125;Props形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> CounterProps &#123;</span><br><span class="line">  defaultCount: <span class="built_in">number</span>; <span class="comment">// 可选props, 不需要?修饰</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组件状态, 不需要暴露</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类注释</span></span><br><span class="line"><span class="comment"> * 继承React.Component, 并声明Props和State类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Counter <span class="keyword">extends</span> React.Component&lt;CounterProps, State&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    defaultCount: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化State</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> state = &#123;</span><br><span class="line">    count: <span class="keyword">this</span>.props.defaultCount,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 声明周期方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 建议靠近componentDidMount, 资源消费和资源释放靠近在一起, 方便review</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentWillUnmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidCatch() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidUpdate(prevProps: CounterProps, prevState: State) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 渲染函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.decrement&#125;&gt;Decrement&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>**</span><br><span class="line">   * ① 组件私有方法, 不暴露</span><br><span class="line">   * ② 使用类实例属性+箭头函数形式绑定<span class="keyword">this</span></span><br><span class="line">   *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  private increment = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count + 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  private decrement = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count - 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="2️⃣-使用static-defaultprops定义默认-props"><a href="#2️⃣-使用static-defaultprops定义默认-props" class="headerlink" title="2️⃣ 使用static defaultProps定义默认 props"></a>2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></h4><p>Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx" target="_blank" rel="noopener">3.0</a>开始支持对使用 defaultProps 对 JSX props 进行推断, 在 defaultProps 中定义的 props 可以不需要’?’可选操作符修饰. 代码如上 👆</p><p><br></p><h4 id="3️⃣-子组件声明"><a href="#3️⃣-子组件声明" class="headerlink" title="3️⃣ 子组件声明"></a>3️⃣ <strong>子组件声明</strong></h4><p>类组件可以使用静态属性形式声明子组件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Layout <span class="keyword">extends</span> React.Component&lt;LayoutProps&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Header = Header;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Footer = Footer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-泛型"><a href="#4️⃣-泛型" class="headerlink" title="4️⃣ 泛型"></a>4️⃣ <strong>泛型</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> List&lt;T&gt; <span class="keyword">extends</span> React.Component&lt;ListProps&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="3-高阶组件"><a href="#3-高阶组件" class="headerlink" title="3. 高阶组件"></a>3. 高阶组件</h3><p>在 React Hooks 出来之前, 高阶组件是 React 的一个重要逻辑复用方式. 相比较而言高阶组件比较重, 且难以理解, 容易造成<code>嵌套地狱(wrapper)</code>. 另外对 Typescript 类型化也不友好(以前会使用<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/9c1c7e78a9a2b4af8e2cda842c3693f67bb9e42d/types/react-router/index.d.ts#L137" target="_blank" rel="noopener">Omit</a>来计算导出的 props). 所以新项目还是建议使用 React Hooks.</p><p>一个简单的高阶组件:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给指定组件注入'主题'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withTheme</span>&lt;<span class="title">P</span>&gt;(<span class="params">Component: React.ComponentType&lt;P &amp; ThemeProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * WithTheme 自己暴露的Props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件的props, 忽略ThemeProps, 外部不需要传递这些属性</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">type</span> WithThemeProps = P &amp; OwnProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> WithTheme = <span class="function">(<span class="params">props: WithThemeProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">    <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">      primary: <span class="string">'red'</span>,</span><br><span class="line">      secondary: <span class="string">'blue'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  WithTheme.displayName = <span class="string">`withTheme<span class="subst">$&#123;Component.displayName&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> WithTheme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">const</span> Foo: FC&lt;&#123; a: <span class="built_in">number</span> &#125; &amp; ThemeProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &lt;div style=&#123;&#123; color: props.primary &#125;&#125; /&gt;;</span><br><span class="line"><span class="keyword">const</span> FooWithTheme = withTheme(Foo);</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  &lt;FooWithTheme a=&#123;<span class="number">1</span>&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再重构一下:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽取出通用的高阶组件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> HOC&lt;InjectedProps, OwnProps = &#123;&#125;&gt; = &lt;P&gt;(</span><br><span class="line">  Component: React.ComponentType&lt;P &amp; InjectedProps&gt;,</span><br><span class="line">) =&gt; React.ComponentType&lt;P &amp; OwnProps&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withTheme: HOC&lt;ThemeProps&gt; = <span class="function"><span class="params">Component</span> =&gt;</span> props =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">  <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用高阶组件还有一些痛点:</p><ul><li>无法完美地使用 ref(这已不算什么痛点)<ul><li>在 React.forwardRef 发布之前, 有一些库会使用 innerRef 或者 wrapperRef, 转发给封装的组件的 ref.</li><li>无法推断 ref 引用组件的类型, 需要显式声明.</li></ul></li><li>高阶组件类型报错很难理解</li></ul><p><br></p><hr><p><br></p><h3 id="4-render-props"><a href="#4-render-props" class="headerlink" title="4. Render Props"></a>4. Render Props</h3><p>React 的 props(包括 children)并没有限定类型, 它可以是一个函数. 于是就有了 render props, 这是和高阶组件一样常见的模式:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeConsumerProps &#123;</span><br><span class="line">  children: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeConsumer = <span class="function">(<span class="params">props: ThemeConsumerProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fakeTheme = &#123; primary: <span class="string">'red'</span>, secondary: <span class="string">'blue'</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> props.children(fakeTheme);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line">&lt;ThemeConsumer&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">&#123; primary &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div style=&#123;&#123; color: primary &#125;&#125; /&gt;;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/ThemeConsumer&gt;;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="5-context"><a href="#5-context" class="headerlink" title="5. Context"></a>5. Context</h3><p>Context 提供了一种跨组件间状态共享机制</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Theme &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Context的类型, 以&#123;Name&#125;ContextValue命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeContextValue &#123;</span><br><span class="line">  theme: Theme;</span><br><span class="line">  onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Context, 并设置默认值, 以&#123;Name&#125;Context命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext&lt;ThemeContextValue&gt;(&#123;</span><br><span class="line">  theme: &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  onThemeChange: noop,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provider, 以&#123;Name&#125;Provider命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeProvider: FC&lt;&#123; theme: Theme; onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;&#123; theme: props.theme, onThemeChange: props.onThemeChange &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 暴露hooks, 以use&#123;Name&#125;命名</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">export function useTheme() &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="6-杂项"><a href="#6-杂项" class="headerlink" title="6. 杂项"></a>6. 杂项</h3><h4 id="1️⃣-使用handleevent命名事件处理器"><a href="#1️⃣-使用handleevent命名事件处理器" class="headerlink" title="1️⃣ 使用handleEvent命名事件处理器."></a>1️⃣ <strong>使用<code>handleEvent</code>命名事件处理器</strong>.</h4><p>如果存在多个相同事件处理器, 则按照<code>handle{Type}{Event}</code>命名, 例如 handleNameChange.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback&lt;React.MouseEventHandler&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    evt.preventDefault();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;handleClick&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2️⃣-内置事件处理器的类型"><a href="#2️⃣-内置事件处理器的类型" class="headerlink" title="2️⃣ 内置事件处理器的类型"></a>2️⃣ <strong>内置事件处理器的类型</strong></h4><p><code>@types/react</code>内置了以下事件处理器的类型 👇</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EventHandler&lt;E <span class="keyword">extends</span> SyntheticEvent&lt;<span class="built_in">any</span>&gt;&gt; = &#123; bivarianceHack(event: E): <span class="built_in">void</span> &#125;[<span class="string">'bivarianceHack'</span>];</span><br><span class="line"><span class="keyword">type</span> ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> CompositionEventHandler&lt;T = Element&gt; = EventHandler&lt;CompositionEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure><p>可以简洁地声明事件处理器类型:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ChangeEventHandler &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 可以限定具体Target的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback&lt;ChangeEventHandler&lt;HTMLInputElement&gt;&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(evt.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;input onChange=&#123;handleChange&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3️⃣-自定义组件暴露事件处理器类型"><a href="#3️⃣-自定义组件暴露事件处理器类型" class="headerlink" title="3️⃣ 自定义组件暴露事件处理器类型"></a>3️⃣ <strong>自定义组件暴露事件处理器类型</strong></h4><p>和原生 html 元素一样, 自定义组件应该暴露自己的事件处理器类型, 尤其是较为复杂的事件处理器, 这样可以避免开发者手动为每个事件处理器的参数声明类型</p><p>自定义事件处理器类型以<code>{ComponentName}{Event}Handler</code>命名. 为了和原生事件处理器类型区分, 不使用<code>EventHandler</code>形式的后缀</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadValue &#123;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露事件处理器类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> UploadChangeHandler = <span class="function">(<span class="params">value?: UploadValue, file?: File</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadProps &#123;</span><br><span class="line">  value?: UploadValue;</span><br><span class="line">  onChange?: UploadChangeHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Upload: FC&lt;UploadProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;...&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-获取原生元素-props-定义"><a href="#4️⃣-获取原生元素-props-定义" class="headerlink" title="4️⃣ 获取原生元素 props 定义"></a>4️⃣ <strong>获取原生元素 props 定义</strong></h4><p>有些场景我们希望原生元素扩展一下一些 props. 所有原生元素 props 都继承了<code>React.HTMLAttributes</code>, 某些特殊元素也会扩展了自己的属性, 例如<code>InputHTMLAttributes</code>. 具体可以参考<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/eafef8bd049017b3998939de2edbab5d8a96423b/types/react/index.d.ts#L203" target="_blank" rel="noopener"><code>React.createElement</code></a>方法的实现</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fixClass</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">T</span> <span class="title">extends</span> <span class="title">Element</span> = <span class="title">HTMLDivElement</span>,</span></span><br><span class="line"><span class="function">  <span class="title">Attribute</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt; = <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params">cls: <span class="built_in">string</span>, <span class="keyword">type</span>: keyof React.ReactHTML = 'div'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FixedClassName: FC&lt;Attribute&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="keyword">type</span>, &#123; ...props, className: <span class="string">`<span class="subst">$&#123;cls&#125;</span> <span class="subst">$&#123;props.className&#125;</span>`</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FixedClassName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Container = fixClass(<span class="string">'card'</span>);</span><br><span class="line"><span class="keyword">const</span> Header = fixClass(<span class="string">'card__header'</span>, <span class="string">'header'</span>);</span><br><span class="line"><span class="keyword">const</span> Body = fixClass(<span class="string">'card__body'</span>, <span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">const</span> Footer = fixClass(<span class="string">'card__body'</span>, <span class="string">'footer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &lt;Header&gt;header&lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Body&gt;header&lt;/</span>Body&gt;</span><br><span class="line">      &lt;Footer&gt;footer&lt;<span class="regexp">/Footer&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Container&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5️⃣-不要使用-proptypes"><a href="#5️⃣-不要使用-proptypes" class="headerlink" title="5️⃣ 不要使用 PropTypes"></a>5️⃣ <strong>不要使用 PropTypes</strong></h4><p>有了 Typescript 之后可以安全地约束 Props 和 State, 没有必要引入 React.PropTypes, 而且它的表达能力比较弱</p><p><br></p><h4 id="6️⃣-styled-components"><a href="#6️⃣-styled-components" class="headerlink" title="6️⃣ styled-components"></a>6️⃣ <strong>styled-components</strong></h4><p>styled-components 是目前最流行的<code>CSS-in-js</code>库, Typescript 在 2.9 支持泛型<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#generic-type-arguments-in-generic-tagged-templates" target="_blank" rel="noopener"><code>标签模板</code></a>. 这意味着可以简单地对 styled-components 创建的组件进行类型约束</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖于@types/styled-components</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components/macro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1&lt;&#123; active?: <span class="built_in">boolean</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; (props.active ? 'red' : 'gray')&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展已有组件</span></span><br><span class="line"><span class="keyword">const</span> NewHeader = styled(Header)&lt;&#123; customColor: <span class="built_in">string</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; props.customColor&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>了解更多<a href="https://www.styled-components.com/docs/api#typescript" target="_blank" rel="noopener">styled-components 和 Typescript</a></p><p><br></p><h4 id="7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明"><a href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明" class="headerlink" title="7️⃣ 为没有提供 Typescript 声明文件的第三方库自定义模块声明"></a>7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></h4><p>笔者一般习惯在项目根目录下(和 tsconfig.json 同在一个目录下)放置一个<code>global.d.ts</code>. 放置项目的全局声明文件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /global.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模块声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'awesome-react-component' &#123;</span><br><span class="line">  <span class="comment">// 依赖其他模块的声明文件</span></span><br><span class="line">  <span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> Foo: React.FC&lt;&#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解更多<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">如何定义声明文件</a></p><p><br></p><h4 id="8️⃣-为文档生成做好准备"><a href="#8️⃣-为文档生成做好准备" class="headerlink" title="8️⃣ 为文档生成做好准备"></a>8️⃣ <strong>为文档生成做好准备</strong></h4><p>目前社区有多种 react 组件文档生成方案, 例如<a href="https://www.docz.site" target="_blank" rel="noopener"><code>docz</code></a>, <a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener"><code>styleguidist</code></a>还有<a href="https://github.com/storybooks/storybook" target="_blank" rel="noopener">storybook</a>. 它们底层都使用<a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener">react-docgen-typescript</a>对 Typescript 进行解析. 就目前而言, 它还有些坑, 而且解析比较慢. 不管不妨碍我们使用它的风格对代码进行注释:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Props注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ColumnProps <span class="keyword">extends</span> React.HTMLAttributes&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">/** prop1 description */</span></span><br><span class="line">  prop1?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">/** prop2 description */</span></span><br><span class="line">  prop2: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * prop3 description</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  prop3: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">/** prop4 description */</span></span><br><span class="line">  prop4: <span class="string">'option1'</span> | <span class="string">'option2'</span> | <span class="string">'option3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对组件进行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Column <span class="keyword">extends</span> Component&lt;ColumnProps, &#123;&#125;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;Column&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9️⃣-开启-strict-模式"><a href="#9️⃣-开启-strict-模式" class="headerlink" title="9️⃣ 开启 strict 模式"></a>9️⃣ <strong>开启 strict 模式</strong></h4><p>为了真正把 Typescript 用起来, 应该始终开启 strict 模式, 避免使用 any 类型声明.</p><p><br></p><hr><p><br></p><h3 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h3><ul><li><a href="https://github.com/piotrwitek/react-redux-typescript-guide" target="_blank" rel="noopener">piotrwitek/react-redux-typescript-guide</a></li><li><a href="https://www.zhihu.com/question/279911703" target="_blank" rel="noopener">TypeScript 如何完美地书写 React 中的 HOC？</a></li><li><a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">Typescript 官方文档</a></li><li><a href="https://basarat.gitbooks.io/typescript/docs/why-typescript.html" target="_blank" rel="noopener">Typescript-deep-dive</a></li><li><a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">Typescript 思维导图</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系列引言&quot;&gt;&lt;a href=&quot;#系列引言&quot; class=&quot;headerlink&quot; title=&quot;系列引言&quot;&gt;&lt;/a&gt;系列引言&lt;/h2&gt;&lt;p&gt;最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对&lt;strong&gt;R
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Rx建模入门</title>
    <link href="https://bobi.ink/2019/04/19/rxjs-by-example/"/>
    <id>https://bobi.ink/2019/04/19/rxjs-by-example/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-21T12:08:02.515Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何使用 Rx 的响应式编程思维来对业务逻辑进行建模, 你会了解到响应式编程的优势和业务抽象能力, 学会将现有的业务流程以数据流的方式表达出来. 你的工具库中不能少了 Rx 这件利器.</p><p>Rx 学习曲线陡峭是总所周知的, 我们接触的大部分编程语言或框架都是面向对象的. 在面对 Rx 这响应式编程的方式, 会觉得无从入手,<br>笔者也是 Rx 的初学者, 拜读过多次<a href="https://www.zhihu.com/people/sharpmaster/posts" target="_blank" rel="noopener">徐飞</a>Rx 的相关文章, 基本上都是云里雾里. 主要原因还是思维没有转换过来.</p><p>如果你不理解响应式编程的奥妙，是很难在<strong>‘面向场景编程’</strong>时考虑到 Rx 的优势. 笔者一般遵循’面向场景编程’, 即在对应的场景考虑不同的技术或框架. 可能是痛点还没有到难以忍受的地步，或许是现有应用还不够复杂，我目前为止还没接触到必须要应用 Rx 的场景.</p><p>我觉得应该反过来，采取刻意学习的方式来学习 Rx, 以流的方式来思考，再将其放在现有的场景中看是否有更简洁的解决方案或化学反应.<br>不得不说写 Rx 是一个比较有趣的事情。 但也要认识到 Rx 不是万金油，正如很多教程所说的 Rx 擅长复杂的异步协调，并不是所有场景都适合，一些问题有更简洁的解决方案</p><p><br></p><h2 id="rx-的建模过程"><a href="#rx-的建模过程" class="headerlink" title="Rx 的建模过程"></a>Rx 的建模过程</h2><p>对于 Rx 的入门者, 可以使用下面的流程, 一步一步将业务逻辑转换为 Rx 数据流来进行表达.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">流程图 -&gt; 数据流抽象 -&gt; 实现</span><br></pre></td></tr></table></figure><h3 id="①-流程图"><a href="#①-流程图" class="headerlink" title="① 流程图"></a><code>① 流程图</code></h3><p>首先从流程图开始, 这个阶段没什么特别的, 不管是响应式编程还是其他范式, 编码之前都需要缕清业务逻辑.</p><p>这个阶段使用<code>流程图</code>来描述技术无关的事务过程, 让业务逻辑更加清晰, 也方便我们识别业务流程的主体和关键事件.</p><blockquote><p>什么是业务逻辑? <a href="https://en.wikipedia.org/wiki/Business_logic" target="_blank" rel="noopener">wiki</a> 上这样定义:<br><strong>Business logic</strong> or domain logic is that part of the program which encodes the real-world business rules that determine how data can be created, displayed, stored, and changed. It prescribes how business objects interact with one another, and enforces the routes and the methods by which business objects are accessed and updated.<br><br> <strong>Business Rules</strong> describe the operations, definitions and constraints that apply to an organization. The operations collectively form a process; every business uses these processes to form systems that get things done.</p></blockquote><p><br><br><br></p><h3 id="②-数据流抽象"><a href="#②-数据流抽象" class="headerlink" title="② 数据流抽象"></a><code>② 数据流抽象</code></h3><p>Rx 的世界里面<em>一切皆流</em>, 换句话说就是<strong>面向流编程</strong>. 和<em>面向对象编程</em>把现实世界的实体抽象为对象一样. 响应式编程将业务中的<em>变动实体</em>(<em>想不到更好的词, 或者变量?</em>)抽象为流</p><p><strong>(1)首先需要识别什么是<em>变动实体</em></strong>? 变动实体一般是数据流的源头, 它驱动着业务走向. 像河流一样, 源头可能不只一个. 我认为变动实体至少具备以下特征之一:</p><ul><li>它是变动的. 例如鼠标的位置, 商品的价格, 随着时间的迁移状态会进行变动</li><li>它是业务的’输入’. 变动实体是一个系统的输入(外部事件)或者是另一个流(衍生)的输入.</li><li>它是业务的参与者(或者说业务的主体).</li><li>它表示业务的状态. 例如一个 todo 列表, 这是一个纯状态的流</li></ul><p><strong>(2)接着识别<em>变动实体</em>之间的关系</strong>. 主体之间的关系也就是流之间的关系, 这是 Rx 建模的核心. 只有理解了主体之间的关系, 才能将主体与业务流程串联起来, 才能真正地使用数据流的方式将业务表达出来. 在<a href="https://www.jianshu.com/p/c95e29854cb1" target="_blank" rel="noopener">重新理解响应式编程</a>一文中对’响应式编程’的定义和笔者的理解非常契合:</p><blockquote><p>响应式编程是一种通过异步和数据流来构建事务关系的编程模型 . 事务关系是响应式编程的核心理念, “数据流”和“异步”是实现这个核心理念的关键.</p></blockquote><p>这种关系和面向对象的类关系是不一样的, 面向对象的关系一般是指依赖关系. 而<strong>数据流之间关系, 是业务之间的实际关系</strong>, 比如流程 b 依赖流程 a, 数据流是变动实体之间的沟通桥梁.</p><p>一般以下面的方法来构建流之间的关系:</p><ul><li>分治: 将业务划分为多个模块(流), 一个大的流总是由小的流组成, 小的流职责更单一, 更容易理解和测试</li><li>变换: 将流映射为另外一个流. 一般用于状态变更或业务衍生(高阶流变换)</li><li>合并: 像河流一样, 数据流最终是需要汇聚在一起注入大海的. 拆分和合并的方式都是依赖于所要表达的业务逻辑</li></ul><p>总的来说变动实体一般就是业务的’<strong>输入</strong>‘, 我们首先把它们确定为流, 再根据关系衍生出其他流(<strong>输出</strong>). 对于流本身来说, <strong>本质上只有输入和输出的关系</strong>:</p><p><img src="/images/03/stream.png" alt="stream"></p><p>例如 increment$和decrement$就是 action$的输入, action$就是 count$的输入, 以此类推. <strong>响应式编程将复杂业务关系转换成原始的输出/输出关系</strong></p><p><strong>(3)符合函数式编程的约束</strong>. 一般来说, 我们说的响应式编程指的是<code>函数式响应式编程(Functional reactive programming FRP)</code>, 所以需要符合函数式的一些约束:</p><ul><li><code>纯函数(Pure)</code>: 函数只是输入参数到输出结果的映射, 不要产生副作用<ul><li>没有共享状态: 不依赖外部变量来维护流程的状态.</li><li>幂等性: 幂等性在复杂流程中很重要, 这使得整个流程可被重试</li><li>没有副作用: 可预测, 可测试.</li></ul></li><li><code>不可变性(Immuatability)</code>: 数据一旦产生, 就肯定它的值不会变化, 这有利于代码的理解. 易于并发</li><li><code>声明式(Declarative)</code>:<ul><li>函数式编程和命令式编程相比有较高的抽象级别, 他可以让你专注于定义与事件相互依存的业务逻辑, 而不是在实现细节上. 换句话说, 函数式编程定义关系, 而命令式编程定义步骤</li><li>集中的逻辑. Rx 自然而然在一处定义逻辑, 避免其他范式逻辑分散在代码库的各个地方. 另外 Rx 的 Observable 通过订阅来创建资源, 通过取消订阅来释放资源, 一般开发几乎不需要去关心资源的生命周期, 例如时间器.</li></ul></li></ul><p>这个阶段将第一个阶段的流程图转换为 Rx <code>弹珠图(Marble Diagrams)</code>表示, 弹珠图可以描述流之间关系, 表现’时间’的流逝, 让复杂的数据流更容易理解</p><p><br><br><br></p><h3 id="③-实现"><a href="#③-实现" class="headerlink" title="③ 实现"></a><code>③ 实现</code></h3><p>这个阶段就是把弹珠图翻译为实现代码, 根据需求在 rxjs 工具箱中查找合适的操作符. 当缕清了业务逻辑, 使用数据流进行建模后,<br>代码实现就是一件很简单的事情了.</p><blockquote><p>可以配合 Rxjs 官方的<a href="https://rxjs.dev/operator-decision-tree" target="_blank" rel="noopener">操作符决策树</a>选择合适的操作符</p></blockquote><p><br></p><hr><p><br></p><p>下面使用例子来体会 Rx 的编程思维:</p><h2 id="example-1-c-a-b"><a href="#example-1-c-a-b" class="headerlink" title="Example 1: c := a + b"></a>Example 1: c := a + b</h2><p>这是最简单的实例, 我们期望当 a 和 b 变动时能够响应到 c, 我们按照上述的步骤对这个需求进行建模:</p><ul><li><p><code>流程</code>:</p><p><img src="/images/03/process-02.png" alt="c=a+b"></p></li><li><p><code>数据流抽象</code>: 从上可以识别出两个变动的实体 a 和 b, 所以 a 和 b 都可以视作流, 那么 c 就是 a 和 b 衍生出来的流, 表示 a 和 b 的实时加法结果, 使用弹珠图来描述三者的关系:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">a$</span>: ----1------------2---------------</span><br><span class="line"><span class="meta">b$</span>: --2-------4------------6------8------</span><br><span class="line">              \ (a + b) /</span><br><span class="line"><span class="meta">c$</span>: ----3-----5------6-----8------10-----</span><br></pre></td></tr></table></figure></li><li><p><code>代码实现</code>: 由弹珠图可以看出, c$流的输出值就是a$和 b$输出值的实时计算结果, 也就是说c$接收来自 a$和b$ 的最新数据, 输出他们的和.<br>另外由原本的两个流合并为单个流, 在 rxjs 工具箱中可以找到<code>combineLatest</code>操作符符合该场景. 代码实现如下:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a$ = interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> b$ = interval(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">a$.pipe(combineLatest(b$))</span><br><span class="line">  .pipe(map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b))</span><br><span class="line">  .subscribe(<span class="function"><span class="params">sum</span> =&gt;</span> <span class="built_in">console</span>.log(sum));</span><br></pre></td></tr></table></figure></li></ul><p><br></p><hr><p><br></p><h2 id="example-2-元素拖拽的例子"><a href="#example-2-元素拖拽的例子" class="headerlink" title="Example 2: 元素拖拽的例子"></a>Example 2: 元素拖拽的例子</h2><p>元素拖拽也是 Rx 的经典例子的的例子. 假设我们需要先移动端和桌面端都支持元素拖拽移动.</p><p><code>流程图</code></p><p><img src="/images/03/process-01.png" alt></p><p><code>数据流抽象</code></p><p>这里使用分治的方法, 将流程进行一步步拆解, 然后使用弹珠图的形式进行描述.</p><p>由上面的流程图可以识别出来, down, move 以及 up 都是<code>变动实体</code>, 我们可以将他们视作’流’.</p><p>① down/move/up 都是抽象的事件, 在桌面端下是 mousedown/mousemove/mouseup, 移动端下对应的是<br>touchstart/touchmove/touchend. 我们不区分这些事件, 例如接收到 mousedown 或 touchstart 事件都认为是一个’down’事件. 所以事件监听的数据流如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 1</span><br><span class="line"><span class="meta">mousedown$</span> : ---d----------d--------</span><br><span class="line"><span class="meta">touchstart$</span>: -s---s-----------s-----</span><br><span class="line">        \(merge)/</span><br><span class="line"><span class="meta">down$</span>      : -s-d-s--------d--s-----</span><br></pre></td></tr></table></figure><p>move 和 up 事件同理</p><p>② 接下来要识别 up$, move$, down$ 三个数据流之间的关系, down 事件触发后我们才会去监听 move 和 up 事件, 也就是说由 down$可以衍生出 move$和 up$流. 在 up 事件触发后整个流程就终止. up$流决定了整个流程的生命周期的结束</p><p>使用弹珠图的描述三者的关系如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 2</span><br><span class="line"><span class="meta">down$</span>: -----d-------------------------</span><br><span class="line">             \</span><br><span class="line"><span class="meta">up$</span>  :        ----------u|</span><br><span class="line"><span class="meta">move$</span>:        -m--m--m---|</span><br></pre></td></tr></table></figure><p>③ 一个拖拽结束后还可以重新再发起拖拽, 即我们会持续监听 down 事件. 上面的流程还规定如果当前拖拽还未结束,<br>其他 down 事件应该被忽略, 在移动端下多点触摸是可能导致多个 down 事件触发的.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 3</span><br><span class="line"><span class="meta">down$</span>: ---d---d--d---------d------    # 中间两个事件因为拖拽未完成被忽略</span><br><span class="line">           \                \</span><br><span class="line"><span class="meta">up$</span>:        -----u|          ------u|</span><br><span class="line"><span class="meta">move$</span>:      -m-mm-|          m-m-m--|</span><br></pre></td></tr></table></figure><p><code>实现</code>:</p><p>有了弹珠图后, 就是把翻译问题了, 现在就打开 rxjs 的工具箱, 找找有什么合适的工具.</p><p>首先是抽象事件的处理. 由#1 可以看出, 这就是一个数据流合并, 这个适合使用<code>merge</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">merge(fromEvent(el, <span class="string">'touchstart'</span>), fromEvent(el, <span class="string">'mousedown'</span>));</span><br></pre></td></tr></table></figure><p>down$流的切换可以使用<code>exhaustMap</code>操作符, 这个操作符可以将输出值映射为Observable, 最后再使用exhaust操作符对Observable进行合并.<br>这可以满足我们’当一个拖拽未结束时, 新发起的 down$输出会被忽略, 直到拖拽完结’的需求</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">down$</span><br><span class="line">  .pipe(</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">evt</span> =&gt;</span> <span class="comment">/* 转换为新的Observable流 */</span>)</span><br></pre></td></tr></table></figure><p>使用 exhaustMap 来将 down$输出值转换为move$ 流, 并在 up$ 输出后结束, 可以使用<code>takeUntil</code>操作符:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">down$</span><br><span class="line">  .pipe(</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">      evt.preventDefault();</span><br><span class="line">      <span class="keyword">if</span> (evt.type === <span class="string">'mousedown'</span>) &#123;</span><br><span class="line">        <span class="comment">// 鼠标控制</span></span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = evt <span class="keyword">as</span> MouseEvent;</span><br><span class="line">        <span class="keyword">return</span> mouseMove$.pipe(</span><br><span class="line">          map(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              deltaX: (evt <span class="keyword">as</span> MouseEvent).clientX - clientX,</span><br><span class="line">              deltaY: (evt <span class="keyword">as</span> MouseEvent).clientY - clientY,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;),</span><br><span class="line">          takeUntil(mouseUp$),</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 触摸事件</span></span><br><span class="line">        <span class="keyword">const</span> &#123; touches &#125; = evt <span class="keyword">as</span> TouchEvent;</span><br><span class="line">        <span class="keyword">const</span> touch = touches[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = touch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> getTouch = <span class="function">(<span class="params">evt: TouchEvent</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> touches = <span class="built_in">Array</span>.from(evt.changedTouches);</span><br><span class="line">          <span class="keyword">return</span> touches.find(<span class="function"><span class="params">t</span> =&gt;</span> t.identifier === touch.identifier);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> touchFilter = filter(<span class="function">(<span class="params">e: Event</span>) =&gt;</span> !!getTouch(e <span class="keyword">as</span> TouchEvent));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> touchMove$.pipe(</span><br><span class="line">          touchFilter,</span><br><span class="line">          map(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> touch = getTouch(evt <span class="keyword">as</span> TouchEvent)!;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              deltaX: touch.clientX - clientX,</span><br><span class="line">              deltaY: touch.clientY - clientY,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;),</span><br><span class="line">          takeUntil(touchUp$.pipe(touchFilter)),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">delta</span> =&gt;</span> &#123;</span><br><span class="line">    el.style.transform = <span class="string">`translate(<span class="subst">$&#123;delta.deltaX&#125;</span>px, <span class="subst">$&#123;delta.deltaY&#125;</span>px)`</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="example-3-todos"><a href="#example-3-todos" class="headerlink" title="Example 3: Todos"></a>Example 3: Todos</h2><p>如果使用 rxjs 来创建 Todos 应用, 首先是<code>流程图</code>:</p><p><img src="/images/03/process-03.png" alt></p><p><code>数据流抽象</code>:</p><p>首先识别变动的实体, 变动的实体就是 todos 列表, 所以可以认为 todos 列表就是一个流. 它从 localStorage 中恢复<br>初始化状态. 由<code>新增</code>, <code>删除</code>等事件触发状态改变, 这些事件也可以视作流</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">add$</span>:      --a-----a------</span><br><span class="line"><span class="meta">modify$</span>:   ----m----------</span><br><span class="line"><span class="meta">remove$</span>    -------r-------</span><br><span class="line"><span class="meta">complete$</span>: ------c----c---</span><br><span class="line">             \(merge)/</span><br><span class="line"><span class="meta">update$</span>    --a-m-cra--c--- # 各种事件合并为update$流</span><br><span class="line">              \(reduce)/</span><br><span class="line"><span class="meta">todos$</span>:    i-u-u-uuu--u---- # i 为初始化数据, update$的输出将触发重新计算状态</span><br></pre></td></tr></table></figure><p>todos$流会响应到 view 上, 另一方面需要持久化到本地存储. 也就是说这是一个多播流.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">todos$</span>: i-u-u-uuu--u---- #</span><br><span class="line">          \(debounce)/</span><br><span class="line"><span class="meta">save$</span>   i--u--u---u----- # 存储流, 使用debounce来避免频繁存储</span><br></pre></td></tr></table></figure><p>并行渲染到页面:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">todos$</span>: i-u-u-uuu--u---- #</span><br><span class="line">       \(render)/</span><br><span class="line"><span class="meta">dom$</span>:   i--u--u---u----- # dom渲染, 假设也是流(cycle.js就是如此)</span><br></pre></td></tr></table></figure><p>这个实例的数据流和 Redux 的模型非常像, add$, modify$, remove$和complete$就是 Action, todos 流会使用<br>类似 Reducer 的机制来处理这些 Action 生成新的 State</p><p><img src="/images/03/redux.png" alt="redux"></p><p><code>代码实现</code>:</p><p>首先 add$, modify$以及 remove$和complete$可以分别使用一个 Subject 对象来表示, 用于接收外部事件. 其实还可以简化为一个流,<br>它们的区别只是参数</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Action&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  payload: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INIT_ACTION = <span class="string">'INIT'</span>; <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> ADD_ACTION = <span class="string">'ADD'</span>;</span><br><span class="line"><span class="keyword">const</span> REMOVE_ACTION = <span class="string">'REMOVE'</span>;</span><br><span class="line"><span class="keyword">const</span> MODIFY_ACTION = <span class="string">'MODIFY'</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETE_ACTION = <span class="string">'COMPLETE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update$ = <span class="keyword">new</span> Subject&lt;Action&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: ADD_ACTION,</span><br><span class="line">    payload: value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: REMOVE_ACTION,</span><br><span class="line">    payload: id,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: COMPLETE_ACTION,</span><br><span class="line">    payload: id,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">id: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: MODIFY_ACTION,</span><br><span class="line">    payload: &#123; id, value &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建todos$流, 对update$ 的输出进行 reduce:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化Store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialStore</span>(<span class="params"></span>): <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="built_in">window</span>.localStorage.getItem(STORAGE_KEY);</span><br><span class="line">  <span class="keyword">return</span> value ? <span class="built_in">JSON</span>.parse(value) : &#123; list: [] &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos$ = update$.pipe(</span><br><span class="line">  <span class="comment">// 从INIT_ACTION 触发scan初始化</span></span><br><span class="line">  startWith(&#123; <span class="keyword">type</span>: INIT_ACTION &#125; <span class="keyword">as</span> Action),</span><br><span class="line">  <span class="comment">// reducer</span></span><br><span class="line">  scan&lt;Action, Store&gt;<span class="function">(<span class="params">(<span class="params">state, &#123; <span class="keyword">type</span>, payload &#125;</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> produce(<span class="params">state, draftState =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">let</span> idx: <span class="built_in">number</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">switch</span> (<span class="params"><span class="keyword">type</span></span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> ADD_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          draftState.list.push(<span class="params">&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">            id: <span class="built_in">Date</span>.now(<span class="params"></span>).toString(<span class="params"></span>),</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">            value: payload,</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          &#125;</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> MODIFY_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload.id</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list[idx].value = payload.value;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> REMOVE_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list.splice(<span class="params">idx, 1</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> COMPLETE_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list[idx].completed = <span class="literal">true</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">default</span>:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, initialStore(<span class="params"></span>)</span>),</span></span><br><span class="line"><span class="function">  // 支持多播</span></span><br><span class="line"><span class="function">  <span class="params">shareReplay</span><span class="params">()</span>,</span></span><br><span class="line"><span class="function">);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 持久化</span></span><br><span class="line"><span class="function"><span class="params">todos</span>$.<span class="params">pipe</span>(<span class="params">debounceTime(<span class="params">1000</span>)</span>).<span class="params">subscribe</span>(<span class="params">store =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">window</span>.localStorage.setItem(<span class="params">STORAGE_KEY, <span class="built_in">JSON</span>.stringify(<span class="params">store</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br></pre></td></tr></table></figure><blockquote><p>更多例子: 徐飞在<a href="https://github.com/xufei/blog/issues/44" target="_blank" rel="noopener">“RxJS 入门指引和初步应用&gt;”</a>提到了一个”幸福人生”的例子, 挺有意思, 读者可以尝试对其进行建模</p></blockquote><p><br></p><hr><p><br></p><p>经过上述过程, 可以深刻体会到<em>函数响应式编程</em>的<strong>优势</strong>:</p><ul><li><strong>数据流抽象了很多现实问题</strong>. 也就说数据流对业务逻辑的表达能力流程图基本一致. 可以说弹珠图是流程图的直观翻译, 而 Rx 代码则是弹珠图的直观翻译. 使用 Rx 以声明式形式编写代码, 可以让代码更容易理解, 因为它们接近业务流程.</li><li><strong>把复杂的问题分解成简单的问题的组合</strong>. Rx 编程本质上就是数据流的分治和合并</li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.jianshu.com/p/c95e29854cb1" target="_blank" rel="noopener">重新理解响应式编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/53009201" target="_blank" rel="noopener">【响应式编程的思维艺术】响应式 Vs 面向对象</a></li><li><a href="http://www.uml.org.cn/zjjs/201008021.asp" target="_blank" rel="noopener">细说业务逻辑</a></li><li><a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">Reactive programming</a></li><li><a href="https://github.com/xufei/blog/issues/44" target="_blank" rel="noopener">RxJS 入门指引和初步应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍如何使用 Rx 的响应式编程思维来对业务逻辑进行建模, 你会了解到响应式编程的优势和业务抽象能力, 学会将现有的业务流程以数据流的方式表达出来. 你的工具库中不能少了 Rx 这件利器.&lt;/p&gt;
&lt;p&gt;Rx 学习曲线陡峭是总所周知的, 我们接触的大部分编程语言或框架都
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Yarn Plug&#39;n&#39;Play可否助你脱离node_modules苦海?</title>
    <link href="https://bobi.ink/2019/04/08/plug-n-play/"/>
    <id>https://bobi.ink/2019/04/08/plug-n-play/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-07T04:18:21.737Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Yarn(v1.12+)的 Plug’n’Play 机制来取代 node_modules. 目前这还是一个实验性的特性.</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/images/node_modules-hole.png" alt="node_modules"></p><p><code>node_modules</code>早就成为的全民吐槽的对象, 其他语言的开发者看到 node_modules 对 Node 就望而祛步了,<br>用一个字来形容的话就是’重!’.</p><blockquote><p>如果不了解 Node 模块查找机制, 请点击<a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">require() 源码解读</a></p></blockquote><p>一个简单的前端项目(<em>create-react-app</em>)的大小和文件数:</p><center><br>  <img src="/images/front-end-project.png" alt="frontend-project" width="400"><br></center><p>而 macOS 的<code>/Library</code>目录的大小的文件数:</p><center><br>  <img src="/images/mac-library.png" alt="macos library" width="400"><br></center><p>一行<code>hello world</code>就需要安装 130MB 以上的依赖模块, 而且文件数是<strong>32,313</strong>. 相比之下 macOS 的<code>/Library</code><br>的空间占用 9.02GB, 文件数只是前者的两倍(<strong>67,890</strong>). 综上可以看出 node_modules 的特点是:</p><ul><li>目录树结构复杂</li><li>文件数较多且都比较小</li><li>依赖多, 一个简单的项目就要安装好几吨依赖</li></ul><p>所以说 node_modules 对于机械硬盘来说是个噩梦, 记得有一次一个同事删除 node_modules 一个下午都没搞定.<br>对于前端开发者来说, 我们有 N 个需要<code>npm install</code>的项目 😹.</p><p>除此之外, Node 的模块机制还有以下<strong>缺点</strong>:</p><ul><li><p>Node 本身并没有模块的概念, 它在运行时进行查找和加载. 这个缺点和<em>‘动态语言与静态语言的优劣对比’</em>相似,<br>你可能在开发环境运行得好好的, 可能到了线上就运行不了了, 原因是一个模块没有添加到 package.json</p></li><li><p>Node 模块的查找策略非常浪费. 这个缺点在大部分前端项目中可以进行优化,<br>比如 webpack 就可以限定只在项目根目录下的 node_modules 中查找, 但是对于嵌套的依赖, 依然需要 2 次以上的查找</p></li><li><p>node_modules 不能有效地处理重复的包. 两个名称相同但是不同版本的包是不能在一个目录下共存的.<br>所以会导致嵌套的 node_modules, 而且这些项目’依赖的依赖’是无法和项目或其他依赖共享的:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> ① 假设项目依赖a,b,c三个模块, 依赖树为:</span><br><span class="line"><span class="meta">#</span>  +- a</span><br><span class="line"><span class="meta">#</span>    +- react@15</span><br><span class="line"><span class="meta">#</span>  +- b</span><br><span class="line"><span class="meta">#</span>    +- react@16</span><br><span class="line"><span class="meta">#</span>  +- c</span><br><span class="line"><span class="meta">#</span>    +- react@16</span><br><span class="line"><span class="meta">#</span> yarn安装时会按照项目被依赖的次数作为权重, 将依赖提升(hoisting),</span><br><span class="line"><span class="meta">#</span> 安装后的node_modules结构为:</span><br><span class="line">  .</span><br><span class="line">  └── node_modules</span><br><span class="line">      ├── a</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   ├── node_modules</span><br><span class="line">      │   │   └── react  # @15</span><br><span class="line">      │   └── package.json</span><br><span class="line">      ├── b</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   └── package.json</span><br><span class="line">      ├── c</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   └── package.json</span><br><span class="line">      └── react  # @16 被依赖了两次, 所以进行提升</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> ② 现在假设在①的基础上, 根项目依赖了react@15, 对于项目自己的依赖肯定是要放在node_modules根目录的,</span><br><span class="line"><span class="meta">#</span> 由于一个目录下不能存在同名目录, 所以react@16没有的提升机会. </span><br><span class="line"><span class="meta">#</span> 安装后node_moduels结构为</span><br><span class="line">  .</span><br><span class="line">  └── node_modules</span><br><span class="line">      ├── a</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   └── package.json # react@15 提升</span><br><span class="line">      ├── b</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   ├── node_modules</span><br><span class="line">      │   │   └── react  # @16</span><br><span class="line">      │   └── package.json</span><br><span class="line">      ├── c</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   ├── node_modules</span><br><span class="line">      │   │   └── react  # @16</span><br><span class="line">      │   └── package.json</span><br><span class="line">      └── react  # @15</span><br><span class="line"><span class="meta">#</span> 上面的结果可以看出, react@16出现了重复</span><br></pre></td></tr></table></figure></li></ul><p>为此 Yarn 集成了<code>Plug&#39;n&#39;Play</code>(简称 pnp), 中文名称可以称为’即插即用’, 来解决 node_modules’地狱’.</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>按照普通的按照流程, Yarn 会生成一个 node_modules 目录, 然后 Node 按照它的模块查找规则在 node_modules 目录中查找.<br>但实际上 Node 并不知道这个模块是什么, 它在 node_modules 查找, 没找到就在父目录的 node_modules 查找, 以此类推.<br>这个效率是非常低下的.</p><p><strong>但是 Yarn 作为一个包管理器, 它知道你的项目的依赖树. 那能不能让 Yarn 告诉 Node? 让它直接到某个目录去加载模块.<br>这样即可以提高 Node 模块的查找效率, 也可以减少 node_modules 文件的拷贝. 这就是<code>Plug&#39;n&#39;Play</code>的基本原理.</strong></p><p>在 pnp 模式下, Yarn 不会创建 node_modules 目录, 取而代之的是一个<code>.png.js</code>文件, 这是一个 node 程序,<br>这个文件包含了项目的依赖树信息, 模块查找算法, 也包含了模块查找器的 patch 代码(在 Node 环境, 覆盖 Module._load 方法).</p><p><br></p><p>使用 pnp 机制的以下<strong>优点</strong>:</p><ul><li>摆脱 node_modules.<ul><li>时间上: 相比较在热缓存(hot cache)环境下运行<code>yarn install</code>节省 70%的时间</li><li>空间上: pnp 模式下, 所有 npm 模块都会存放在全局的缓存目录下, 依赖树扁平化, 避免拷贝和重复</li></ul></li><li>提高模块加载效率. Node 为了查找模块, 需要调用大量的 stat 和 readdir 系统调用.<br>pnp 通过 Yarn 获取或者模块信息, 直接定位模块</li><li>不再受限于 node_modules 同名模块不同版本不能在同一目录</li></ul><blockquote><p>在 Mac 下 Yarn 的安装速度非常快, 热缓存下仅需几秒. 原因是 SSD + APFS 的 Copy-on-write 机制.<br>这使得文件的拷贝不用占用空间, 相当于创建一个链接. 所以拷贝和删除的速度非常快.<br>但是 node_modules 复杂的目录结构和超多的文件, 仍然需要调用大量的系统调用, 这也会拖慢安装过程.<br><br><br>💡 如果觉得 pnp 繁琐或不可靠, 那就赶紧用上 SSD 配合支持 Copy-on-write 的文件系统.</p></blockquote><p><br></p><p>使用 pnp 的<strong>风险</strong>:</p><p>目前前端社区的各种工具都依赖于 node_modules 模块查找机制. 例如</p><ul><li>Node</li><li>Electron, electron-builder 等等</li><li>Webpack</li><li>Typescript: 定位类型声明文件</li><li>Babel: 定位插件和 preset</li><li>Eslint: 定位插件和 preset, rules</li><li>Jest</li><li>编辑器, 如 VsCode</li><li>…😿</li></ul><p>pnp 一个非常新的东西, 在去年 9 月份(2018)面世. 要让这些工具和 pnp 集成是个不小的挑战, 而且这些这些工具<br>和 pnp 都是在不断迭代的, pnp 还不稳定, 未来可能变化, 这也会带来某些维护方面的负担.</p><p>除了模块查找机制, 有一些工具是直接在 node_modules 中做其他事情的, 比如缓存, 存放临时证书. 例如<code>cache-loader</code>, <code>webpack-dev-server</code></p><h2 id="开启-pnp"><a href="#开启-pnp" class="headerlink" title="开启 pnp"></a>开启 pnp</h2><p>如果只是单纯的 Node 项目, 迁入过程还算比较简单. 首先在<code>package.json</code>开启 pnp 安装模式:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"installConfig"</span>: &#123;</span><br><span class="line">    <span class="attr">"pnp"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着安装依赖:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add express</span><br></pre></td></tr></table></figure><p>安装后项目根目录就会出现一个<code>.pnp.js</code>文件. 下一步编写代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; res.send(<span class="string">'Hello World!'</span>));</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>));</span><br></pre></td></tr></table></figure><p>接下来就是运行 Node 代码了, 如果直接<code>node index.js</code>会报<code>Error: Cannot find module &#39;express&#39;</code>异常.<br>这是因为还没有 patch Node 的模块查找器. 可以通过以下命令运行:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"></span><br><span class="line">node --require="./.pnp.js" index.js</span><br></pre></td></tr></table></figure><blockquote><p><code>.pnp.js</code>文件不应该提交到版本库, 这个文件里面包含了硬编码的缓存目录. 在 Yarn v2 中会进行重构</p></blockquote><h2 id="怎么集成到现有项目"><a href="#怎么集成到现有项目" class="headerlink" title="怎么集成到现有项目?"></a>怎么集成到现有项目?</h2><p>pnp 集成无非就是重新实现现有工具的模块查找机制. 随着前端工程化的发展, 一个前端项目会集成非常多的工具,<br>如果这些工具没法适配, 可以说 pnp 很难往前走. 然而这并不是 pnp 能够控制的, 需要这些工具开发者的配合.</p><p>社区上不少项目已经集成了 pnp:</p><ul><li><a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a></li><li><a href="https://github.com/gatsbyjs/gatsby" target="_blank" rel="noopener">gastby</a></li></ul><p><br></p><h3 id="node"><a href="#node" class="headerlink" title="Node"></a>Node</h3><p>对于 Node, pnp 是开箱即用的, 直接使用<code>--require=&quot;./.pnp.js&quot;</code>导入<code>.pnp.js</code>文件即可,<br><code>.pnp.js</code>会对 Node 的 Module 对象进行 patch, 重新实现模块查找机制</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 使用的模块查找器是<a href="https://github.com/webpack/enhanced-resolve" target="_blank" rel="noopener"><code>enhanced-resolve</code></a>, 可以通过<a href="https://github.com/arcanis/pnp-webpack-plugin" target="_blank" rel="noopener"><code>pnp-webpack-plugin</code></a>插件来扩展<code>enhanced-resolve</code><br>来支持 pnp.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PnpWebpackPlugin = <span class="built_in">require</span>(<span class="string">`pnp-webpack-plugin`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 扩展模块查找器</span></span><br><span class="line">    plugins: [PnpWebpackPlugin],</span><br><span class="line">  &#125;,</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    <span class="comment">// 扩展loader模块查找器.</span></span><br><span class="line">    plugins: [PnpWebpackPlugin.moduleLoader(<span class="built_in">module</span>)],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h3><p><a href="http://jestjs.io" target="_blank" rel="noopener">jest</a>支持通过<code>resolver</code>来配置查找器:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolver: <span class="built_in">require</span>.resolve(<span class="string">`jest-pnp-resolver`</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="typescript"><a href="#typescript" class="headerlink" title="Typescript"></a>Typescript</h3><p>Typescript 也使用自己的模块查找器, TS团队为了性能方面的考虑, 暂时不允许第三方工具来扩展查找器. 也就是说<strong>暂时不能用</strong>.</p><p>在这个<a href="https://github.com/Microsoft/TypeScript/issues/28289" target="_blank" rel="noopener">issue</a>中, 有人提出使用<code>&quot;moduleResolution&quot;: &quot;yarnpnp&quot;</code>或者使用类似<a href="https://github.com/TypeStrong/ts-loader" target="_blank" rel="noopener"><code>ts-loader</code></a>的<a href="https://github.com/arcanis/pnp-webpack-plugin/blob/b09fbdc2a9f16dc3837454b8d367963b1a30655f/index.js#L141" target="_blank" rel="noopener"><code>resolveModuleName</code></a>的方式支持 pnp 模块查找.</p><p>TS 团队的回应是: pnp(或者 npm 的 tink)还是早期阶段, 未来可能会有变化, 例如<code>.pnp.js</code>文件, 显然不合适那么早入坑.<br>另外为了优化和控制编译器性能, TS 也没有计划在编译期间暴露接口给第三方执行代码.</p><p>所以现在 Typescript 至今也没有类似 babel 的插件机制. 除非自己实现一个’TS compiler host’, 例如<code>ts-loader</code>就自己扩展了插件机制和模块查找机制, 来支持类似<a href="https://github.com/Brooooooklyn/ts-import-plugin" target="_blank" rel="noopener">ts-import-plugin</a>等插件, 因此<code>ts-loader</code>现在是支持 pnp 的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PnpWebpackPlugin = <span class="built_in">require</span>(<span class="string">`pnp-webpack-plugin`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        loader: <span class="built_in">require</span>.resolve(<span class="string">'ts-loader'</span>),</span><br><span class="line">        options: PnpWebpackPlugin.tsLoaderOptions(),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>总结, <strong><code>Typescript</code>暂时不支持</strong>, 且近期也没有开发计划, 所以<code>VsCode</code>也别指望了. <a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin/issues/181" target="_blank" rel="noopener"><code>fork-ts-checker-webpack-plugin</code></a>也还没跟上. 显然 Typescript 是 pnp 的第一拦路虎</p><p><br></p><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ul><li><a href="https://github.com/arcanis/rollup-plugin-pnp-resolve" target="_blank" rel="noopener">rollup-plugin-pnp-resolve</a></li><li><a href="https://yarnpkg.com/en/package/resolve" target="_blank" rel="noopener">resolve</a>: babel, gulp</li><li><a href="https://github.com/yarnpkg/yarn/pull/6449" target="_blank" rel="noopener">eslint</a>: 到 v6 才能<a href="https://github.com/yarnpkg/berry/issues/8" target="_blank" rel="noopener">完美支持</a>.</li><li><a href="https://github.com/facebook/flow/issues/7014" target="_blank" rel="noopener">flow</a></li><li><a href="https://github.com/facebook/create-react-app/pull/5136" target="_blank" rel="noopener">create-react-app</a> 支持 pnp, 但是 Typescript 模式下不支持</li><li>electron: 暂时没有相关的消息. 对于一个electron应用来说, 依赖是自包含的, 所以pnp可能不适合该场景</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上, pnp 是一个不错的解决方案, 可以解决 Node 模块机制的空间和时间的效率问题. 但是在现阶段, 它还不是成熟, 有<br>很多坑要踩, 且和社区各种工具集成存在不少问题. 所以还不建议在生产环境中使用.</p><p>所以目前阶段对于普通开发者来说, 如果要提升npm安装速度, 还是得上SSD+Copy-On-Write!😂</p><p>下面是各种项目的集成情况(✅(支持)|🚧(计划中或不完美)|❌(不支持)):</p><table><thead><tr><th>项目</th><th></th></tr></thead><tbody><tr><td>Webpack</td><td>✅</td></tr><tr><td>rollup</td><td>✅</td></tr><tr><td>browserify</td><td>✅</td></tr><tr><td>gulp</td><td>✅</td></tr><tr><td>jest</td><td>✅</td></tr><tr><td>Node</td><td>✅</td></tr><tr><td>Typescript/VScode IntelliSense</td><td>❌</td></tr><tr><td>eslint</td><td>🚧</td></tr><tr><td>flow</td><td>🚧</td></tr><tr><td>create-react-app</td><td>🚧</td></tr><tr><td>ts-loader</td><td>✅</td></tr><tr><td>fork-ts-checker-webpack-plugin</td><td>🚧</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/yarnpkg/rfcs/blob/master/accepted/0000-plug-an-play.md" target="_blank" rel="noopener">Plug’n’Play Whitepaper</a> pnp的论文</li><li><a href="https://medium.freecodecamp.org/getting-rid-of-node-modules-with-yarn-plugn-play-a490e5e747d7" target="_blank" rel="noopener">How to get rid of node_modules with Yarn Plug’n’Play</a></li><li><a href="https://yarnpkg.com/en/docs/pnp" target="_blank" rel="noopener">Yarn 官方文档</a></li><li><a href="https://github.com/yarnpkg/pnp-sample-app" target="_blank" rel="noopener">pnp-sample-app</a> pnp 官方示例</li><li><a href="https://github.com/yarnpkg/yarn/issues/6953" target="_blank" rel="noopener">Yarn’s Future - v2 and beyond</a></li><li><a href="https://medium.com/@thomasreggi/yarn-plugn-play-1c398bf3e417" target="_blank" rel="noopener">Hacker News Discussion</a></li></ul><p>相关 issues:</p><ul><li><a href="https://github.com/yarnpkg/yarn/issues/6388" target="_blank" rel="noopener">Yarn Plug ‘N Play should generate a static manifest file, not <code>.pnp.js</code></a></li><li><a href="https://github.com/Microsoft/TypeScript/issues/28289" target="_blank" rel="noopener">Typescript: Add new moduleResolution option: <code>yarn-pnp</code></a></li><li><a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin/issues/181" target="_blank" rel="noopener">fork-ts-checker-webpack-plugin: Custom resolveModuleName</a></li></ul><p>其他方案</p><ul><li><a href="https://github.com/npm/tink" target="_blank" rel="noopener">npm tink</a>: a dependency unwinder for javascript</li><li><a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">pnpm</a> Fast, disk space efficient package manager</li><li><a href="https://yarnpkg.com/en/docs/workspaces" target="_blank" rel="noopener">Yarn Workspaces</a> 多个项目共有依赖</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 Yarn(v1.12+)的 Plug’n’Play 机制来取代 node_modules. 目前这还是一个实验性的特性.&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Rxjs 操作符决策树 - Mindnode</title>
    <link href="https://bobi.ink/2019/04/06/rx-operations/"/>
    <id>https://bobi.ink/2019/04/06/rx-operations/</id>
    <published>2019-04-05T16:00:00.000Z</published>
    <updated>2019-04-06T09:27:17.301Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Mindnode</strong> 是 macOS 下一个美观简洁的思维导图工具, 它是一个强大的学习/整理工具, 本文列举了近日学习<code>rxjs</code>所整理出来的思维导图.</p><blockquote><p>图片较大, 加载可能需要一点时间. 建议右击图片在新的 Tab 中查看</p></blockquote><blockquote><p>Mindode项目<a href="https://github.com/ivan-94/mindnodes/tree/master/rxjs/操作符" target="_blank" rel="noopener">地址</a>, 可以在这个项目获取原始的Mindode文件.</p></blockquote><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul><li><a href="https://rxjs.dev" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://rxmarbles.com/#distinctUntilChanged" target="_blank" rel="noopener">可交互的弹珠图</a> 直观地理解操作符的功能</li><li><a href="https://rxjs-cn.github.io/learn-rxjs-operators/" target="_blank" rel="noopener">reactive.how</a> 学习响应式编程的动画卡片</li><li><a href="https://rxjs-cn.github.io/learn-rxjs-operators/" target="_blank" rel="noopener">学习RxJS操作符</a></li><li><a href="https://www.amazon.cn/dp/B07CXZ9D8N/ref=sr_1_1?__mk_zh_CN=亚马逊网站&amp;keywords=rxjs&amp;qid=1554539743&amp;s=gateway&amp;sr=8-1" target="_blank" rel="noopener">book: 深入浅出RxJS</a></li></ul><h2 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/创建操作符.png" alt="创建操作符"></p><h2 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/过滤.png" alt="过滤操作符"></p><h2 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/转换.png" alt="转换操作符"></p><h2 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/组合.png" alt="组合操作符"></p><h2 id="分组操作符"><a href="#分组操作符" class="headerlink" title="分组操作符"></a>分组操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/分组.png" alt="分组操作符"></p><h2 id="错误处理操作符"><a href="#错误处理操作符" class="headerlink" title="错误处理操作符"></a>错误处理操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/错误处理.png" alt="错误处理操作符"></p><h2 id="辅助-条件-数学-配置操作符"><a href="#辅助-条件-数学-配置操作符" class="headerlink" title="辅助-条件-数学-配置操作符"></a>辅助-条件-数学-配置操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/辅助-条件-数学-配置.png" alt="辅助-条件-数学-配置操作符"></p><h2 id="多播操作符"><a href="#多播操作符" class="headerlink" title="多播操作符"></a>多播操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/多播.png" alt="多播操作符"></p><h2 id="高阶-observable-操作符"><a href="#高阶-observable-操作符" class="headerlink" title="高阶 Observable 操作符"></a>高阶 Observable 操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/高阶Observable.png" alt="高阶Observable操作符"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Mindnode&lt;/strong&gt; 是 macOS 下一个美观简洁的思维导图工具, 它是一个强大的学习/整理工具, 本文列举了近日学习&lt;code&gt;rxjs&lt;/code&gt;所整理出来的思维导图.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图片较大, 加载可能需要一
      
    
    </summary>
    
      <category term="Mindnode" scheme="https://bobi.ink/categories/Mindnode/"/>
    
    
  </entry>
  
</feed>
