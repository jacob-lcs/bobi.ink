<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2019-05-12T09:40:23.122Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React组件设计实践总结01 - 类型检查</title>
    <link href="https://bobi.ink/2019/05/10/react-component-design-01/"/>
    <id>https://bobi.ink/2019/05/10/react-component-design-01/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-12T09:40:23.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系列引言"><a href="#系列引言" class="headerlink" title="系列引言"></a>系列引言</h2><p>最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对<strong> React 组件设计的相关实践和规范</strong>整理了一些文档, 将部分章节分享了出来. 由于经验有限, 文章可能会有某些错误, 希望大家指出, 互相交流.</p><p>由于篇幅太长, 所以拆分为几篇文章. 主要有以下几个主题:</p><ul><li><a href="./">01 类型检查</a></li><li>02 组件的组织 待更新</li><li>03 样式的管理 待更新</li><li>04 组件的思维 待更新</li><li>05 状态管理 待更新</li></ul><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>静态类型检查对于当今的前端项目越来越不可或缺, 尤其是大型项目. <strong>它可以在开发时就避免许多类型问题, 减少低级错误的; 另外通过类型智能提示, 可以提高编码的效率; 有利于书写自描述的代码(类型即文档); 方便代码重构(配合 IDE 可以自动重构)</strong>. 对于静态类型检查的好处这里就不予赘述, 读者可以查看这个回答<a href="https://www.zhihu.com/question/28016252/answer/39056940" target="_blank" rel="noopener">flow.js/typescript 这类定义参数类型的意义何在？</a>.</p><p>Javascript 的类型检查器主要有<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">Typescript</a>和<a href="https://flow.org" target="_blank" rel="noopener">Flow</a>, 笔者两者都用过, Typescript 更强大一些, 可以避免很多坑, 有更好的生态(例如第三方库类型声明), 而且 VSCode 内置支持. 而对于 Flow, 连 Facebook 自己的开源项目(如 Yarn, Jest)都抛弃了它, 所以不建议入坑. 所以本篇文章使用 Typescript(v3.3) 对 React 组件进行类型检查声明</p><p>建议通过官方文档来<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">学习 Typescript</a>. 笔者此前也整理了 Typescript 相关的<a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">思维导图(mindnode)</a></p><blockquote><p>当然 Flow 也有某些 Typescript 没有的特性: <a href="https://github.com/niieani/typescript-vs-flowtype" target="_blank" rel="noopener">typescript-vs-flowtype</a></p></blockquote><blockquote><p>React 组件类型检查依赖于<code>@types/react</code>和<code>@types/react-dom</code></p></blockquote><blockquote><p>直接上手使用试用 <br> <a href="https://codesandbox.io/s/5vx5wwmkvx?fontsize=14" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit typescript-react-playground"></a></p></blockquote><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#系列引言">系列引言</a></li><li><a href="#类型检查">类型检查</a><ul><li><a href="#1-函数组件">1. 函数组件</a><ul><li><a href="#1️⃣-使用componentnameprops-形式声明-props-类型-并导出">1️⃣ <strong>使用<code>{ComponentName}Props</code> 形式声明 Props 类型, 并导出</strong></a></li><li><a href="#2️⃣-优先使用fcfunctioncomponent的简写类型来声明函数组件">2️⃣ <strong>优先使用<code>FC</code>(<code>FunctionComponent</code>的简写)类型来声明函数组件</strong></a></li><li><a href="#3️⃣-不要直接使用export-default导出组件">3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</a></li><li><a href="#4️⃣-默认-props-声明">4️⃣ <strong>默认 props 声明</strong></a></li><li><a href="#5️⃣-泛型函数组件">5️⃣ <strong>泛型函数组件</strong></a></li><li><a href="#6️⃣-子组件声明">6️⃣ <strong>子组件声明</strong></a></li><li><a href="#7️⃣-forwarding-refs">7️⃣ <strong>Forwarding Refs</strong></a></li></ul></li><li><a href="#2-类组件">2. 类组件</a><ul><li><a href="#1️⃣-继承-reactcomponent-或-reactpurecomponent">1️⃣ <strong>继承 React.Component 或 React.PureComponent</strong></a></li><li><a href="#2️⃣-使用static-defaultprops定义默认-props">2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></a></li><li><a href="#3️⃣-子组件声明">3️⃣ <strong>子组件声明</strong></a></li><li><a href="#4️⃣-泛型">4️⃣ <strong>泛型</strong></a></li></ul></li><li><a href="#3-高阶组件">3. 高阶组件</a></li><li><a href="#4-render-props">4. Render Props</a></li><li><a href="#5-context">5. Context</a></li><li><a href="#6-杂项">6. 杂项</a><ul><li><a href="#1️⃣-使用handleevent命名事件处理器">1️⃣ <strong>使用<code>handle{Event}</code>命名事件处理器</strong>.</a></li><li><a href="#2️⃣-使用-typesreact-内置事件处理器的类型">2️⃣ <strong>使用 @types/react 内置事件处理器的类型</strong></a></li><li><a href="#3️⃣-自定义组件暴露事件处理器类型">3️⃣ <strong>自定义组件暴露事件处理器类型</strong></a></li><li><a href="#4️⃣-获取原生元素-props-定义">4️⃣ <strong>获取原生元素 props 定义</strong></a></li><li><a href="#5️⃣-不要使用-reactproptypes">5️⃣ <strong>不要使用 React.PropTypes</strong></a></li><li><a href="#6️⃣-styled-components">6️⃣ <strong>styled-components</strong></a></li><li><a href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明">7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></a></li><li><a href="#8️⃣-为文档生成做好准备">8️⃣ <strong>为文档生成做好准备</strong></a></li><li><a href="#9️⃣-开启-strict-模式">9️⃣ <strong>开启 strict 模式</strong></a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h3 id="1-函数组件"><a href="#1-函数组件" class="headerlink" title="1. 函数组件"></a>1. 函数组件</h3><p>React Hooks 出现后, 函数组件有了更多出镜率. 由于函数组件只是普通函数, 它非常容易进行类型声明</p><p><br></p><h4 id="1️⃣-使用-ComponentName-Props-形式声明-Props-类型-并导出"><a href="#1️⃣-使用-ComponentName-Props-形式声明-Props-类型-并导出" class="headerlink" title="1️⃣ 使用{ComponentName}Props 形式声明 Props 类型, 并导出"></a>1️⃣ <strong>使用<code>{ComponentName}Props</code> 形式声明 Props 类型, 并导出</strong></h4><p><br></p><h4 id="2️⃣-优先使用FC-FunctionComponent的简写-类型来声明函数组件"><a href="#2️⃣-优先使用FC-FunctionComponent的简写-类型来声明函数组件" class="headerlink" title="2️⃣ 优先使用FC(FunctionComponent的简写)类型来声明函数组件"></a>2️⃣ <strong>优先使用<code>FC</code>(<code>FunctionComponent</code>的简写)类型来声明函数组件</strong></h4><p>这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Props类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyComponent: FC&lt;MyComponentProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>你也可以直接使用普通函数来进行组件声明, 下文会看到这种形式更加灵活:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  <span class="comment">// 手动声明children</span></span><br><span class="line">  children?: React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props: MyComponentProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="3️⃣-不要直接使用export-default导出组件"><a href="#3️⃣-不要直接使用export-default导出组件" class="headerlink" title="3️⃣ 不要直接使用export default导出组件."></a>3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</h4><p>这种方式导出的组件在<code>React Inspector</code>查看时会显示为<code>Unknown</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (props: &#123;&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>如果非得这么做, 请使用<code>命名 function</code> 定义:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">props: &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;xxx&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-默认-props-声明"><a href="#4️⃣-默认-props-声明" class="headerlink" title="4️⃣ 默认 props 声明"></a>4️⃣ <strong>默认 props 声明</strong></h4><p>实际上截止目前对于上面的使用<code>FC</code>类型声明的函数组件并<a href="https://github.com/Microsoft/TypeScript/issues/27425" target="_blank" rel="noopener">不能完美支持 defaultProps</a>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ❌! missing name</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure><p>笔者一般喜欢这样子声明默认 props:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>; <span class="comment">// 声明为可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用对象默认属性值语法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name = 'TJ' &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br></pre></td></tr></table></figure><p>如果非得使用 defaultProps, 可以这样子声明 👇. Typescript 可以推断和在函数上定义的属性, 这个特性在 Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#properties-declarations-on-functions" target="_blank" rel="noopener">3.1</a>开始支持.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用函数参数声明</span></span><br><span class="line"><span class="comment">// PropsWithChildren只是扩展了children, 完全可以自己声明</span></span><br><span class="line"><span class="comment">// type PropsWithChildren&lt;P&gt; = P &amp; &#123;</span></span><br><span class="line"><span class="comment">//    children?: ReactNode;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">const</span> Hello = <span class="function">(<span class="params">&#123; name &#125;: PropsWithChildren&lt;HelloProps&gt;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ✅ ok!</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure><p>这种方式也非常简洁, 只不过 defaultProps 的类型和组件本身的 props 没有关联性, 这会使得 defaultProps 无法得到类型约束, 所以必要时进一步显式声明 defaultProps 的类型:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello.defaultProps = &#123; name: <span class="string">'TJ'</span> &#125; <span class="keyword">as</span> Partial&lt;HelloProps&gt;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5️⃣-泛型函数组件"><a href="#5️⃣-泛型函数组件" class="headerlink" title="5️⃣ 泛型函数组件"></a>5️⃣ <strong>泛型函数组件</strong></h4><p>泛型在一下列表型或容器型的组件中比较常用, 直接使用<code>FC</code>无法满足需求:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ListProps&lt;T&gt; &#123;</span><br><span class="line">  visible: <span class="built_in">boolean</span>;</span><br><span class="line">  list: T[];</span><br><span class="line">  renderItem: <span class="function">(<span class="params">item: T, index: <span class="built_in">number</span></span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: ListProps&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;List</span><br><span class="line">      list=&#123;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">      renderItem=&#123;<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/*自动推断i为number类型*/</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="6️⃣-子组件声明"><a href="#6️⃣-子组件声明" class="headerlink" title="6️⃣ 子组件声明"></a>6️⃣ <strong>子组件声明</strong></h4><p>使用<code>Parent.Child</code>形式的 JSX 可以让节点父子关系更加直观, 它类似于一种命名空间的机制, 可以避免命名冲突. 相比<code>ParentChild</code>这种命名方式, <code>Parent.Child</code>更为优雅些. 当然也有可能让代码变得啰嗦.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutProps &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutHeaderProps &#123;&#125; <span class="comment">// 采用ParentChildProps形式命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutFooterProps &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">props: PropsWithChildren&lt;LayoutProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 作为父组件的属性</span></span><br><span class="line"><span class="regexp">Layout.Header = (props: PropsWithChildren&lt;LayoutHeaderProps&gt;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;div className="header"&gt;&#123;props.children&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Layout.Footer = <span class="function">(<span class="params">props: PropsWithChildren&lt;LayoutFooterProps&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"footer"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Test</span></span><br><span class="line"><span class="regexp">&lt;Layout&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Layout.Header&gt;header&lt;/</span>Layout.Header&gt;</span><br><span class="line">  &lt;Layout.Footer&gt;footer&lt;<span class="regexp">/Layout.Footer&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Layout&gt;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="7️⃣-Forwarding-Refs"><a href="#7️⃣-Forwarding-Refs" class="headerlink" title="7️⃣ Forwarding Refs"></a>7️⃣ <strong>Forwarding Refs</strong></h4><p><code>React.forwardRef</code> 在 16.3 新增, 可以用于转发 ref, 适用于 HOC 和函数组件.</p><p>函数组件在 16.8.4 之前是不支持 ref 的, 配合 forwardRef 和 useImperativeHandle 可以让函数组件向外暴露方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment"> * MyModal.tsx</span></span><br><span class="line"><span class="comment"> ****************************/</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useImperativeHandle, FC, useRef, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalProps &#123;</span><br><span class="line">  title?: React.ReactNode;</span><br><span class="line">  onOk?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onCancel?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露的方法, 适用`&#123;ComponentName&#125;Methods`形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalMethods &#123;</span><br><span class="line">  show(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyModal = React.forwardRef&lt;MyModalMethods, MyModalProps&gt;<span class="function">(<span class="params">(<span class="params">props, ref</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> [visible, setVisible] = useState(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 初始化ref暴露的方法</span></span></span></span><br><span class="line"><span class="function"><span class="params">  useImperativeHandle(<span class="params">ref, (<span class="params"></span>) =&gt; (<span class="params">&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">    show: (<span class="params"></span>) =&gt; setVisible(<span class="params"><span class="literal">true</span></span>),</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">  &#125;</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> &lt;Modal visible=&#123;visible&#125;&gt;...&lt;/Modal&gt;;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/*******************</span></span><br><span class="line"><span class="function"> * <span class="params">Test</span>.<span class="params">tsx</span></span></span><br><span class="line"><span class="function"> *******************/</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">Test</span>: <span class="params">FC</span>&lt;&#123;&#125;&gt; = <span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 引用</span></span><br><span class="line">  <span class="keyword">const</span> modal = useRef&lt;MyModalMethods | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> confirm = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modal.current) &#123;</span><br><span class="line">      modal.current.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleOk = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;confirm&#125;&gt;show&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MyModal ref=&#123;modal&#125; onOk=&#123;handleOk&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="2-类组件"><a href="#2-类组件" class="headerlink" title="2. 类组件"></a>2. 类组件</h3><p>相比函数, 基于类的类型检查可能会更好理解(例如那些熟悉传统面向对象编程语言的开发者).</p><h4 id="1️⃣-继承-React-Component-或-React-PureComponent"><a href="#1️⃣-继承-React-Component-或-React-PureComponent" class="headerlink" title="1️⃣ 继承 React.Component 或 React.PureComponent"></a>1️⃣ <strong>继承 React.Component 或 React.PureComponent</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先导出Props声明, 同样是&#123;ComponentName&#125;Props形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> CounterProps &#123;</span><br><span class="line">  defaultCount: <span class="built_in">number</span>; <span class="comment">// 可选props, 不需要?修饰</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组件状态, 不需要暴露</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类注释</span></span><br><span class="line"><span class="comment"> * 继承React.Component, 并声明Props和State类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Counter <span class="keyword">extends</span> React.Component&lt;CounterProps, State&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    defaultCount: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化State</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> state = &#123;</span><br><span class="line">    count: <span class="keyword">this</span>.props.defaultCount,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 声明周期方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 建议靠近componentDidMount, 资源消费和资源释放靠近在一起, 方便review</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentWillUnmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidCatch() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidUpdate(prevProps: CounterProps, prevState: State) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 渲染函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.decrement&#125;&gt;Decrement&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>**</span><br><span class="line">   * ① 组件私有方法, 不暴露</span><br><span class="line">   * ② 使用类实例属性+箭头函数形式绑定<span class="keyword">this</span></span><br><span class="line">   *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  private increment = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count + 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  private decrement = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count - 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="2️⃣-使用static-defaultProps定义默认-props"><a href="#2️⃣-使用static-defaultProps定义默认-props" class="headerlink" title="2️⃣ 使用static defaultProps定义默认 props"></a>2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></h4><p>Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx" target="_blank" rel="noopener">3.0</a>开始支持对使用 defaultProps 对 JSX props 进行推断, 在 defaultProps 中定义的 props 可以不需要’?’可选操作符修饰. 代码如上 👆</p><p><br></p><h4 id="3️⃣-子组件声明"><a href="#3️⃣-子组件声明" class="headerlink" title="3️⃣ 子组件声明"></a>3️⃣ <strong>子组件声明</strong></h4><p>类组件可以使用静态属性形式声明子组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Layout <span class="keyword">extends</span> React.Component&lt;LayoutProps&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Header = Header;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Footer = Footer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-泛型"><a href="#4️⃣-泛型" class="headerlink" title="4️⃣ 泛型"></a>4️⃣ <strong>泛型</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> List&lt;T&gt; <span class="keyword">extends</span> React.Component&lt;ListProps&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="3-高阶组件"><a href="#3-高阶组件" class="headerlink" title="3. 高阶组件"></a>3. 高阶组件</h3><p>在 React Hooks 出来之前, 高阶组件是 React 的一个重要逻辑复用方式. 相比较而言高阶组件比较重, 且难以理解, 容易造成<code>嵌套地狱(wrapper)</code>. 另外对 Typescript 类型化也不友好(以前会使用<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/9c1c7e78a9a2b4af8e2cda842c3693f67bb9e42d/types/react-router/index.d.ts#L137" target="_blank" rel="noopener">Omit</a>来计算导出的 props). 所以新项目还是建议使用 React Hooks.</p><p>一个简单的高阶组件:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给指定组件注入'主题'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withTheme</span>&lt;<span class="title">P</span>&gt;(<span class="params">Component: React.ComponentType&lt;P &amp; ThemeProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * WithTheme 自己暴露的Props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件的props, 忽略ThemeProps, 外部不需要传递这些属性</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">type</span> WithThemeProps = P &amp; OwnProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> WithTheme = <span class="function">(<span class="params">props: WithThemeProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">    <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">      primary: <span class="string">'red'</span>,</span><br><span class="line">      secondary: <span class="string">'blue'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  WithTheme.displayName = <span class="string">`withTheme<span class="subst">$&#123;Component.displayName&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> WithTheme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">const</span> Foo: FC&lt;&#123; a: <span class="built_in">number</span> &#125; &amp; ThemeProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &lt;div style=&#123;&#123; color: props.primary &#125;&#125; /&gt;;</span><br><span class="line"><span class="keyword">const</span> FooWithTheme = withTheme(Foo);</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  &lt;FooWithTheme a=&#123;<span class="number">1</span>&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再重构一下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽取出通用的高阶组件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> HOC&lt;InjectedProps, OwnProps = &#123;&#125;&gt; = &lt;P&gt;(</span><br><span class="line">  Component: React.ComponentType&lt;P &amp; InjectedProps&gt;,</span><br><span class="line">) =&gt; React.ComponentType&lt;P &amp; OwnProps&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withTheme: HOC&lt;ThemeProps&gt; = <span class="function"><span class="params">Component</span> =&gt;</span> props =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">  <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用高阶组件还有一些痛点:</p><ul><li>无法完美地使用 ref(这已不算什么痛点)<ul><li>在 React.forwardRef 发布之前, 有一些库会使用 innerRef 或者 wrapperRef, 转发给封装的组件的 ref.</li><li>无法推断 ref 引用组件的类型, 需要显式声明.</li></ul></li><li>高阶组件类型报错很难理解</li></ul><p><br></p><hr><p><br></p><h3 id="4-Render-Props"><a href="#4-Render-Props" class="headerlink" title="4. Render Props"></a>4. Render Props</h3><p>React 的 props(包括 children)并没有限定类型, 它可以是一个函数. 于是就有了 render props, 这是和高阶组件一样常见的模式:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeConsumerProps &#123;</span><br><span class="line">  children: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeConsumer = <span class="function">(<span class="params">props: ThemeConsumerProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fakeTheme = &#123; primary: <span class="string">'red'</span>, secondary: <span class="string">'blue'</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> props.children(fakeTheme);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line">&lt;ThemeConsumer&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">&#123; primary &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div style=&#123;&#123; color: primary &#125;&#125; /&gt;;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/ThemeConsumer&gt;;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="5-Context"><a href="#5-Context" class="headerlink" title="5. Context"></a>5. Context</h3><p>Context 提供了一种跨组件间状态共享机制</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Theme &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Context的类型, 以&#123;Name&#125;ContextValue命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeContextValue &#123;</span><br><span class="line">  theme: Theme;</span><br><span class="line">  onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Context, 并设置默认值, 以&#123;Name&#125;Context命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext&lt;ThemeContextValue&gt;(&#123;</span><br><span class="line">  theme: &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  onThemeChange: noop,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provider, 以&#123;Name&#125;Provider命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeProvider: FC&lt;&#123; theme: Theme; onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;&#123; theme: props.theme, onThemeChange: props.onThemeChange &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 暴露hooks, 以use&#123;Name&#125;命名</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">export function useTheme() &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="6-杂项"><a href="#6-杂项" class="headerlink" title="6. 杂项"></a>6. 杂项</h3><h4 id="1️⃣-使用handle-Event-命名事件处理器"><a href="#1️⃣-使用handle-Event-命名事件处理器" class="headerlink" title="1️⃣ 使用handle{Event}命名事件处理器."></a>1️⃣ <strong>使用<code>handle{Event}</code>命名事件处理器</strong>.</h4><p>如果存在多个相同事件处理器, 则按照<code>handle{Type}{Event}</code>命名, 例如 handleNameChange.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback&lt;React.MouseEventHandler&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    evt.preventDefault();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;handleClick&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2️⃣-使用-types-react-内置事件处理器的类型"><a href="#2️⃣-使用-types-react-内置事件处理器的类型" class="headerlink" title="2️⃣ 使用 @types/react 内置事件处理器的类型"></a>2️⃣ <strong>使用 @types/react 内置事件处理器的类型</strong></h4><p><code>@types/react</code>内置了以下事件处理器的类型 👇</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventHandler&lt;E <span class="keyword">extends</span> SyntheticEvent&lt;<span class="built_in">any</span>&gt;&gt; = &#123; bivarianceHack(event: E): <span class="built_in">void</span> &#125;[<span class="string">'bivarianceHack'</span>];</span><br><span class="line"><span class="keyword">type</span> ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> CompositionEventHandler&lt;T = Element&gt; = EventHandler&lt;CompositionEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure><p>可以简洁地声明事件处理器类型:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ChangeEventHandler &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 可以限定具体Target的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback&lt;ChangeEventHandler&lt;HTMLInputElement&gt;&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(evt.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;input onChange=&#123;handleChange&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3️⃣-自定义组件暴露事件处理器类型"><a href="#3️⃣-自定义组件暴露事件处理器类型" class="headerlink" title="3️⃣ 自定义组件暴露事件处理器类型"></a>3️⃣ <strong>自定义组件暴露事件处理器类型</strong></h4><p>和原生 html 元素一样, 自定义组件应该暴露自己的事件处理器类型, 尤其是较为复杂的事件处理器, 这样可以避免开发者手动为每个事件处理器的参数声明类型</p><p>自定义事件处理器类型以<code>{ComponentName}{Event}Handler</code>命名. 为了和原生事件处理器类型区分, 不使用<code>EventHandler</code>形式的后缀</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadValue &#123;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露事件处理器类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> UploadChangeHandler = <span class="function">(<span class="params">value?: UploadValue, file?: File</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadProps &#123;</span><br><span class="line">  value?: UploadValue;</span><br><span class="line">  onChange?: UploadChangeHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Upload: FC&lt;UploadProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;...&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-获取原生元素-props-定义"><a href="#4️⃣-获取原生元素-props-定义" class="headerlink" title="4️⃣ 获取原生元素 props 定义"></a>4️⃣ <strong>获取原生元素 props 定义</strong></h4><p>有些场景我们希望原生元素扩展一下一些 props. 所有原生元素 props 都继承了<code>React.HTMLAttributes</code>, 某些特殊元素也会扩展了自己的属性, 例如<code>InputHTMLAttributes</code>. 具体可以参考<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/eafef8bd049017b3998939de2edbab5d8a96423b/types/react/index.d.ts#L203" target="_blank" rel="noopener"><code>React.createElement</code></a>方法的实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fixClass</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">T</span> <span class="title">extends</span> <span class="title">Element</span> = <span class="title">HTMLDivElement</span>,</span></span><br><span class="line"><span class="function">  <span class="title">Attribute</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt; = <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params">cls: <span class="built_in">string</span>, <span class="keyword">type</span>: keyof React.ReactHTML = 'div'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FixedClassName: FC&lt;Attribute&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="keyword">type</span>, &#123; ...props, className: <span class="string">`<span class="subst">$&#123;cls&#125;</span> <span class="subst">$&#123;props.className&#125;</span>`</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FixedClassName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Container = fixClass(<span class="string">'card'</span>);</span><br><span class="line"><span class="keyword">const</span> Header = fixClass(<span class="string">'card__header'</span>, <span class="string">'header'</span>);</span><br><span class="line"><span class="keyword">const</span> Body = fixClass(<span class="string">'card__body'</span>, <span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">const</span> Footer = fixClass(<span class="string">'card__body'</span>, <span class="string">'footer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &lt;Header&gt;header&lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Body&gt;header&lt;/</span>Body&gt;</span><br><span class="line">      &lt;Footer&gt;footer&lt;<span class="regexp">/Footer&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Container&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5️⃣-不要使用-React-PropTypes"><a href="#5️⃣-不要使用-React-PropTypes" class="headerlink" title="5️⃣ 不要使用 React.PropTypes"></a>5️⃣ <strong>不要使用 React.PropTypes</strong></h4><p>有了 Typescript 之后可以安全地约束 Props 和 State, 没有必要引入 React.PropTypes, 而且它的表达能力比较弱</p><p><br></p><h4 id="6️⃣-styled-components"><a href="#6️⃣-styled-components" class="headerlink" title="6️⃣ styled-components"></a>6️⃣ <strong>styled-components</strong></h4><p>styled-components 是目前最流行的<code>CSS-in-js</code>库, Typescript 在 2.9 支持泛型<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#generic-type-arguments-in-generic-tagged-templates" target="_blank" rel="noopener"><code>标签模板</code></a>. 这意味着可以简单地对 styled-components 创建的组件进行类型约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖于@types/styled-components</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components/macro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1&lt;&#123; active?: <span class="built_in">boolean</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; (props.active ? 'red' : 'gray')&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展已有组件</span></span><br><span class="line"><span class="keyword">const</span> NewHeader = styled(Header)&lt;&#123; customColor: <span class="built_in">string</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; props.customColor&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>了解更多<a href="https://www.styled-components.com/docs/api#typescript" target="_blank" rel="noopener">styled-components 和 Typescript</a></p><p><br></p><h4 id="7️⃣-为没有提供-Typescript-声明文件的第三方库自定义模块声明"><a href="#7️⃣-为没有提供-Typescript-声明文件的第三方库自定义模块声明" class="headerlink" title="7️⃣ 为没有提供 Typescript 声明文件的第三方库自定义模块声明"></a>7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></h4><p>笔者一般习惯在项目根目录下(和 tsconfig.json 同在一个目录下)放置一个<code>global.d.ts</code>. 放置项目的全局声明文件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /global.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模块声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'awesome-react-component' &#123;</span><br><span class="line">  <span class="comment">// 依赖其他模块的声明文件</span></span><br><span class="line">  <span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> Foo: React.FC&lt;&#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解更多<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">如何定义声明文件</a></p><p><br></p><h4 id="8️⃣-为文档生成做好准备"><a href="#8️⃣-为文档生成做好准备" class="headerlink" title="8️⃣ 为文档生成做好准备"></a>8️⃣ <strong>为文档生成做好准备</strong></h4><p>目前社区有多种 react 组件文档生成方案, 例如<a href="https://www.docz.site" target="_blank" rel="noopener"><code>docz</code></a>, <a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener"><code>styleguidist</code></a>还有<a href="https://github.com/storybooks/storybook" target="_blank" rel="noopener">storybook</a>. 它们底层都使用<a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener">react-docgen-typescript</a>对 Typescript 进行解析. 就目前而言, 它还有些坑, 而且解析比较慢. 不管不妨碍我们使用它的风格对代码进行注释:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Props注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ColumnProps <span class="keyword">extends</span> React.HTMLAttributes&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">/** prop1 description */</span></span><br><span class="line">  prop1?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">/** prop2 description */</span></span><br><span class="line">  prop2: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * prop3 description</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  prop3: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">/** prop4 description */</span></span><br><span class="line">  prop4: <span class="string">'option1'</span> | <span class="string">'option2'</span> | <span class="string">'option3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对组件进行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Column <span class="keyword">extends</span> Component&lt;ColumnProps, &#123;&#125;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;Column&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9️⃣-开启-strict-模式"><a href="#9️⃣-开启-strict-模式" class="headerlink" title="9️⃣ 开启 strict 模式"></a>9️⃣ <strong>开启 strict 模式</strong></h4><p>为了真正把 Typescript 用起来, 应该始终开启 strict 模式, 避免使用 any 类型声明.</p><p><br></p><hr><p><br></p><h3 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h3><ul><li><a href="https://github.com/piotrwitek/react-redux-typescript-guide" target="_blank" rel="noopener">piotrwitek/react-redux-typescript-guide</a></li><li><a href="https://www.zhihu.com/question/279911703" target="_blank" rel="noopener">TypeScript 如何完美地书写 React 中的 HOC？</a></li><li><a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">Typescript 官方文档</a></li><li><a href="https://basarat.gitbooks.io/typescript/docs/why-typescript.html" target="_blank" rel="noopener">Typescript-deep-dive</a></li><li><a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">Typescript 思维导图</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系列引言&quot;&gt;&lt;a href=&quot;#系列引言&quot; class=&quot;headerlink&quot; title=&quot;系列引言&quot;&gt;&lt;/a&gt;系列引言&lt;/h2&gt;&lt;p&gt;最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对&lt;strong&gt; 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Rx建模入门</title>
    <link href="https://bobi.ink/2019/04/19/rxjs-by-example/"/>
    <id>https://bobi.ink/2019/04/19/rxjs-by-example/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-21T12:08:02.515Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何使用 Rx 的响应式编程思维来对业务逻辑进行建模, 你会了解到响应式编程的优势和业务抽象能力, 学会将现有的业务流程以数据流的方式表达出来. 你的工具库中不能少了 Rx 这件利器.</p><p>Rx 学习曲线陡峭是总所周知的, 我们接触的大部分编程语言或框架都是面向对象的. 在面对 Rx 这响应式编程的方式, 会觉得无从入手,<br>笔者也是 Rx 的初学者, 拜读过多次<a href="https://www.zhihu.com/people/sharpmaster/posts" target="_blank" rel="noopener">徐飞</a>Rx 的相关文章, 基本上都是云里雾里. 主要原因还是思维没有转换过来.</p><p>如果你不理解响应式编程的奥妙，是很难在<strong>‘面向场景编程’</strong>时考虑到 Rx 的优势. 笔者一般遵循’面向场景编程’, 即在对应的场景考虑不同的技术或框架. 可能是痛点还没有到难以忍受的地步，或许是现有应用还不够复杂，我目前为止还没接触到必须要应用 Rx 的场景.</p><p>我觉得应该反过来，采取刻意学习的方式来学习 Rx, 以流的方式来思考，再将其放在现有的场景中看是否有更简洁的解决方案或化学反应.<br>不得不说写 Rx 是一个比较有趣的事情。 但也要认识到 Rx 不是万金油，正如很多教程所说的 Rx 擅长复杂的异步协调，并不是所有场景都适合，一些问题有更简洁的解决方案</p><p><br></p><h2 id="Rx-的建模过程"><a href="#Rx-的建模过程" class="headerlink" title="Rx 的建模过程"></a>Rx 的建模过程</h2><p>对于 Rx 的入门者, 可以使用下面的流程, 一步一步将业务逻辑转换为 Rx 数据流来进行表达.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流程图 -&gt; 数据流抽象 -&gt; 实现</span><br></pre></td></tr></table></figure><h3 id="①-流程图"><a href="#①-流程图" class="headerlink" title="① 流程图"></a><code>① 流程图</code></h3><p>首先从流程图开始, 这个阶段没什么特别的, 不管是响应式编程还是其他范式, 编码之前都需要缕清业务逻辑.</p><p>这个阶段使用<code>流程图</code>来描述技术无关的事务过程, 让业务逻辑更加清晰, 也方便我们识别业务流程的主体和关键事件.</p><blockquote><p>什么是业务逻辑? <a href="https://en.wikipedia.org/wiki/Business_logic" target="_blank" rel="noopener">wiki</a> 上这样定义:<br><strong>Business logic</strong> or domain logic is that part of the program which encodes the real-world business rules that determine how data can be created, displayed, stored, and changed. It prescribes how business objects interact with one another, and enforces the routes and the methods by which business objects are accessed and updated.<br><br> <strong>Business Rules</strong> describe the operations, definitions and constraints that apply to an organization. The operations collectively form a process; every business uses these processes to form systems that get things done.</p></blockquote><p><br><br><br></p><h3 id="②-数据流抽象"><a href="#②-数据流抽象" class="headerlink" title="② 数据流抽象"></a><code>② 数据流抽象</code></h3><p>Rx 的世界里面<em>一切皆流</em>, 换句话说就是<strong>面向流编程</strong>. 和<em>面向对象编程</em>把现实世界的实体抽象为对象一样. 响应式编程将业务中的<em>变动实体</em>(<em>想不到更好的词, 或者变量?</em>)抽象为流</p><p><strong>(1)首先需要识别什么是<em>变动实体</em></strong>? 变动实体一般是数据流的源头, 它驱动着业务走向. 像河流一样, 源头可能不只一个. 我认为变动实体至少具备以下特征之一:</p><ul><li>它是变动的. 例如鼠标的位置, 商品的价格, 随着时间的迁移状态会进行变动</li><li>它是业务的’输入’. 变动实体是一个系统的输入(外部事件)或者是另一个流(衍生)的输入.</li><li>它是业务的参与者(或者说业务的主体).</li><li>它表示业务的状态. 例如一个 todo 列表, 这是一个纯状态的流</li></ul><p><strong>(2)接着识别<em>变动实体</em>之间的关系</strong>. 主体之间的关系也就是流之间的关系, 这是 Rx 建模的核心. 只有理解了主体之间的关系, 才能将主体与业务流程串联起来, 才能真正地使用数据流的方式将业务表达出来. 在<a href="https://www.jianshu.com/p/c95e29854cb1" target="_blank" rel="noopener">重新理解响应式编程</a>一文中对’响应式编程’的定义和笔者的理解非常契合:</p><blockquote><p>响应式编程是一种通过异步和数据流来构建事务关系的编程模型 . 事务关系是响应式编程的核心理念, “数据流”和“异步”是实现这个核心理念的关键.</p></blockquote><p>这种关系和面向对象的类关系是不一样的, 面向对象的关系一般是指依赖关系. 而<strong>数据流之间关系, 是业务之间的实际关系</strong>, 比如流程 b 依赖流程 a, 数据流是变动实体之间的沟通桥梁.</p><p>一般以下面的方法来构建流之间的关系:</p><ul><li>分治: 将业务划分为多个模块(流), 一个大的流总是由小的流组成, 小的流职责更单一, 更容易理解和测试</li><li>变换: 将流映射为另外一个流. 一般用于状态变更或业务衍生(高阶流变换)</li><li>合并: 像河流一样, 数据流最终是需要汇聚在一起注入大海的. 拆分和合并的方式都是依赖于所要表达的业务逻辑</li></ul><p>总的来说变动实体一般就是业务的’<strong>输入</strong>‘, 我们首先把它们确定为流, 再根据关系衍生出其他流(<strong>输出</strong>). 对于流本身来说, <strong>本质上只有输入和输出的关系</strong>:</p><p><img src="/images/03/stream.png" alt="stream"></p><p>例如 increment$和decrement$就是 action$的输入, action$就是 count$的输入, 以此类推. <strong>响应式编程将复杂业务关系转换成原始的输出/输出关系</strong></p><p><strong>(3)符合函数式编程的约束</strong>. 一般来说, 我们说的响应式编程指的是<code>函数式响应式编程(Functional reactive programming FRP)</code>, 所以需要符合函数式的一些约束:</p><ul><li><code>纯函数(Pure)</code>: 函数只是输入参数到输出结果的映射, 不要产生副作用<ul><li>没有共享状态: 不依赖外部变量来维护流程的状态.</li><li>幂等性: 幂等性在复杂流程中很重要, 这使得整个流程可被重试</li><li>没有副作用: 可预测, 可测试.</li></ul></li><li><code>不可变性(Immuatability)</code>: 数据一旦产生, 就肯定它的值不会变化, 这有利于代码的理解. 易于并发</li><li><code>声明式(Declarative)</code>:<ul><li>函数式编程和命令式编程相比有较高的抽象级别, 他可以让你专注于定义与事件相互依存的业务逻辑, 而不是在实现细节上. 换句话说, 函数式编程定义关系, 而命令式编程定义步骤</li><li>集中的逻辑. Rx 自然而然在一处定义逻辑, 避免其他范式逻辑分散在代码库的各个地方. 另外 Rx 的 Observable 通过订阅来创建资源, 通过取消订阅来释放资源, 一般开发几乎不需要去关心资源的生命周期, 例如时间器.</li></ul></li></ul><p>这个阶段将第一个阶段的流程图转换为 Rx <code>弹珠图(Marble Diagrams)</code>表示, 弹珠图可以描述流之间关系, 表现’时间’的流逝, 让复杂的数据流更容易理解</p><p><br><br><br></p><h3 id="③-实现"><a href="#③-实现" class="headerlink" title="③ 实现"></a><code>③ 实现</code></h3><p>这个阶段就是把弹珠图翻译为实现代码, 根据需求在 rxjs 工具箱中查找合适的操作符. 当缕清了业务逻辑, 使用数据流进行建模后,<br>代码实现就是一件很简单的事情了.</p><blockquote><p>可以配合 Rxjs 官方的<a href="https://rxjs.dev/operator-decision-tree" target="_blank" rel="noopener">操作符决策树</a>选择合适的操作符</p></blockquote><p><br></p><hr><p><br></p><p>下面使用例子来体会 Rx 的编程思维:</p><h2 id="Example-1-c-a-b"><a href="#Example-1-c-a-b" class="headerlink" title="Example 1: c := a + b"></a>Example 1: c := a + b</h2><p>这是最简单的实例, 我们期望当 a 和 b 变动时能够响应到 c, 我们按照上述的步骤对这个需求进行建模:</p><ul><li><p><code>流程</code>:</p><p><img src="/images/03/process-02.png" alt="c=a+b"></p></li><li><p><code>数据流抽象</code>: 从上可以识别出两个变动的实体 a 和 b, 所以 a 和 b 都可以视作流, 那么 c 就是 a 和 b 衍生出来的流, 表示 a 和 b 的实时加法结果, 使用弹珠图来描述三者的关系:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">a$</span>: ----1------------2---------------</span><br><span class="line"><span class="meta">b$</span>: --2-------4------------6------8------</span><br><span class="line">              \ (a + b) /</span><br><span class="line"><span class="meta">c$</span>: ----3-----5------6-----8------10-----</span><br></pre></td></tr></table></figure></li><li><p><code>代码实现</code>: 由弹珠图可以看出, c$流的输出值就是a$和 b$输出值的实时计算结果, 也就是说c$接收来自 a$和b$ 的最新数据, 输出他们的和.<br>另外由原本的两个流合并为单个流, 在 rxjs 工具箱中可以找到<code>combineLatest</code>操作符符合该场景. 代码实现如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a$ = interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> b$ = interval(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">a$.pipe(combineLatest(b$))</span><br><span class="line">  .pipe(map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b))</span><br><span class="line">  .subscribe(<span class="function"><span class="params">sum</span> =&gt;</span> <span class="built_in">console</span>.log(sum));</span><br></pre></td></tr></table></figure></li></ul><p><br></p><hr><p><br></p><h2 id="Example-2-元素拖拽的例子"><a href="#Example-2-元素拖拽的例子" class="headerlink" title="Example 2: 元素拖拽的例子"></a>Example 2: 元素拖拽的例子</h2><p>元素拖拽也是 Rx 的经典例子的的例子. 假设我们需要先移动端和桌面端都支持元素拖拽移动.</p><p><code>流程图</code></p><p><img src="/images/03/process-01.png" alt></p><p><code>数据流抽象</code></p><p>这里使用分治的方法, 将流程进行一步步拆解, 然后使用弹珠图的形式进行描述.</p><p>由上面的流程图可以识别出来, down, move 以及 up 都是<code>变动实体</code>, 我们可以将他们视作’流’.</p><p>① down/move/up 都是抽象的事件, 在桌面端下是 mousedown/mousemove/mouseup, 移动端下对应的是<br>touchstart/touchmove/touchend. 我们不区分这些事件, 例如接收到 mousedown 或 touchstart 事件都认为是一个’down’事件. 所以事件监听的数据流如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1</span><br><span class="line"><span class="meta">mousedown$</span> : ---d----------d--------</span><br><span class="line"><span class="meta">touchstart$</span>: -s---s-----------s-----</span><br><span class="line">        \(merge)/</span><br><span class="line"><span class="meta">down$</span>      : -s-d-s--------d--s-----</span><br></pre></td></tr></table></figure><p>move 和 up 事件同理</p><p>② 接下来要识别 up$, move$, down$ 三个数据流之间的关系, down 事件触发后我们才会去监听 move 和 up 事件, 也就是说由 down$可以衍生出 move$和 up$流. 在 up 事件触发后整个流程就终止. up$流决定了整个流程的生命周期的结束</p><p>使用弹珠图的描述三者的关系如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 2</span><br><span class="line"><span class="meta">down$</span>: -----d-------------------------</span><br><span class="line">             \</span><br><span class="line"><span class="meta">up$</span>  :        ----------u|</span><br><span class="line"><span class="meta">move$</span>:        -m--m--m---|</span><br></pre></td></tr></table></figure><p>③ 一个拖拽结束后还可以重新再发起拖拽, 即我们会持续监听 down 事件. 上面的流程还规定如果当前拖拽还未结束,<br>其他 down 事件应该被忽略, 在移动端下多点触摸是可能导致多个 down 事件触发的.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 3</span><br><span class="line"><span class="meta">down$</span>: ---d---d--d---------d------    # 中间两个事件因为拖拽未完成被忽略</span><br><span class="line">           \                \</span><br><span class="line"><span class="meta">up$</span>:        -----u|          ------u|</span><br><span class="line"><span class="meta">move$</span>:      -m-mm-|          m-m-m--|</span><br></pre></td></tr></table></figure><p><code>实现</code>:</p><p>有了弹珠图后, 就是把翻译问题了, 现在就打开 rxjs 的工具箱, 找找有什么合适的工具.</p><p>首先是抽象事件的处理. 由#1 可以看出, 这就是一个数据流合并, 这个适合使用<code>merge</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">merge(fromEvent(el, <span class="string">'touchstart'</span>), fromEvent(el, <span class="string">'mousedown'</span>));</span><br></pre></td></tr></table></figure><p>down$流的切换可以使用<code>exhaustMap</code>操作符, 这个操作符可以将输出值映射为Observable, 最后再使用exhaust操作符对Observable进行合并.<br>这可以满足我们’当一个拖拽未结束时, 新发起的 down$输出会被忽略, 直到拖拽完结’的需求</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">down$</span><br><span class="line">  .pipe(</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">evt</span> =&gt;</span> <span class="comment">/* 转换为新的Observable流 */</span>)</span><br></pre></td></tr></table></figure><p>使用 exhaustMap 来将 down$输出值转换为move$ 流, 并在 up$ 输出后结束, 可以使用<code>takeUntil</code>操作符:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">down$</span><br><span class="line">  .pipe(</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">      evt.preventDefault();</span><br><span class="line">      <span class="keyword">if</span> (evt.type === <span class="string">'mousedown'</span>) &#123;</span><br><span class="line">        <span class="comment">// 鼠标控制</span></span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = evt <span class="keyword">as</span> MouseEvent;</span><br><span class="line">        <span class="keyword">return</span> mouseMove$.pipe(</span><br><span class="line">          map(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              deltaX: (evt <span class="keyword">as</span> MouseEvent).clientX - clientX,</span><br><span class="line">              deltaY: (evt <span class="keyword">as</span> MouseEvent).clientY - clientY,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;),</span><br><span class="line">          takeUntil(mouseUp$),</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 触摸事件</span></span><br><span class="line">        <span class="keyword">const</span> &#123; touches &#125; = evt <span class="keyword">as</span> TouchEvent;</span><br><span class="line">        <span class="keyword">const</span> touch = touches[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = touch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> getTouch = <span class="function">(<span class="params">evt: TouchEvent</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> touches = <span class="built_in">Array</span>.from(evt.changedTouches);</span><br><span class="line">          <span class="keyword">return</span> touches.find(<span class="function"><span class="params">t</span> =&gt;</span> t.identifier === touch.identifier);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> touchFilter = filter(<span class="function">(<span class="params">e: Event</span>) =&gt;</span> !!getTouch(e <span class="keyword">as</span> TouchEvent));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> touchMove$.pipe(</span><br><span class="line">          touchFilter,</span><br><span class="line">          map(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> touch = getTouch(evt <span class="keyword">as</span> TouchEvent)!;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              deltaX: touch.clientX - clientX,</span><br><span class="line">              deltaY: touch.clientY - clientY,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;),</span><br><span class="line">          takeUntil(touchUp$.pipe(touchFilter)),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">delta</span> =&gt;</span> &#123;</span><br><span class="line">    el.style.transform = <span class="string">`translate(<span class="subst">$&#123;delta.deltaX&#125;</span>px, <span class="subst">$&#123;delta.deltaY&#125;</span>px)`</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="Example-3-Todos"><a href="#Example-3-Todos" class="headerlink" title="Example 3: Todos"></a>Example 3: Todos</h2><p>如果使用 rxjs 来创建 Todos 应用, 首先是<code>流程图</code>:</p><p><img src="/images/03/process-03.png" alt></p><p><code>数据流抽象</code>:</p><p>首先识别变动的实体, 变动的实体就是 todos 列表, 所以可以认为 todos 列表就是一个流. 它从 localStorage 中恢复<br>初始化状态. 由<code>新增</code>, <code>删除</code>等事件触发状态改变, 这些事件也可以视作流</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">add$</span>:      --a-----a------</span><br><span class="line"><span class="meta">modify$</span>:   ----m----------</span><br><span class="line"><span class="meta">remove$</span>    -------r-------</span><br><span class="line"><span class="meta">complete$</span>: ------c----c---</span><br><span class="line">             \(merge)/</span><br><span class="line"><span class="meta">update$</span>    --a-m-cra--c--- # 各种事件合并为update$流</span><br><span class="line">              \(reduce)/</span><br><span class="line"><span class="meta">todos$</span>:    i-u-u-uuu--u---- # i 为初始化数据, update$的输出将触发重新计算状态</span><br></pre></td></tr></table></figure><p>todos$流会响应到 view 上, 另一方面需要持久化到本地存储. 也就是说这是一个多播流.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">todos$</span>: i-u-u-uuu--u---- #</span><br><span class="line">          \(debounce)/</span><br><span class="line"><span class="meta">save$</span>   i--u--u---u----- # 存储流, 使用debounce来避免频繁存储</span><br></pre></td></tr></table></figure><p>并行渲染到页面:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">todos$</span>: i-u-u-uuu--u---- #</span><br><span class="line">       \(render)/</span><br><span class="line"><span class="meta">dom$</span>:   i--u--u---u----- # dom渲染, 假设也是流(cycle.js就是如此)</span><br></pre></td></tr></table></figure><p>这个实例的数据流和 Redux 的模型非常像, add$, modify$, remove$和complete$就是 Action, todos 流会使用<br>类似 Reducer 的机制来处理这些 Action 生成新的 State</p><p><img src="/images/03/redux.png" alt="redux"></p><p><code>代码实现</code>:</p><p>首先 add$, modify$以及 remove$和complete$可以分别使用一个 Subject 对象来表示, 用于接收外部事件. 其实还可以简化为一个流,<br>它们的区别只是参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Action&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  payload: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INIT_ACTION = <span class="string">'INIT'</span>; <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> ADD_ACTION = <span class="string">'ADD'</span>;</span><br><span class="line"><span class="keyword">const</span> REMOVE_ACTION = <span class="string">'REMOVE'</span>;</span><br><span class="line"><span class="keyword">const</span> MODIFY_ACTION = <span class="string">'MODIFY'</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETE_ACTION = <span class="string">'COMPLETE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update$ = <span class="keyword">new</span> Subject&lt;Action&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: ADD_ACTION,</span><br><span class="line">    payload: value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: REMOVE_ACTION,</span><br><span class="line">    payload: id,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: COMPLETE_ACTION,</span><br><span class="line">    payload: id,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">id: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: MODIFY_ACTION,</span><br><span class="line">    payload: &#123; id, value &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建todos$流, 对update$ 的输出进行 reduce:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化Store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialStore</span>(<span class="params"></span>): <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="built_in">window</span>.localStorage.getItem(STORAGE_KEY);</span><br><span class="line">  <span class="keyword">return</span> value ? <span class="built_in">JSON</span>.parse(value) : &#123; list: [] &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos$ = update$.pipe(</span><br><span class="line">  <span class="comment">// 从INIT_ACTION 触发scan初始化</span></span><br><span class="line">  startWith(&#123; <span class="keyword">type</span>: INIT_ACTION &#125; <span class="keyword">as</span> Action),</span><br><span class="line">  <span class="comment">// reducer</span></span><br><span class="line">  scan&lt;Action, Store&gt;<span class="function">(<span class="params">(<span class="params">state, &#123; <span class="keyword">type</span>, payload &#125;</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> produce(<span class="params">state, draftState =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">let</span> idx: <span class="built_in">number</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">switch</span> (<span class="params"><span class="keyword">type</span></span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> ADD_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          draftState.list.push(<span class="params">&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">            id: <span class="built_in">Date</span>.now(<span class="params"></span>).toString(<span class="params"></span>),</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">            value: payload,</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          &#125;</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> MODIFY_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload.id</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list[idx].value = payload.value;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> REMOVE_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list.splice(<span class="params">idx, 1</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> COMPLETE_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list[idx].completed = <span class="literal">true</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">default</span>:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, initialStore(<span class="params"></span>)</span>),</span></span><br><span class="line"><span class="function">  // 支持多播</span></span><br><span class="line"><span class="function">  <span class="params">shareReplay</span><span class="params">()</span>,</span></span><br><span class="line"><span class="function">);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 持久化</span></span><br><span class="line"><span class="function"><span class="params">todos</span>$.<span class="params">pipe</span>(<span class="params">debounceTime(<span class="params">1000</span>)</span>).<span class="params">subscribe</span>(<span class="params">store =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">window</span>.localStorage.setItem(<span class="params">STORAGE_KEY, <span class="built_in">JSON</span>.stringify(<span class="params">store</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br></pre></td></tr></table></figure><blockquote><p>更多例子: 徐飞在<a href="https://github.com/xufei/blog/issues/44" target="_blank" rel="noopener">“RxJS 入门指引和初步应用&gt;”</a>提到了一个”幸福人生”的例子, 挺有意思, 读者可以尝试对其进行建模</p></blockquote><p><br></p><hr><p><br></p><p>经过上述过程, 可以深刻体会到<em>函数响应式编程</em>的<strong>优势</strong>:</p><ul><li><strong>数据流抽象了很多现实问题</strong>. 也就说数据流对业务逻辑的表达能力流程图基本一致. 可以说弹珠图是流程图的直观翻译, 而 Rx 代码则是弹珠图的直观翻译. 使用 Rx 以声明式形式编写代码, 可以让代码更容易理解, 因为它们接近业务流程.</li><li><strong>把复杂的问题分解成简单的问题的组合</strong>. Rx 编程本质上就是数据流的分治和合并</li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.jianshu.com/p/c95e29854cb1" target="_blank" rel="noopener">重新理解响应式编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/53009201" target="_blank" rel="noopener">【响应式编程的思维艺术】响应式 Vs 面向对象</a></li><li><a href="http://www.uml.org.cn/zjjs/201008021.asp" target="_blank" rel="noopener">细说业务逻辑</a></li><li><a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">Reactive programming</a></li><li><a href="https://github.com/xufei/blog/issues/44" target="_blank" rel="noopener">RxJS 入门指引和初步应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍如何使用 Rx 的响应式编程思维来对业务逻辑进行建模, 你会了解到响应式编程的优势和业务抽象能力, 学会将现有的业务流程以数据流的方式表达出来. 你的工具库中不能少了 Rx 这件利器.&lt;/p&gt;
&lt;p&gt;Rx 学习曲线陡峭是总所周知的, 我们接触的大部分编程语言或框架都
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Yarn Plug&#39;n&#39;Play可否助你脱离node_modules苦海?</title>
    <link href="https://bobi.ink/2019/04/08/plug-n-play/"/>
    <id>https://bobi.ink/2019/04/08/plug-n-play/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-07T04:18:21.737Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Yarn(v1.12+)的 Plug’n’Play 机制来取代 node_modules. 目前这还是一个实验性的特性.</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/images/node_modules-hole.png" alt="node_modules"></p><p><code>node_modules</code>早就成为的全民吐槽的对象, 其他语言的开发者看到 node_modules 对 Node 就望而祛步了,<br>用一个字来形容的话就是’重!’.</p><blockquote><p>如果不了解 Node 模块查找机制, 请点击<a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">require() 源码解读</a></p></blockquote><p>一个简单的前端项目(<em>create-react-app</em>)的大小和文件数:</p><center><br>  <img src="/images/front-end-project.png" alt="frontend-project" width="400"><br></center><p>而 macOS 的<code>/Library</code>目录的大小的文件数:</p><center><br>  <img src="/images/mac-library.png" alt="macos library" width="400"><br></center><p>一行<code>hello world</code>就需要安装 130MB 以上的依赖模块, 而且文件数是<strong>32,313</strong>. 相比之下 macOS 的<code>/Library</code><br>的空间占用 9.02GB, 文件数只是前者的两倍(<strong>67,890</strong>). 综上可以看出 node_modules 的特点是:</p><ul><li>目录树结构复杂</li><li>文件数较多且都比较小</li><li>依赖多, 一个简单的项目就要安装好几吨依赖</li></ul><p>所以说 node_modules 对于机械硬盘来说是个噩梦, 记得有一次一个同事删除 node_modules 一个下午都没搞定.<br>对于前端开发者来说, 我们有 N 个需要<code>npm install</code>的项目 😹.</p><p>除此之外, Node 的模块机制还有以下<strong>缺点</strong>:</p><ul><li><p>Node 本身并没有模块的概念, 它在运行时进行查找和加载. 这个缺点和<em>‘动态语言与静态语言的优劣对比’</em>相似,<br>你可能在开发环境运行得好好的, 可能到了线上就运行不了了, 原因是一个模块没有添加到 package.json</p></li><li><p>Node 模块的查找策略非常浪费. 这个缺点在大部分前端项目中可以进行优化,<br>比如 webpack 就可以限定只在项目根目录下的 node_modules 中查找, 但是对于嵌套的依赖, 依然需要 2 次以上的查找</p></li><li><p>node_modules 不能有效地处理重复的包. 两个名称相同但是不同版本的包是不能在一个目录下共存的.<br>所以会导致嵌套的 node_modules, 而且这些项目’依赖的依赖’是无法和项目或其他依赖共享的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ① 假设项目依赖a,b,c三个模块, 依赖树为:</span><br><span class="line"><span class="meta">#</span>  +- a</span><br><span class="line"><span class="meta">#</span>    +- react@15</span><br><span class="line"><span class="meta">#</span>  +- b</span><br><span class="line"><span class="meta">#</span>    +- react@16</span><br><span class="line"><span class="meta">#</span>  +- c</span><br><span class="line"><span class="meta">#</span>    +- react@16</span><br><span class="line"><span class="meta">#</span> yarn安装时会按照项目被依赖的次数作为权重, 将依赖提升(hoisting),</span><br><span class="line"><span class="meta">#</span> 安装后的node_modules结构为:</span><br><span class="line">  .</span><br><span class="line">  └── node_modules</span><br><span class="line">      ├── a</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   ├── node_modules</span><br><span class="line">      │   │   └── react  # @15</span><br><span class="line">      │   └── package.json</span><br><span class="line">      ├── b</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   └── package.json</span><br><span class="line">      ├── c</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   └── package.json</span><br><span class="line">      └── react  # @16 被依赖了两次, 所以进行提升</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> ② 现在假设在①的基础上, 根项目依赖了react@15, 对于项目自己的依赖肯定是要放在node_modules根目录的,</span><br><span class="line"><span class="meta">#</span> 由于一个目录下不能存在同名目录, 所以react@16没有的提升机会. </span><br><span class="line"><span class="meta">#</span> 安装后node_moduels结构为</span><br><span class="line">  .</span><br><span class="line">  └── node_modules</span><br><span class="line">      ├── a</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   └── package.json # react@15 提升</span><br><span class="line">      ├── b</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   ├── node_modules</span><br><span class="line">      │   │   └── react  # @16</span><br><span class="line">      │   └── package.json</span><br><span class="line">      ├── c</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   ├── node_modules</span><br><span class="line">      │   │   └── react  # @16</span><br><span class="line">      │   └── package.json</span><br><span class="line">      └── react  # @15</span><br><span class="line"><span class="meta">#</span> 上面的结果可以看出, react@16出现了重复</span><br></pre></td></tr></table></figure></li></ul><p>为此 Yarn 集成了<code>Plug&#39;n&#39;Play</code>(简称 pnp), 中文名称可以称为’即插即用’, 来解决 node_modules’地狱’.</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>按照普通的按照流程, Yarn 会生成一个 node_modules 目录, 然后 Node 按照它的模块查找规则在 node_modules 目录中查找.<br>但实际上 Node 并不知道这个模块是什么, 它在 node_modules 查找, 没找到就在父目录的 node_modules 查找, 以此类推.<br>这个效率是非常低下的.</p><p><strong>但是 Yarn 作为一个包管理器, 它知道你的项目的依赖树. 那能不能让 Yarn 告诉 Node? 让它直接到某个目录去加载模块.<br>这样即可以提高 Node 模块的查找效率, 也可以减少 node_modules 文件的拷贝. 这就是<code>Plug&#39;n&#39;Play</code>的基本原理.</strong></p><p>在 pnp 模式下, Yarn 不会创建 node_modules 目录, 取而代之的是一个<code>.png.js</code>文件, 这是一个 node 程序,<br>这个文件包含了项目的依赖树信息, 模块查找算法, 也包含了模块查找器的 patch 代码(在 Node 环境, 覆盖 Module._load 方法).</p><p><br></p><p>使用 pnp 机制的以下<strong>优点</strong>:</p><ul><li>摆脱 node_modules.<ul><li>时间上: 相比较在热缓存(hot cache)环境下运行<code>yarn install</code>节省 70%的时间</li><li>空间上: pnp 模式下, 所有 npm 模块都会存放在全局的缓存目录下, 依赖树扁平化, 避免拷贝和重复</li></ul></li><li>提高模块加载效率. Node 为了查找模块, 需要调用大量的 stat 和 readdir 系统调用.<br>pnp 通过 Yarn 获取或者模块信息, 直接定位模块</li><li>不再受限于 node_modules 同名模块不同版本不能在同一目录</li></ul><blockquote><p>在 Mac 下 Yarn 的安装速度非常快, 热缓存下仅需几秒. 原因是 SSD + APFS 的 Copy-on-write 机制.<br>这使得文件的拷贝不用占用空间, 相当于创建一个链接. 所以拷贝和删除的速度非常快.<br>但是 node_modules 复杂的目录结构和超多的文件, 仍然需要调用大量的系统调用, 这也会拖慢安装过程.<br><br><br>💡 如果觉得 pnp 繁琐或不可靠, 那就赶紧用上 SSD 配合支持 Copy-on-write 的文件系统.</p></blockquote><p><br></p><p>使用 pnp 的<strong>风险</strong>:</p><p>目前前端社区的各种工具都依赖于 node_modules 模块查找机制. 例如</p><ul><li>Node</li><li>Electron, electron-builder 等等</li><li>Webpack</li><li>Typescript: 定位类型声明文件</li><li>Babel: 定位插件和 preset</li><li>Eslint: 定位插件和 preset, rules</li><li>Jest</li><li>编辑器, 如 VsCode</li><li>…😿</li></ul><p>pnp 一个非常新的东西, 在去年 9 月份(2018)面世. 要让这些工具和 pnp 集成是个不小的挑战, 而且这些这些工具<br>和 pnp 都是在不断迭代的, pnp 还不稳定, 未来可能变化, 这也会带来某些维护方面的负担.</p><p>除了模块查找机制, 有一些工具是直接在 node_modules 中做其他事情的, 比如缓存, 存放临时证书. 例如<code>cache-loader</code>, <code>webpack-dev-server</code></p><h2 id="开启-pnp"><a href="#开启-pnp" class="headerlink" title="开启 pnp"></a>开启 pnp</h2><p>如果只是单纯的 Node 项目, 迁入过程还算比较简单. 首先在<code>package.json</code>开启 pnp 安装模式:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"installConfig"</span>: &#123;</span><br><span class="line">    <span class="attr">"pnp"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着安装依赖:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add express</span><br></pre></td></tr></table></figure><p>安装后项目根目录就会出现一个<code>.pnp.js</code>文件. 下一步编写代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; res.send(<span class="string">'Hello World!'</span>));</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>));</span><br></pre></td></tr></table></figure><p>接下来就是运行 Node 代码了, 如果直接<code>node index.js</code>会报<code>Error: Cannot find module &#39;express&#39;</code>异常.<br>这是因为还没有 patch Node 的模块查找器. 可以通过以下命令运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"></span><br><span class="line">node --require="./.pnp.js" index.js</span><br></pre></td></tr></table></figure><blockquote><p><code>.pnp.js</code>文件不应该提交到版本库, 这个文件里面包含了硬编码的缓存目录. 在 Yarn v2 中会进行重构</p></blockquote><h2 id="怎么集成到现有项目"><a href="#怎么集成到现有项目" class="headerlink" title="怎么集成到现有项目?"></a>怎么集成到现有项目?</h2><p>pnp 集成无非就是重新实现现有工具的模块查找机制. 随着前端工程化的发展, 一个前端项目会集成非常多的工具,<br>如果这些工具没法适配, 可以说 pnp 很难往前走. 然而这并不是 pnp 能够控制的, 需要这些工具开发者的配合.</p><p>社区上不少项目已经集成了 pnp:</p><ul><li><a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a></li><li><a href="https://github.com/gatsbyjs/gatsby" target="_blank" rel="noopener">gastby</a></li></ul><p><br></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>对于 Node, pnp 是开箱即用的, 直接使用<code>--require=&quot;./.pnp.js&quot;</code>导入<code>.pnp.js</code>文件即可,<br><code>.pnp.js</code>会对 Node 的 Module 对象进行 patch, 重新实现模块查找机制</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 使用的模块查找器是<a href="https://github.com/webpack/enhanced-resolve" target="_blank" rel="noopener"><code>enhanced-resolve</code></a>, 可以通过<a href="https://github.com/arcanis/pnp-webpack-plugin" target="_blank" rel="noopener"><code>pnp-webpack-plugin</code></a>插件来扩展<code>enhanced-resolve</code><br>来支持 pnp.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PnpWebpackPlugin = <span class="built_in">require</span>(<span class="string">`pnp-webpack-plugin`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 扩展模块查找器</span></span><br><span class="line">    plugins: [PnpWebpackPlugin],</span><br><span class="line">  &#125;,</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    <span class="comment">// 扩展loader模块查找器.</span></span><br><span class="line">    plugins: [PnpWebpackPlugin.moduleLoader(<span class="built_in">module</span>)],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h3><p><a href="http://jestjs.io" target="_blank" rel="noopener">jest</a>支持通过<code>resolver</code>来配置查找器:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolver: <span class="built_in">require</span>.resolve(<span class="string">`jest-pnp-resolver`</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h3><p>Typescript 也使用自己的模块查找器, TS团队为了性能方面的考虑, 暂时不允许第三方工具来扩展查找器. 也就是说<strong>暂时不能用</strong>.</p><p>在这个<a href="https://github.com/Microsoft/TypeScript/issues/28289" target="_blank" rel="noopener">issue</a>中, 有人提出使用<code>&quot;moduleResolution&quot;: &quot;yarnpnp&quot;</code>或者使用类似<a href="https://github.com/TypeStrong/ts-loader" target="_blank" rel="noopener"><code>ts-loader</code></a>的<a href="https://github.com/arcanis/pnp-webpack-plugin/blob/b09fbdc2a9f16dc3837454b8d367963b1a30655f/index.js#L141" target="_blank" rel="noopener"><code>resolveModuleName</code></a>的方式支持 pnp 模块查找.</p><p>TS 团队的回应是: pnp(或者 npm 的 tink)还是早期阶段, 未来可能会有变化, 例如<code>.pnp.js</code>文件, 显然不合适那么早入坑.<br>另外为了优化和控制编译器性能, TS 也没有计划在编译期间暴露接口给第三方执行代码.</p><p>所以现在 Typescript 至今也没有类似 babel 的插件机制. 除非自己实现一个’TS compiler host’, 例如<code>ts-loader</code>就自己扩展了插件机制和模块查找机制, 来支持类似<a href="https://github.com/Brooooooklyn/ts-import-plugin" target="_blank" rel="noopener">ts-import-plugin</a>等插件, 因此<code>ts-loader</code>现在是支持 pnp 的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PnpWebpackPlugin = <span class="built_in">require</span>(<span class="string">`pnp-webpack-plugin`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        loader: <span class="built_in">require</span>.resolve(<span class="string">'ts-loader'</span>),</span><br><span class="line">        options: PnpWebpackPlugin.tsLoaderOptions(),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>总结, <strong><code>Typescript</code>暂时不支持</strong>, 且近期也没有开发计划, 所以<code>VsCode</code>也别指望了. <a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin/issues/181" target="_blank" rel="noopener"><code>fork-ts-checker-webpack-plugin</code></a>也还没跟上. 显然 Typescript 是 pnp 的第一拦路虎</p><p><br></p><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ul><li><a href="https://github.com/arcanis/rollup-plugin-pnp-resolve" target="_blank" rel="noopener">rollup-plugin-pnp-resolve</a></li><li><a href="https://yarnpkg.com/en/package/resolve" target="_blank" rel="noopener">resolve</a>: babel, gulp</li><li><a href="https://github.com/yarnpkg/yarn/pull/6449" target="_blank" rel="noopener">eslint</a>: 到 v6 才能<a href="https://github.com/yarnpkg/berry/issues/8" target="_blank" rel="noopener">完美支持</a>.</li><li><a href="https://github.com/facebook/flow/issues/7014" target="_blank" rel="noopener">flow</a></li><li><a href="https://github.com/facebook/create-react-app/pull/5136" target="_blank" rel="noopener">create-react-app</a> 支持 pnp, 但是 Typescript 模式下不支持</li><li>electron: 暂时没有相关的消息. 对于一个electron应用来说, 依赖是自包含的, 所以pnp可能不适合该场景</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上, pnp 是一个不错的解决方案, 可以解决 Node 模块机制的空间和时间的效率问题. 但是在现阶段, 它还不是成熟, 有<br>很多坑要踩, 且和社区各种工具集成存在不少问题. 所以还不建议在生产环境中使用.</p><p>所以目前阶段对于普通开发者来说, 如果要提升npm安装速度, 还是得上SSD+Copy-On-Write!😂</p><p>下面是各种项目的集成情况(✅(支持)|🚧(计划中或不完美)|❌(不支持)):</p><table><thead><tr><th>项目</th><th></th></tr></thead><tbody><tr><td>Webpack</td><td>✅</td></tr><tr><td>rollup</td><td>✅</td></tr><tr><td>browserify</td><td>✅</td></tr><tr><td>gulp</td><td>✅</td></tr><tr><td>jest</td><td>✅</td></tr><tr><td>Node</td><td>✅</td></tr><tr><td>Typescript/VScode IntelliSense</td><td>❌</td></tr><tr><td>eslint</td><td>🚧</td></tr><tr><td>flow</td><td>🚧</td></tr><tr><td>create-react-app</td><td>🚧</td></tr><tr><td>ts-loader</td><td>✅</td></tr><tr><td>fork-ts-checker-webpack-plugin</td><td>🚧</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/yarnpkg/rfcs/blob/master/accepted/0000-plug-an-play.md" target="_blank" rel="noopener">Plug’n’Play Whitepaper</a> pnp的论文</li><li><a href="https://medium.freecodecamp.org/getting-rid-of-node-modules-with-yarn-plugn-play-a490e5e747d7" target="_blank" rel="noopener">How to get rid of node_modules with Yarn Plug’n’Play</a></li><li><a href="https://yarnpkg.com/en/docs/pnp" target="_blank" rel="noopener">Yarn 官方文档</a></li><li><a href="https://github.com/yarnpkg/pnp-sample-app" target="_blank" rel="noopener">pnp-sample-app</a> pnp 官方示例</li><li><a href="https://github.com/yarnpkg/yarn/issues/6953" target="_blank" rel="noopener">Yarn’s Future - v2 and beyond</a></li><li><a href="https://medium.com/@thomasreggi/yarn-plugn-play-1c398bf3e417" target="_blank" rel="noopener">Hacker News Discussion</a></li></ul><p>相关 issues:</p><ul><li><a href="https://github.com/yarnpkg/yarn/issues/6388" target="_blank" rel="noopener">Yarn Plug ‘N Play should generate a static manifest file, not <code>.pnp.js</code></a></li><li><a href="https://github.com/Microsoft/TypeScript/issues/28289" target="_blank" rel="noopener">Typescript: Add new moduleResolution option: <code>yarn-pnp</code></a></li><li><a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin/issues/181" target="_blank" rel="noopener">fork-ts-checker-webpack-plugin: Custom resolveModuleName</a></li></ul><p>其他方案</p><ul><li><a href="https://github.com/npm/tink" target="_blank" rel="noopener">npm tink</a>: a dependency unwinder for javascript</li><li><a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">pnpm</a> Fast, disk space efficient package manager</li><li><a href="https://yarnpkg.com/en/docs/workspaces" target="_blank" rel="noopener">Yarn Workspaces</a> 多个项目共有依赖</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 Yarn(v1.12+)的 Plug’n’Play 机制来取代 node_modules. 目前这还是一个实验性的特性.&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Rxjs 操作符决策树 - Mindnode</title>
    <link href="https://bobi.ink/2019/04/06/rx-operations/"/>
    <id>https://bobi.ink/2019/04/06/rx-operations/</id>
    <published>2019-04-05T16:00:00.000Z</published>
    <updated>2019-04-06T09:27:17.301Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Mindnode</strong> 是 macOS 下一个美观简洁的思维导图工具, 它是一个强大的学习/整理工具, 本文列举了近日学习<code>rxjs</code>所整理出来的思维导图.</p><blockquote><p>图片较大, 加载可能需要一点时间. 建议右击图片在新的 Tab 中查看</p></blockquote><blockquote><p>Mindode项目<a href="https://github.com/ivan-94/mindnodes/tree/master/rxjs/操作符" target="_blank" rel="noopener">地址</a>, 可以在这个项目获取原始的Mindode文件.</p></blockquote><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul><li><a href="https://rxjs.dev" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://rxmarbles.com/#distinctUntilChanged" target="_blank" rel="noopener">可交互的弹珠图</a> 直观地理解操作符的功能</li><li><a href="https://rxjs-cn.github.io/learn-rxjs-operators/" target="_blank" rel="noopener">reactive.how</a> 学习响应式编程的动画卡片</li><li><a href="https://rxjs-cn.github.io/learn-rxjs-operators/" target="_blank" rel="noopener">学习RxJS操作符</a></li><li><a href="https://www.amazon.cn/dp/B07CXZ9D8N/ref=sr_1_1?__mk_zh_CN=亚马逊网站&amp;keywords=rxjs&amp;qid=1554539743&amp;s=gateway&amp;sr=8-1" target="_blank" rel="noopener">book: 深入浅出RxJS</a></li></ul><h2 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/创建操作符.png" alt="创建操作符"></p><h2 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/过滤.png" alt="过滤操作符"></p><h2 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/转换.png" alt="转换操作符"></p><h2 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/组合.png" alt="组合操作符"></p><h2 id="分组操作符"><a href="#分组操作符" class="headerlink" title="分组操作符"></a>分组操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/分组.png" alt="分组操作符"></p><h2 id="错误处理操作符"><a href="#错误处理操作符" class="headerlink" title="错误处理操作符"></a>错误处理操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/错误处理.png" alt="错误处理操作符"></p><h2 id="辅助-条件-数学-配置操作符"><a href="#辅助-条件-数学-配置操作符" class="headerlink" title="辅助-条件-数学-配置操作符"></a>辅助-条件-数学-配置操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/辅助-条件-数学-配置.png" alt="辅助-条件-数学-配置操作符"></p><h2 id="多播操作符"><a href="#多播操作符" class="headerlink" title="多播操作符"></a>多播操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/多播.png" alt="多播操作符"></p><h2 id="高阶-Observable-操作符"><a href="#高阶-Observable-操作符" class="headerlink" title="高阶 Observable 操作符"></a>高阶 Observable 操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/高阶Observable.png" alt="高阶Observable操作符"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Mindnode&lt;/strong&gt; 是 macOS 下一个美观简洁的思维导图工具, 它是一个强大的学习/整理工具, 本文列举了近日学习&lt;code&gt;rxjs&lt;/code&gt;所整理出来的思维导图.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图片较大, 加载可能需要一
      
    
    </summary>
    
      <category term="Mindnode" scheme="https://bobi.ink/categories/Mindnode/"/>
    
    
  </entry>
  
</feed>
