<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2019-10-19T09:37:19.201Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这是最通俗的 React Fiber 打开方式</title>
    <link href="https://bobi.ink/2019/10/18/react-fiber/"/>
    <id>https://bobi.ink/2019/10/18/react-fiber/</id>
    <published>2019-10-17T16:00:00.000Z</published>
    <updated>2019-10-19T09:37:19.201Z</updated>
    
    <content type="html"><![CDATA[<p>写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!</p><p><br></p><p><img src="/images/react-fiber/react-conf.png" alt></p><p><br></p><p>一年一度的 React 春晚: <a href="https://conf.reactjs.org/schedule.html" target="_blank" rel="noopener">React Conf</a> 即将到来，不知道今年会不会有什么惊喜，去年是 React Hooks，前年是 React Fiber…<br>我得赶在 React Conf 之前发布这篇文章:</p><ul><li><p>😲 <strong>React Fiber 已经出来这么久了， 这文章是老酒装新瓶吧</strong>? <em>对于我来说，通过这篇文章我重新认识了 React Fiber，它不是一个新东西, 它也是老酒装新瓶，不信你就看吧…</em></p></li><li><p>🆕 <strong>React Fiber 不是一个新的东西，但在前端领域是第一次广为认知的应用</strong>。</p></li><li><p>😦 <strong>了解它有啥用</strong>? <em>React Fiber 代码很复杂，门槛很高，你不了解它，后面 React 新出的 Killer Feature 你可能就更不能理解了</em></p></li><li><p>🤥 <strong>我不是升到React v16了吗? 没什么出奇的啊</strong>? <em>真正要体会到React Fiber重构效果，可能要等到 v17，也就是说，现在的React 还是同步渲染的，一直在跳票、不是说今年第二季度就出来了吗</em>？</p></li><li><p>😁 <strong>不好意思，一不小心又写得有点长，你就当小说看吧, 代码都是伪代码</strong></p></li></ul><p><br></p><p><strong>以下文章大纲</strong></p><!-- TOC --><ul><li><a href="#单处理进程调度-fiber-不是一个新的东西">单处理进程调度: Fiber 不是一个新的东西</a></li><li><a href="#类比浏览器javascript执行环境">类比浏览器JavaScript执行环境</a></li><li><a href="#何为-fiber">何为 Fiber</a><ul><li><a href="#1-一种流程控制原语">1. 一种流程控制原语</a></li><li><a href="#2-一个执行单元">2. 一个执行单元</a></li></ul></li><li><a href="#react-的fiber改造">React 的Fiber改造</a><ul><li><a href="#1-数据结构的调整">1. 数据结构的调整</a></li><li><a href="#2-两个阶段的拆分">2. 两个阶段的拆分</a></li><li><a href="#3-reconcilation">3. Reconcilation</a></li><li><a href="#4-双缓冲">4. 双缓冲</a></li><li><a href="#5-副作用的收集和提交">5. 副作用的收集和提交</a></li></ul></li><li><a href="#凌波微步">凌波微步</a></li><li><a href="#站在巨人的肩膀上">站在巨人的肩膀上</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="单处理进程调度-fiber-不是一个新的东西"><a href="#单处理进程调度-fiber-不是一个新的东西" class="headerlink" title="单处理进程调度: Fiber 不是一个新的东西"></a>单处理进程调度: Fiber 不是一个新的东西</h2><p><br></p><p><img src="/images/react-fiber/dos.jpg" alt><br><i>这个黑乎乎的界面应该就是微软的 <code>DOS</code> 操作系统</i></p><p><br></p><p>微软 <a href="https://zh.wikipedia.org/zh-cn/DOS" target="_blank" rel="noopener"><code>DOS</code></a> 是一个<code>单任务操作系统</code>, 也称为’单工操作系统‘. 这种操作系统同一个时间只允许运行一个程序. <a href="https://www.zhihu.com/people/s.invalid" target="_blank" rel="noopener">invalid s</a>在<a href="https://www.zhihu.com/question/319595914/answer/683541635" target="_blank" rel="noopener">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为: ‘<strong>一种压根没有任务调度的“残疾”操作系统</strong>‘.</p><p>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。</p><p>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。</p><blockquote><p>注意并发和并行不是同一个概念。</p></blockquote><p><br></p><p>现代操作系统都是<strong>多任务操作系统</strong>. 进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。</p><p><strong>🔴说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。</p><brk><p><img src="/images/react-fiber/longzhu.jpg" alt></p><p><br></p><p>这让我想起了“龙珠”中的分身术(小时候看过，说错了别喷)，实质上是一个人，只不过是他运动速度太快，看起来就像分身了. 这就是所谓的<strong>并发</strong>。</p><p><br></p><p><img src="/images/react-fiber/naruto.jpg" alt></p><p><br></p><p>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。</p><p>所以说<strong>🔴并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">Concurrency is not parallelism</a></p><p><br></p><p>扯远了，接下来进程怎么调度就是教科书的内容了。如果读者在大学认真学过<strong>操作系统原理</strong>, 你可以很快理解以下几种单处理器进程<strong>调度策略</strong>(我就随便科普一下，算送的, 如果你很熟悉这块，可以跳过)：</p><p><br></p><p><strong>0️⃣ 先到先得(First-Come-First-Served, FCFS)</strong></p><p>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队).</p><p><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p><ul><li><p><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程，可以用饭堂排队来比喻: <em>在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久…</em></p></li><li><p><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被宠幸。 可以类比ZF部门办业务: <em>假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平…</em></p></li></ul><p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。</p><p><br></p><p><strong>1️⃣ 轮转</strong></p><p>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p><blockquote><p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p></blockquote><p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。</p><p>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>.</p><p>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。</p><p><br></p><p><strong>2️⃣ 最短进程优先(Shortest Process Next, SPN)</strong></p><p>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让’最短’的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。</p><p>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。</p><p><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。</p><p>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。</p><p><br></p><p><strong>3️⃣ 最短剩余时间(Shortest Remaining Time, SRT)</strong></p><p><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较<em>刚添加的新进程</em>和<em>当前正在执行的老进程</em>的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。</p><p>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。</p><p><br></p><p><strong>4️⃣ 最高响应比优先(HRRN)</strong></p><p><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">响应比 = （等待执行时间 + 进程执行时间） / 进程执行时间</span><br></pre></td></tr></table></figure><p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p><ul><li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li><li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li></ul><p><br></p><p><strong>5️⃣ 反馈法</strong></p><p>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。</p><p>举个例子: </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">队列1</span><br><span class="line">队列2</span><br><span class="line">...</span><br><span class="line">队列N</span><br></pre></td></tr></table></figure><p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。</p><p><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。</p><p>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。</p><p><br><br><br></p><p><img src="/images/react-fiber/process-schedule.png" alt></p><p>没有一种调度策略是万能的, 它需要考虑很多因素:</p><ul><li>响应速率。进程等待被执行的时间</li><li>公平性。兼顾短进程、长进程、I/O进程</li></ul><p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。</p><p>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a href="https://blog.csdn.net/gatieme/article/details/51456569" target="_blank" rel="noopener">《Linux进程调度策略的发展和演变》</a>。</p><p><br><br><br></p><h2 id="类比浏览器javascript执行环境"><a href="#类比浏览器javascript执行环境" class="headerlink" title="类比浏览器JavaScript执行环境"></a>类比浏览器JavaScript执行环境</h2><p><br></p><p><img src="/images/react-fiber/singleroad.jpg" alt><br><i>JavaScript 就像单行道</i></p><p><br></p><p>JavaScript 是<a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">单线程运行</a>的，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p><blockquote><p>这里特指Javascript 引擎是单线程运行的。 严格来说，页面绘制由单独的<code>GUI渲染进程</code>负责，只不过<code>GUI渲染线程</code>和<code>Javascript线程</code>是互斥的. 另外底层的异步操作实际上也是多线程的。</p></blockquote><p><img src="/images/react-fiber/frame-full.jpg" alt><br><i>图片来源: <a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Rendering Performance</a></i></p><p><strong>它只是一个’JavaScript’，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。</p><p><br></p><p>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, <strong>🔴在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)</strong>.</p><p><br></p><p><img src="/images/react-fiber/perf.png" alt></p><p><br></p><p>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。</p><p>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a> 的 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲, 推荐看一下</em>):</p><p><br></p><p>同步模式下的 React:</p><p><img src="/images/react-fiber/sync-mode.gif" alt></p><p><br></p><p>优化后的异步模式下的 React:</p><p><img src="/images/react-fiber/concurrent-mode.gif" alt></p><p><br></p><p>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源.</p><p>所以React 是怎么优化的？ 划重点， <strong>🔴为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p><p><br></p><p><strong>🔴所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p><ul><li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a href="https://juejin.im/post/5d76f469f265da039a28aff7#heading-1" target="_blank" rel="noopener">《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 都做了相关实验</li><li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 也提到：<strong>🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>.</li></ul><p><br></p><p>这就是为什么React 需要 Fiber 😏。</p><p><br></p><h2 id="何为-fiber"><a href="#何为-fiber" class="headerlink" title="何为 Fiber"></a>何为 Fiber</h2><p>对于 React 来说，Fiber 可以从两个角度理解:</p><p><br></p><h3 id="1-一种流程控制原语"><a href="#1-一种流程控制原语" class="headerlink" title="1. 一种流程控制原语"></a>1. 一种流程控制原语</h3><p>Fiber 也称<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272" target="_blank" rel="noopener">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener"><code>Generator</code></a>。</p><blockquote><p>本文不纠结 <a href="https://stackoverflow.com/questions/3324643/processes-threads-green-threads-protothreads-fibers-coroutines-whats-the/16375591#16375591" target="_blank" rel="noopener">Processes, threads, green threads, protothreads, fibers, coroutines: what’s the difference?</a></p></blockquote><p><strong>🔴 其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:</p><p>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>而 <code>Generator</code> 可以:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>React Fiber 的思想和协程的概念是契合的: <strong>🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><p><br></p><p>那么现在你应该有以下疑问:</p><ul><li>1️⃣ 浏览器没有抢占的条件, 所以React只能用让出机制?</li><li>2️⃣ 怎么确定有高优先任务要处理，即什么时候让出？</li><li>3️⃣ React 那为什么不使用 Generator？</li></ul><p><br><br><br></p><p><strong>答1️⃣: 没错, 主动让出机制</strong></p><p>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。</p><p>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a href="https://juejin.im/post/5d12c907f265da1b6d4033c5#heading-7" target="_blank" rel="noopener"><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong></p><p><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p><p><img src="/images/react-fiber/cs.png" alt></p><p><br></p><p>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。</p><p>当然你超时不还浏览器也拿你没办法 🤷‍… 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p><p><br></p><hr><p><br></p><p><strong>答2️⃣: requestIdleCallback API</strong></p><p>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。</p><p>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: <em>确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器</em>。</p><p>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。</p><p>其实浏览器提供了相关的接口 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener"><code>requestIdleCallback</code></a> API：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestIdleCallback(</span><br><span class="line">  callback: <span class="function">(<span class="params">dealine: IdleDeadline</span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  option?: &#123;timeout: <span class="built_in">number</span>&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p><br></p><p><code>IdleDeadline</code>的接口如下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IdleDealine &#123;</span><br><span class="line">  didTimeout: <span class="built_in">boolean</span> <span class="comment">// 表示任务执行是否超过约定时间</span></span><br><span class="line">  timeRemaining(): DOMHighResTimeStamp <span class="comment">// 任务可供执行的剩余时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。</p><p><br></p><p><strong>那浏览器什么时候有空？</strong></p><p>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:</p><p><img src="/images/react-fiber/frame.png" alt><br><i>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</i></p><p><br></p><p><img src="/images/react-fiber/frame-life.png" alt><br><i>图片来源: <a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></i></p><p>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p><ul><li>处理用户输入事件</li><li>Javascript执行</li><li>requestAnimation 调用</li><li>布局 Layout</li><li>绘制 Paint</li></ul><p><br></p><p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如</p><p><br></p><p><img src="/images/react-fiber/ric.png" alt></p><p><br></p><p><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p><blockquote><p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p></blockquote><p><br></p><p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js" target="_blank" rel="noopener">自己实现了一个</a>。它利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行:</p><p><br></p><p><img src="/images/react-fiber/mc.png" alt></p><p><br></p><details><br><summary>简单看一下代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line"><span class="keyword">const</span> ch = <span class="keyword">new</span> MessageChannel()</span><br><span class="line"><span class="keyword">let</span> pendingCallback</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">ch.port2.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 在绘制之后被执行</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCallback) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = performance.now()</span><br><span class="line">    <span class="comment">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span></span><br><span class="line">    <span class="comment">// 通过这些数据来计算剩余时间</span></span><br><span class="line">    <span class="comment">// 另外还要处理超时(timeout)，避免任务被饿死</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRemain &amp;&amp; noTimeout) &#123;</span><br><span class="line">      pendingCallback(deadline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleRequestIdleCallback</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在绘制之前被执行</span></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    startTime = performance.now()</span><br><span class="line">    timeout = timeout</span><br><span class="line">    dosomething()</span><br><span class="line">    <span class="comment">// 调度回调到绘制结束后执行</span></span><br><span class="line">    pendingCallback = callback</span><br><span class="line">    ch.port1.postMessage(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><p><br></p><p><strong>任务优先级</strong></p><p>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p><ul><li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li><li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li></ul><p><br></p><hr><p><br></p><p><strong>答3️⃣: 太麻烦</strong></p><p>官方在<a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p><ol><li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li><li>Generator 是有状态的, 很难在中间恢复这些状态。</li></ol><blockquote><p>上面理解可能有出入，建议看一下原文</p></blockquote><p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。</p><p><br><br><br></p><h3 id="2-一个执行单元"><a href="#2-一个执行单元" class="headerlink" title="2. 一个执行单元"></a>2. 一个执行单元</h3><p>Fiber的另外一种解读是’纤维‘: <strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>🔴将它视作一个执行单元，每次执行完一个’执行单元’,  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.</p><p><br></p><p>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：</p><p>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣ 循环取出updateQueue中的任务</span></span><br><span class="line">  <span class="keyword">while</span> (updateQueue.length &gt; <span class="number">0</span> &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    workLoop(deadline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度</span></span><br><span class="line">  <span class="keyword">if</span> (updateQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: FiberNode | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: FiberNode | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 每执行完一个执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个流程图吧！</p><p><br></p><p><img src="/images/react-fiber/workloop.png" alt></p><p><br><br><br></p><h2 id="react-的fiber改造"><a href="#react-的fiber改造" class="headerlink" title="React 的Fiber改造"></a>React 的Fiber改造</h2><p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。</p><p><br></p><h3 id="1-数据结构的调整"><a href="#1-数据结构的调整" class="headerlink" title="1. 数据结构的调整"></a>1. 数据结构的调整</h3><p>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。</p><p><br></p><p>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解😂, 它非常适合树这种嵌套数据结构的处理。</p><p>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 另外它还不利于异步处理。如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。</p><p>因此<strong>首先我们需要对React现有的数据结构进行调整，将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.</p><p><br></p><p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>FiberNode</code>表示, 它的结构大概如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>用图片来展示这种关系会更直观一些：</p><p><img src="/images/react-fiber/fiber-node.png" alt></p><p><br></p><p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * @params topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: FiberNode, topWork: FiberNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>FiberNode 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>FiberNode</code> 进行操作，并按照深度遍历的顺序返回下一个 FiberNode</strong>。</p><p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>FiberNode</code>继续遍历下去</strong>。</p><p>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：</p><p><br></p><p><img src="/images/react-fiber/work-order.png" alt><br><i>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</i></p><p><br><br><br></p><h3 id="2-两个阶段的拆分"><a href="#2-两个阶段的拆分" class="headerlink" title="2. 两个阶段的拆分"></a>2. 两个阶段的拆分</h3><p><br></p><p><img src="/images/react-fiber/fiber-reconciler.png" alt></p><p><br></p><p>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p><blockquote><p>我在之前的多篇文章中都有提及: <a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p></blockquote><p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p><ul><li><p><strong>⚛️ 协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’<code>副作用</code>(Effect)’ . 以下生命周期钩子会在协调阶段被调用：</p><ul><li>constructor</li><li>componentWillMount 废弃</li><li>componentWillReceiveProps 废弃</li><li>static getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate 废弃</li><li>render</li><li>getSnapshotBeforeUpdate()</li></ul></li><li><p><strong>⚛️ 提交阶段</strong>: 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)</strong>一次性执行了。<strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:</p><ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul></li></ul><p><br></p><p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p><p>需要注意的是：因此协调阶段可以被中断和恢复，<strong>React 可能不能保证协调阶段的某些生命周期钩子只被执行一次</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。 所以 <strong>协调阶段的生命周期钩子不应该包含副作用</strong>. 索性 React 就废弃了这些可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillMount</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</p><p><br></p><p>现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。</p><p><br><br><br></p><h3 id="3-reconcilation"><a href="#3-reconcilation" class="headerlink" title="3. Reconcilation"></a>3. Reconcilation</h3><p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。</p><p>首先再进一步看一下<code>FiberNode</code>的结构:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> FiberNode &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的类型信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span></span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 结构信息</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span></span><br><span class="line">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 节点实例(状态)：</span></span><br><span class="line">  <span class="comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span></span><br><span class="line">  <span class="comment">//        对于类组件来说，这里保存类组件的实例</span></span><br><span class="line">  <span class="comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span></span><br><span class="line">  stateNode: <span class="built_in">any</span>,</span><br><span class="line">  <span class="comment">// 新的、待处理的props</span></span><br><span class="line">  pendingProps: <span class="built_in">any</span>,</span><br><span class="line">  <span class="comment">// 上一次渲染的props</span></span><br><span class="line">  memoizedProps: <span class="built_in">any</span>, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// 上一次渲染的组件状态</span></span><br><span class="line">  memoizedState: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 副作用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line">  <span class="comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的FiberNode连接起来</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 替身</span></span><br><span class="line"><span class="comment">   * 指向旧树中的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>FiberNode 包含的属性可以划分为 5 个部分:</p><ul><li><strong>🆕 结构信息</strong> - 这个上文我们已经见过了，FiberNode 使用链表的形式来表示节点在树中的定位</li><li><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp</li><li><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出</li><li><p><strong>🆕 副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记).<br>那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来</p></li><li><p><strong>🆕 替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</p></li></ul><p><br></p><p>现在可以放大看看<code>beginWork</code>  是如何对 FiberNode 进行比对的:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: FiberNode</span>): <span class="title">FiberNode</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>宿主节点比对:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffHostComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.pendingProps.children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>类组件节点比对也差不多:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffClassComponent</span>(<span class="params">fiber: FiberNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createInstance(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.hasMounted) &#123;</span><br><span class="line">    <span class="comment">// 调用更新前生命周期钩子</span></span><br><span class="line">    applybeforeUpdateHooks(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用挂载前生命周期钩子</span></span><br><span class="line">    applybeforeMountHooks(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染新节点</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.stateNode.render();</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line"></span><br><span class="line">  fiber.memoizedState = fiber.stateNode.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>子节点比对:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">fiber: FiberNode, newChildren: React.ReactNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 全新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber == <span class="literal">null</span>) &#123;</span><br><span class="line">    mountChildFibers(fiber, newChildren)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> elements = extraElements(newChildren)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子元素</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">const</span> sameType = isSameType(element, oldFiber)</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = cloneFiber(oldFiber, element)</span><br><span class="line">      <span class="comment">// 更新关系</span></span><br><span class="line">      newFiber.alternate = oldFiber</span><br><span class="line">      <span class="comment">// 打上Tag</span></span><br><span class="line">      newFiber.effectTag = UPDATE</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = createFiber(element)</span><br><span class="line">      newFiber.effectTag = PLACEMENT</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      oldFiber.nextEffect = fiber.nextEffect</span><br><span class="line">      fiber.nextEffect = oldFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.</p><p><br></p><p>这里引用一下<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p><blockquote><p>这篇文章<a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">《React Fiber》</a> 用文字版解释了Link Clark Slide.</p></blockquote><p><img src="/images/react-fiber/effect-tag.png" alt></p><p><br></p><p>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。</p><p><br><br><br></p><h3 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4. 双缓冲"></a>4. 双缓冲</h3><p><code>WIP 树</code>构建这种技术类似于图形化领域的’<strong>双缓存(Double Buffering)</strong>‘技术, 图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。</p><p>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。</p><p>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。</p><p>Dan 在 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉</strong>:</p><p><br></p><p><img src="/images/react-fiber/gitbranch.png" alt></p><p><br><br><br></p><h3 id="5-副作用的收集和提交"><a href="#5-副作用的收集和提交" class="headerlink" title="5. 副作用的收集和提交"></a>5. 副作用的收集和提交</h3><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = fiber.return</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到达顶端</span></span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span> || fiber === topWork) &#123;</span><br><span class="line">    pendingCommit = fiber</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.nextEffect) &#123;</span><br><span class="line">      parent.nextEffect.nextEffect = fiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.nextEffect = fiber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.nextEffect) &#123;</span><br><span class="line">    parent.nextEffect = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>最后了，将所有副作用提交了:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = fiber</span><br><span class="line">  <span class="keyword">while</span>(next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fiber.effectTag) &#123;</span><br><span class="line">      <span class="comment">// 提交，偷一下懒，这里就不展开了</span></span><br><span class="line">      commitWork(fiber)</span><br><span class="line">    &#125;</span><br><span class="line">    next = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理现场</span></span><br><span class="line">  pendingCommit = nextUnitOfWork = topWork = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打完收工…</p><p><br><br><br></p><h2 id="凌波微步"><a href="#凌波微步" class="headerlink" title="凌波微步"></a>凌波微步</h2><p><img src="/images/react-fiber/new-frame.jpg" alt><br><i>同样来自Link Clark 的 Slider</i></p><p>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。</p><p>React Fiber开启异步渲染之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就休息少一点。</p><p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。</p><p>为了共同创造美好的世界，我们要严律于己， 该做的优化还需要做: 纯组件、虚表、简化组件、缓存… <strong>不要期望 Fiber 能给你现有应用带来质的提升, 自己的锅还是得自己背</strong>.</p><p><br><br><br></p><h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><p><br></p><p>本文之所以能成文，离不开社区上优质的开源项目和资料:</p><p><strong>迷你 Fiber 实现</strong>:</p><p>React 现在的代码库太复杂了! <a href="https://www.zhihu.com/people/he-shi-jun" target="_blank" rel="noopener">Hax</a> 在 <a href="https://www.zhihu.com/question/270428598/answer/354017709" target="_blank" rel="noopener">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……</p><p>如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p><ul><li><a href="https://github.com/RubyLouvre/anu" target="_blank" rel="noopener">anu</a> <a href="https://github.com/RubyLouvre" target="_blank" rel="noopener">司徒正美</a> 开发的类React框架</li><li><a href="https://github.com/132yse/fre" target="_blank" rel="noopener">Fre</a> <a href="https://www.zhihu.com/people/132yse" target="_blank" rel="noopener">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li><li><a href="https://github.com/Foveluy/Luy" target="_blank" rel="noopener">Luy</a></li><li><a href="https://github.com/pomber/didact" target="_blank" rel="noopener">didact</a></li></ul><p><br></p><p><strong>优秀的文章</strong></p><ul><li><a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></li><li><a href="https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/" target="_blank" rel="noopener">深入探究 eventloop 与浏览器渲染的时序问题</a></li><li><a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">司徒正美: React Fiber架构 👍</a></li><li><a href="https://www.zhihu.com/search?type=content&amp;q=requestIdleCallback" target="_blank" rel="noopener">淡苍：深入剖析 React Concurrent</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">黯羽轻扬: 完全理解React Fiber</a></li><li><a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">Fiber Principles: Contributing To Fiber</a></li><li><a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/" target="_blank" rel="noopener">Accurately measuring layout on the web</a></li><li><a href="https://philippspiess.com/scheduling-in-react/" target="_blank" rel="noopener">Scheduling in React</a></li><li><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec" target="_blank" rel="noopener">Didact Fiber: Incremental reconciliation</a></li><li><a href="https://juejin.im/post/5d12c907f265da1b6d4033c5" target="_blank" rel="noopener">桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li><li><a href="https://juejin.im/post/5b028db26fb9a07ac162ba68#heading-12" target="_blank" rel="noopener">为 Luy 实现 React Fiber 架构</a></li><li><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">妖僧风月: React Fiber</a></li><li><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">译 深入React fiber架构及源码</a></li><li><a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">程墨: React Fiber是什么</a></li><li><a href="https://www.zhihu.com/people/NE_SmallTown/posts" target="_blank" rel="noopener">展望 React 17，回顾 React 往事</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Web Fundamentals &gt; Performance</a></li></ul><p><br></p><p><strong>自荐React 相关文章</strong></p><ul><li><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715" target="_blank" rel="noopener">React组件设计实践总结 系列 共5篇</a></li><li><a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">自己写个React渲染器: 以 Remax 为例(用React写小程序)</a></li><li><a href="https://juejin.im/post/5d44e3745188255d5861d654" target="_blank" rel="noopener">谈谈React事件机制和未来(react-events)</a></li><li><a href="https://juejin.im/post/5d594ea5518825041301bbcb" target="_blank" rel="noopener">2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></li><li><a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">浅谈React性能优化的方向</a></li><li><a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">从Preact中了解React组件和hooks基本原理</a></li><li><a href="https://juejin.im/post/5d06bf0a51882528194a9736" target="_blank" rel="noopener">React性能测量和分析</a></li></ul><p><br></p><p>问卷调查，你觉得这种文章风格怎样？</p><p>A. 事无巨细，太啰嗦了<br>B. 娓娓道来，深入浅出我喜欢<br>C. 内容不够深入<br>D. 文章篇幅太长，可以拆分</p><p>多选，下方评论，谢谢</p><p><br></p><p>还有很多没讲完，后面的文章见！</p><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p></brk>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>深入浅出 Babel 下篇：既生 Plugin 何生 Macros</title>
    <link href="https://bobi.ink/2019/10/10/babel-macro/"/>
    <id>https://bobi.ink/2019/10/10/babel-macro/</id>
    <published>2019-10-09T16:00:00.000Z</published>
    <updated>2019-10-18T14:10:34.400Z</updated>
    
    <content type="html"><![CDATA[<p>接着上篇文章: <a href="https://juejin.im/post/5d94bfbf5188256db95589be" target="_blank" rel="noopener">《深入浅出 Babel 上篇：架构和原理 + 实战 🔥》</a></p><p><br></p><p><strong>这篇文章干货不少于上篇文章，这篇我们深入讨论一下宏这个玩意</strong> —— <em>我想我们对宏并不陌生，因为很多程序员第一门语言就是 <code>C/C++</code>; 一些 <code>Lisp</code> 方言也支持宏(如 <code>Clojure</code>、<code>Scheme</code>), 听说它们的宏写起来很优雅；一些现代的编程语言对宏也有一定的支持，如 <code>Rust</code>、<code>Nim</code>、<code>Julia</code>、<code>Elixir</code>，它们是如何解决技术问题, 实现类Lisp的宏系统的？宏在这些语言中扮演这什么角色…</em></p><blockquote><p>如果没读过上篇文章，请先阅读一下，避免影响对本篇文章内容的理解。</p></blockquote><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#关于宏">关于宏</a><ul><li><a href="#文本替换式">文本替换式</a></li><li><a href="#语法扩展式">语法扩展式</a></li><li><a href="#sweetjs">Sweet.js</a></li><li><a href="#小结">小结</a></li></ul></li><li><a href="#既生-plugin-何生-macro">既生 Plugin 何生 Macro</a></li><li><a href="#如何写一个-babel-macro">如何写一个 Babel Macro</a><ul><li><a href="#实战">实战</a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br></p><h2 id="关于宏"><a href="#关于宏" class="headerlink" title="关于宏"></a>关于宏</h2><p><a href="https://zh.wikipedia.org/wiki/巨集" target="_blank" rel="noopener"><code>Wiki</code></a> 上面对‘宏’的定义是：<strong>宏(Macro), 是一种批处理的称谓，它根据一系列的预定义规则转换一定的文本模式。<code>解释器</code>或<code>编译器</code>在遇到宏时会自动进行这一模式转换，这个转换过程被称为“宏展开(Macro Expansion)”。对于编译语言，宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。</strong></p><p>你可以认为，<strong>宏就是用来生成代码的代码，它有能力进行一些句法解析和代码转换</strong>。宏大致可以分为两种: <strong>文本替换</strong>和<strong>语法扩展</strong></p><p><br></p><h3 id="文本替换式"><a href="#文本替换式" class="headerlink" title="文本替换式"></a>文本替换式</h3><p>大家或多或少有接触过宏，很多程序员第一门语言是<code>C/C++</code>(包括C的衍生语言<code>Objective-C</code>),  在<code>C</code>中就有宏的概念。使用<code>#define</code>指令定义一个宏:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(X, Y) ((X) &lt; (Y) ? (X) : (Y))</span></span><br></pre></td></tr></table></figure><p>如果我们的程序使用了这个宏，就会在编译阶段被展开，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MIN(a + b, c + d)</span><br></pre></td></tr></table></figure><p>会被展开为:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((a + b) &lt; (c + d) ? (a + b) : (c + d))</span><br></pre></td></tr></table></figure><p><br></p><p>除了<code>函数宏</code>, <code>C</code> 中还有<code>对象宏</code>, 我们通常使用它来声明’常量’:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1214</span></span><br></pre></td></tr></table></figure><p><br></p><p><img src="/images/babel/c-compile.gif" alt></p><p>如上图，<strong>宏本质上不是<code>C</code>语言的一部分</strong>, 它由<code>C预处理器</code>提供，预处理器在编译之前对源代码进行<strong>文本替换</strong>，生成‘真正’的 <code>C</code> 代码，再传递给编译器。</p><blockquote><p>当然 C 预处理器不仅仅会处理宏，它还包含了头文件引入、条件编译、行控制等操作</p></blockquote><p>除此之外，<a href="https://segmentfault.com/a/1190000004104696" target="_blank" rel="noopener"><code>GNU m4</code></a>是一个更专业/更强大/更通用的预处理器(宏展开器)。这是一个通用的宏展开器，不仅可以用于 C，也可以用于其他语言和文本文件的处理(<em>参考这篇有趣的文章：<a href="https://segmentfault.com/a/1190000004342956" target="_blank" rel="noopener">《使用 GNU m4 为 Markdown 添加目录支持》</a></em>)， 关于<code>m4</code>可以看<a href="https://segmentfault.com/a/1190000004104696" target="_blank" rel="noopener">让这世界再多一份 GNU m4 教程</a> 系列文章.</p><p>文本替换式宏很容易理解、实现也简单，因为它们只是纯文本替换, 换句话说它就像‘文本编辑器’。所以相对而言，<strong>这种形式的宏能力有限，比如它不会检验语法是否合法, 使用它经常会出现问题</strong>。</p><p>所以<strong>随着现代编程语言表达能力越来越强，很多语言都不再推荐使用宏/不提供宏，而是使用语言本身的机制(例如函数)来解决问题，这样更安全、更容易理解和调试。没用宏机制，现代语言可以通过提供强大的反射机制或者动态编程特性(如Javascript的Proxy、Python的装饰器)来弥补缺失宏导致的元编程短板。 所以反过来推导，之所以<code>C</code>语言需要宏，正是因为<code>C</code>语言的表达能力太弱了</strong>。</p><p><br><br><br></p><h3 id="语法扩展式"><a href="#语法扩展式" class="headerlink" title="语法扩展式"></a>语法扩展式</h3><p>‘真正’的宏起源于<a href="https://zh.wikipedia.org/wiki/LISP" target="_blank" rel="noopener"><code>Lisp</code></a>. 这个得益于Lisp语言本身的一些特性：</p><p><img src="/images/babel/lisp.png" alt></p><p><br></p><ul><li><strong>它的语法非常简单</strong>。只有<a href="https://zh.wikipedia.org/wiki/S-表达式" target="_blank" rel="noopener">S-表达式(s-expression)</a>(<em>特征为括号化的前缀表示法, 可以认为S-表达式就是近似的 Lisp 的抽象语法树(AST)</em>)</li><li><strong>数据即代码</strong>。S-表达式本身就是树形数据结构。另外 Lisp 支持数据和代码之间的转换</li></ul><p><br></p><p>由于 Lisp 这种简单的语法结构，使得数据和程序之间只有一线之隔(<strong>quote修饰就是数据， 没有quote就是程序</strong>), 换句话说就是程序和数据之间可以灵活地转换。这种<code>数据即程序、程序即数据</code>的概念，使得Lisp可以轻松地自定义宏. 不妨来看一下Lisp定义宏的示例：</p><figure class="highlight clj"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 使用defmacro定义一个nonsense宏, 接收一个function-name参数. 宏需要返回一个quoted</span></span><br><span class="line"><span class="comment">; ` 这是quote函数的简写，表示quote，即这段‘程序’是一段‘数据’, 或者说将‘程序’转换为‘数据’. quote不会被‘求值’</span></span><br><span class="line"><span class="comment">; defun 定义一个函数</span></span><br><span class="line"><span class="comment">; , 这是unquote函数的简写， 表示unquote，即将‘数据’转换为‘程序’. unquote会进行求值</span></span><br><span class="line"><span class="comment">; intern 将字符串转换为symbol，即标识符</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> nonsense (<span class="name">function-name</span>)</span><br><span class="line">  `(<span class="name">defun</span> ,(<span class="name"><span class="builtin-name">intern</span></span> (<span class="name"><span class="builtin-name">concat</span></span> <span class="string">"nonsense-"</span> function-name)) (<span class="name">input</span>) <span class="comment">; 定义一个nonsense-$&#123;function-name&#125; 方法</span></span><br><span class="line">     (<span class="name">print</span> (<span class="name"><span class="builtin-name">concat</span></span> ,function-name input))))                   <span class="comment">; 输入`$&#123;function-name&#125;$&#123;input&#125;`</span></span><br></pre></td></tr></table></figure><details><br>  <summary>如果你不理解上面程序的含义，这里有一个Javascript的实现</summary><br><br>  注意：‘宏’一般在编译阶段被展开, 下面代码只是为了协作你理解上述的Lisp代码<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">nonsense</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> rtn</span><br><span class="line">   <span class="built_in">eval</span>(<span class="string">`rtn = function nonsense<span class="subst">$&#123;name&#125;</span>(input) &#123;</span></span><br><span class="line"><span class="string">     console.log('<span class="subst">$&#123;name&#125;</span>', input)</span></span><br><span class="line"><span class="string">   &#125;`</span>)</span><br><span class="line">   <span class="keyword">return</span> rtn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><p><br></p><p>应用宏展开：</p><figure class="highlight clj"><table><tr><td class="code"><pre><span class="line">(<span class="name">nonsense</span> <span class="string">"apple"</span>)           <span class="comment">; 展开宏，这里会创建一个nonsense-apple函数</span></span><br><span class="line">(<span class="name">nonsense-apple</span> <span class="string">" is good"</span>)  <span class="comment">; 调用刚刚创建的宏</span></span><br><span class="line">                             <span class="comment">; =&gt; "apple is good"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>对于Lisp而言，宏有点像一个函数, 只不过这个函数必须返回一个<code>quoted数据</code>; 当调用这个宏时，Lisp会使用<code>unquote</code>函数将宏返回的<code>quoted数据</code>转换为<code>程序</code></strong>。</p><p><img src="/images/babel/lisp-macro.png" alt></p><p><br></p><p>通过上面的示例，你会感叹Lisp的宏实现竟然如此清奇，如此简单。 搞得我想跟着<a href="http://tiye.me" target="_blank" rel="noopener">题叶</a>学一波<a href="https://clojure.org" target="_blank" rel="noopener">Clojure</a>，但是后来我学了<a href="https://elixir-lang.org" target="_blank" rel="noopener">Elixir</a> 😂.</p><p><img src="/images/babel/sicp.png" alt></p><p><br></p><p>Lisp宏的灵活性得益于简单的语法(S-表达式可以等价于它的AST)，对于复杂语法的语言(例如Javascript)，要实现类似Lisp的宏就难得多. 因此很少有现代语言提供宏机制可能也是这个原因。</p><p>尽管如此，现在很多技术难点慢慢被解决，很多现代语言也引入’类’ Lisp的宏机制，如<a href="https://doc.rust-lang.org/book/ch19-06-macros.html" target="_blank" rel="noopener">Rust</a>、<a href="https://julialang.org" target="_blank" rel="noopener">Julia</a>, 还有Javascript的 <a href="https://www.sweetjs.org/doc/tutorial" target="_blank" rel="noopener">Sweet.js</a></p><p><br><br><br></p><h3 id="sweet-js"><a href="#sweet-js" class="headerlink" title="Sweet.js"></a>Sweet.js</h3><p>Sweet.js 和 Rust 师出同门，所以两个的宏语法和非常接近(初期)。 不过需要注意的是: <strong>官方认为 Sweet.js 目前仍处于实验阶段</strong>，而且Github最后提交时间停留在2年前，社区上也未见大规模的使用。所以不要在生产环境中使用它，但是不妨碍我们去学习一个现代编程语言的宏机制。</p><p>我们先使用 <code>Sweet.js</code> 来实现上面我们通过 <code>Lisp</code> 实现的<code>nosense</code>宏, 对比起来更容易理解:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unwrap, fromIdentifier, fromStringLiteral &#125; <span class="keyword">from</span> <span class="string">'@sweet-js/helpers'</span> <span class="keyword">for</span> syntax;</span><br><span class="line"></span><br><span class="line">syntax nosense = <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = ctx.next().value;</span><br><span class="line">  <span class="keyword">let</span> funcName = <span class="string">'nonsense'</span> + unwrap(name).value</span><br><span class="line"></span><br><span class="line">  return #`function $&#123;fromIdentifier(name, funcName)&#125; () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log($&#123;fromStringLiteral(name, unwrap(name).value)&#125; + input)</span><br><span class="line">  &#125;<span class="string">`;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nosense Apple</span></span><br><span class="line"><span class="string">nosenseApple(" is Good") // Apple is Good</span></span><br></pre></td></tr></table></figure><p><br></p><p>首先，Sweet.js使用<code>syntax</code>关键字来定义一个宏，其语法类似于<code>const</code>或者<code>let</code>。</p><p><strong>本质上一个宏就是一个函数, 只不过在编译阶段被执行</strong>. 这个函数接收一个 <a href="https://www.sweetjs.org/doc/reference#syntax-transformer" target="_blank" rel="noopener"><code>TransformerContext</code></a> 对象，你也通过这个对象获取宏应用传入的<strong>语法对象(Syntax Object)数组</strong>，最终这个宏也要返回<strong>语法对象数组</strong>。</p><p>什么是语法对象？语法对象是 Sweet.js 关于语法的内部表示, 你可以类比上文Lisp的 quoted 数据。<strong>在复杂语法的语言中，没办法使用 quoted 这么简单的序列来表示语法，而使用 AST 则更复杂，开发者更难以驾驭。所以大部分宏实现会参考 Lisp 的<code>S-表达式</code>，取折中方案，将传入的程序转换为Tokens，再组装成类似quoted的数据结构</strong>。</p><p>举个例子，Sweet.js 会将 <code>foo,bar(&#39;baz&#39;, 1)</code>转换成这样的数据结构:</p><p><img src="/images/babel/syntaxobject.png" alt></p><p>从上图可知，Sweet.js 会将传入的程序解析成<strong>嵌套的Token序列</strong>，这个结构和Lisp的<code>S-表达式</code>非常相似。也就是, 说对于闭合的词法单元会被嵌套存储，例如上例的<code>(&#39;baz&#39;, 1)</code>.</p><blockquote><p>Elixir 也采用了<a href="https://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="noopener">类似的quote/unquote机制</a>，可以结合着一起理解</p></blockquote><p><br></p><p><code>TransformerContext</code>实现了迭代器方法，所以我们通过调用它的<code>next()</code>来遍历获取语法对象。最后宏必须返回一个语法对象数组，Sweet.js 使用了类似<code>字符串模板</code>的<a href="https://www.sweetjs.org/doc/reference#syntax-templates" target="_blank" rel="noopener">语法</a>(称为<code>语法模板</code>)来简化开发，这个模板最终转换为语法对象数组。</p><blockquote><p>需要注意的是<code>语法模板</code>的内嵌值只能是语法对象、语法对象序列或者TransformerContext.</p></blockquote><details><br><summary>旧版本使用了<a href="https://jlongster.com/Stop-Writing-JavaScript-Compilers--Make-Macros-Instead" target="_blank" rel="noopener">模式匹配</a>，和Rust语法类似，我个人更喜欢这个，不知为何废弃了</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">macro define &#123;</span><br><span class="line">    rule &#123; $x &#125; =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> $x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rule &#123; $x = $expr &#125; =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> $x = $expr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define y;</span><br><span class="line">define y = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><br><br></details><p><br></p><p>说了这么多，类似Sweet.js <code>语法对象</code> 的设计是现代编程语言为了贴近 Lisp 宏的一个关键技术点。我发现<code>Elixir</code>、<code>Rust</code>等语言也使用了类似的设计。 除了数据结构的设计，现代编程语言的宏机制还包含以下特性：</p><p><br></p><p><strong>1️⃣ 卫生宏(Hygiene)</strong></p><p>卫生宏指的是在宏内生成的变量不会污染外部作用域，也就是说，在宏展开时，Sweet.js 会避免宏内定义的变量和外部冲突.</p><p>举个例子，我们创建一个swap宏，交换变量的值:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">syntax swap = <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> a = ctx.next().value</span><br><span class="line"> ctx.next() <span class="comment">// 吃掉','</span></span><br><span class="line"> <span class="keyword">const</span> b = ctx.next().value</span><br><span class="line"> return #`</span><br><span class="line"> <span class="keyword">let</span> temp = $&#123;a&#125;</span><br><span class="line"> $&#123;a&#125; = $&#123;b&#125;</span><br><span class="line"> $&#123;b&#125; = temp</span><br><span class="line"> <span class="string">`;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">swap foo,bar</span></span><br></pre></td></tr></table></figure><p>展开会输出为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> temp_10 = foo; <span class="comment">// temp变量被重命名为temp_10</span></span><br><span class="line">foo = bar;</span><br><span class="line">bar = temp_10;</span><br></pre></td></tr></table></figure><p>如果你想引用外部的变量，也可以。不过不建议这么做，<strong>宏不应该假定其被展开的上下文</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">syntax swap = <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  return #`</span><br><span class="line">  temp = $&#123;a&#125; <span class="comment">// 不使用 let 声明</span></span><br><span class="line">  $&#123;a&#125; = $&#123;b&#125;</span><br><span class="line">  $&#123;b&#125; = temp</span><br><span class="line">  <span class="string">`;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>2️⃣ 模块化</strong></p><p>Sweet.js 的宏是模块化的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'lang sweet.js'</span>;</span><br><span class="line"><span class="comment">// 导出宏</span></span><br><span class="line"><span class="keyword">export</span> syntax <span class="class"><span class="keyword">class</span> </span>= <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>导入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="class"><span class="keyword">class</span> &#125; <span class="title">from</span> './<span class="title">es2015</span>-<span class="title">macros</span>'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Droid</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rollWithIt(it) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" is rolling with "</span> + it;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>相对Babel(编译器)来说，Sweet.js的宏是模块化/显式的。Babel你需要在配置文件中配置各种插件和选项，尤其是团队项目构建有统一规范和环境时，项目构建脚本修改可能有限制。而模块化的宏是源代码的一部分，而不是构建脚本的一部分，这使得它们可以被灵活地使用、重构以及废弃</strong>。</p><p>下文介绍的 <code>babel-plugin-macros</code> 最大的优势就在这里, 通常<strong>我们希望构建环境是统一的、稳定的、开发人员应该专注于代码的开发，而不是如何去构建程序，正是因为代码多变性，才催生出了这些方案</strong>。</p><p><br></p><p>需要注意的是<strong>宏是在编译阶段展开</strong>的，所以无法运行用户代码，例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function"><span class="params">msg</span> =&gt;</span> <span class="built_in">console</span>.log(msg); <span class="comment">// 用户代码, 运行时被求值，所以无法被访问</span></span><br><span class="line"></span><br><span class="line">syntax m = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 宏函数在编译阶段被执行</span></span><br><span class="line">  log(<span class="string">'doing some Sweet things'</span>); <span class="comment">// ERROR: 未找到变量log</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>Sweet.js 和其他语言的宏一样，有了它你可以:</p><ul><li>新增语法糖(和Sweet.js 一样甜), 实现复合自己口味的语法或者某些实验性的语言特性</li><li>自定义<a href="https://www.sweetjs.org/doc/tutorial#sweet-operators" target="_blank" rel="noopener">操作符</a>, 很强大</li><li>消灭重复的代码，提升语言的表达能力。</li><li>…</li><li>别炫技</li></ul><p><br></p><p>🤕很遗憾！Sweet.js 基本死了。所以现在当个玩具玩玩尚可，切勿用于生产环境。即使没有死，Sweet.js 这种非标准的语法, 和现有的Javascript工具链生态格格不入，开发和调试都会比较麻烦(比如Typescript).</p><p>归根到底，Sweet.js 的失败，是社区抛弃了它。Javascript语言表达能力越来越强，版本迭代快速，加上有了Babel和Typescript这些解决方案，实在拿不出什么理由来使用 Sweet.js</p><blockquote><p>Sweet.js 相关论文可以看<a href="https://github.com/sweet-js/sweet-core/wiki/Macro-resources" target="_blank" rel="noopener">这里</a></p></blockquote><p><br></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这一节扯得有点多，将宏的历史和分类讲了个遍。 最后的总结是Elixir官方教程里面的一句话：<strong>显式好于隐式，清晰的代码优于简洁的代码(Clear code is better than concise code)</strong></p><p>能力越大、责任越大。宏强大，比正常程序要更难以驾驭，你可能需要一定的成本去学习和理解它, 所以能不用宏就不用宏，<strong>宏是应该最后的法宝</strong>.</p><p><br><br><br></p><h2 id="既生-plugin-何生-macro"><a href="#既生-plugin-何生-macro" class="headerlink" title="既生 Plugin 何生 Macro"></a>既生 Plugin 何生 Macro</h2><p>🤓还没完， 一下子扯了好远，掰回正题。既然 Babel 有了 Plugin 为什么又冒出了个 <a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener"><code>babel-plugin-macros</code></a>?</p><blockquote><p>如果你尚不了解Babel Macro，可以先读一下<a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener">官方文档</a>, 另外<a href="https://create-react-app.dev" target="_blank" rel="noopener">Creact-React-APP</a> 已经内置</p></blockquote><p>这个得从 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">Create-React-App(CRA)</a> 说起，CRA 将所有的项目构建逻辑都封装在<a href="https://github.com/facebook/create-react-app/tree/master/packages/react-scripts" target="_blank" rel="noopener"><code>react-scripts</code></a> 服务中。<strong>这样的好处是，开发者不需要再关心构建的细节, 另外构建工具的升级也变得非常方便, 直接升级 <code>react-scripts</code>即可</strong>。</p><p>如果自己维护构建脚本的话，升一次级你需要升级一大堆的依赖，如果你要维护跨项目的构建脚本，那就更蛋疼了。</p><blockquote><p>我在<a href="https://juejin.im/post/5d2fcaacf265da1b95708f63" target="_blank" rel="noopener">《为什么要用vue-cli3?》</a> 里阐述了 CRA 以及 Vue-cli这类的工具对团队项目维护的重要性。</p></blockquote><p>CRA 是<strong>强约定</strong>的，它是按照React社区的最佳实践给你准备的，为了保护封装带来的红利，它不推荐你去手动配置Webpack、Babel… 所以才催生除了 babel-plugin-macros, 大家可以看这个 <a href="https://github.com/facebook/create-react-app/issues/2730" target="_blank" rel="noopener">Issue: RFC - babel-macros</a></p><p><strong>所以为 Babel 寻求一个’零配置’的机制是 <code>babel-plugin-macros</code> 诞生的主要动机</strong>。</p><p>这篇文章正好证实了这个动机：<a href="https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros" target="_blank" rel="noopener">《Zero-config code transformation with babel-plugin-macros》</a>, 这篇文章引述了一个重要的观点：”<strong>Compilers are the New Frameworks</strong>“</p><p>的确，<strong>Babel 在现代的前端开发中扮演着一个很重要的角色，越来越多的框架或库会创建自己的 Babel 插件，它们会在编译阶段做一些优化，来提高用户体验、开发体验以及运行时的性能</strong>。比如:</p><ul><li><a href="https://github.com/lodash/babel-plugin-lodash" target="_blank" rel="noopener">babel-plugin-lodash</a> 将lodash导入转换为按需导入</li><li><a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a> 上篇文章提过的这个插件，也是实现按需导入</li><li><a href="https://github.com/jamiebuilds/babel-react-optimize" target="_blank" rel="noopener">babel-react-optimize</a> 静态分析React代码，利用一定的措施优化运行效率。比如将静态的props或组件抽离为常量</li><li><a href="https://github.com/entwicklerstube/babel-plugin-root-import" target="_blank" rel="noopener">root-import</a> 将基于根目录的导入路径重写为相对路径</li><li><a href="https://www.styled-components.com/docs/tooling#babel-macro" target="_blank" rel="noopener">styled-components</a> 典型的CSS-in-js方案，利用Babel 插件来支持服务端渲染、预编译模板、样式压缩、清除死代码、提升调试体验。</li><li><a href="https://github.com/kentcdodds/babel-plugin-preval" target="_blank" rel="noopener">preval</a> 在编译时预执行代码</li><li><a href="https://www.apollographql.com/docs/react/v2.5/recipes/babel/#using-babel-plugin-graphql-tag" target="_blank" rel="noopener">babel-plugin-graphql-tag</a> 预编译GraphQL查询</li><li>…</li></ul><p><br></p><p>上面列举的插件场景中，<strong>并不是所有插件都是通用的，它们要么是跟某一特定的框架绑定、要么用于处理特定的文件类型或数据。这些非通用的插件是最适合使用macro取代的</strong>。</p><p>用 <code>preval</code> 举个例子. 使用插件形式, 你首先要配置插件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"preval"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传递给preval的字符串会在编译阶段被执行</span></span><br><span class="line"><span class="comment">// preval插件会查找preval标识符，将字符串提取出来执行，在将执行的结果赋值给greeting</span></span><br><span class="line"><span class="keyword">const</span> greeting = preval<span class="string">`</span></span><br><span class="line"><span class="string">  const fs = require('fs')</span></span><br><span class="line"><span class="string">  module.exports = fs.readFileSync(require.resolve('./greeting.txt'), 'utf8')</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p><br></p><p>使用Macro方式:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先你要显式导入</span></span><br><span class="line"><span class="keyword">import</span> preval <span class="keyword">from</span> <span class="string">'preval.macro'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面一样</span></span><br><span class="line"><span class="keyword">const</span> greeting = preval<span class="string">`</span></span><br><span class="line"><span class="string">  const fs = require('fs')</span></span><br><span class="line"><span class="string">  module.exports = fs.readFileSync(require.resolve('./greeting.txt'), 'utf8')</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p><br></p><p>这两者达到的效果是一样的，但意义却不太一样。有哪些区别？</p><ul><li><p>1️⃣ <strong>很显然，Macro不需要配置<code>.babelrc</code></strong>(<em>当然babel-plugin-macros这个基座需要装好</em>). 这个对于CRA这种不推荐配置构建脚本的工具来说很有帮助</p></li><li><p>2️⃣ <strong>由隐式转换为了显式</strong>。上一节就说了“显式好于隐式”。你必须在源代码中通过<code>导入语句</code>声明你使用了 Macro； 而基于插件的方式，你可能不知道<code>preval</code>这个标识符哪里来的? 如何被应用？何时被应用？而且通常你还需要和其他工具链的配合，例如ESlint、Typescript声明等等。</p><p>  Macro 由代码显式地应用，我们更明确它被应用的目的和时机，对源代码的侵入性最小。因为中间多了 <code>babel-plugin-macro</code> 这一层，我们降低了对构建环境的耦合，让我们的代码更方便被迁移。</p></li><li><p>3️⃣ <strong>Macro相比Plugin 更容易被实现</strong>。因为它专注于具体的 AST 节点，见下文</p></li><li><p>4️⃣ 另外，当配置出错时，Macro可以得到更好的错误提示</p></li></ul><p>有利有弊，Babel Macro 肯定也有些缺陷，例如相对于插件来说只能<em>显式转换</em>，这样代码可能会比较啰嗦，不过个人觉得在某些场景利大于弊, 能显式的就显式。</p><p><br></p><p>那么Babel Macro也是宏？<strong>相对于 Sweet.js 这些’正统’的宏机制有哪些不足</strong>？</p><ul><li><p><strong>首先 Babel Macro 必须是合法的 Javascript 语法</strong>。不支持自定义语法，也要分两面讨论，合法的Javascript语法不至于打破现有的工具协作链，如果允许用户毫无限制地创建新的语法，将来指不定会和标准的语法发生歧义。 反过来不能自定义语法的‘宏’，是否显得不太地道，不够’强大’?</p></li><li><p><strong>因为必须是合法的Javascript语法，Babel Macro 实现DSL(Domain-specific languages)能力就弱化了</strong></p></li><li><p><strong>再者，Babel Macro 和 Babel Plugin没有本质的区别</strong>，相比Sweet.js提供了显式定义和应用宏的语法，Babel Macro直接操作 AST 则要复杂得多，你还是需要了解一些编译原理，这把一般的开发者挡在了门外。</p></li></ul><blockquote><p>Babel 可以实现自定义语法，只不过你需要Fork <code>@babel/parser</code>, 对它进行改造(可以看这篇文章<a href="https://juejin.im/post/5d9be731f265da5bbc3e879b" target="_blank" rel="noopener">《精读《用 Babel 创造自定义 JS 语法》》</a>)。这个有点折腾，不太推荐</p></blockquote><p><br></p><p><strong>总之，Babel Macro 本质上和Babel Plugin没有什么区别，它只是在Plugin 之上封装了一层(<a href="https://juejin.im/post/5d7ffad551882545ff173083" target="_blank" rel="noopener">分层架构模式的强大</a>)，创建了一个新的平台，让开发者可以在源代码层面显式地应用代码转换</strong>。所以，<strong>任何适合显式去转换的场景都适合用Babel Macro来做</strong>：</p><ul><li>特定框架、库的代码转换。如 <code>styled-components</code></li><li>动态生成代码。<code>preval</code></li><li>特定文件、语言的处理。例如<code>graphql-tag.macro</code>、<code>yaml.macro</code>、<code>svgr.macro</code></li><li>… (查看<a href="https://github.com/jgierer12/awesome-babel-macros#graphql" target="_blank" rel="noopener">awesome-babel-macros</a>)</li></ul><p><br><br><br></p><h2 id="如何写一个-babel-macro"><a href="#如何写一个-babel-macro" class="headerlink" title="如何写一个 Babel Macro"></a>如何写一个 Babel Macro</h2><p>所以，Babel Macro是如何运作的呢？ <code>babel-plugin-macros</code> 要求开发者必须显式地导入 Macro，它会遍历匹配所有导入语句，<strong>如果导入源匹配<code>/[./]macro(\.js)?$/</code>正则，就会认为你在启用Macro</strong>。例如下面这些导入语句都匹配正则：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'my.macro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'./bar/macro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; baz <span class="keyword">as</span> _baz&#125; <span class="keyword">from</span> <span class="string">'baz/macro.js'</span></span><br><span class="line"><span class="comment">// 不支持命名空间导入</span></span><br></pre></td></tr></table></figure><p><br></p><p>Ok, 当匹配到导入语句后，<code>babel-plugin-macros</code>就会去导入你指定的 <code>macro</code> <strong>模块或者npm包</strong>(Macro 即可以是本地文件，也可以是公开的 npm 包， 或者是npm包中的子路径)。</p><p>那么 <code>macro</code> 文件里面要包含什么内容呢？如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createMacro &#125; = <span class="built_in">require</span>(<span class="string">'babel-plugin-macros'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createMacro(<span class="function">(<span class="params">&#123;references, state, babel&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... macro 逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p><code>macro</code> 文件必须默认导出一个由 <code>ceateMacro</code> 创建的实例, 在其回调中可以获取到一些关键对象：</p><ul><li><code>babel</code> 和普通的Babel插件一样，Macro 可以获取到一个 <code>babel-core</code> 对象</li><li><code>state</code> 这个我们也比较熟悉，Babel 插件的 visitor 方法的第二个参数就是它, 我们可以通过它获取一些配置信息以及保存一些自定义状态</li><li><code>references</code> 获取 Macro 导出标识符的所有引用。上一篇文章介绍了作用域，你应该还没忘记绑定和引用的概念。如下</li></ul><p>假设用户这样子使用你的 Macro:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo, &#123;bar, baz <span class="keyword">as</span> Baz&#125; <span class="keyword">from</span> <span class="string">'./my.macro'</span> <span class="comment">// 创建三个绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面开始引用这些绑定</span></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line">foo(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">bar<span class="string">`by tagged Template`</span></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">Baz</span>&gt;</span>by JSX<span class="tag">&lt;/<span class="name">Baz</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>那么你将拿到<code>references</code>结构是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// key 为'绑定', value 为'引用数组'</span></span><br><span class="line">  <span class="keyword">default</span>: [NodePath<span class="comment">/*Identifier(foo)*/</span>, NodePath<span class="comment">/*Identifier(foo)*/</span>], <span class="comment">// 默认导出，即foo</span></span><br><span class="line">  bar: [NodePath<span class="comment">/*Identifier(bar)*/</span>],</span><br><span class="line">  baz: [NodePath<span class="comment">/*JSXIdentifier(Baz)*/</span>], <span class="comment">// 注意key为baz，不是Baz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查看<a href="https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md" target="_blank" rel="noopener">详细开发指南</a> <br><br><a href="https://astexplorer.net" target="_blank" rel="noopener">AST Explorer</a> 也支持 babel-plugin-macros，可以玩一下. 下面的实战实例，也建议在这里探索一下</p></blockquote><p>接下来你就可以遍历<code>references</code>, 对这些节点进行转换，实现你想要的宏功能。开始实战!</p><p><br><br><br></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>这一次我们模范<a href="https://github.com/kentcdodds/babel-plugin-preval/blob/master/src/object-to-ast.js" target="_blank" rel="noopener"><code>preval</code></a> 创建一个<code>eval.macro</code> Macro, 利用它在编译阶段执行(eval)一些代码。例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> evalm <span class="keyword">from</span> <span class="string">'eval.macro'</span></span><br><span class="line"><span class="keyword">const</span> x = evalm<span class="string">`</span></span><br><span class="line"><span class="string">function fib(n) &#123;</span></span><br><span class="line"><span class="string">  const SQRT_FIVE = Math.sqrt(5);</span></span><br><span class="line"><span class="string">  return Math.round(1/SQRT_FIVE * (Math.pow(0.5 + SQRT_FIVE/2, n) - Math.pow(0.5 - SQRT_FIVE/2, n)));</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fib(20)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      ↓ ↓ ↓ ↓ ↓ ↓</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">6765</span></span><br></pre></td></tr></table></figure><p><br></p><p>创建 Macro 文件. 按照上一节的介绍，① 我们使用<code>createMacro</code>来创建一个 <code>Macro</code>实例, ② 并从<code>references</code> 中拿出所有<code>导出标识符</code>的引用路径, ③接着就是对这些引用路径进行AST转换:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createMacro, MacroError &#125; = <span class="built_in">require</span>(<span class="string">'babel-plugin-macros'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myMacro</span>(<span class="params">&#123; references, state, babel &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取默认导出的所有引用</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">default</span>: defaultImport = [] &#125; = references;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历引用并进行求值</span></span><br><span class="line">  defaultImport.forEach(<span class="function"><span class="params">referencePath</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (referencePath.parentPath.type === <span class="string">"TaggedTemplateExpression"</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = referencePath.parentPath.get(<span class="string">"quasi"</span>).evaluate().value</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">eval</span>(val)</span><br><span class="line">      <span class="keyword">const</span> ast = objToAst(res)</span><br><span class="line">      referencePath.parentPath.replaceWith(ast)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 输出友好的报错信息</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MacroError(<span class="string">'只支持标签模板字符串, 例如：evalm`1`'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createMacro(myMacro);</span><br></pre></td></tr></table></figure><p><br></p><p>为了行文简洁，本案例中只支持<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="noopener"><code>标签模板字符串</code></a> 形式调用，但是标签模板字符串中可能包含内插的字符串，例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hello<span class="string">`</span></span><br><span class="line"><span class="string">hello world <span class="subst">$&#123;foo&#125;</span> + <span class="subst">$&#123;bar + baz&#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>其 AST 结构如下:</p><p><img src="/images/babel/tag-template.png" alt></p><p><br></p><p>我们需要将 <code>TaggedTemplateExpression</code> 节点转换为字符串。手动去拼接会很麻烦，好在每个 AST 节点的 Path 对象都有一个<code>evaluate</code> 方法，这个方法可以对节点进行‘静态求值’：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">t.evaluate(parse(<span class="string">"5 + 5"</span>)) <span class="comment">// &#123; confident: true, value: 10 &#125;</span></span><br><span class="line">t.evaluate(parse(<span class="string">"!true"</span>)) <span class="comment">// &#123; confident: true, value: false &#125;</span></span><br><span class="line"><span class="comment">// ❌两个变量相加无法求值，因为变量值在运行时才存在，这里confident为false：  </span></span><br><span class="line">t.evaluate(parse(<span class="string">"foo + foo"</span>)) <span class="comment">// &#123; confident: false, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><p>因此这样子的标签模板字符串是无法求值的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">evalm<span class="string">`1 + <span class="subst">$&#123;foo&#125;</span>`</span> <span class="comment">// 包含变量</span></span><br><span class="line">evalm<span class="string">`1 + <span class="subst">$&#123;bar(<span class="number">1</span>)&#125;</span>`</span> <span class="comment">// 包含函数调用</span></span><br></pre></td></tr></table></figure><p><strong>这个和 <code>Typescript</code> 的 <a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener"><code>enum</code></a>， 还有一些编译语言的常量是一样的，它们在编译阶段被求值，只有一些原始值以及一些原始值的表达式才支持在编译阶段被求值</strong>.</p><p><br></p><p>So，上面的代码还不够健壮，我们再优化一下，在求值失败时给用户更好的提示:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">defaultImport.forEach(<span class="function"><span class="params">referencePath</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (referencePath.parentPath.type === <span class="string">"TaggedTemplateExpression"</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> evaluated = referencePath.parentPath.get(<span class="string">"quasi"</span>).evaluate();</span><br><span class="line">    <span class="comment">// 转换标签模板字符串失败</span></span><br><span class="line">    <span class="keyword">if</span> (!evaluated.confident) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MacroError(<span class="string">"标签模板字符串内插值只支持原始值和原始值表达式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">eval</span>(evaluated.value);</span><br><span class="line">      <span class="keyword">const</span> ast = objToAst(res);</span><br><span class="line">      <span class="comment">// 替换掉调用节点</span></span><br><span class="line">      referencePath.parentPath.replaceWith(ast);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MacroError(<span class="string">`求值失败: <span class="subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MacroError(<span class="string">"只支持标签模板字符串, 例如：evalm`1 + 1`"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>接下来将执行后的值转换为 AST，然后替换掉<code>TaggedTemplateExpression</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToAst</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(res);</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">    str = <span class="string">"undefined"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> variableDeclarationNode = babel.template(<span class="string">`var x = <span class="subst">$&#123;str&#125;</span>`</span>, &#123;&#125;)();</span><br><span class="line">  <span class="comment">// 取出初始化表达式的 AST</span></span><br><span class="line">  <span class="keyword">return</span> variableDeclarationNode.declarations[<span class="number">0</span>].init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>@babel/template</code> 就派上用场了，它可以将字符串代码解析成 AST，当然直接使用<code>parse</code>方法解析也是可以的。</p><p><br></p><p>Ok, 文章到这里基本结束了。本文对‘宏’进行了深入的讨论，从 <code>C</code> 语言的文本替换宏到濒死的<code>Sweet.js</code>, 最后介绍了<code>babel-plugin-macros</code>.</p><p>Babel Macro 本质上还是Babel 插件，只不过它是模块化的，你要使用它必须显式地导入。和‘正统’宏相比， Babel Macro 直接操作 AST，需要你掌握编译原理， ‘正统’宏可以实现的东西, Babel Macro也可以实现(例如卫生宏). 虽然相比Babel插件略有简化，还是比较啰嗦。另外Babel Macro 不能创建新的语法，这使得它可以和现有的工具生态保持兼容。</p><p>最后！打开脑洞 🧠，Babel Macro 可以做很多有意思的东西，查看<a href="https://github.com/jgierer12/awesome-babel-macros" target="_blank" rel="noopener">《Awesome babel macros》</a>。不过要<strong>谨记：‘显式好于隐式，清晰的代码优于简洁的代码’</strong></p><p><br></p><p><strong>截止 2019.10.10 掘金粉丝数已经突破 ✨2000✨，继续关注我，点赞给我支持</strong>。</p><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros" target="_blank" rel="noopener">Zero-config code transformation with babel-plugin-macros</a></li><li><a href="https://github.com/facebook/create-react-app/issues/2730" target="_blank" rel="noopener">RFC - babel-macros</a></li><li><a href="https://jlongster.com/Stop-Writing-JavaScript-Compilers--Make-Macros-Instead" target="_blank" rel="noopener">STOP WRITING JAVASCRIPT COMPILERS! MAKE MACROS INSTEAD</a></li><li><a href="https://blog.oyanglul.us/javascript/clojure-essence-in-javascript-macro" target="_blank" rel="noopener">JavaScript玩转Clojure大法之 - Macro (1)</a></li><li><a href="https://elixir-lang.org/getting-started/meta/macros.html" target="_blank" rel="noopener">Elixir Macro</a></li><li><a href="https://kaisery.gitbooks.io/rust-book-chinese/content/content/Macros%20宏.html" target="_blank" rel="noopener">Rust 的宏</a></li><li><a href="https://juejin.im/post/5cebce946fb9a07ece67aec4" target="_blank" rel="noopener">iOS深思篇 | 宏定义</a></li><li><a href="https://medium.com/@fxn/how-does-elixir-compile-execute-code-c1b36c9ec8cf" target="_blank" rel="noopener">How does Elixir compile/execute code?</a></li><li><a href="https://segmentfault.com/a/1190000004104696" target="_blank" rel="noopener">让这世界再多一份 GNU m4 教程 (1)</a></li><li><a href="https://segmentfault.com/a/1190000004050807" target="_blank" rel="noopener">宏语言为何不受欢迎</a></li><li><a href="https://github.com/babel/awesome-babel" target="_blank" rel="noopener">awesome-babel</a></li><li><a href="https://www.zhihu.com/question/19875500" target="_blank" rel="noopener">各编程语言对「宏」的支持是怎样的？</a></li><li><a href="https://github.com/sweet-js/sweet-core/wiki/Macro-resources" target="_blank" rel="noopener">Sweetjs 相关论文</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接着上篇文章: &lt;a href=&quot;https://juejin.im/post/5d94bfbf5188256db95589be&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《深入浅出 Babel 上篇：架构和原理 + 实战 🔥》&lt;/a&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>深入浅出 Babel 上篇：架构和原理 + 实战</title>
    <link href="https://bobi.ink/2019/10/01/babel/"/>
    <id>https://bobi.ink/2019/10/01/babel/</id>
    <published>2019-09-30T16:00:00.000Z</published>
    <updated>2019-10-10T23:18:31.108Z</updated>
    
    <content type="html"><![CDATA[<p>国庆放假了，我还在利用碎片时间在写文章，不知道长假还有没有人看，试试水吧！</p><p>这个文章系列将带大家深入浅出 <a href="https://babeljs.io" target="_blank" rel="noopener"><code>Babel</code></a>, 这个系列将分为上下两篇：上篇主要介绍 Babel 的架构和原理，顺便实践一下插件开发的；下篇会介绍 <a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener">`babel-plugin-macros </a>, 利用它来写属于 Javascript 的’宏‘，</p><p>✨满满的干货，不容错过哦. 写文不易，点赞是最大的鼓励。</p><blockquote><p>注意: 本文不是 Babel 的基础使用教程！如果你对 Babel 尚不了解，请查看<a href="https://babeljs.io" target="_blank" rel="noopener">官方网站</a>, 或者这个<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" target="_blank" rel="noopener">用户手册</a></p></blockquote><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#babel-的处理流程">Babel 的处理流程</a></li><li><a href="#babel-的架构">Babel 的架构</a></li><li><a href="#访问者模式">访问者模式</a><ul><li><a href="#节点的遍历">节点的遍历</a></li><li><a href="#节点的上下文">节点的上下文</a></li><li><a href="#副作用的处理">副作用的处理</a></li><li><a href="#作用域的处理">作用域的处理</a></li></ul></li><li><a href="#搞一个插件呗">搞一个插件呗</a></li><li><a href="#最后">最后</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="babel-的处理流程"><a href="#babel-的处理流程" class="headerlink" title="Babel 的处理流程"></a>Babel 的处理流程</h2><p><img src="/images/babel/process.png" alt><br><i>Babel 的处理流程</i></p><p><br></p><p>上图是 Babel 的处理流程, 如果读者学习过<code>编译器原理</code>，这个过程就相当亲切了.</p><p>首先从源码 <code>解析(Parsing)</code> 开始，解析包含了两个步骤:</p><p><strong>1️⃣词法解析(Lexical Analysis)</strong>： <code>词法解析器(Tokenizer)</code>在这个阶段将字符串形式的代码转换为<code>Tokens(令牌)</code>. Tokens 可以视作是一些语法片段组成的数组. 例如<code>for (const item of items) {}</code> 词法解析后的结果如下:</p><p><img src="/images/babel/tokens.png" alt></p><p>从上图可以看，每个 Token 中包含了语法片段、位置信息、以及一些类型信息. 这些信息有助于后续的语法分析。</p><p><br></p><p><strong>2️⃣语法解析(Syntactic Analysis)</strong>：这个阶段语法<code>解析器(Parser)</code>会把<code>Tokens</code>转换为<code>抽象语法树(Abstract Syntax Tree，AST)</code></p><p><strong>什么是AST</strong>?</p><p>它就是一棵’对象树’，用来表示代码的语法结构，例如<code>console.log(&#39;hello world&#39;)</code>会解析成为:</p><p><img src="/images/babel/ast.png" alt></p><p><code>Program</code>、<code>CallExpression</code>、<code>Identifier</code> <strong>这些都是节点的类型，每个节点都是一个有意义的语法单元</strong>。 这些节点类型定义了一些属性来描述节点的信息。</p><p>JavaScript的语法越来越复杂，而且 Babel 除了支持最新的JavaScript规范语法, 还支持 <code>JSX</code>、<code>Flow</code>、现在还有<code>Typescript</code>。想象一下 AST 的节点类型有多少，其实我们不需要去记住这么多类型、也记不住. <strong>插件开发者会利用 <a href="https://astexplorer.net" target="_blank" rel="noopener"><code>ASTExplorer</code></a> 来审查解析后的AST树</strong>, 非常强大👍。</p><p><strong>AST 是 Babel 转译的核心数据结构，后续的操作都依赖于 AST</strong>。</p><p><br></p><p>接着就是<strong>转换(Transform)</strong>了，转换阶段会对 AST 进行遍历，在这个过程中对节点进行增删查改。Babel 所有插件都是在这个阶段工作, 比如语法转换、代码压缩。</p><p><br></p><p><strong>Javascript In Javascript Out</strong>, 最后阶段还是要把 AST 转换回字符串形式的Javascript，同时这个阶段还会生成Source Map。</p><p><br><br><br></p><h2 id="babel-的架构"><a href="#babel-的架构" class="headerlink" title="Babel 的架构"></a>Babel 的架构</h2><p>我在<a href="https://juejin.im/post/5d7ffad551882545ff173083" target="_blank" rel="noopener">《透过现象看本质: 常见的前端架构风格和案例🔥》</a> 提及 <code>Babel</code> 和 <code>Webpack</code> 为了适应复杂的定制需求和频繁的功能变化，都使用了<a href="https://juejin.im/post/5d7ffad551882545ff173083#heading-10" target="_blank" rel="noopener">微内核</a> 的架构风格。<strong>也就是说它们的核心非常小，大部分功能都是通过插件扩展实现的</strong>。</p><p><br></p><p>所以简单地了解一下 Babel 的架构和一些基本概念，对后续文章内容的理解, 以及Babel的使用还是有帮助的。</p><p><strong>一图胜千言</strong>。仔细读过我文章的朋友会发现，我的风格就是能用图片说明的就不用文字、能用文字的就不用代码。<strong>虽然我的原创文章篇幅都很长，图片还是值得看看的</strong>。</p><p><img src="/images/babel/arch.png" alt></p><p><br></p><p>Babel 是一个 <a href="https://github.com/lerna/lerna" target="_blank" rel="noopener"><code>MonoRepo</code></a> 项目， 不过组织非常清晰，下面就源码上我们能看到的模块进行一下分类， 配合上面的架构图让你对Babel有个大概的认识:</p><p><br></p><p><strong>1️⃣ 核心</strong>:</p><p><code>@babel/core</code> 这也是上面说的‘微内核’架构中的‘内核’。对于Babel来说，这个内核主要干这些事情：</p><ul><li>加载和处理配置(config)</li><li>加载插件</li><li>调用 <code>Parser</code> 进行语法解析，生成 <code>AST</code></li><li>调用 <code>Traverser</code> 遍历AST，并使用<code>访问者模式</code>应用’插件’对 AST 进行转换</li><li>生成代码，包括SourceMap转换和源代码生成</li></ul><p><br></p><p><strong>2️⃣ 核心周边支撑</strong></p><ul><li><p><strong>Parser(<code>@babel/parser</code>)</strong>： 将源代码解析为 AST 就靠它了。 它已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的ECMAScript规范。目前为了执行效率，parser是<a href="https://babeljs.io/docs/en/babel-parser#faq" target="_blank" rel="noopener">不支持扩展的</a>，由官方进行维护。如果你要支持自定义语法，可以 fork 它，不过这种场景非常少。</p></li><li><p><strong>Traverser(<code>@babel/traverse</code>)</strong>：  实现了<code>访问者模式</code>，对 AST 进行遍历，<code>转换插件</code>会通过它获取感兴趣的AST节点，对节点继续操作, 下文会详细介绍<code>访问器模式</code>。</p></li><li><p><strong>Generator(<code>@babel/generator</code>)</strong>： 将 AST 转换为源代码，支持 SourceMap</p></li></ul><p><br></p><p><strong>3️⃣ 插件</strong></p><p>打开 Babel 的源代码，会发现有好几种类型的‘插件’。</p><ul><li><p><strong>语法插件(<code>@babel/plugin-syntax-*</code>)</strong>：上面说了 <code>@babel/parser</code> 已经支持了很多 JavaScript 语法特性，Parser也不支持扩展. <strong>因此<code>plugin-syntax-*</code>实际上只是用于开启或者配置Parser的某个功能特性</strong>。</p><p>一般用户不需要关心这个，Transform 插件里面已经包含了相关的<code>plugin-syntax-*</code>插件了。用户也可以通过<a href="https://babeljs.io/docs/en/options#parseropts" target="_blank" rel="noopener"><code>parserOpts</code></a>配置项来直接配置 Parser</p></li><li><p><strong>转换插件</strong>： 用于对 AST 进行转换, 实现转换为ES5代码、压缩、功能增强等目的. Babel仓库将转换插件划分为两种(只是命名上的区别)：</p><ul><li><code>@babel/plugin-transform-*</code>： 普通的转换插件</li><li><code>@babel/plugin-proposal-*</code>： 还在’提议阶段’(非正式)的语言特性, 目前有<a href="https://babeljs.io/docs/en/next/plugins#experimental" target="_blank" rel="noopener">这些</a></li></ul></li><li><p><strong>预定义集合(<code>@babel/presets-*</code>)</strong>： 插件集合或者分组，主要方便用户对插件进行管理和使用。比如<code>preset-env</code>含括所有的标准的最新特性; 再比如<code>preset-react</code>含括所有react相关的插件.</p></li></ul><p><br></p><p><strong>4️⃣ 插件开发辅助</strong></p><ul><li><p><code>@babel/template</code>： 某些场景直接操作AST太麻烦，就比如我们直接操作DOM一样，所以Babel实现了这么一个简单的模板引擎，可以将字符串代码转换为AST。比如在生成一些辅助代码(helper)时会用到这个库</p></li><li><p><code>@babel/types</code>： AST 节点构造器和断言. 插件开发时使用很频繁</p></li><li><p><code>@babel/helper-*</code>： 一些辅助器，用于辅助插件开发，例如简化AST操作</p></li><li><p><code>@babel/helper</code>： 辅助代码，单纯的语法转换可能无法让代码运行起来，比如低版本浏览器无法识别class关键字，这时候需要添加辅助代码，对class进行模拟。</p></li></ul><p><br></p><p><strong>5️⃣ 工具</strong></p><ul><li><p><code>@babel/node</code>： Node.js CLI, 通过它直接运行需要 Babel 处理的JavaScript文件</p></li><li><p><code>@babel/register</code>： Patch NodeJs 的require方法，支持导入需要Babel处理的JavaScript模块</p></li><li><p><code>@babel/cli</code>： CLI工具</p></li></ul><p><br><br><br></p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>转换器会遍历 AST 树，找出自己感兴趣的节点类型, 再进行转换操作. 这个过程和我们操作<code>DOM</code>树差不多，只不过目的不太一样。AST 遍历和转换一般会使用<a href="https://www.jianshu.com/p/1f1049d0a0f4" target="_blank" rel="noopener"><code>访问者模式</code></a>。</p><p>想象一下，Babel 有那么多插件，如果每个插件自己去遍历AST，对不同的节点进行不同的操作，维护自己的状态。这样子不仅低效，它们的逻辑分散在各处，会让整个系统变得难以理解和调试， 最后插件之间关系就纠缠不清，乱成一锅粥。</p><p><strong>所以转换器操作 AST 一般都是使用<code>访问器模式</code>，由这个<code>访问者(Visitor)</code>来 ① 进行统一的遍历操作，② 提供节点的操作方法，③ 响应式维护节点之间的关系；而插件(设计模式中称为‘具体访问者’)只需要定义自己感兴趣的节点类型，当访问者访问到对应节点时，就调用插件的访问(visit)方法</strong>。</p><p><br></p><h3 id="节点的遍历"><a href="#节点的遍历" class="headerlink" title="节点的遍历"></a>节点的遍历</h3><p>假设我们的代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span> + v + <span class="string">'!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>解析后的 AST 结构如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">File</span><br><span class="line">  Program (program)</span><br><span class="line">    FunctionDeclaration (body)</span><br><span class="line">      Identifier (id)  #hello</span><br><span class="line">      Identifier (params[0]) #v</span><br><span class="line">      BlockStatement (body)</span><br><span class="line">        ExpressionStatement ([0])</span><br><span class="line">          CallExpression (expression)</span><br><span class="line">            MemberExpression (callee)  #console.log</span><br><span class="line">              Identifier (object)  #console</span><br><span class="line">              Identifier (property)  #log</span><br><span class="line">            BinaryExpression (arguments[0])</span><br><span class="line">              BinaryExpression (left)</span><br><span class="line">                StringLiteral (left)  #'hello'</span><br><span class="line">                Identifier (right)  #v</span><br><span class="line">              StringLiteral (right)  #'!'</span><br></pre></td></tr></table></figure><p><br></p><p>访问者会以<code>深度优先</code>的顺序, 或者说递归地对 AST 进行遍历，其调用顺序如下图所示:</p><p><img src="/images/babel/traveser.png" alt></p><p><br></p><p>上图中<code>绿线</code>表示进入该节点，<code>红线</code>表示离开该节点。下面写一个超简单的’具体访问者’来还原上面的遍历过程:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babel.parseSync(code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`enter <span class="subst">$&#123;path.type&#125;</span>(<span class="subst">$&#123;path.key&#125;</span>)`</span>)</span><br><span class="line">    depth++</span><br><span class="line">  &#125;,</span><br><span class="line">  exit(path) &#123;</span><br><span class="line">    depth--</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`  exit <span class="subst">$&#123;path.type&#125;</span>(<span class="subst">$&#123;path.key&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><details><br><summary> 查看代码执行结果 </summary><br><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">enter Program(program)</span><br><span class="line">  enter FunctionDeclaration(0)</span><br><span class="line">    enter Identifier(id)</span><br><span class="line">    exit Identifier(id)</span><br><span class="line">    enter Identifier(0)</span><br><span class="line">    exit Identifier(0)</span><br><span class="line">    enter BlockStatement(body)</span><br><span class="line">      enter ExpressionStatement(0)</span><br><span class="line">        enter CallExpression(expression)</span><br><span class="line">          enter MemberExpression(callee)</span><br><span class="line">            enter Identifier(object)</span><br><span class="line">            exit Identifier(object)</span><br><span class="line">            enter Identifier(property)</span><br><span class="line">            exit Identifier(property)</span><br><span class="line">          exit MemberExpression(callee)</span><br><span class="line">          enter BinaryExpression(0)</span><br><span class="line">            enter BinaryExpression(left)</span><br><span class="line">              enter StringLiteral(left)</span><br><span class="line">              exit StringLiteral(left)</span><br><span class="line">              enter Identifier(right)</span><br><span class="line">              exit Identifier(right)</span><br><span class="line">            exit BinaryExpression(left)</span><br><span class="line">            enter StringLiteral(right)</span><br><span class="line">            exit StringLiteral(right)</span><br><span class="line">          exit BinaryExpression(0)</span><br><span class="line">        exit CallExpression(expression)</span><br><span class="line">      exit ExpressionStatement(0)</span><br><span class="line">    exit BlockStatement(body)</span><br><span class="line">  exit FunctionDeclaration(0)</span><br><span class="line">exit Program(program)</span><br></pre></td></tr></table></figure><br><br></details><p><br></p><p>当访问者进入一个节点时就会调用 <code>enter(进入)</code> 方法，反之离开该节点时会调用 <code>exit(离开)</code> 方法。 一般情况下，插件不会直接使用<code>enter</code>方法，只会关注少数几个节点类型，所以具体访问者也可以这样声明访问方法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 访问标识符</span></span><br><span class="line">  Idenfifier(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`enter Identifier`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 访问调用表达式</span></span><br><span class="line">  CallExpression(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`enter CallExpression`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 上面是enter的简写，如果要处理exit，也可以这样</span></span><br><span class="line">  <span class="comment">// 二元操作符</span></span><br><span class="line">  BinaryExpression: &#123;</span><br><span class="line">    enter(path) &#123;&#125;,</span><br><span class="line">    exit(path) &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 更高级的, 使用同一个方法访问多种类型的节点</span></span><br><span class="line">  <span class="string">"ExportNamedDeclaration|Flow"</span>(path) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>那么 Babel 插件是怎么被应用的呢？</strong></p><p>Babel 会按照插件定义的顺序来应用访问方法，比如你注册了多个插件，babel-core 最后传递给访问器的数据结构大概长这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Identifier: &#123;</span><br><span class="line">    enter: [plugin-xx, plugin-yy,] <span class="comment">// 数组形式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>当进入一个节点时，这些插件会按照注册的顺序被执行。大部分插件是不需要开发者关心定义的顺序的，有少数的情况需要稍微注意以下，例如<code>plugin-proposal-decorators</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@babel/plugin-proposal-decorators"</span>,     <span class="comment">// 必须在plugin-proposal-class-properties之前</span></span><br><span class="line">    <span class="string">"@babel/plugin-proposal-class-properties"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>所有插件定义的顺序，按照惯例，应该是新的或者说实验性的插件在前面，老的插件定义在后面。因为可能需要新的插件将 AST 转换后，老的插件才能识别语法（向后兼容）。下面是官方配置例子, 为了确保先后兼容，<code>stage-*</code>阶段的插件先执行:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"react"</span>, <span class="string">"stage-2"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意Preset的执行顺序相反，详见官方<a href="https://babeljs.io/docs/en/next/plugins#plugin-ordering" target="_blank" rel="noopener">文档</a></p></blockquote><p><br></p><h3 id="节点的上下文"><a href="#节点的上下文" class="headerlink" title="节点的上下文"></a>节点的上下文</h3><p>访问者在访问一个节点时, 会无差别地调用 <code>enter</code> 方法，我们怎么知道这个节点在什么位置以及和其他节点的关联关系呢？</p><p>通过上面的代码，读者应该可以猜出几分，每个<code>visit</code>方法都接收一个 <code>Path</code> 对象, 你可以将它当做一个‘上下文’对象，类似于<code>JQuery</code>的 <code>JQuery</code>(<code>const $el = $(&#39;.el&#39;)</code>) 对象，这里面包含了很多信息：</p><ul><li>当前节点信息</li><li>节点的关联信息。父节点、子节点、兄弟节点等等</li><li>作用域信息</li><li>上下文信息</li><li>节点操作方法。节点增删查改</li><li>断言方法。isXXX, assertXXX</li></ul><p>下面是它的主要结构:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NodePath</span>&lt;<span class="title">T</span> </span>= Node&gt; &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(hub: Hub, parent: Node);</span><br><span class="line">    parent: Node;</span><br><span class="line">    hub: Hub;</span><br><span class="line">    contexts: TraversalContext[];</span><br><span class="line">    data: object;</span><br><span class="line">    shouldSkip: boolean;</span><br><span class="line">    shouldStop: boolean;</span><br><span class="line">    removed: boolean;</span><br><span class="line">    state: any;</span><br><span class="line">    opts: object;</span><br><span class="line">    skipKeys: object;</span><br><span class="line">    parentPath: NodePath;</span><br><span class="line">    context: TraversalContext;</span><br><span class="line">    container: object | object[];</span><br><span class="line">    listKey: string; // 如果节点在一个数组中，这个就是节点数组的键</span><br><span class="line">    inList: boolean;</span><br><span class="line">    parentKey: string;</span><br><span class="line">    key: string | number; // 节点所在的键或索引</span><br><span class="line">    node: T;  // 🔴 当前节点</span><br><span class="line">    scope: Scope; // 🔴当前节点所在的作用域</span><br><span class="line">    type: T extends undefined | null ? string | null : string; // 🔴节点类型</span><br><span class="line">    typeAnnotation: object;</span><br><span class="line">    // ... 还有很多方法，实现增删查改</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过这个<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-visitors" target="_blank" rel="noopener">手册</a>来学习怎么通过 Path 来转换 AST. 后面也会有代码示例，这里就不展开细节了</p><p><br></p><h3 id="副作用的处理"><a href="#副作用的处理" class="headerlink" title="副作用的处理"></a>副作用的处理</h3><p>实际上访问者的工作比我们想象的要复杂的多，上面示范的是静态 AST 的遍历过程。而 AST 转换本身是有副作用的，比如插件将旧的节点替换了，那么访问者就没有必要再向下访问旧节点了，而是继续访问新的节点, 代码如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  ExpressionStatement(path) &#123;</span><br><span class="line">    <span class="comment">// 将 `console.log('hello' + v + '!')` 替换为 `return ‘hello’ + v`</span></span><br><span class="line">    <span class="keyword">const</span> rtn = t.returnStatement(t.binaryExpression(<span class="string">'+'</span>, t.stringLiteral(<span class="string">'hello'</span>), t.identifier(<span class="string">'v'</span>)))</span><br><span class="line">    path.replaceWith(rtn)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码, 将<code>console.log(&#39;hello&#39; + v + &#39;!&#39;)</code>语句替换为<code>return &quot;hello&quot; + v;</code>, 下图是遍历的过程：</p><p><img src="/images/babel/replace.png" alt></p><p><br></p><p>我们可以对 AST 进行任意的操作，比如删除父节点的兄弟节点、删除第一个子节点、新增兄弟节点… <strong>当这些操作’污染’了 AST 树后，访问者需要记录这些状态，响应式(Reactive)更新 Path 对象的关联关系, 保证正确的遍历顺序，从而获得正确的转译结果</strong>。</p><p><br></p><h3 id="作用域的处理"><a href="#作用域的处理" class="headerlink" title="作用域的处理"></a>作用域的处理</h3><p>访问者可以确保正确地遍历和修改节点，但是对于转换器来说，另一个比较棘手的是对作用域的处理，这个责任落在了插件开发者的头上。插件开发者必须非常谨慎地处理作用域，不能破坏现有代码的执行逻辑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="keyword">return</span> foo + bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如你要将 <code>add</code> 函数的第一个参数 <code>foo</code> 标识符修改为<code>a</code>, 你就需要<strong>递归</strong>遍历子树，查出<code>foo</code>标识符的所有<code>引用</code>, 然后替换它:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 将第一个参数名转换为a</span></span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstParams = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParams == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name = firstParams.node.name</span><br><span class="line">    <span class="comment">// 递归遍历，这是插件常用的模式。这样可以避免影响到外部作用域</span></span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">      Identifier(path) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.node.name === name) &#123;</span><br><span class="line">          path.replaceWith(t.identifier(<span class="string">'a'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generate(ast).code)</span><br><span class="line"><span class="comment">// function add(a, bar) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(a, b);</span></span><br><span class="line"><span class="comment">//   return a + bar;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>🤯慢着，好像没那么简单，替换成 <code>a</code> 之后, <code>console.log(a, b)</code> 的行为就被破坏了。所以这里不能用 <code>a</code>，得换个标识符, 譬如<code>c</code>.</p><p><br></p><p>这就是转换器需要考虑的作用域问题，<strong>AST 转换的前提是保证程序的正确性</strong>。 我们在添加和修改<code>引用</code>时，需要确保与现有的所有引用不冲突。Babel本身不能检测这类异常，只能依靠插件开发者谨慎处理。</p><p><br></p><p>Javascript采用的是词法作用域, 也就是根据源代码的词法结构来确定作用域：</p><p><img src="/images/babel/scope.png" alt></p><p>在<strong>词法区块(block)</strong>中，由于新建变量、函数、类、函数参数等创建的标识符，都属于这个区块作用域. 这些标识符也称为<strong>绑定(Binding)</strong>，而对这些绑定的使用称为<strong>引用(Reference)</strong></p><p>在Babel中，使用<code>Scope</code>对象来表示作用域。 我们可以通过Path对象的<code>scope</code>字段来获取当前节点的<code>Scope</code>对象。它的结构如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: NodePath;</span><br><span class="line">  block: Node;         <span class="comment">// 所属的词法区块节点, 例如函数节点、条件语句节点</span></span><br><span class="line">  parentBlock: Node;   <span class="comment">// 所属的父级词法区块节点</span></span><br><span class="line">  parent: Scope;       <span class="comment">// ⚛️指向父作用域</span></span><br><span class="line">  bindings: &#123; [name: string]: Binding; &#125;; <span class="comment">// ⚛️ 该作用域下面的所有绑定(即该作用域创建的标识符)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>Scope</code> 对象和 <code>Path</code> 对象差不多，<strong>它包含了作用域之间的关联关系(通过parent指向父作用域)，收集了作用域下面的所有绑定(bindings), 另外还提供了丰富的方法来对作用域仅限操作</strong>。</p><p>我们可以通过<code>bindings</code>属性获取当前作用域下的所有绑定(即标识符)，每个绑定由<code>Binding</code>类来表示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Binding</span> </span>&#123;</span><br><span class="line">  identifier: t.Identifier;</span><br><span class="line">  scope: Scope;</span><br><span class="line">  path: NodePath;</span><br><span class="line">  kind: <span class="string">"var"</span> | <span class="string">"let"</span> | <span class="string">"const"</span> | <span class="string">"module"</span>;</span><br><span class="line">  referenced: boolean;</span><br><span class="line">  references: number;              <span class="comment">// 被引用的数量</span></span><br><span class="line">  referencePaths: NodePath[];      <span class="comment">// ⚛️获取所有应用该标识符的节点路径</span></span><br><span class="line">  constant: boolean;               <span class="comment">// 是否是常量</span></span><br><span class="line">  constantViolations: NodePath[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>Binding</code>对象我们可以确定标识符被引用的情况</strong>。</p><p>Ok，有了 <code>Scope</code> 和 <code>Binding</code>, 现在有能力实现安全的变量重命名转换了。 为了更好地展示作用域交互，在上面代码的基础上，我们再增加一下难度：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="string">'1'</span> <span class="comment">// 新增了一个变量声明</span></span><br><span class="line">    <span class="keyword">return</span> a + (foo + bar)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你要重命名函数参数 <code>foo</code>, 不仅要考虑<code>外部的作用域</code>, 也要考虑<code>下级作用域</code>的绑定情况，确保这两者都不冲突。</p><p>上面的代码作用域和标识符引用情况如下图所示:</p><p><img src="/images/babel/scope2.png" alt></p><p><br></p><p>来吧，接受挑战，试着将函数的第一个参数重新命名为更短的标识符:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于获取唯一的标识符</span></span><br><span class="line"><span class="keyword">const</span> getUid = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`_<span class="subst">$&#123;(uid++) || <span class="string">''</span>&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babel.parseSync(code)</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="comment">// 获取第一个参数</span></span><br><span class="line">    <span class="keyword">const</span> firstParam = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParam == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> currentName = firstParam.node.name</span><br><span class="line">    <span class="keyword">const</span> currentBinding = path.scope.getBinding(currentName)</span><br><span class="line">    <span class="keyword">const</span> gid = getUid()</span><br><span class="line">    <span class="keyword">let</span> sname</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环找出没有被占用的变量名</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      sname = gid()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1️⃣首先看一下父作用域是否已定义了该变量</span></span><br><span class="line">      <span class="keyword">if</span> (path.scope.parentHasBinding(sname)) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2️⃣ 检查当前作用域是否定义了变量</span></span><br><span class="line">      <span class="keyword">if</span> (path.scope.hasOwnBinding(sname)) &#123;</span><br><span class="line">        <span class="comment">// 已占用</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  再检查第一个参数的当前的引用情况,</span></span><br><span class="line">      <span class="comment">// 如果它所在的作用域定义了同名的变量，我们也得放弃</span></span><br><span class="line">      <span class="keyword">if</span> (currentBinding.references &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> findIt = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> refNode <span class="keyword">of</span> currentBinding.referencePaths) &#123;</span><br><span class="line">          <span class="keyword">if</span> (refNode.scope !== path.scope &amp;&amp; refNode.scope.hasBinding(sname)) &#123;</span><br><span class="line">            findIt = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findIt) &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始替换掉</span></span><br><span class="line">    <span class="keyword">const</span> i = t.identifier(sname)</span><br><span class="line">    currentBinding.referencePaths.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.replaceWith(i))</span><br><span class="line">    firstParam.replaceWith(i)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generate(ast).code)</span><br><span class="line"><span class="comment">// const a = 1,</span></span><br><span class="line"><span class="comment">//       b = 2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function add(_, bar) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(a, b);</span></span><br><span class="line"><span class="comment">//   return () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     const a = '1'; // 新增了一个变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return a + (_ + bar);</span></span><br><span class="line"><span class="comment">//   &#125;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>上面的例子虽然没有什么实用性，而且还有Bug(没考虑<code>label</code>)，但是正好可以揭示了作用域处理的复杂性。</p><p><br></p><p>Babel的 <code>Scope</code> 对象其实提供了一个<code>generateUid</code>方法来生成唯一的、不冲突的标识符。我们利用这个方法再简化一下我们的代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstParam = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParam == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = path.scope.generateUidIdentifier(<span class="string">'_'</span>) <span class="comment">// 也可以使用generateUid</span></span><br><span class="line">    <span class="keyword">const</span> currentBinding = path.scope.getBinding(firstParam.node.name)</span><br><span class="line">    currentBinding.referencePaths.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.replaceWith(i))</span><br><span class="line">    firstParam.replaceWith(i)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>能不能再短点!</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstParam = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParam == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = path.scope.generateUid(<span class="string">'_'</span>) <span class="comment">// 也可以使用generateUid</span></span><br><span class="line">    path.scope.rename(firstParam.node.name, i)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><details><br><summary>查看generateUid的实现代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">generateUid(name: string = <span class="string">"temp"</span>) &#123;</span><br><span class="line">  name = t</span><br><span class="line">    .toIdentifier(name)</span><br><span class="line">    .replace(<span class="regexp">/^_+/</span>, <span class="string">""</span>)</span><br><span class="line">    .replace(<span class="regexp">/[0-9]+$/g</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> uid;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    uid = <span class="keyword">this</span>._generateUid(name, i);</span><br><span class="line">    i++;</span><br><span class="line">  &#125; <span class="keyword">while</span> (</span><br><span class="line">    <span class="keyword">this</span>.hasLabel(uid) ||</span><br><span class="line">    <span class="keyword">this</span>.hasBinding(uid) ||</span><br><span class="line">    <span class="keyword">this</span>.hasGlobal(uid) ||</span><br><span class="line">    <span class="keyword">this</span>.hasReference(uid)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> program = <span class="keyword">this</span>.getProgramParent();</span><br><span class="line">  program.references[uid] = <span class="literal">true</span>;</span><br><span class="line">  program.uids[uid] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><p>非常简洁哈？作用域操作最典型的场景是代码压缩，代码压缩会对变量名、函数名等进行压缩… 然而实际上很少的插件场景需要跟作用域进行复杂的交互，所以关于作用域这一块就先讲到这里。</p><p><br></p><h2 id="搞一个插件呗"><a href="#搞一个插件呗" class="headerlink" title="搞一个插件呗"></a>搞一个插件呗</h2><p>等等别走，还没完呢，这才到2/3。学了上面得了知识，总得写一个玩具插件试试水吧?</p><p>现在打算模仿<a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a>, 写一个极简版插件，来实现模块的按需导入. 在这个插件中，我们会将类似这样的导入语句:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;A, B, C <span class="keyword">as</span> D&#125; <span class="keyword">from</span> <span class="string">'foo'</span></span><br></pre></td></tr></table></figure><p>转换为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">'foo/A'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'foo/A/style.css'</span></span><br><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">'foo/B'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'foo/B/style.css'</span></span><br><span class="line"><span class="keyword">import</span> D <span class="keyword">from</span> <span class="string">'foo/C'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'foo/C/style.css'</span></span><br></pre></td></tr></table></figure><p>首先通过 <a href="https://astexplorer.net" target="_blank" rel="noopener">AST Explorer</a> 看一下导入语句的 AST 节点结构:</p><p><img src="/images/babel/import.png" alt></p><p><br></p><p>通过上面展示的结果，我们需要处理 <code>ImportDeclaration</code> 节点类型，将它的<code>specifiers</code>拿出来遍历处理一下。另外如果用户使用了<code>默认导入</code>语句，我们将抛出错误，提醒用户不能使用默认导入. </p><p>基本实现如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要识别的模块</span></span><br><span class="line"><span class="keyword">const</span> MODULE = <span class="string">'foo'</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 访问导入语句</span></span><br><span class="line">  ImportDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.node.source.value !== MODULE) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是空导入则直接删除掉</span></span><br><span class="line">    <span class="keyword">const</span> specs = path.node.specifiers</span><br><span class="line">    <span class="keyword">if</span> (specs.length === <span class="number">0</span>) &#123;</span><br><span class="line">      path.remove()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否包含了默认导入和命名空间导入</span></span><br><span class="line">    <span class="keyword">if</span> (specs.some(<span class="function"><span class="params">i</span> =&gt;</span> t.isImportDefaultSpecifier(i) || t.isImportNamespaceSpecifier(i))) &#123;</span><br><span class="line">      <span class="comment">// 抛出错误，Babel会展示出错的代码帧</span></span><br><span class="line">      <span class="keyword">throw</span> path.buildCodeFrameError(<span class="string">"不能使用默认导入或命名空间导入"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换命名导入</span></span><br><span class="line">    <span class="keyword">const</span> imports = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> spec <span class="keyword">of</span> specs) &#123;</span><br><span class="line">      <span class="keyword">const</span> named = MODULE + <span class="string">'/'</span> + spec.imported.name</span><br><span class="line">      <span class="keyword">const</span> local = spec.local</span><br><span class="line">      imports.push(t.importDeclaration([t.importDefaultSpecifier(local)], t.stringLiteral(named)))</span><br><span class="line">      imports.push(t.importDeclaration([], t.stringLiteral(<span class="string">`<span class="subst">$&#123;named&#125;</span>/style.css`</span>)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换原有的导入语句</span></span><br><span class="line">    path.replaceWithMultiple(imports)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>逻辑还算简单，<code>babel-plugin-import</code>可比这复杂得多。</p><p><br></p><p>接下来，我们将它封装成标准的 Babel 插件。 按照规范，我们需要创建一个<code>babel-plugin-*</code>前缀的包名：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mkdir babel-plugin-toy-<span class="keyword">import</span></span><br><span class="line">cd babel-plugin-toy-<span class="keyword">import</span></span><br><span class="line">yarn init -y</span><br><span class="line">touch index.js</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>你也可以通过 <a href="https://github.com/babel/generator-babel-plugin/tree/master/generators/app/templates" target="_blank" rel="noopener">generator-babel-plugin</a> 来生成项目模板.</p></blockquote><p><br></p><p>在 <code>index.js</code> 文件中填入我们的代码。<code>index.js</code>默认导出一个函数，函数结构如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个 babel-core 对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">types</span>: t&#125; = babel</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pre(state) &#123;</span><br><span class="line">      <span class="comment">// 前置操作，可选，可以用于准备一些资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      <span class="comment">// 我们的访问者代码将放在这里</span></span><br><span class="line">      ImportDeclaration(path, state) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    post(state) &#123;</span><br><span class="line">      <span class="comment">// 后置操作，可选</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>我们可以从访问器方法的第二个参数<code>state</code>中获取用户传入的参数</strong>。假设用户配置为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [[<span class="string">'toy-plugin'</span>, &#123;<span class="attr">name</span>: <span class="string">'foo'</span>&#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样获取用户传入的参数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">types</span>: t&#125; = babel</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      ImportDeclaration(path, state) &#123;</span><br><span class="line">        <span class="keyword">const</span> mod = state.opts &amp;&amp; state.opts.name</span><br><span class="line">        <span class="keyword">if</span> (mod == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打完收工 🙏，发布!</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn publish # good luck</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>新世界的大门已经打开: ⛩</p></blockquote><p>本文主要介绍了 Babel 的架构和原理，还实践了一下 Babel 插件开发，读到这里，你算是入了 Babel 的门了.</p><p>接下来你可以去熟读<a href="https://github.com/jamiebuilds/babel-handbook" target="_blank" rel="noopener">Babel手册</a>, 这是目前最好的教程,<br><a href="https://astexplorer.net/#/KJ8AjD6maa" target="_blank" rel="noopener">ASTExplorer</a>是最好的演练场，多写代码多思考。<br>你也可以去看<a href="https://github.com/babel/babel/tree/master/packages" target="_blank" rel="noopener">Babel的官方插件实现</a>, 迈向更高的台阶。</p><p>本文还有下篇，我将在下篇文章中介绍<a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener">babel-plugin-macros</a>, 敬请期待！</p><p>点赞是对我最好鼓励。</p><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://astexplorer.net/#/KJ8AjD6maa" target="_blank" rel="noopener">ASTExplorer</a></li><li><a href="https://github.com/jamiebuilds/babel-handbook" target="_blank" rel="noopener">babel-handbook</a></li><li><a href="https://github.com/babel/generator-babel-plugin" target="_blank" rel="noopener">generator-babel-plugin</a></li><li><a href="https://the-super-tiny-compiler.glitch.me" target="_blank" rel="noopener">the-super-tiny-compiler</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国庆放假了，我还在利用碎片时间在写文章，不知道长假还有没有人看，试试水吧！&lt;/p&gt;
&lt;p&gt;这个文章系列将带大家深入浅出 &lt;a href=&quot;https://babeljs.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Babel&lt;/code
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端团队 Leader，怎么用好看板进行任务管理</title>
    <link href="https://bobi.ink/2019/09/23/kanban/"/>
    <id>https://bobi.ink/2019/09/23/kanban/</id>
    <published>2019-09-22T16:00:00.000Z</published>
    <updated>2019-09-26T23:22:16.651Z</updated>
    
    <content type="html"><![CDATA[<p><code>看板</code>是一种非常常见的任务管理机制。我们使用到的大部分团队协作工具中都有看板的身影，例如 <a href="http://tower.im" target="_blank" rel="noopener"><code>Tower</code></a>、<a href="http://teambition.com" target="_blank" rel="noopener"><code>Teambition</code></a>、<code>Trello</code>、<code>Github</code>、<code>Gitlab</code>… </p><p>看板不仅可以用于团队协作，也可以用于对个人时间进行管理和优化。 <strong>可是你真的会用看板吗</strong>？</p><p><br></p><p><code>Wiki</code> 上面的解释是： <code>看板是丰田生产模式中的重要概念，指为了达到及时生产（JIT）方式控制现场生产流程的工具。及时生产方式中的拉式生产系统可以使信息的流程缩短，并配合定量、固定装货容器等方式，而使生产过程中的物料流动顺畅</code>.</p><p>从上面的定义中需要注意以下要点:</p><ul><li><strong>及时生产</strong> - 这是一种通过减少生产过程中的库存和相关的顺带成本，改善商业投资回报的管理战略。</li><li><strong>控制现场</strong> - 看板是一种<code>现场还原</code>和<code>现场控制</code>方法</li><li><strong>拉式生产系统</strong> - 传统的软件开发都是使用<code>推(Push)模式</code>，即规定某个任务由指定人在指定时间内完成。而拉式生产系统，更像生产者-消费者模式，看板就是一个信号等，当上游有已完成的任务，通知下游开始处理这些任务</li><li><strong>定量</strong> - 流程上的每个环节是有固定带宽的，这有助于暴露流程上的瓶颈</li></ul><p><br></p><p><a href="https://www.infoq.cn/article/kanban-development-method" target="_blank" rel="noopener">《解析精益产品开发（一）—— 看板开发方法》</a> 对看板总结得非常好, <strong>看板工具的实质是</strong>：后道工序在需要时，通过看板向前道工序发出信号——请给我需要数量的输入，前道工序只有得到看板后，才按需生产。看板信号由下游向上游传递，拉动上游的生产活动，使产品向下游流动。拉动的源头是最上游的客户价值，也就是客户订单或需求。</p><p>下面会循序渐进，介绍看板应用的几个阶段。如果你的团队还停留在第一个阶段，不妨试试继续深入实践。</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#第一阶-从既有的流程开始-流程可视化">第一阶： 从既有的流程开始， 流程可视化</a><ul><li><a href="#流程的抽象">流程的抽象</a></li><li><a href="#不断改进的流程">不断改进的流程</a></li><li><a href="#看板的范围">看板的范围</a></li><li><a href="#优先级划分">优先级划分</a></li><li><a href="#推模型push与拉模型pull">推模型(Push)与拉模型(Pull)</a></li><li><a href="#暴露瓶颈">暴露瓶颈</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#第二阶在制品限制">第二阶：在制品限制</a><ul><li><a href="#什么是在制品">什么是在制品</a></li><li><a href="#为什么限制在制品">为什么限制在制品?</a></li><li><a href="#wip要限制多少">WIP要限制多少?</a></li></ul></li><li><a href="#第三阶-结合scrum">第三阶: 结合Scrum</a><ul><li><a href="#简单介绍一下scrum">简单介绍一下Scrum</a></li><li><a href="#融合到看板中">融合到看板中</a><ul><li><a href="#设定开发周期">设定开发周期</a></li><li><a href="#每日回顾">每日回顾</a></li><li><a href="#流程监控">流程监控</a></li></ul></li></ul></li><li><a href="#看板一日游">看板一日游</a><ul><li><a href="#设计看板">设计看板</a></li><li><a href="#创建任务">创建任务</a></li><li><a href="#开始吧">开始吧</a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br></p><p><strong>系列文章</strong></p><ul><li><a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范? 🔥</a></li><li><a href="https://juejin.im/post/5d71cec6e51d4561b674c4d0" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么做好概要设计</a></li><li><a href="https://juejin.im/post/5d8d4557e51d4577fe41b62d" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么用好看板进行任务管理?</a></li></ul><p><br></p><h2 id="第一阶：-从既有的流程开始，-流程可视化"><a href="#第一阶：-从既有的流程开始，-流程可视化" class="headerlink" title="第一阶： 从既有的流程开始， 流程可视化"></a>第一阶： 从既有的流程开始， 流程可视化</h2><p><img src="/images/kanban/sample.png" alt></p><p><strong>将开发流程可视化是看板的最基本的用法</strong>. 上面是一个典型的看板实例，它直观地描述了一个<code>功能项</code>的<strong>生命周期</strong>以及该团队的<strong>开发流程</strong>。它给我们展示了这样一个流程:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">需求分析 -&gt; 产品设计 -&gt; 开发 -&gt; 测试 -&gt; 部署</span><br></pre></td></tr></table></figure><p><br></p><h3 id="流程的抽象"><a href="#流程的抽象" class="headerlink" title="流程的抽象"></a>流程的抽象</h3><p>每个人、每个团队工作流程都不一样。在设计看板之前我们需要梳理一下自己的工作流程.</p><p>比如’个人‘的流程就非常简单了，就只有一个动作：’做与不做’. 所以个人看板通常是这样的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">todo -&gt; doing -&gt; done</span><br></pre></td></tr></table></figure><p>你会发现，即使很简单的流程，<strong>流程的每个环节都会有三个子模块：<code>未做</code>/<code>正在做</code>/<code>已完成</code></strong>. 对于个人看板而言，划分这三个模块，主要是为了<strong>还原当前的现场</strong>。对于团队而言，这一点更为重要，你可以通过看板直观地跟踪任务开发的进度</p><p><br></p><p>我们团队目前的开发流程也很简单是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">设计 -&gt; 开发 -&gt; ...</span><br></pre></td></tr></table></figure><ul><li><strong>设计</strong>: 应用设计，可选，一般在开启一个项目或者重要的功能开发时会进行<a href="https://juejin.im/post/5d71cec6e51d4561b674c4d0" target="_blank" rel="noopener"><code>概要设计</code></a></li><li><strong>开发</strong>: 正常的开发流程</li></ul><p>当然这仅仅是前端团队的’局部‘流程，完整的软件开发流程如第一个看板实例所示。因为我们不是一个’敏捷‘团队，只要负责<code>前端开发</code>这个环节即可. 大局上看<code>需求分析</code>、<code>产品设计</code>、<code>测试</code>以及<code>部署</code>不在我们的控制范围之内。所以不应归纳到我们的开发流程中。</p><p><br></p><h3 id="不断改进的流程"><a href="#不断改进的流程" class="headerlink" title="不断改进的流程"></a>不断改进的流程</h3><p>流程不是一成不变的，它会随着实践的深入不断演化。举个例子，因为我们团队成员能力和经验不均匀，比如新手代码经常出 Bug，细节也没有做好。怎么解决？</p><p><strong>首先想一下能否在流程上做一下改进</strong>, 来减缓或杜绝这种情况，提高代码质量?</p><p>反复思考和讨论后，我们决定在 <code>开发</code> 环节之后添加了一个 <code>交叉测试/Review/用户体验测试</code> 环节。这个包含三层含义, <code>交叉测试</code>是指定其他人来测试、<code>Review</code>指的是代码层次的审查(白盒)，<code>用户体验测试</code>则是从用户角度触发进行验收测试(黑盒)。</p><p><br></p><p>下面是改进后的看板(<code>设计 -&gt; 开发 -&gt; 交叉测试</code>):</p><p><img src="/images/kanban/ourkanban.png" alt></p><p><br></p><h3 id="看板的范围"><a href="#看板的范围" class="headerlink" title="看板的范围"></a>看板的范围</h3><p><img src="/images/kanban/person.png" alt><br><i>颜值很高的个人看板</i></p><p><br></p><p>上面看到了’个人看板‘、’团队看板‘，以及’一个涵盖完整软件开发流程的看板‘。<strong>你会发现看板应用得非常广，可以应用于不同的层次，表示任务的粒度也不一样</strong>。</p><p>我们前端团队内部就有两个看板，一个是<code>周计划看板</code>，一个是<code>任务看板</code>。</p><p><code>周计划看板</code>任务粒度是’项目’或者’重大功能’，用于规划和跟踪每周的大概任务； 而<code>任务看板</code>则是各种细化的任务, 例如小的功能、Bug修复、细节优化. 粒度平均在1<code>人/天</code>以下，可以最大程度还原每个开发成员的开发现场。</p><p><br></p><p>在团队协作层面, 我们还有一个<code>研发看板</code>，这个和第一个看板例子相似，还原一个应用完整的研发流程，每个团队占用看板上面的一栏，展示和跟踪团队之间的信息流动:</p><p><img src="/images/kanban/team.png" alt><br><i>研发看板</i></p><p><br></p><h3 id="优先级划分"><a href="#优先级划分" class="headerlink" title="优先级划分"></a>优先级划分</h3><p>上面我们<code>团队看板</code>中，有几个比较特殊的栏: <code>计划</code>/<code>本周待办</code>/<code>缓冲区</code>。主要栏主要目的是为了给任务划分优先级，让团队专注于目前应该优先处理的任务。</p><p>看板中优先级可以通过两种方式来处理:</p><p><strong>1. 拆分看板</strong>:</p><p>例如优先级排序 <code>缓冲区</code> &gt; <code>本周待办</code> &gt; <code>计划</code></p><ul><li><strong>计划</strong> - 近期需要进行的任务，有些任务优先级很低，可能一年半载都不会处理。这一栏有点像备忘录</li><li><strong>周计划</strong> - 从计划栏中筛选部分任务，作为本周的’开发目标‘。表示本周计划要完成的事情</li><li><strong>缓冲区</strong> - 从周计划中筛选优先级最高的任务，需要优先被处理</li><li><strong>已完成(周结束时间)</strong> 放置每周已完成的任务, 这个和周计划相对应，可以反馈’周计划‘完成的进度。</li></ul><p>我们通常会每周’归档‘一次<code>已完成</code>栏。如果使用<code>Tower</code>，可以通过’查看归档‘，获取所有的以周为单位的历史记录</p><p><img src="/images/kanban/arch.png" alt></p><p><br></p><p><strong>2. 设置任务优先级</strong></p><p>在任务层级也可以设定特殊的标签，来标记任务的优先级。另外也可以将高优先级任务排在队列前面, 表示任务的优先级</p><p>下图使用 <code>Tower</code> 可以为任务设置优先级，它会使用不同的颜色来标注它:</p><p><img src="/images/kanban/create-task.png" alt></p><p><br></p><h3 id="推模型-push-与拉模型-pull"><a href="#推模型-push-与拉模型-pull" class="headerlink" title="推模型(Push)与拉模型(Pull)"></a>推模型(Push)与拉模型(Pull)</h3><p>还是<a href="https://coolshell.cn" target="_blank" rel="noopener">左耳朵耗子</a>, 他在某期节目提到的’x 型人才和y 型人才论‘，让我印象深刻, 他指出人才可以分为两种:</p><ul><li>x 型人才: 给任务就做，不给任务就不知道做什么</li><li>y 型人才: 自驱动、拥有自主性和主动性，对企业有归宿感。这种人适合做管理者</li></ul><p>大部分人都是x型人才，所以企业需要花高一点的薪酬雇佣y型人才来管理和驱动x型人才。 但我认为这不是天生的，在后天给予一定的责任和鼓励，或者在某些管理机制下，我们也可以成为 y 型人才，甚至成为 y 型团队。很多敏捷理论就推崇’团队自治‘、希望团队以及成员可以<strong>自我驱动</strong>，推动业务的发展。<code>拉模式</code>也能体现这种思想.</p><p>传统团队都使用推模式，由Leader将任务分配给团队成员, 指定完成的时间和各种指标。这种方式也称为<code>推动系统(Push System)</code>,  它一般依赖于时间的排定，时间到了就被’被动地‘推动去做某些事情.</p><p>而看板非常适合拉模式。所以看板也被称为<code>信号板(Signal)</code>, 你可以将任务当做一个’事件‘，由事件来驱动工作(类似生产者-消费者模式)。这还是有点像工厂的流水线，上游的产出就是一种’事件‘，下游主动去拉取上游的物件进行处理.</p><p>这种模式的好处是，Leader不需要再去关心细微的工作分配和决策，让团队成员自己有效地安排事件。另外这也可以避免出现这样一种情况：团队成员只熟悉其中某些项目，或者只会做、只负责一类事情。这使得成员离岗时，团队会变得比较被动，因为其他成员对离岗成员的工作情况不熟悉。因此拉动模式，也可以让团队成员离开自己的舒适区，参与和熟悉各种项目</p><p>我们目前使用的是<strong>混合型</strong>, 有些任务是提前指派合适的人去做的，而如果看板中没有指定负责人，这个任务就可以由任何人来负责，推拉结合。</p><p><br></p><h3 id="暴露瓶颈"><a href="#暴露瓶颈" class="headerlink" title="暴露瓶颈"></a>暴露瓶颈</h3><p>流程上的多个环节会像管道(pipe)一样，通过输入输出连接在一起:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tasks -&gt; (流程1) -&gt; (流程2) -&gt; Done</span><br></pre></td></tr></table></figure><p>上一个流程的输出(Done)，就是下一个流程的输入(Todo). 按照理想的状态，信息流应该是流畅、平稳地在管道上流淌的。如果某个环节出现瓶颈，那么可能会导致忙的忙死，闲的闲死。</p><p>如果你有细心思考，看板的流程管理方式有点像’工厂的流水线作业‘，如果某个环节阻塞，这个环节就会堆积很多元件，而下游则会出现空闲等待情况, 而该环节的上游也会被阻塞。</p><p><br></p><p><strong>通过看板的现场还原，我们可以容易地发现这种流程上的瓶颈. 怎么解决这个问题</strong>？</p><p>这个可以类比程序，当我们发现程序上的一个性能问题时，通常有两个解决的方向:</p><ul><li>是否是算法问题? 能否使用更好的算法或者解决方案？对应到开发任务中，要考虑一下是否实现的方法不对？</li><li>如果是硬件的瓶颈，能否扩展硬件资源，升级好点的硬件？对应到开发任务中，要考虑一下是否要多加些人手？</li></ul><p>下一节会介绍，我会介绍通过设置<code>在制品</code>数量(带宽)，让看板更容易地暴露瓶颈.</p><p><br></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过看板我们可以得到这些好处:</p><ul><li><strong>流程可视化</strong>: 通过看板可以看到任务会经过哪些环节，当前在哪个环节</li><li><strong>还原开发现场</strong>:<ul><li>直观地跟踪开发的进度</li><li>暴露流程瓶颈</li><li>贡献看得见</li></ul></li><li><strong>拉模式</strong>: 自我驱动</li></ul><p><br><br><br></p><h2 id="第二阶：在制品限制"><a href="#第二阶：在制品限制" class="headerlink" title="第二阶：在制品限制"></a>第二阶：在制品限制</h2><p>大部分团队对看板的应用只停留在第一阶，即流程可视化。看板的魅力远不止于此。第二个阶段，我们要开始限制在制品的数量。</p><p><br></p><h3 id="什么是在制品"><a href="#什么是在制品" class="headerlink" title="什么是在制品"></a>什么是在制品</h3><p>在制品(Work-In-Process WIP), 也称为半成品。顾名思义就是部分未完成的任务。</p><p><img src="/images/kanban/wip.jpg" alt></p><p>在看板中, 一些栏会有在制品限制，用于<strong>限制该环节’同时‘可以处理的事情</strong>。换句话说就是限制某个环节的’流量带宽‘，或者说节流.</p><p><br></p><h3 id="为什么限制在制品"><a href="#为什么限制在制品" class="headerlink" title="为什么限制在制品?"></a>为什么限制在制品?</h3><p><strong>1. 更快暴露瓶颈</strong></p><p>尽管在’第一阶’时，我们也可以识别出流程的瓶颈，但并不是特别直观，至少从看板上较难察觉。你可能要详细跟踪询问，才能了解哪个流程卡住了。</p><p>限制了WIP后，每个环节的带宽是固定的，比如’测试‘环节的WIP限制是6，如果’测试‘环节到达限制，上游就没办法给它塞其他任务了。这就暴露了’测试’环节的瓶颈</p><p><strong>怎么设定WIP的限制额也是比较重要的，设置太小，会导致并发处理的任务量变小，资源可能得不到利用，太大又不容易暴露瓶颈</strong>。下节会介绍如何设置WIP.</p><p><br></p><p><strong>2. 避免中断，避免上下文切换</strong></p><p>限制WIP的另一个好处，是减少成员并发处理多个任务的数量。</p><p>和计算机的进程一样，进程的上下文切换代价是比较大的。对于开发者来说，任务中断、任务调换也会浪费切换的时间，因为我们需要调整/回顾思路来投入新的任务流程。</p><p>所以说通过限制WIP，可以让成员专注于正在处理的任务，做完这个任务再去拉取新的任务。</p><p><br></p><p><strong>3. 盈余时间</strong></p><p>当下游出现阻塞，上游或下游可能就会出现<code>盈余时间</code>。这些盈余时间看起来像浪费，其实对于开发者或团队来说，可以做很多事情。比如:</p><ul><li><strong>休息/学习</strong>:<br>可以利用这段时间来学习。对于前端来说，必须不断的学习，提高自己的水平和竞争力，这对项目开发也是有益处的. 在996这种环境下，企业家逐渐剥夺了我们生产生产力的能力。</li><li><strong>帮助解决瓶颈</strong>:<br>下游出现瓶颈了，我们可以停下来，帮助他们解决问题。例如其他同事因为某些问题卡住，我们可以帮助他一起解决问题；再比如下游测试环节出问题了，我们可以一起进行测试。作为一个团队齐步向前，变相提高团队凝聚力和责任心</li><li><strong>优化</strong>:<br>反思流程问题，考虑如果提高产能</li><li><strong>其他事情</strong>:<br>比如可以进行交叉测试和写文档，优化开发工具</li></ul><p><br></p><h3 id="wip要限制多少"><a href="#wip要限制多少" class="headerlink" title="WIP要限制多少?"></a>WIP要限制多少?</h3><p>在制品限制值不是具体可计算的，需要长期经验积累和磨合才能定下一个合适的值. 值越小，成员可以更专注于当前的事情，增强成员之间的协作。值越大，可以处理的事情更多，任务调度会更为灵活。</p><p>一个基于经验的、折中的公式是： <code>在制品上限 = 团队规模 * 2 -1</code>。</p><p><br><br><br></p><h2 id="第三阶-结合scrum"><a href="#第三阶-结合scrum" class="headerlink" title="第三阶: 结合Scrum"></a>第三阶: 结合Scrum</h2><p><a href="https://zh.wikipedia.org/zh-hans/Scrum" target="_blank" rel="noopener"><code>Scrum</code></a> 也是一个敏捷框架. 它的规则非常简单，但是要精通非常难。所以第三阶段，我们可以尝试将 <code>Scrum</code> 的某些规则融合到看板的管理流程中</p><p><br></p><h3 id="简单介绍一下scrum"><a href="#简单介绍一下scrum" class="headerlink" title="简单介绍一下Scrum"></a>简单介绍一下Scrum</h3><p><img src="/images/kanban/scrum.png" alt></p><p>上图一个典型的 <code>Scrum</code> 流程.</p><p>简而言之，<code>Scrum</code> 首先会将应用开发过程拆分为多个迭代周期，这个迭代周期称为 <code>Sprint</code> (一个冲刺)，周期一般为1-4周。</p><p><br></p><p><img src="/images/kanban/backlog.png" alt></p><p>在每次开始一个冲刺时，会从<code>功能列表</code>(Product Backlog)中，按照优先级和时间评估筛选出这个冲刺可以完成的任务列表，称为<code>冲刺列表</code>(Sprint Backlog); 接着就在这个迭代周期里专心完成这些任务</p><p>另外 <code>Scrum</code> 还定义了各种<code>活动</code>, 来进行持续的反馈和调整， 例如:</p><ul><li><strong>Sprint计划会议</strong> - 在开始一个冲刺前，计划一个周期内需要做哪些任务，对任务进行时间评估</li><li><strong>每日立会</strong> - 同步开发进度、发现开发中的障碍、增加交流和沟通</li><li><strong>评审会议</strong> - 在冲刺结束时举行，用于检查计划中的工作，哪些完成了，哪些没有完成。有些团队会让功能的负责人演示自己所做的功能，然后 PM 会看这个功能是否达到了要求</li><li><strong>回顾会议</strong> - 在冲刺结束时举行，回顾和反省本次迭代遇到的问题、以及如何改进</li></ul><p>另外，<code>Scrum</code>还定义了各种角色和价值观。这些不在本文的范围之内，我们也不会全部照搬. 有兴趣的读者可以查看参考文献</p><p><br></p><h3 id="融合到看板中"><a href="#融合到看板中" class="headerlink" title="融合到看板中"></a>融合到看板中</h3><h4 id="设定开发周期"><a href="#设定开发周期" class="headerlink" title="设定开发周期"></a>设定开发周期</h4><p>瀑布式和敏捷的明显区别就是开发流程分割成多个迭代过程。按<code>Scrum</code>的定义就是一个’冲刺‘.</p><p>在我们实际的开发中，会以一个星期作为一个开发周期。我觉的一周的时间刚刚好，时间太长很难对任务时间进行评估，而且未知因素也会更多.</p><p><img src="/images/kanban/sprint.png" alt></p><p>在一个星期开始前，从’计划‘栏中筛选本周要进行任务，拖进’本周待办’栏。这个过程就有点像 <code>Scrum</code> 的<code>计划会议</code></p><p><br></p><h4 id="每日回顾"><a href="#每日回顾" class="headerlink" title="每日回顾"></a>每日回顾</h4><p>笔者每天开始工作时，就会将团队成员聚集在一起，对着看板简单询问任务开发的进度，回顾昨日的工作，看是否出现障碍。如果有障碍则及时处理障碍，如果任务超出预期，则考虑是否应该重新调整计划。</p><p>总之就是尽早暴露问题，保证流程的顺畅。在这里<strong>看板就是一种重要的沟通工具</strong>。每日询问的时间都很短，一般都不超过10分钟，这个过程有点像 <code>Scrum</code> 的每日立会</p><p>在<code>Tower</code>中，完成任务后我们不会直接将卡片拖入已完成列表，而是在最后一个环节点击’已完成‘，这样方便次日对已完成的任务进行回顾，回顾完成后再统一拖入’已完成‘栏</p><p><br></p><h4 id="流程监控"><a href="#流程监控" class="headerlink" title="流程监控"></a>流程监控</h4><p><strong>燃尽图</strong></p><p>燃尽图是常见的Scrum进度跟踪工具。它的外形如下:</p><p><img src="/images/kanban/burndown.png" alt></p><p>横轴为开发周期，纵轴为任务量. 理想状态下，任务量在周期结束时应该变为0，也就是说理想的线段是一条对角线(蓝线), 这也是一条参考线。如果在某个指定时间点，红线高于蓝线，则说明进度有些延迟，反之就是超前</p><p>使用燃尽图，我们一般会通常会在每日回顾时在燃尽图上绘制一个点，表示截止到此刻未完成的任务量</p><p><br></p><p><strong>累计流量图</strong></p><p>累计流量图统计每一天每一栏的在制品数量。从而可以反映不同环节任务处理速率，以及暴露环节之间的瓶颈:</p><p><img src="/images/kanban/cumulative-flow.png" alt></p><p><br><br><br></p><h2 id="看板一日游"><a href="#看板一日游" class="headerlink" title="看板一日游"></a>看板一日游</h2><p>下面模仿经典的文章<a href="https://blog.crisp.se/2009/06/26/henrikkniberg/1246053060000" target="_blank" rel="noopener">《看板一日游》</a> 实践一下本文讲述的看板使用流程。我们使用的工具是 <code>Tower</code>，这个也是我们团队目前在使用的，功能基本够用。</p><p><br></p><h3 id="设计看板"><a href="#设计看板" class="headerlink" title="设计看板"></a>设计看板</h3><p>假设我们的前端团队有3个人，开发流程是这样的: <code>开发 -&gt; 交叉测试 -&gt; 部署</code>。按照上面学到的知识，我们设计了这样的看板布局:</p><p><img src="/images/kanban/oneday1-1.png" alt></p><p><br></p><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>现在点开Tower任务创建窗口. <code>Tower</code> 的任务功能已经非常丰富了。为了更方面其他人处理任务，我们对任务进行了一些规范</p><p><img src="/images/kanban/oneday2.png" alt></p><p><br></p><ul><li>① 标题: <code>以 [scope] 概述 (时间评估)</code>. <ul><li><code>scope</code> 是指任务的范围，例如项目A，项目B</li><li><code>时间评估</code> 要求对耗时较久的任务进行评估。我们一般推荐任务的粒度在3h 到 2d之间，小于3h考虑将任务进行合并，大于2d则考虑继续拆分任务</li></ul></li><li>② 指派负责人: 可选，不指派则说明采用拉模式</li><li>③ 任务的Deadline</li><li>④ 设置任务优先级</li><li>⑤ 详细说明</li><li>⑥ 细化任务</li><li>⑦ 依赖任务</li><li>⑧ 任务标签: 可以指定任务的类型，例如功能、Bug、优化、重构</li></ul><p><br></p><h3 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h3><p><strong>首选计划一下这周需要这些什么</strong>:</p><p><img src="/images/kanban/oneday3.png" alt></p><p><br></p><p><strong>开始工作，按照优先级排序 ，放入缓冲区:</strong></p><p><img src="/images/kanban/oneday4.png" alt></p><p><br></p><p><strong>认领自己的任务</strong></p><p><img src="/images/kanban/oneday5-1.png" alt></p><p><br></p><p><strong>ok，完成了，放入下一个栏</strong></p><p><img src="/images/kanban/oneday6-1.png" alt></p><p><br></p><p><img src="/images/kanban/oneday7-1.png" alt></p><p><br></p><p><strong>下游达到在制品限制了，不行, 得清一下，停下手动的工作，做一下交叉测试吧</strong></p><p><img src="/images/kanban/oneday8-1.png" alt></p><p><br></p><p><img src="/images/kanban/oneday9-1.png" alt></p><p><br></p><p><img src="/images/kanban/oneday10-1.png" alt></p><p><strong>次日问询回顾，任务完成的还不错，有遇到什么问题吗？完成回顾后将任务正式拖入已完成</strong></p><p><img src="/images/kanban/oneday11-1.png" alt></p><p><br></p><p>😫好累，不写总结了，就这样吧，</p><p>本文完！</p><p><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://www.zhihu.com/question/30270633" target="_blank" rel="noopener">求推荐在线看板工具软件？</a> 电子看板推荐</li><li><a href="https://github.com" target="_blank" rel="noopener">看板系统实施细则</a></li><li><a href="https://book.douban.com/subject/26764497/" target="_blank" rel="noopener">《精益开发与看板方法》</a></li><li><a href="https://www.infoq.cn/article/kanban-development-method" target="_blank" rel="noopener">解析精益产品开发（一）—— 看板开发方法</a></li><li><a href="https://www.jianshu.com/p/e44b1038c9cf" target="_blank" rel="noopener">Scrum vs. 看板，还是Scrum + 看板？</a></li><li><a href="https://ruddyblog.wordpress.com/tag/看板一日遊/" target="_blank" rel="noopener">one day in kanban land 中文版</a></li></ul><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;看板&lt;/code&gt;是一种非常常见的任务管理机制。我们使用到的大部分团队协作工具中都有看板的身影，例如 &lt;a href=&quot;http://tower.im&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Tower&lt;/code&gt;&lt;/a&gt;、
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>自己写个React渲染器: 以 Remax 为例(用React写小程序)</title>
    <link href="https://bobi.ink/2019/09/15/remax/"/>
    <id>https://bobi.ink/2019/09/15/remax/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-20T05:34:23.384Z</updated>
    
    <content type="html"><![CDATA[<p>上个月蚂蚁金服前端发布了一个新的框架 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a>, 口号是<strong>使用真正的、完整的 React 来开发小程序</strong>.</p><p>对于原本的 React 开发者来说 ‘Learn once, write anywhere’ , 和 ReactNative 开发体验差不多，<strong>而对于小程序来说则是全新的开发体验</strong>。</p><p><a href="https://github.com/NervJS/taro" target="_blank" rel="noopener"><code>Taro</code></a>号称是‘类React’的开发方案，但是它是使用静态编译的方式实现，<a href="https://www.zhihu.com/people/meck" target="_blank" rel="noopener">边柳</a> 在它的 <a href="https://zhuanlan.zhihu.com/p/79788488" target="_blank" rel="noopener">《Remax - 使用真正的 React 构建小程序》</a>文章中也提到了这一点:</p><p><code>所谓静态编译，就是使用工具把代码语法分析一遍，把其中的 JSX 部分和逻辑部分抽取出来，分别生成小程序的模板和 Page 定义。</code></p><p>这种方案实现起来比较复杂，且运行时并没有 React 存在。</p><p><br></p><p>相比而言，<a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 的解决方案就简单很多，<strong>它不过就是新的React渲染器</strong>.</p><p><img src="/images/remax/01.png" alt></p><p><br></p><blockquote><p>因为 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 刚发布不久，核心代码比较简单，感兴趣的可以去 <a href="https://github.com/remaxjs/remax" target="_blank" rel="noopener">github</a> 观摩贡献 <br><br>可以通过 CodeSandbox 游乐场试玩自定义Renderer: <a href="https://codesandbox.io/s/react-custom-renderer-mm9kl?fontsize=14" target="_blank" rel="noopener">Edit react-custom-renderer</a> <br><br>文章看起来比较长，好戏在后头，一步一步来 🦖</p></blockquote><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#关于react的一些基本概念">关于React的一些基本概念</a></li><li><a href="#自定义react渲染器">自定义React渲染器</a></li><li><a href="#hostconfig-渲染器适配">HostConfig 渲染器适配</a></li><li><a href="#宿主组件">宿主组件</a></li><li><a href="#镜像树的构建和操作">镜像树的构建和操作</a></li><li><a href="#节点更新">节点更新</a></li><li><a href="#副作用提交">副作用提交</a></li><li><a href="#hostconfig执行流程总结">HostConfig执行流程总结</a></li><li><a href="#同步到渲染进程">同步到渲染进程</a></li><li><a href="#总结">总结</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br></p><h2 id="关于react的一些基本概念"><a href="#关于react的一些基本概念" class="headerlink" title="关于React的一些基本概念"></a>关于React的一些基本概念</h2><p>创建一个 React 自定义渲染器，你需要对React渲染的基本原理有一定的了解。所以在深入阅读本文之前，先要确保你能够理解以下几个基本概念:</p><p><strong>1. Element</strong></p><p>我们可以通过 <code>JSX</code> 或者 <code>React.createElement</code> 来创建 Element，用来描述我们要创建的视图节点。比如:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'button button-blue'</span>&gt;</span><br><span class="line">  &lt;b&gt;</span><br><span class="line">    OK!</span><br><span class="line">  &lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure><p><code>JSX</code> 会被转义译为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">"button"</span>,</span><br><span class="line">  &#123; <span class="attr">class</span>: <span class="string">'button button-blue'</span> &#125;,</span><br><span class="line">  React.createElement(<span class="string">"b"</span>, <span class="literal">null</span>, <span class="string">"OK!"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>React.createElement</code> 最终构建出类似这样的对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'button'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'button button-blue'</span>,</span><br><span class="line">    children: &#123;</span><br><span class="line">      type: <span class="string">'b'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        children: <span class="string">'OK!'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 <strong>Element 就是一个普通的对象，描述用户创建的节点类型、props 以及 children</strong>。这些 Elements 组合成树，描述用户视图</p><p><br></p><p><strong>2. Component</strong></p><p>可以认为是 Element 的类型，它有两种类型：</p><ul><li><p><strong>Host Component</strong>: 宿主组件，这是由渲染的平台提供的‘内置’组件，例如<code>ReactDOM</code> 平台下面的 <code>DOM</code> 节点，如 <code>div</code>、<code>span</code>… 这些组件类型为字符串</p></li><li><p><strong>Composite Component</strong>: 复合组件，这是一种用户自定义的组件封装单位。通常包含自定义的逻辑、状态以及输出 Element 树。复合类型可以为类或函数</p></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DeleteAccount = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Are you sure?<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;DangerButton&gt;Yep&lt;<span class="regexp">/DangerButton&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Button color='blue'&gt;Cancel&lt;/</span>Button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>3. Instance</strong></p><p>当 React 开始渲染一个 Element 时，会根据组件类型为它创建一个‘实例’，例如类组件，会调用<code>new</code>操作符实例化。这个实例会一直引用，直到 Element 从 Element Tree 中被移除。</p><p><code>首次渲染</code>: React 会实例化一个 <code>MyButton</code> 实例，调用挂载相关的生命周期方法，并执行 <code>render</code> 方法，递归渲染下级</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">MyButton</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">MyButton</span>&gt;</span></span>, container)</span><br></pre></td></tr></table></figure><p><br></p><p><code>更新</code>: 因为组件类型没有变化，React 不会再实例化，这个属于‘节点更新’，React 会执行更新相关的生命周期方法，如<code>shouldComponentUpdate</code>。如果需要更新则再次执行<code>render</code>方法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">MyButton</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">MyButton</span>&gt;</span></span>, container)</span><br></pre></td></tr></table></figure><p><br></p><p><code>卸载</code>: 组件类型不一样了, 原有的 MyButton 被替换. MyButton 的实例将要被销毁，React 会执行卸载相关的生命周期方法，如<code>componentWillUnmount</code></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>, container)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>4. Reconciler</strong> &amp; <strong>Renderer</strong></p><p><code>Reconciler</code> 和 <code>Renderer</code> 的关系可以通过下图缕清楚.</p><p><strong>Reconciler 的职责是维护 VirtualDOM 树，内部实现了 Diff/Fiber 算法，决定什么时候更新、以及要更新什么</strong></p><p>而 <strong>Renderer 负责具体平台的渲染工作，它会提供宿主组件、处理事件等等</strong>。例如ReactDOM就是一个渲染器，负责DOM节点的渲染和DOM事件处理。</p><p><br></p><p><img src="/images/remax/02.png" alt></p><p><br></p><p><strong>5. Fiber 的两个阶段</strong><br>React 使用了 Fiber 架构之后，更新过程被分为两个阶段(Phase)</p><ul><li><strong>协调阶段(Reconciliation Phase)</strong> 这个阶段 React 会找出需要更新的节点。这个阶段是可以被打断的，比如有优先级更高的事件要处理时。</li><li><strong>提交阶段(Commit Phase)</strong> 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)</strong>一次性执行了。这个阶段必须同步执行，不能被打断</li></ul><p><br></p><p>如果按照<code>render</code>为界，可以将生命周期函数按照两个阶段进行划分：</p><ul><li><strong>协调阶段</strong><ul><li><code>constructor</code></li><li><code>componentWillMount</code> 废弃</li><li><code>componentWillReceiveProps</code> 废弃</li><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code> 废弃</li><li><code>render</code></li><li><code>getSnapshotBeforeUpdate()</code></li></ul></li><li><strong>提交阶段</strong><ul><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul></li></ul><p><br></p><blockquote><p>没理解？那么下文读起来对你可能比较吃力，建议阅读一些关于React基本原理的相关文章。</p></blockquote><p><br></p><p>就目前而言，React 大部分核心的工作已经在 Reconciler 中完成，好在 React 的架构和模块划分还比较清晰，React官方也暴露了一些库，这极大简化了我们开发 Renderer 的难度。开始吧！</p><p><br></p><h2 id="自定义react渲染器"><a href="#自定义react渲染器" class="headerlink" title="自定义React渲染器"></a>自定义React渲染器</h2><p>React官方暴露了一些库供开发者来扩展自定义渲染器：</p><ul><li><a href="https://github.com/facebook/react/tree/master/packages/react-reconciler" target="_blank" rel="noopener">react-reconciler</a> - 这就是 React 的协调器, React 的核心所在。我们主要通过它来开发渲染器。</li><li><a href="https://github.com/facebook/react/tree/master/packages/scheduler" target="_blank" rel="noopener">scheduler</a> - 合作调度器的一些 API 。本文不会用到</li></ul><blockquote><p>需要注意的是，<strong>这些包还是实验性的</strong>，API可能不太稳定。另外，没有详细的文档，你需要查看源代码或者其他渲染器实现；本文以及扩展阅读中的文章也是很好的学习资料。</p></blockquote><p><br></p><p>创建一个自定义渲染器只需两步:</p><p><img src="/images/remax/04.png" alt></p><p>第一步: <strong>实现宿主配置</strong>，这是<code>react-reconciler</code>要求宿主提供的一些适配器方法和配置项。这些配置项定义了如何创建节点实例、构建节点树、提交和更新等操作。下文会详细介绍这些配置项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Reconciler = <span class="built_in">require</span>(<span class="string">'react-reconciler'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">// ... 实现适配器方法和配置项</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>第二步：<strong>实现渲染函数</strong>，类似于<a href="https://reactjs.org/docs/react-dom.html#render" target="_blank" rel="noopener"><code>ReactDOM.render()</code></a> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Reconciler实例, 并将HostConfig传递给Reconciler</span></span><br><span class="line"><span class="keyword">const</span> MyRenderer = Reconciler(HostConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设和ReactDOM一样，接收三个参数</span></span><br><span class="line"><span class="comment"> * render(&lt;MyComponent /&gt;, container, () =&gt; console.log('rendered'))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建根容器</span></span><br><span class="line">  <span class="keyword">if</span> (!container._rootContainer) &#123;</span><br><span class="line">    container._rootContainer = ReactReconcilerInst.createContainer(container, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新根容器</span></span><br><span class="line">  <span class="keyword">return</span> ReactReconcilerInst.updateContainer(element, container._rootContainer, <span class="literal">null</span>, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器既是 React 组件树挂载的<code>目标</code>(例如 ReactDOM 我们通常会挂载到 <code>#root</code> 元素，<code>#root</code> 就是一个容器)、也是组件树的 <code>根Fiber节点(FiberRoot)</code>。根节点是整个组件树的入口，它将会被 Reconciler 用来保存一些信息，以及管理所有节点的更新和渲染。</p><p>关于 Fiber 架构的一些细节可以看这些文章:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">《译 深入React fiber架构及源码》</a></li><li><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">《React Fiber》</a> 有能力的同学，可以直接看<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark</a>的演讲</li></ul><p><br></p><h2 id="hostconfig-渲染器适配"><a href="#hostconfig-渲染器适配" class="headerlink" title="HostConfig 渲染器适配"></a>HostConfig 渲染器适配</h2><p><code>HostConfig</code> 支持非常多的参数，完整列表可以看<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/forks/ReactFiberHostConfig.custom.js" target="_blank" rel="noopener">这里</a>. 下面是一些自定义渲染器<strong>必须</strong>提供的参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface HostConfig &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于分享一些上下文信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 获取根容器的上下文信息, 只在根节点调用一次</span></span><br><span class="line">  getRootHostContext(rootContainerInstance: Container): HostContext;</span><br><span class="line">  <span class="comment">// 获取子节点的上下文信息, 每遍历一个节点都会调用一次</span></span><br><span class="line">  getChildHostContext(parentHostContext: HostContext, <span class="attr">type</span>: Type, <span class="attr">rootContainerInstance</span>: Container): HostContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点实例的创建</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 普通节点实例创建，例如DOM的Element类型</span></span><br><span class="line">  createInstance(type: Type, <span class="attr">props</span>: Props, <span class="attr">rootContainerInstance</span>: Container, <span class="attr">hostContext</span>: HostContext, <span class="attr">internalInstanceHandle</span>: OpaqueHandle,): Instance;</span><br><span class="line">  <span class="comment">// 文本节点的创建，例如DOM的Text类型</span></span><br><span class="line">  createTextInstance(text: string, <span class="attr">rootContainerInstance</span>: Container, <span class="attr">hostContext</span>: HostContext, <span class="attr">internalInstanceHandle</span>: OpaqueHandle): TextInstance;</span><br><span class="line">  <span class="comment">// 决定是否要处理子节点/子文本节点. 如果不想创建则返回true. 例如ReactDOM中使用dangerouslySetInnerHTML, 这时候子节点会被忽略</span></span><br><span class="line">  shouldSetTextContent(type: Type, <span class="attr">props</span>: Props): boolean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点树构建</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 如果节点在*未挂载*状态下，会调用这个来添加子节点</span></span><br><span class="line">  appendInitialChild(parentInstance: Instance, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// **下面都是副作用(Effect)，在’提交‘阶段被执行**</span></span><br><span class="line">  <span class="comment">// 添加子节点</span></span><br><span class="line">  appendChild?(parentInstance: Instance, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 添加子节点到容器节点(根节点)</span></span><br><span class="line">  appendChildToContainer?(container: Container, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 插入子节点</span></span><br><span class="line">  insertBefore?(parentInstance: Instance, <span class="attr">child</span>: Instance | TextInstance, <span class="attr">beforeChild</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 插入子节点到容器节点(根节点)</span></span><br><span class="line">  insertInContainerBefore?(container: Container, <span class="attr">child</span>: Instance | TextInstance, <span class="attr">beforeChild</span>: Instance | TextInstance,): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 删除子节点</span></span><br><span class="line">  removeChild?(parentInstance: Instance, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 从容器节点(根节点)中移除子节点</span></span><br><span class="line">  removeChildFromContainer?(container: Container, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点挂载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 在完成所有子节点初始化时(所有子节点都appendInitialChild完毕)时被调用, 如果返回true，则commitMount将会被触发</span></span><br><span class="line">  <span class="comment">// ReactDOM通过这个属性和commitMount配置实现表单元素的autofocus功能</span></span><br><span class="line">  finalizeInitialChildren(parentInstance: Instance, <span class="attr">type</span>: Type, <span class="attr">props</span>: Props, <span class="attr">rootContainerInstance</span>: Container, <span class="attr">hostContext</span>: HostContext): boolean;</span><br><span class="line">  <span class="comment">// 和finalizeInitialChildren配合使用，commitRoot会在’提交‘完成后(resetAfterCommit)执行, 也就是说组件树渲染完毕后执行</span></span><br><span class="line">  commitMount?(instance: Instance, <span class="attr">type</span>: Type, <span class="attr">newProps</span>: Props, <span class="attr">internalInstanceHandle</span>: OpaqueHandle): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点更新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 准备节点更新. 如果返回空则表示不更新，这时候commitUpdate则不会被调用</span></span><br><span class="line">  prepareUpdate(instance: Instance, <span class="attr">type</span>: Type, <span class="attr">oldProps</span>: Props, <span class="attr">newProps</span>: Props, <span class="attr">rootContainerInstance</span>: Container, <span class="attr">hostContext</span>: HostContext,): <span class="literal">null</span> | UpdatePayload;</span><br><span class="line">  <span class="comment">// **下面都是副作用(Effect)，在’提交‘阶段被执行**</span></span><br><span class="line">  <span class="comment">// 文本节点提交</span></span><br><span class="line">  commitTextUpdate?(textInstance: TextInstance, <span class="attr">oldText</span>: string, <span class="attr">newText</span>: string): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 普通节点提交</span></span><br><span class="line">  commitUpdate?(instance: Instance, <span class="attr">updatePayload</span>: UpdatePayload, <span class="attr">type</span>: Type, <span class="attr">oldProps</span>: Props, <span class="attr">newProps</span>: Props, <span class="attr">internalInstanceHandle</span>: OpaqueHandle): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 重置普通节点文本内容, 这个需要和shouldSetTextContent(返回true时)配合使用，</span></span><br><span class="line">  resetTextContent?(instance: Instance): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 提交</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 开始’提交‘之前被调用，比如这里可以保存一些状态，在’提交‘完成后恢复状态。比如ReactDOM会保存当前元素的焦点状态，在提交后恢复</span></span><br><span class="line">  <span class="comment">// 执行完prepareForCommit，就会开始执行Effects(节点更新)</span></span><br><span class="line">  prepareForCommit(containerInfo: Container): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 和prepareForCommit对应，在提交完成后被执行</span></span><br><span class="line">  resetAfterCommit(containerInfo: Container): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 调度</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 这个函数将被Reconciler用来计算当前时间, 比如计算任务剩余时间 </span></span><br><span class="line">  <span class="comment">// ReactDOM中会优先使用Performance.now, 普通场景用Date.now即可</span></span><br><span class="line">  now(): number;</span><br><span class="line">  <span class="comment">// 自定义计时器</span></span><br><span class="line">  setTimeout(handler: <span class="function">(<span class="params">...args: any[]</span>) =&gt;</span> <span class="keyword">void</span>, <span class="attr">timeout</span>: number): TimeoutHandle | NoTimeout;</span><br><span class="line">  <span class="comment">// 取消计时器</span></span><br><span class="line">  clearTimeout(handle: TimeoutHandle | NoTimeout): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 表示一个空的计时器，见👆clearTimeout的签名</span></span><br><span class="line">  noTimeout: NoTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ? 功能未知</span></span><br><span class="line">  shouldDeprioritizeSubtree(type: Type, <span class="attr">props</span>: Props): boolean;</span><br><span class="line">  <span class="comment">// 废弃</span></span><br><span class="line">  scheduleDeferredCallback(callback: <span class="function"><span class="params">()</span> =&gt;</span> any, options?: &#123; <span class="attr">timeout</span>: number &#125;): any;</span><br><span class="line">  <span class="comment">// 废弃</span></span><br><span class="line">  cancelDeferredCallback(callbackID: any): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 功能开启</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 开启节点修改，一般渲染器都会开启，不然无法更新节点</span></span><br><span class="line">  supportsMutation: boolean;</span><br><span class="line">  <span class="comment">// 开启持久化 ?</span></span><br><span class="line">  supportsPersistence: boolean;</span><br><span class="line">  <span class="comment">// 开启hydrate，一般用于服务端渲染</span></span><br><span class="line">  supportsHydration: boolean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 杂项</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 获取可公开的节点实例，即你愿意暴露给用户的节点信息，用户通过ref可以获取到这个对象。一般自定义渲染器原样返回即可, 除非你想有选择地给用户暴露信息</span></span><br><span class="line">  getPublicInstance(instance: Instance | TextInstance): PublicInstance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 还有很多参数，由于一般渲染器不会用到，暂时不讲了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>如果按照<code>Fiber的两个阶段</code>来划分的话，接口分类是这样的:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">| 协调阶段                 | 开始提交         | 提交阶段                  | 提交完成         |</span><br><span class="line">|-------------------------|----------------|--------------------------|-----------------|</span><br><span class="line">| createInstance          | prepareCommit  | appendChild              | resetAfterCommit|</span><br><span class="line">| createTextInstance      |                | appendChildToContainer   | commitMount     |</span><br><span class="line">| shouldSetTextContent    |                | insertBefore             |                 |</span><br><span class="line">| appendInitialChild      |                | insertInContainerBefore  |                 |</span><br><span class="line">| finalizeInitialChildren  |                | removeChild              |                 |</span><br><span class="line">| prepareUpdate           |                | removeChildFromContainer |                 |</span><br><span class="line">|                         |                | commitTextUpdate         |                 |</span><br><span class="line">|                         |                | commitUpdate             |                 |</span><br><span class="line">|                         |                | resetTextContent         |                 |</span><br></pre></td></tr></table></figure><p><br></p><p>通过上面接口定义可以知道 <code>HostConfig</code> 配置比较丰富，涉及节点操作、挂载、更新、调度、以及各种生命周期钩子, 可以控制渲染器的各种行为.</p><p>看得有点蒙圈？没关系, 你暂时没有必要了解所有的参数，下面会一点一点展开解释这些功能。你可以最后再回来看这里。</p><p><br></p><h2 id="宿主组件"><a href="#宿主组件" class="headerlink" title="宿主组件"></a>宿主组件</h2><p>React中有两种组件类型，一种是<code>宿主组件(Host Component)</code>, 另一种是<code>复合组件(CompositeComponent)</code>. <code>宿主组件</code>是平台提供的，例如 <code>ReactDOM</code> 平台提供了 <code>div</code>、<code>span</code>、<code>h1</code>… 等组件. 这些组件通常是字符串类型，直接渲染为平台下面的视图节点。</p><p>而<code>复合组件</code>，也称为<code>自定义组件</code>，用于组合其他<code>复合组件</code>和<code>宿主组件</code>，通常是类或函数。</p><p>渲染器不需要关心<code>复合组件</code>的处理, Reconciler 交给渲染器的是一颗<code>宿主组件树</code>。</p><p>当然在 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 中，也定义了很多小程序特定的<code>宿主组件</code>，比如我们可以这样子使用它们:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>Reconciler</code> 会调用 <code>HostConfig</code> 的 <code>createInstance</code> 和<code>createTextInstance</code> 来创建<code>宿主组件</code>的实例，所以自定义渲染器必须实现这两个方法. 看看 <code>Remax</code> 是怎么做的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">// 创建宿主组件实例</span></span><br><span class="line">  createInstance(type: string, <span class="attr">newProps</span>: any, <span class="attr">container</span>: Container) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = generate();</span><br><span class="line">    <span class="comment">// 预处理props, remax会对事件类型Props进行一些特殊处理</span></span><br><span class="line">    <span class="keyword">const</span> props = processProps(newProps, container, id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VNode(&#123;</span><br><span class="line">      id,</span><br><span class="line">      type,</span><br><span class="line">      props,</span><br><span class="line">      container,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建宿主组件文本节点实例</span></span><br><span class="line">  createTextInstance(text: string, <span class="attr">container</span>: Container) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = generate();</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> VNode(&#123;</span><br><span class="line">      id,</span><br><span class="line">      type: TYPE_TEXT,</span><br><span class="line">      props: <span class="literal">null</span>,</span><br><span class="line">      container,</span><br><span class="line">    &#125;);</span><br><span class="line">    node.text = text;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否需要处理子节点。如果返回true则不创建，整个下级组件树都会被忽略。</span></span><br><span class="line">  <span class="comment">// 有一些场景是不需要创建文本节点的，而是由父节点内部消化。</span></span><br><span class="line">  <span class="comment">// 举个例子，在ReactDOM中，如果某个节点设置了dangerouslySetInnerHTML，那么它的children应该被忽略，</span></span><br><span class="line">  <span class="comment">// 这时候 shouldSetTextContent则应该返回true</span></span><br><span class="line">  shouldSetTextContent(type, nextProps) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ReactDOM 中上面两个方法分别会通过 <code>document.createElement</code> 和 <code>document.createTextNode</code> 来创建<code>宿主组件</code>(即<code>DOM节点</code>)。</p><p><br></p><p><img src="/images/remax/wxm.png" alt></p><p>上面是微信小程序的架构图(图片来源: <a href="https://mp.weixin.qq.com/s/3QE3g0NmaBAi91lbrihhVw" target="_blank" rel="noopener">一起脱去小程序的外套 - 微信小程序架构解析</a>)。</p><p><strong>因为小程序隔离了<code>渲染进程</code>和<code>逻辑进程</code>。<a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 是跑在<code>逻辑进程</code>上的，在<code>逻辑进程</code>中无法进行实际的渲染, 只能通过<code>setData</code>方式将更新指令传递给<code>渲染进程</code>后，再进行解析渲染</strong>。</p><p>所以<a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a>选择在<code>逻辑进程</code>中先构成一颗<code>镜像树</code>(Mirror Tree), 然后再同步到<code>渲染进程</code>中，如下图:</p><p><img src="/images/remax/03.png" alt></p><p><br></p><p><strong>上面的 <code>VNode</code> 就是镜像树中的<code>虚拟节点</code>，主要用于保存一些节点信息，不做任何特殊处理</strong>, 它的结构如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  id: number;                  <span class="comment">// 唯一的节点id</span></span><br><span class="line">  container: Container;</span><br><span class="line">  children: VNode[];           <span class="comment">// 子节点</span></span><br><span class="line">  mounted = <span class="literal">false</span>;             <span class="comment">// 节点是否已经挂载</span></span><br><span class="line">  type: string | symbol;       <span class="comment">// 节点的类型</span></span><br><span class="line">  props?: any;                 <span class="comment">// 节点的props</span></span><br><span class="line">  parent: VNode | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 父节点引用</span></span><br><span class="line">  text?: string;               <span class="comment">// 如果是文本节点，这里保存文本内容</span></span><br><span class="line">  path(): Path                 <span class="comment">// 节点的路径. 同步到渲染进程后，通过path恢复到树中</span></span><br><span class="line">  <span class="comment">// 子节点操作</span></span><br><span class="line">  appendChild(node: VNode, <span class="attr">immediately</span>: boolean)</span><br><span class="line">  removeChild(node: VNode, <span class="attr">immediately</span>: boolean)</span><br><span class="line">  insertBefore(newNode: VNode, <span class="attr">referenceNode</span>: VNode, <span class="attr">immediately</span>: boolean)</span><br><span class="line"></span><br><span class="line">  update()                     <span class="comment">// 触发同步到渲染进程</span></span><br><span class="line">  toJSON(): string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VNode 的完整代码可以看<a href="https://github.com/remaxjs/remax/blob/master/packages/remax/src/VNode.ts" target="_blank" rel="noopener">这里</a></p><p><br></p><h2 id="镜像树的构建和操作"><a href="#镜像树的构建和操作" class="headerlink" title="镜像树的构建和操作"></a>镜像树的构建和操作</h2><p>要构建出完整的节点树需要实现<code>HostConfig</code> 的 <code>appendChild</code>、<code>insertBefore</code>、<code>removeChild</code> 等方法, 如下， 这些方法都比较容易理解，所以不需要过多解释。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持节点修改</span></span><br><span class="line">  <span class="comment">// 有些静态渲染的场景，例如渲染为pdf文档，这时候可以关闭</span></span><br><span class="line">  <span class="comment">// 当关闭时，只需要实现appendInitiaChild</span></span><br><span class="line">  supportsMutation: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于初始化(首次)时添加子节点</span></span><br><span class="line">  appendInitialChild: <span class="function">(<span class="params">parent: VNode, child: VNode</span>) =&gt;</span> &#123;</span><br><span class="line">    parent.appendChild(child, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加子节点</span></span><br><span class="line">  appendChild(parent: VNode, <span class="attr">child</span>: VNode) &#123;</span><br><span class="line">    parent.appendChild(child, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入子节点</span></span><br><span class="line">  insertBefore(parent: VNode, <span class="attr">child</span>: VNode, <span class="attr">beforeChild</span>: VNode) &#123;</span><br><span class="line">    parent.insertBefore(child, beforeChild, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  removeChild(parent: VNode, <span class="attr">child</span>: VNode) &#123;</span><br><span class="line">    parent.removeChild(child, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加节点到容器节点，一般情况我们不需要和appendChild特殊区分</span></span><br><span class="line">  appendChildToContainer(container: any, <span class="attr">child</span>: VNode) &#123;</span><br><span class="line">    container.appendChild(child);</span><br><span class="line">    child.mounted = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入节点到容器节点</span></span><br><span class="line">  insertInContainerBefore(container: any, <span class="attr">child</span>: VNode, <span class="attr">beforeChild</span>: VNode) &#123;</span><br><span class="line">    container.insertBefore(child, beforeChild);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从容器节点移除节点</span></span><br><span class="line">  removeChildFromContainer(container: any, <span class="attr">child</span>: VNode) &#123;</span><br><span class="line">    container.removeChild(child);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="节点更新"><a href="#节点更新" class="headerlink" title="节点更新"></a>节点更新</h2><p>上一节讲的是树结构层面的更新，当节点属性变动或者文本内容变动时，也需要进行更新。我们可以通过下列 <code>HostConfig</code> 配置来处理这类更新:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 更新相关</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 可以在这里比对props，如果props没有变化则不进行更新，这和React组件的shouldComponentUpdate差不多</span></span><br><span class="line">  <span class="comment">// **返回’空‘则表示不更新该节点, 这时候commitUpdate则不会被调用**</span></span><br><span class="line">  prepareUpdate(node: VNode, <span class="attr">type</span>: string, <span class="attr">oldProps</span>: any, <span class="attr">newProps</span>: any) &#123;</span><br><span class="line">    oldProps = processProps(oldProps, node.container, node.id);</span><br><span class="line">    newProps = processProps(newProps, node.container, node.id);</span><br><span class="line">    <span class="keyword">if</span> (!shallowequal(newProps, oldProps)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行节点更新</span></span><br><span class="line">  commitUpdate(</span><br><span class="line">    node: VNode,</span><br><span class="line">    updatePayload: any,</span><br><span class="line">    type: string,</span><br><span class="line">    oldProps: any,</span><br><span class="line">    newProps: any</span><br><span class="line">  ) &#123;</span><br><span class="line">    node.props = processProps(newProps, node.container, node.id);</span><br><span class="line">    node.update();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行文本节点更新</span></span><br><span class="line">  commitTextUpdate(node: VNode, <span class="attr">oldText</span>: string, <span class="attr">newText</span>: string) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldText !== newText) &#123;</span><br><span class="line">      node.text = newText;</span><br><span class="line">      <span class="comment">// 更新节点</span></span><br><span class="line">      node.update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok, 这个也比较好理解。<br>对于普通节点更新，<code>Reconciler</code> 会先调用 <code>prepareUpdate</code>, 确定是否要更新，如果返回非空数据，<code>Reconciler</code> 就会将节点放入 <code>Effects</code> 链中，在<code>提交</code>阶段调用 <code>commitUpdate</code> 来执行更新。<br>文本节点更新则直接调用 <code>commitTextUpdate</code>，不在话下.</p><p><br></p><h2 id="副作用提交"><a href="#副作用提交" class="headerlink" title="副作用提交"></a>副作用提交</h2><p>React 的<code>更新的两个阶段</code>这个概念非常重要，这个也体现在HostConfig上:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">// Reconciler说，我要开始提交了，你提交前要做什么，就在这做吧</span></span><br><span class="line">  <span class="comment">// 比如ReactDOM会在这里保存当前DOM文档的选中状态和焦点状态, 以及禁用事件处理。因为DOM更新可能会破坏这些状态</span></span><br><span class="line">  prepareForCommit: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reconciler说，我已经提交完了</span></span><br><span class="line">  <span class="comment">// ReactDOM会在这里恢复提交前的DOM文档的选中状态和焦点状态</span></span><br><span class="line">  resetAfterCommit: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在协调阶段，当一个节点完成'创建'后调用。如果有子节点，则在所有子节点appendInitialChild完成后调用</span></span><br><span class="line">  <span class="comment">// 返回一个boolean值表示’完成提交‘后是否要调用commitMount. 通俗讲就是告诉Reconciler，当前节点完成’挂载‘后要执行某些东西</span></span><br><span class="line">  <span class="comment">// ReactDOM会使用这个钩子来处理带有autofoucs属性的节点，在commitMount中实现自动获取焦点</span></span><br><span class="line">  finalizeInitialChildren: <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 和finalizeInitialChildren配合使用，如果前者返回true，在Reconciler完成提交后，对应节点的commitMount会被执行</span></span><br><span class="line">  commitMount: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>将上文讲到的所有钩子都聚合起来，按照更新的阶段和应用的目标(target)进行划分，它们的分布是这样的：</p><p><img src="/images/remax/overview.png" alt></p><p><br></p><p>那么对于 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 来说, 什么时候应该将’更新’提交到<code>渲染进程</code>呢？答案是上图所有在<code>提交阶段</code>的方法被调用时。</p><p><code>提交阶段</code>原意就是用于执行各种副作用的，例如视图更新、远程方法请求、订阅… 所以 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 也会在这个阶段收集<code>更新指令</code>，在下一个循环推送给渲染进程。</p><p><br></p><h2 id="hostconfig执行流程总结"><a href="#hostconfig执行流程总结" class="headerlink" title="HostConfig执行流程总结"></a>HostConfig执行流程总结</h2><p>回顾一下自定义渲染器各种方法调用的流程, 首先看一下<strong>挂载</strong>的流程:</p><p>假设我们的组件结构如下:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container()</span><br><span class="line"><span class="keyword">const</span> MyComp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;hello world&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div className=<span class="string">"root"</span>&gt;</span><br><span class="line">    &lt;MyComp /&gt;</span><br><span class="line">    &lt;span&gt;--custom renderer&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;,</span><br><span class="line">  container,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"rendered"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>React 组件树的结构如下(左图)，但对于渲染器来说，树结构是右图。<br>自定义组件是React 层级的东西，渲染器只需要关心最终需要渲染的视图结构, 换句话说渲染器只关心<code>宿主组件</code>:</p><p><img src="/images/remax/tree-compare.png" alt></p><p><br></p><p>挂载会经历以下流程:</p><p><img src="/images/remax/mount.png" alt></p><p>通过上面的流程图，可以很清晰看到每个钩子的调用时机。</p><p><br></p><p>同理，我们再来看一下节点<strong>更新</strong>时的流程. 我们稍微改造一下上面的程序，让它定时触发更新:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> isEven = count % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 递增计数器</span></span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(timer)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"mycomp"</span> style=&#123;&#123; <span class="attr">color</span>: isEven ? <span class="string">"red"</span> : <span class="string">"blue"</span> &#125;&#125;&gt;</span><br><span class="line">      &#123;isEven ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>even<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">      &lt;span className=<span class="string">"foo"</span>&gt;hello world &#123;count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>下面是更新的流程:</p><p><img src="/images/remax/update.png" alt></p><p><br></p><p>当<code>MyComp</code>的 <code>count</code> 由1变为2时，<code>MyComp</code> 会被重新渲染，这时候新增了一个<code>div</code> 节点(红色虚框), 另外 <code>hello world 1</code> 也变成了 <code>hello world 2</code>。</p><p>新增的 <code>div</code> 节点创建流程和挂载时一样，只不过它不会立即插入到父节点中，而是先放到<code>Effect</code>链表中，在<code>提交阶段</code>统一执行。</p><p>同理<code>hello world {count}</code>文本节点的更新、以及其他节点的 Props 更新都是放到Effect链表中，最后时刻才更新提交. 如上图的 <code>insertBefore</code>、<code>commitTextUpdate</code>、<code>commitUpdate</code>.</p><p>另外一个比较重要的是 <code>prepareUpdate</code> 钩子，你可以在这里告诉 Reconciler，节点是否需要更新，如果需要更新则返回非空值，这样 <code>commitUpdate</code> 才会被触发。</p><p><br></p><h2 id="同步到渲染进程"><a href="#同步到渲染进程" class="headerlink" title="同步到渲染进程"></a>同步到渲染进程</h2><p>React 自定义渲染器差不多就这样了，接下来就是平台相关的事情了。<br><a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 目前的做法是在触发更新后，通过小程序 <code>Page</code> 对象的 <code>setData</code> 方法将<code>更新指令</code>传递给渲染进程;<br><code>渲染进程</code>侧再通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/" target="_blank" rel="noopener"><code>WXS</code></a> 机制，将<code>更新指令</code>恢复到树中； 最后再通过<code>模板</code>机制，将树递归渲染出来。</p><p>整体的架构如下:</p><p><img src="/images/remax/07.png" alt></p><p><br></p><p>先来看看<code>逻辑进程</code>侧是如何推送更新指令的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在根容器上管理更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 触发更新</span></span><br><span class="line">  requestUpdate(</span><br><span class="line">    path: Path,</span><br><span class="line">    start: number,</span><br><span class="line">    deleteCount: number,</span><br><span class="line">    immediately: boolean,</span><br><span class="line">    ...items: RawNode[]</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> update: SpliceUpdate = &#123;</span><br><span class="line">      path, <span class="comment">// 更新节点的树路径</span></span><br><span class="line">      start, <span class="comment">// 更新节点在children中的索引</span></span><br><span class="line">      deleteCount,</span><br><span class="line">      items, <span class="comment">// 当前节点的信息</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (immediately) &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateQueue.push(update);</span><br><span class="line">      <span class="keyword">this</span>.applyUpdate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 放入更新队列，延时收集更新指令</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.updateQueue.length === <span class="number">0</span>) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.applyUpdate());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.updateQueue.push(update);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  applyUpdate() &#123;</span><br><span class="line">    <span class="keyword">const</span> action = &#123;</span><br><span class="line">      type: <span class="string">'splice'</span>,</span><br><span class="line">      payload: <span class="keyword">this</span>.updateQueue.map(<span class="function"><span class="params">update</span> =&gt;</span> (&#123;</span><br><span class="line">        path: stringPath(update.path),</span><br><span class="line">        start: update.start,</span><br><span class="line">        deleteCount: update.deleteCount,</span><br><span class="line">        item: update.items[<span class="number">0</span>],</span><br><span class="line">      &#125;)),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过setData通知渲染进程</span></span><br><span class="line">    <span class="keyword">this</span>.context.setData(&#123; action &#125;);</span><br><span class="line">    <span class="keyword">this</span>.updateQueue = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>逻辑还是比较清楚的，即将需要更新的节点(包含节点路径、节点信息)推入更新队列，然后触发 <code>setData</code> 通知到<code>渲染进程</code>。</p><p><br></p><p><code>渲染进程</code>侧，则需要通过 <code>WXS</code> 机制，相对应地将<code>更新指令</code>恢复到<code>渲染树</code>中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染树</span></span><br><span class="line"><span class="keyword">var</span> tree = &#123;</span><br><span class="line">  root: &#123;</span><br><span class="line">    children: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指令应用到渲染树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; action.payload.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="keyword">get</span>(tree, action.payload[i].path);</span><br><span class="line">        if (action.payload[i].item) &#123;</span><br><span class="line">          value.splice(</span><br><span class="line">            action.payload[i].start,</span><br><span class="line">            action.payload[i].deleteCount,</span><br><span class="line">            action.payload[i].item</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          value.splice(action.payload[i].start, action.payload[i].deleteCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(tree, action.payload[i].path, value);</span><br><span class="line">      &#125;</span><br><span class="line">      return tree;</span><br><span class="line">    default:</span><br><span class="line">      return tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>OK, 接着开始渲染, <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 采用了<code>模板</code>的形式进行渲染:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">src</span>=<span class="string">"../../helper.wxs"</span> <span class="attr">module</span>=<span class="string">"helper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"../../base.wxml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"REMAX_TPL"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;tree: helper.reduce(action)&#125;&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 为每个组件类型都生成了一个<code>template</code>，动态’递归’渲染整颗树:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"REMAX_TPL"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;tree.root.children&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;id&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"REMAX_TPL_1_CONTAINER"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;i: item&#125;&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">"_h"</span>&gt;</span></span><br><span class="line">  module.exports = &#123;</span><br><span class="line">  v: function(value) &#123;</span><br><span class="line">  return value !== undefined ? value : '';</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 按照层级生成模板 --&gt;</span></span><br><span class="line">&lt;% for (var i = 1; i &lt;= depth; i++) &#123; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">%var</span> <span class="attr">id</span> = <span class="string">i;</span> %&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生成组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span> (<span class="attr">let</span> <span class="attr">component</span> <span class="attr">of</span> <span class="attr">components</span>) &#123; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">include</span>('<span class="attr">.</span>/<span class="attr">component.ejs</span>', &#123;</span></span><br><span class="line"><span class="tag">        <span class="attr">props:</span> <span class="attr">component.props</span>,</span></span><br><span class="line"><span class="tag">        <span class="attr">id:</span> <span class="attr">component.id</span>,</span></span><br><span class="line"><span class="tag">        <span class="attr">templateId:</span> <span class="attr">id</span>,</span></span><br><span class="line"><span class="tag">      &#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"REMAX_TPL_&lt;%=id%&gt;_plain-text"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;i: i&#125;&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span>&gt;</span>&#123;&#123;i.text&#125;&#125;<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  把动态选择模板的逻辑放入一个模板内，可以提升性能问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"REMAX_TPL_&lt;%=id%&gt;_CONTAINER"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;i: i&#125;&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"&#123;&#123;'REMAX_TPL_&lt;%=id%&gt;_' + i.type&#125;&#125;"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;i: i&#125;&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p>限于小程序的渲染机制，以下因素可能会影响渲染的性能:</p><ul><li>进程IPC。更新指令通过IPC通知到渲染进程，频繁更新可能会影响性能.  ReactNative 中涉及到 Native 和 JS引擎之间的通信，也是存在这个问题的。<br>所以小程序才有了 <code>WXS</code> 这类方案，用来处理复杂的视图交互问题，比如动画。未来 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 也需要考虑这个问题</li><li><code>Reconciler</code>这一层已经进行了 Diff，到<code>渲染进程</code>可能需要重复再做一遍？</li><li>基于模板的方案，局部更新是否会导致页面级别重新渲染？和小程序原生的自定义组件相比性能如何？</li></ul><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文以 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 为例，科普一个 React 自定义渲染器是如何运作的。对于 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a>，目前还处于开发阶段，很多功能还不完善。至于<a href="https://github.com/remaxjs/remax/issues/156" target="_blank" rel="noopener">性能如何</a>，笔者还不好做评论，可以看官方给出的初步<a href="https://github.com/remaxjs/benchmark" target="_blank" rel="noopener">基准测试</a>。有能力的同学，可以参与代码贡献或者 Issue 讨论。</p><p>最后谢谢<a href="https://www.zhihu.com/people/meck" target="_blank" rel="noopener">边柳</a>对本文审校和建议。</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/79788488" target="_blank" rel="noopener">Remax - 使用真正的 React 构建小程序</a></li><li><a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">React Fiber是什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">深入React fiber架构及源码</a></li><li><a href="https://medium.com/@agent_hunt/hello-world-custom-react-renderer-9a95b7cd04bc" target="_blank" rel="noopener">Hello World Custom React Renderer - Shailesh - Medium</a></li><li><a href="https://blog.atulr.com/react-custom-renderer-1/" target="_blank" rel="noopener">⚛️👆 Part 1/3 - Beginners guide to Custom React Renderers. How to build your own renderer from scratch?</a> 这系列文章很棒</li><li><a href="https://zhuanlan.zhihu.com/p/82741561" target="_blank" rel="noopener">谜之wxs，uni-app如何用它大幅提升性能</a></li><li><a href="https://zhuanlan.zhihu.com/p/59787245" target="_blank" rel="noopener">全新重构，uni-app实现微信端性能翻倍</a></li><li><a href="https://www.zhihu.com/search?type=content&amp;q=小程序原理" target="_blank" rel="noopener">浅谈小程序运行机制</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上个月蚂蚁金服前端发布了一个新的框架 &lt;a href=&quot;https://github.com/remaxjs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Remax&lt;/code&gt;&lt;/a&gt;, 口号是&lt;strong&gt;使用真正的、完整的 React
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>透过现象看本质: 常见的前端架构风格和案例</title>
    <link href="https://bobi.ink/2019/09/11/arch-pattern/"/>
    <id>https://bobi.ink/2019/09/11/arch-pattern/</id>
    <published>2019-09-10T16:00:00.000Z</published>
    <updated>2019-09-16T21:24:24.973Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中的各个模块和子系统有机的结合为一个完整的系统</p></blockquote><p>没多少人能记住上面的定义，需要注意的是本文不是专业讨论系统架构的文章，笔者也还没到那个水平. 所以暂时没必要纠结于什么是架构模式、什么是架构风格。在这里<strong>尚且把它们都当成一个系统架构上的套路, 所谓的套路就是一些通用的、可复用的，用于应对某类问题的方式方法. 可以理解为类似“设计模式”的东西，只是解决问题的层次不一样</strong>。</p><p>透过现象看本质，本文将带你领略前端领域一些流行技术栈背后的架构思想。直接进入正题吧</p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#分层风格">分层风格</a><ul><li><a href="#virtual-dom">Virtual DOM</a></li><li><a href="#taro">Taro</a></li></ul></li><li><a href="#管道和过滤器">管道和过滤器</a><ul><li><a href="#中间件middleware">中间件(Middleware)</a></li></ul></li><li><a href="#事件驱动">事件驱动</a></li><li><a href="#mv">MV*</a><ul><li><a href="#家喻户晓的mvc">家喻户晓的MVC</a></li><li><a href="#redux">Redux</a></li></ul></li><li><a href="#复制风格">复制风格</a></li><li><a href="#微内核架构">微内核架构</a></li><li><a href="#微前端">微前端</a></li><li><a href="#组件化架构">组件化架构</a></li><li><a href="#其他">其他</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br></p><h2 id="分层风格"><a href="#分层风格" class="headerlink" title="分层风格"></a>分层风格</h2><blockquote><p>没有什么问题是分层解决不了，如果解决不了, 就再加一层 —— 鲁迅 <br><br>不不，原话是: <code>Any problem  in computer science can be solved by anther layer of indirection.</code></p></blockquote><p>分层架构是最常见的软件架构，你要不知道用什么架构，或者不知道怎么解决问题，那就尝试加多一层。</p><p>一个分层系统是按照层次来组织的，每一层为在其之上的层提供服务，并且使用在其之下的层所提供的服务. <strong>分层通常可以解决什么问题</strong>？</p><ul><li><p><strong>是隔离业务复杂度与技术复杂度的利器</strong>. 典型的例子是网络协议, 越高层越面向人类，越底层越面向机器。一层一层往上，很多技术的细节都被隐藏了，比如我们使用<code>HTTP</code>时，不需要考虑<code>TCP</code>层的握手和包传输细节，<code>TCP</code>层不需要关心<code>IP</code>层的寻址和路由。</p><p><img src="/images/arch-pattern/tcp-ip-model.png" alt></p><p><br></p></li><li><p><strong>分离关注点和复用</strong>。减少跨越多层的耦合, 当一层变动时不会影响到其他层。例如我们前端项目建议拆分逻辑层和视图层，一方面可以降低逻辑和视图之间的耦合，当视图层元素变动时可以尽量减少对逻辑层的影响；另外一个好处是, 当逻辑抽取出去后，可以被不同平台的视图复用。</p></li></ul><p><br></p><p>关注点分离之后，软件的结构会变得容易理解和开发, 每一层可以被复用, 容易被测试, 其他层的接口通过模拟解决. 但是分层架构，也不是全是优点，<strong>分层的抽象可能会丢失部分效率和灵活性</strong>, 比如编程语言就有’层次’(此例可能不太严谨)，语言抽象的层次越高，一般运行效率可能会有所衰减:</p><p><img src="/images/arch-pattern/lang.png" alt></p><p>分层架构在软件领域的案例实在太多太多了，咱讲讲前端的一些’分层’案例：</p><p><br></p><h3 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>前端石器时代，我们页面交互和渲染，是通过服务端渲染或者直接操作DOM实现的, 有点像C/C++这类系统编程语言手动操纵内存. 那时候<code>JQuery</code>很火:</p><p><img src="/images/arch-pattern/jquery.png" alt></p><p>后来随着软硬件性能越来越好、Web应用也越来越复杂，前端开发者的生产力也要跟上，类似JQuery这种命令式的编程方式无疑是比较低效的. 尽管手动操作 DOM 可能可以达到更高的性能和灵活性，但是这样对大部分开发者来说太低效了，我们是可以接受牺牲一点性能换取更高的开发效率的.</p><p>怎么解决，再加一层吧，后来React就搞了一层VirtualDOM。我们可以声明式、组合式地构建一颗对象树, 然后交由React将它映射到DOM：</p><p><img src="/images/arch-pattern/vd1.png" alt></p><p>一开始VirtualDOM和DOM的关系比较暧昧，两者是耦合在一起的。后面有人想，我们有了VirtualDOM这个抽象层，那应该能多搞点别的，比如渲染到移动端原生组件、PDF、Canvas、终端UI等等。</p><p>后来VirtualDOM进行了更彻底的分层，有着这个抽象层我们可以将VirtualDOM映射到更多类似应用场景:</p><p><img src="/images/arch-pattern/vd2.png" alt></p><p>所以说 VirtualDOM 更大的意义在于开发方式的转变: 声明式、 数据驱动, 让开发者不需要关心 DOM 的操作细节(属性操作、事件绑定、DOM 节点变更)，换句话说应用的开发方式变成了<code>view=f(state)</code>, 这对生产力的解放是有很大推动作用的; 另外有了VirtualDOM这一层抽象层，使得多平台渲染成为可能。</p><p>当然VirtualDOM或者React，不是唯一，也不是第一个这样的解决方案。其他前端框架，例如Vue、Angular基本都是这样一个发展历程。</p><p>上面说了，分层不是银弹。我们通过ReactNative可以开发跨平台的移动应用，但是众所周知，它运行效率或者灵活性暂时是无法与原生应用比拟的。</p><p><br></p><h3 id="taro"><a href="#taro" class="headerlink" title="Taro"></a>Taro</h3><p><strong><a href="https://taro-docs.jd.com/taro/docs/README.html" target="_blank" rel="noopener">Taro</a> 和React一样也采用分层架构风格，只不过他们解决的问题是相反的。React加上一个分层，可以渲染到不同的视图形态；而Taro则是为了统一多样的视图形态</strong>: 国内现如今市面上端的形态多种多样，Web、React-Native、微信小程序…… 针对不同的端去编写多套代码的成本非常高，这种需求催生了Taro这类框架的诞生. 使用 Taro，我们可以只书写一套代码, 通过编译工具可以输出到不同的端:</p><p><img src="/images/arch-pattern/taro.jpg" alt><br>(图片来源: <a href="https://aotu.io/notes/2018/06/07/Taro/" target="_blank" rel="noopener">多端统一开发框架 - Taro</a>)</p><p><br><br><br></p><h2 id="管道和过滤器"><a href="#管道和过滤器" class="headerlink" title="管道和过滤器"></a>管道和过滤器</h2><p>在管道/过滤器架构风格中，每个组件都有一组输入和输出，每个组件职责都很单一, 数据输入组件，经过内部处理，然后将处理过的数据输出。所以这些组件也称为过滤器，连接器按照业务需求将组件连接起来，其形状就像‘管道’一样，这种架构风格由此得名。</p><p><img src="/images/arch-pattern/pipeline.png" alt></p><p>这里面最经典的案例是<code>*unix</code> Shell命令，Unix的哲学就是“只做一件事，把它做好”，所以我们常用的Unix命令功能都非常单一，但是Unix Shell还有一件法宝就是管道，通过管道我们可以将命令通过<code>标准输入输出</code>串联起来实现复杂的功能:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 获取网页，并进行拼写检查。代码来源于wiki</span><br><span class="line">curl "http://en.wikipedia.org/wiki/Pipeline_(Unix)" | \</span><br><span class="line">sed 's/[^a-zA-Z ]/ /g' | \</span><br><span class="line">tr 'A-Z ' 'a-z\n' | \</span><br><span class="line">grep '[a-z]' | \</span><br><span class="line">sort -u | \</span><br><span class="line">comm -23 - /usr/share/dict/words | \</span><br><span class="line">less</span><br></pre></td></tr></table></figure><p><br></p><p>另一个和Unix管道相似的例子是<code>ReactiveX</code>, 例如<a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener">RxJS</a>. 很多教程将Rx比喻成河流，这个河流的开头就是一个事件源，这个事件源按照一定的频率发布事件。Rx真正强大的其实是它的操作符，有了这些操作符，你可以对这条河流<a href="https://rxjs.dev/operator-decision-tree" target="_blank" rel="noopener">做一切可以做的事情</a>，例如分流、节流、建大坝、转换、统计、合并、产生河流的河流……</p><p>这些操作符和Unix的命令一样，职责都很单一，只干好一件事情。但我们管道将它们组合起来的时候，就迸发了无限的能力.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; throttleTime, map, scan &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line">fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .pipe(</span><br><span class="line">    throttleTime(<span class="number">1000</span>),</span><br><span class="line">    map(<span class="function"><span class="params">event</span> =&gt;</span> event.clientX),</span><br><span class="line">    scan(<span class="function">(<span class="params">count, clientX</span>) =&gt;</span> count + clientX, <span class="number">0</span>)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">count</span> =&gt;</span> <span class="built_in">console</span>.log(count));</span><br></pre></td></tr></table></figure><p><br></p><p>除了上述的RxJS，管道模式在前端领域也有很多应用，主要集中在前端工程化领域。例如’老牌’的项目构建工具<a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">Gulp</a>, Gulp使用管道化模式来处理各种文件类型，管道中的每一个步骤称为Transpiler(转译器), 它们以 NodeJS 的Stream 作为输入输出。整个过程高效而简单。</p><p><img src="/images/arch-pattern/gulp.png" alt></p><p><br></p><p>不确定是否受到Gulp的影响，现代的<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">Webpack</a>打包工具，也使用同样的模式来实现对文件的处理, 即<a href="https://www.webpackjs.com/concepts/loaders/" target="_blank" rel="noopener">Loader</a>, Loader 用于对模块的源代码进行转换, 通过Loader的组合，可以实现复杂的文件转译需求.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">          loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="中间件-middleware"><a href="#中间件-middleware" class="headerlink" title="中间件(Middleware)"></a>中间件(Middleware)</h3><p><img src="/images/arch-pattern/middleware.png" alt></p><p>如果开发过<code>Express</code>、<code>Koa</code>或者<code>Redux</code>, 你可能会发现中间件模式和上述的管道模式有一定的相似性，如上图。相比管道，中间件模式可以使用一个洋葱剖面来形容. 但和管道相比，一般的中间件实现有以下特点:</p><ul><li>中间件没有显式的输入输出。这些中间件之间通常通过集中式的上下文对象来共享状态</li><li>有一个循环的过程。管道中，数据处理完毕后交给下游了，后面就不管了。而中间件还有一个回归的过程，当下游处理完毕后会进行回溯，所以有机会干预下游的处理结果。</li></ul><p>我在谷歌上搜了老半天中间件，对于中间件都没有得到一个令我满意的定义. <strong>暂且把它当作一个特殊形式的管道模式吧</strong>。这种模式通常用于后端，它可以干净地分离出请求的不同阶段，也就是分离关注点。比如我们可以创建这些中间件：</p><ul><li>日志： 记录开始时间 ⏸ 计算响应时间，输出请求日志</li><li>认证： 验证用户是否登录</li><li>授权： 验证用户是否有执行该操作的权限</li><li>缓存： 是否有缓存结果，有的话就直接返回 ⏸ 当下游响应完成后，再判断一下响应是否可以被缓存</li><li>执行： 执行实际的请求处理 ⏸ 响应</li></ul><p>有了中间件之后，我们不需要在每个响应处理方法中都包含这些逻辑，关注好自己该做的事情。下面是Koa的示例代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> rt = ctx.response.get(<span class="string">'X-Response-Time'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;rt&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">  ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><br></p><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>事件驱动, 或者称为<code>发布-订阅</code>风格， 对于前端开发来说是再熟悉不过的概念了. 它<strong>定义了一种一对多的依赖关系</strong>， 在事件驱动系统风格中，组件不直接调用另一个组件，而是触发或广播一个或多个事件。系统中的其他组件在一个或多个事件中注册。当一个事件被触发，系统会自动通知在这个事件中注册的所有组件. </p><p>这样就<strong>分离了关注点，订阅者依赖于事件而不是依赖于发布者，发布者也不需要关心订阅者，两者解除了耦合</strong>。</p><p>生活中也有很多<code>发布-订阅</code>的例子，比如微信公众号信息订阅，当新增一个订阅者的时候，发布者并不需要作出任何调整，同样发布者调整的时候也不会影响到订阅者，只要协议没有变化。我们可以发现，<strong>发布者和订阅者之间其实是一种弱化的动态的关联关系</strong>。</p><p><strong>解除耦合目的是一方面, 另一方面也可能由基因决定的，一些事情天然就不适合或不支持用同步的方式去调用，或者这些行为是异步触发的</strong>。</p><p>JavaScript的基因决定事件驱动模式在前端领域的广泛使用. 在<a href="https://juejin.im/post/5d693d8b6fb9a06aca383488" target="_blank" rel="noopener">浏览器和Node中的JavaScript是如何工作的? 可视化解释</a> 简单介绍了Javascript的执行原理，其中提到JavaScript是单线程的编程语言，为了应对各种实际的应用场景，一个线程以压根忙不过来的，事件驱动的异步方式是JavaScript的救命稻草.</p><p>浏览器方面，浏览器就是一个GUI程序，<strong>GUI程序是一个循环(更专业的名字是事件循环)，接收用户输入，程序处理然后反馈到页面，再接收用户输入…</strong> 用户的输入是异步，将用户输入抽象为事件是最简洁、自然、灵活的方式。</p><blockquote><p>需要注意的是：事件驱动和异步是不能划等号的。异步 !== 事件驱动，事件驱动 !== 异步</p></blockquote><p><strong>扩展</strong>:</p><ul><li><strong>响应式编程</strong>: 响应式编程本质上也是事件驱动的，下面是前端领域比较流行的两种响应式模式：<ul><li><code>函数响应式(Functional Reactive Programming)</code>, 典型代表RxJS</li><li><code>透明的函数响应式编程(Transparently applying Functional Reactive Programming - TFRP)</code>, 典型代表Vue、Mobx</li></ul></li><li><strong>消息总线</strong>：指接收、发送消息的软件系统。消息基于一组已知的格式，以便系统无需知道实际接收者就能互相通信</li></ul><p><br></p><h2 id="mv"><a href="#mv" class="headerlink" title="MV*"></a>MV*</h2><p><code>MV*</code>架构风格应用也非常广泛。我觉MV*本质上也是一种分层架构，一样强调职责分离。其中最为经典的是MVC架构风格，除此之外还有各种衍生风格，例如<code>MVP</code>、<code>MVVM</code>、<a href="https://medium.com/@fkrautwald/plug-and-play-all-your-observable-streams-with-cycle-js-e543fc287872#.by4c219c8" target="_blank" rel="noopener"><code>MVI(Model View Intent)</code></a>. 还有有点关联<code>Flux</code>或者<code>Redux</code>模式。</p><p><br></p><h3 id="家喻户晓的mvc"><a href="#家喻户晓的mvc" class="headerlink" title="家喻户晓的MVC"></a>家喻户晓的MVC</h3><p><img src="/images/arch-pattern/mvc.png" alt></p><p>如其名，MVC将应用分为三层，分别是：</p><ul><li>视图层(View) 呈现数据给用户</li><li>控制器(Controller) 模型和视图之间的纽带，起到不同层的组织作用：<ul><li>处理事件并作出响应。一般事件有用户的行为(比如用户点击、客户端请求)，模型层的变更</li><li>控制程序的流程。根据请求选择适当的模型进行处理，然后选择适当的视图进行渲染，最后呈现给用户</li></ul></li><li>模型(Model) 封装与应用程序的业务逻辑相关的数据以及对数据的处理方法, 通常它需要和数据持久化层进行通信</li></ul><p>目前前端应用很少有纯粹使用MVC的，要么视图层混合了控制器层，要么就是模型和控制器混合，或者干脆就没有所谓的控制器. 但一点可以确定的是，很多应用都不约而同分离了’逻辑层’和’视图层’。</p><p>下面是典型的AngularJS代码, 视图层:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Todo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"TodoListController as todoList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;todoList.remaining()&#125;&#125; of &#123;&#123;todoList.todos.length&#125;&#125; remaining<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  [ <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">ng-click</span>=<span class="string">"todoList.archive()"</span>&gt;</span>archive<span class="tag">&lt;/<span class="name">a</span>&gt;</span> ]</span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"unstyled"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"todo in todoList.todos"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">ng-model</span>=<span class="string">"todo.done"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"done-&#123;&#123;todo.done&#125;&#125;"</span>&gt;</span>&#123;&#123;todo.text&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">ng-submit</span>=<span class="string">"todoList.addTodo()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ng-model</span>=<span class="string">"todoList.todoText"</span>  <span class="attr">size</span>=<span class="string">"30"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">placeholder</span>=<span class="string">"add new todo here"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn-primary"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>逻辑层:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.module(<span class="string">'todoApp'</span>, [])</span><br><span class="line">  .controller(<span class="string">'TodoListController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> todoList = <span class="keyword">this</span>;</span><br><span class="line">    todoList.todos = [</span><br><span class="line">      &#123;<span class="attr">text</span>:<span class="string">'learn AngularJS'</span>, <span class="attr">done</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">text</span>:<span class="string">'build an AngularJS app'</span>, <span class="attr">done</span>:<span class="literal">false</span>&#125;];</span><br><span class="line"></span><br><span class="line">    todoList.addTodo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      todoList.todos.push(&#123;<span class="attr">text</span>:todoList.todoText, <span class="attr">done</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">      todoList.todoText = <span class="string">''</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    todoList.remaining = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">      angular.forEach(todoList.todos, <span class="function"><span class="keyword">function</span>(<span class="params">todo</span>) </span>&#123;</span><br><span class="line">        count += todo.done ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    todoList.archive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> oldTodos = todoList.todos;</span><br><span class="line">      todoList.todos = [];</span><br><span class="line">      angular.forEach(oldTodos, <span class="function"><span class="keyword">function</span>(<span class="params">todo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!todo.done) todoList.todos.push(todo);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>至于MVP、MVVM，这些MVC模式的延展或者升级，网上都大量的资源，这里就不予赘述。</p><p><br></p><h3 id="redux"><a href="#redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux是Flux架构的改进、融合了Elm语言中函数式的思想. 下面是Redux的架构图:</p><p><img src="/images/arch-pattern/redux.png" alt></p><p>从上图可以看出Redux架构有以下要点:</p><ul><li><strong>单一的数据源</strong>.</li><li><strong>单向的数据流</strong>.</li></ul><p>单一数据源, 首先解决的是传统MVC架构多模型数据流混乱问题(如下图)。单一的数据源可以让应用的状态可预测和可被调试。另外单一数据源也方便做数据镜像，实现撤销/重做，数据持久化等等功能</p><p><img src="/images/arch-pattern/multi-model.png" alt></p><p>单向数据流用于辅助单一数据源, 主要目的是阻止应用代码直接修改数据源，这样一方面简化数据流，同样也让应用状态变化变得可预测。</p><p>上面两个特点是Redux架构风格的核心，至于Redux还强调不可变数据、利用中间件封装副作用、范式化状态树，只是一种最佳实践。还有许多<code>类Redux</code>的框架，例如<a href="http://vuex.vuejs.org" target="_blank" rel="noopener"><code>Vuex</code></a>、<a href="https://ngrx.io" target="_blank" rel="noopener">ngrx</a>，在架构思想层次是一致的:</p><p><img src="/images/arch-pattern/vuex.png" alt></p><p><br></p><h2 id="复制风格"><a href="#复制风格" class="headerlink" title="复制风格"></a>复制风格</h2><p><img src="/images/arch-pattern/pm2.png" alt></p><p>基于复制(Replication)风格的系统，会利用多个实例提供相同的服务，来改善服务的可访问性和可伸缩性，以及性能。这种架构风格可以改善用户可察觉的性能，简单服务响应的延迟。</p><p>这种风格在后端用得比较多，举前端比较熟悉的例子，NodeJS. NodeJS是单线程的，为了利用多核资源，NodeJS标准库提供了一个<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="noopener"><code>cluster</code></a>模块，它可以根据CPU数创建多个Worker进程，这些Worker进程可以共享一个服务器端口，对外提供同质的服务, Master进程会根据一定的策略将资源分配给Worker:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Master <span class="subst">$&#123;process.pid&#125;</span> is running`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fork workers.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> died`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Workers可以共享任意的TCP连接 </span></span><br><span class="line">  <span class="comment">// 比如共享HTTP服务器 </span></span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Worker <span class="subst">$&#123;process.pid&#125;</span> started`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用多核能力可以提升应用的性能和可靠性。我们也可以利用<a href="http://pm2.keymetrics.io/docs/usage/cluster-mode/" target="_blank" rel="noopener">PM2</a>这样的进程管理工具，来简化Node集群的管理，它支持很多有用的特性，例如集群节点重启、日志归集、性能监视等。</p><p>复制风格常用于网络服务器。浏览器和Node都有<code>Worker</code>的概念，但是一般都只推荐在CPU密集型的场景使用它们，因为浏览器或者NodeJS内置的异步操作已经非常高效。实际上前端应用CPU密集型场景并不多，或者目前阶段不是特别实用。除此之外你还要权衡进程间通信的效率、Worker管理复杂度、异常处理等事情。</p><p>有一个典型的CPU密集型的场景，即源文件转译. 典型的例子是<a href="https://codesandbox.io/dashboard" target="_blank" rel="noopener">CodeSandbox</a>, 它就是利用浏览器的Worker机制来提高源文件的转译性能的:</p><p><img src="/images/arch-pattern/codesandbox.png" alt></p><p>除了处理CPU密集型任务，对于浏览器来说，Worker也是一个重要的安全机制，用于隔离不安全代码的执行，或者限制访问浏览器DOM相关的东西。小程序抽离逻辑进程的原因之一就是安全性</p><p>其他示例：</p><ul><li>ServerLess</li></ul><p><br></p><h2 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h2><p><img src="/images/arch-pattern/plugin-architecture.png" alt></p><p>微内核架构(MicroKernel)又称为”插件架构”, 指的是软件的内核相对较小，主要功能和业务逻辑都通过插件形式实现。内核只包含系统运行的最小功能。插件之间相互独立，插件之间的通信，应该降到最低，减少相互依赖。</p><p>微内核结构的难点在于建立一套粒度合适的插件协议、以及对插件之间进行适当的隔离和解耦。从而才能保证良好的扩展性、灵活性和可迁移性。</p><p>前端领域比较典型的例子是<code>Webpack</code>、<code>Babel</code>、<code>PostCSS</code>以及<code>ESLint</code>, 这些应用需要应对复杂的定制需求，而且这些需求时刻在变，只有微内核架构才能保证灵活和可扩展性。</p><p>以Webpack为例。Webpack的核心是一个Compiler，这个Compiler主要功能是集成插件系统、维护<code>模块对象图</code>, 对于模块代码具体编译工作、模块的打包、优化、分析、聚合统统都是基于外部插件完成的.</p><p>如上文说的Loader运用了管道模式，负责对源文件进行转译；那Plugin则可以将行为注入到Compiler运行的整个生命周期的钩子中, 完全访问Compiler的当前状态。</p><blockquote><p><a href="https://twitter.com/thelarkinn" target="_blank" rel="noopener">Sean Larkin</a>有个演讲: <a href="https://www.youtube.com/watch?v=4tQiJaFzuJ8" target="_blank" rel="noopener">Everything is a plugin! Mastering webpack from the inside out </a></p></blockquote><p><img src="/images/arch-pattern/webpack.png" alt></p><p><br></p><p>这里还有一篇文章<a href="https://yunsong0922.github.io/2018/12/09/%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E5%BA%94%E7%94%A8%E7%A0%94%E7%A9%B6/" target="_blank" rel="noopener">&lt;微内核架构应用研究&gt;</a>专门写了前端微内核架构模式的一些应用，推荐阅读一下。</p><p><br></p><h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>前几天听了<a href="http://codetimecn.com/" target="_blank" rel="noopener">代码时间</a>上<a href="https://coolshell.cn/haoel" target="_blank" rel="noopener">左耳朵耗子</a>的一期<a href="http://codetimecn.com/episodes/manager" target="_blank" rel="noopener">节目</a>, 他介绍得了亚马逊内部有很多小团队，亚马逊网站上一块豆腐块大小的区域可能是一个团队在维护，比如地址选择器、购物车、运达时间计算… 大厂的这种超级项目是怎么协调和维护的呢？ 这也许就是微前端或者微服务出现的原因吧。</p><p>微前端旨在将<code>单体前端</code>分解成更小、更简单的模块，这些模块可以被独立的团队进行开发、测试和部署，最后再组合成一个大型的整体。</p><p><img src="/images/arch-pattern/microfrontend.jpg" alt></p><p>微前端下各个应用模块是独立运行、独立开发、独立部署的，相对应的会配备更加自治的团队(一个团队干好一件事情)。 微前端的实施还需要有稳固的前端基础设施和研发体系的支撑。</p><p>如果你想深入学习微前端架构，建议阅读<a href="https://www.zhihu.com/people/phodal/activities" target="_blank" rel="noopener">Phodal</a>的<a href="https://juejin.im/user/5567e339e4b0349d3313190b/posts" target="_blank" rel="noopener">相关文章</a>，还有他的新书<a href="https://www.amazon.cn/dp/B07TJ7R9DX/ref=sr_1_1?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&amp;keywords=%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84&amp;qid=1568279892&amp;s=gateway&amp;sr=8-1" target="_blank" rel="noopener">《前端架构：从入门到微前端》</a></p><p><br></p><h2 id="组件化架构"><a href="#组件化架构" class="headerlink" title="组件化架构"></a>组件化架构</h2><p>组件化开发对现在的我们来说如此自然，就像水对鱼一样。 以致于我们忘了组件化也是一种非常重要的架构思想，它的中心思想就是分而治之。按照Wiki上面的定义是：<code>组件化就是基于可复用目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是减少耦合</code>.</p><p>从前端的角度具体来讲，如下图，石器时代开发方式(右侧), 组件时代(左侧):</p><p><img src="/images/arch-pattern/components2.png" alt><br>(图片来源: <a href="http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text" target="_blank" rel="noopener">http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text</a>)</p><p>按照Vue官网的说法: <code>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</code>：</p><p><img src="/images/arch-pattern/components.png" alt></p><p>按照我的理解<strong>组件跟函数是一样的东西，这就是为什么函数式编程思想在React中会应用的如此自然</strong>。若干个简单函数，可以复合成复杂的函数，复杂的函数再复合成复杂的应用。对于前端来说，页面也是这么来的，一个复杂的页面就是有不同粒度的组件复合而成的。</p><p>组件另外一个重要的特征就是<strong>内聚性</strong>，它是一个独立的单元，自包含了所有需要的资源。例如一个前端组件较包含样式、视图结构、组件逻辑:</p><p><img src="/images/arch-pattern/vue-component.png" alt></p><p><br></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>我终于编不下去了</strong>！还有很多架构风格，限于文章篇幅, 且这些风格主要应用于后端领域，这里就不一一阐述了。你可以通过扩展阅读了解这些模式</p><ul><li>面向对象风格: 将应用或系统任务分割为单独、可复用、可自给的对象，每个对象都包含数据、以及对象相关的行为</li><li>C/S 客户端/服务器风格</li><li>面向服务架构(SOA): 指那些利用契约和消息将功能暴露为服务、消费功能服务的应用</li><li>N层/三层: 和分层架构差不多，侧重物理层. 例如C/S风格就是一个典型的N层架构</li><li>点对点风格</li></ul><p>通过上文，你估计会觉得架构风格比设计模式或者算法好理解多的，正所谓‘<strong>大道至简</strong>’，但是‘<strong>简洁而不简单</strong>’！大部分项目的架构不是一开始就是这样的，它们可能经过长期的迭代，踩着巨人的肩膀，一路走过来才成为今天的样子。</p><p>希望本文可以给你一点启发，对于我们前端工程师来说，最牛的不是能做多酷的页面、掌握多少API，要学会通过现象看本质，举一反三融会贯通，这才是进阶之道。</p><p>本文完！</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://wxs.me/2069" target="_blank" rel="noopener">几种常见的软件架构风格介绍</a></li><li><a href="https://docs.huihoo.com/rest/REST_cn.pdf" target="_blank" rel="noopener">架构风格与基于网络的软件架构设计</a> REST提议者，Roy Thomas Fielding的博士论文</li><li><a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html" target="_blank" rel="noopener">软件架构入门</a></li><li><a href="https://zh.wikipedia.org/wiki/管道_\(Unix\" target="_blank" rel="noopener">管道 (Unix)</a>)</li><li><a href="https://zhuanlan.zhihu.com/p/20597452" target="_blank" rel="noopener">redux middleware 详解</a></li><li><a href="https://juejin.im/post/593021272f301e0058273468" target="_blank" rel="noopener">浅析前端开发中的 MVC/MVP/MVVM 模式</a></li><li><a href="https://juejin.im/post/5d1e0dea51882514bf5bedfa#comment" target="_blank" rel="noopener">CodeSandbox 浏览器端的webpack是如何工作的？ 上篇</a></li><li><a href="https://mp.weixin.qq.com/s/KT288QNmtJzKe-jaPyFtFA" target="_blank" rel="noopener">万金油CS与分层</a></li><li><a href="https://www.infoq.cn/article/03*BeU3zQegIbIytRsX9" target="_blank" rel="noopener">大前端时代下的微前端架构：实现增量升级、代码解耦、独立部署</a></li><li><a href="https://www.iteye.com/blog/moon-walker-2393310" target="_blank" rel="noopener">系统组件化架构设计</a></li><li><a href="https://github.com/xufei/blog/issues/19" target="_blank" rel="noopener">2015前端组件化框架之路</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>关于React的一个V8性能瓶颈背后的故事</title>
    <link href="https://bobi.ink/2019/09/07/react-cliff/"/>
    <id>https://bobi.ink/2019/09/07/react-cliff/</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2019-09-08T13:08:08.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>译注: 原文作者是<a href="https://twitter.com/mathias" target="_blank" rel="noopener">Mathias Bynens</a>, 他是V8开发者，这篇文章也发布在<a href="https://v8.dev/blog" target="_blank" rel="noopener">V8的博客</a>上。他的<a href="https://mathiasbynens.be" target="_blank" rel="noopener">相关文章</a>质量非常高，如果你想了解JavaScript引擎内部是如何工作的，他的文章一定不能错过。后面我还会翻译他的其他文章，一方面是他文章质量很高，另外一方面是我想学习一下他们是怎么写文章的，通过翻译文章，让我可以更好地消化知识和模仿写作技巧, 最后奇文共赏！</p></blockquote><p>原文链接: <a href="https://v8.dev/blog/react-cliff" target="_blank" rel="noopener">The story of a V8 performance cliff in React</a></p><p><a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">之前</a>我们讨论过Javascript引擎是如何通过Shape(外形)和内联缓存(Inline Caches)来优化对象和数组的访问的, 我们还特别探讨了<a href="https://mathiasbynens.be/notes/prototypes" target="_blank" rel="noopener">Javascript引擎是如何加速原型属性访问</a>. 这篇文章讲述<strong>V8如何为不同的Javascript值选择最佳的内存表示(representations), 以及它是如何影响外形机制(shape machinery)的</strong>。这些可以帮助我们解释最近React内核出现的V8性能瓶颈(Performance cliff)问题</p><blockquote><p>如果不想看文章，可以看这个演讲： <a href="https://www.youtube.com/watch?v=0I0d8LkDqyc" target="_blank" rel="noopener">“JavaScript engine fundamentals: the good, the bad, and the ugly”</a></p></blockquote><p><br></p><h2 id="javascript-类型"><a href="#javascript-类型" class="headerlink" title="JavaScript 类型"></a>JavaScript 类型</h2><p>每一个Javascript值都属于以下八个类型之一(目前): <code>Number</code>, <code>String</code>, <code>Symbol</code>, <code>BigInt</code>, <code>Boolean</code>, <code>Undefined</code>, <code>Null</code>, 以及 <code>Object</code>.</p><p><img src="/images/react-cliff/01-javascript-types.svg" alt></p><p>但是有个总所周知的例外，在JavaScript中可以通过<code>typeof</code>操作符观察值的类型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// → 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="comment">// → 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// → 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>n;</span><br><span class="line"><span class="comment">// → 'bigint'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// → 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// → 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// → 'object' 🤔</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="comment">// → 'object'</span></span><br></pre></td></tr></table></figure><p><code>typeof null</code>返回的是’<code>object</code>‘, 而不是’<code>null</code>‘, 尽管<code>Null</code>有一个自己的类型。要理解为什么，考虑将所有Javascript类型的集合分为两组：</p><ul><li><em>对象类型</em> (i.e. <code>Object</code>类型)</li><li><em>原始(primitives)类型</em> (i.e. 任何非对象值)</li></ul><p>因此, <code>null</code>可以理解为”无对象值”, 而<code>undefined</code>则表示为“无值”.</p><blockquote><p>译注：也就是，null可以理解为对象类型的’undefined’；而undefined是所有类型的’undefined’</p></blockquote><p><img src="/images/react-cliff/02-primitives-objects.svg" alt></p><p>遵循这个思路，Brendan Eich 在设计Javascript的时候受到了Java的影响，让<code>typeof</code>右侧所有值(即所有对象和null值)都返回’object’. 这就是为什么<code>typeof null === &#39;object&#39;</code>的原因, 尽管规范中有一个单独的<code>Null</code>类型。</p><p><img src="/images/react-cliff/03-primitives-objects-typeof.svg" alt></p><p><br></p><h2 id="值的表示"><a href="#值的表示" class="headerlink" title="值的表示"></a>值的表示</h2><p>Javascript引擎必须能够在内存中表示任意的Javascript值. 然而，需要注意的是，<strong>Javascript的值类型和Javascript引擎如何在内存中表示它们是两回事</strong>.</p><p>例如值 <code>42</code>，Javascript中是<code>number</code>类型。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// → 'number'</span></span><br></pre></td></tr></table></figure><p>在内存中有很多种方式来表示类似<code>42</code>这样的整型数字:</p><table><thead><tr><th>表示</th><th>位</th></tr></thead><tbody><tr><td>8-bit二进制补码</td><td><code>0010 1010</code></td></tr><tr><td>32-bit二进制补码</td><td><code>0000 0000 0000 0000 0000 0000 0010 1010</code></td></tr><tr><td>压缩二进制编码十进制(packed binary-coded decimal (BCD))</td><td><code>0100 0010</code></td></tr><tr><td>32-bit IEEE-754 浮点数</td><td><code>0100 0010 0010 1000 0000 0000 0000 0000</code></td></tr><tr><td>64-bit IEEE-754 浮点数</td><td><code>0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code></td></tr></tbody></table><p>ECMAScript标准的数字类型是64位的浮点数，或者称为双精度浮点数或者Float64. 然而，这不是意味着Javascript引擎就一定要一直按照Float64表示保存数字 —— 这么做会非常低效！引擎可以选择其他内部表示，只要可被察觉的行为和Float64完全匹配就行。</p><p>实际的JavaScript应用中，大多数数字碰巧都是<a href="https://tc39.es/ecma262/#array-index" target="_blank" rel="noopener">合法ECMAScript数组索引</a>。即0 to 2³²−2之间的整型值.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array[<span class="number">0</span>]; <span class="comment">// 最小合法的数组索引.</span></span><br><span class="line">array[<span class="number">42</span>];</span><br><span class="line">array[<span class="number">2</span>**<span class="number">32</span><span class="number">-2</span>]; <span class="comment">// 最大合法数组索引.</span></span><br></pre></td></tr></table></figure><p>JavaScript引擎可以为这类数字选择最优内存表示，来优化通过索引访问数组元素的代码。为了让处理器可以执行内存访问操作，数组索引必须是<a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">二进制补码</a>. 将数组索引表示为Float64实际上是一种浪费，因为引擎必须在每次有人访问数组元素时在float64和二进制补码之间来回转换</p><p>32位的二进制补码表示不仅仅对数组操作有用。一般来说，<strong>处理器执行整型操作会比浮点型操作要快得多</strong>。这就是为什么下一个例子中，第一个循环执行速度是第二个循环的两倍.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// fast 🚀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0.1</span>; i &lt; <span class="number">1000.1</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// slow 🐌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作符也一样。下面代码片段中，取模操作符的性能依赖于操作数是否是整型.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> remainder = value % divisor;</span><br><span class="line"><span class="comment">// Fast 🚀 如果 `value` 和 `divisor` 都表示为整型,</span></span><br><span class="line"><span class="comment">// slow 🐌 其他情况</span></span><br></pre></td></tr></table></figure><p>如果两个操作数都表示为整型，CPU就可以非常高效地计算结果。如果<code>divisor</code>是2的幂, V8还有额外的快速通道(fast-paths)。对于表示为浮点树的值，计算则要复杂的多，并且需要更长的时间.</p><p>因为整型操作通常都比浮点型操作要快得多，所以引擎似乎可以总是使用二进制补码来表示所有整型值和整型的计算结果。不幸的是，这会违反ECMAScript规范！ECMAScript是在Float64基础上进行标准化，因此实际上某些整数操作也可能会输出浮点数。在这种情况下，JS引擎输出正确的结果更重要。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Float64 的安全整型范围是 53 bits. 超过这个返回会失去精度,</span></span><br><span class="line"><span class="number">2</span>**<span class="number">53</span> === <span class="number">2</span>**<span class="number">53</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float64 支持-0, 索引 -1 * 0 必须是 -0, 但是二进制补码是没办法表示-0.</span></span><br><span class="line"><span class="number">-1</span>*<span class="number">0</span> === <span class="number">-0</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float64 可以通过除以0来得到无穷大.</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span> === <span class="literal">Infinity</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="number">-1</span>/<span class="number">0</span> === -<span class="literal">Infinity</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float64 还有NaN.</span></span><br><span class="line"><span class="number">0</span>/<span class="number">0</span> === <span class="literal">NaN</span>;</span><br></pre></td></tr></table></figure><p>尽管左侧都是整型，右侧所有值却都是浮点型。这就是为什么32位二进制补码不能正确地执行上面这些操作。所以JavaScript引擎必须特别谨慎，以确保整数操作可以适当地回退，从而输出花哨(符合规范)的Float64结果。</p><p>对于31位有符号整数范围内的小整数，V8使用一个称为<code>Smi</code>(译注: Small Integer)的特殊表示。其他非<code>Smi</code>的表示称为<code>HeapObject</code>，即指向内存中某些实体的地址。对于数字，我们使用的是一个特殊类型的<code>HeapObject</code>, 尚且称为<code>HeapNumber</code>, 用来表示不在Smi范围内的数字.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> -<span class="literal">Infinity</span> <span class="comment">// HeapNumber</span></span><br><span class="line">-(<span class="number">2</span>**<span class="number">30</span>)<span class="number">-1</span> <span class="comment">// HeapNumber</span></span><br><span class="line">  -(<span class="number">2</span>**<span class="number">30</span>) <span class="comment">// Smi</span></span><br><span class="line">       <span class="number">-42</span> <span class="comment">// Smi</span></span><br><span class="line">        <span class="number">-0</span> <span class="comment">// HeapNumber</span></span><br><span class="line">         <span class="number">0</span> <span class="comment">// Smi</span></span><br><span class="line">       <span class="number">4.2</span> <span class="comment">// HeapNumber</span></span><br><span class="line">        <span class="number">42</span> <span class="comment">// Smi</span></span><br><span class="line">   <span class="number">2</span>**<span class="number">30</span><span class="number">-1</span> <span class="comment">// Smi</span></span><br><span class="line">     <span class="number">2</span>**<span class="number">30</span> <span class="comment">// HeapNumber</span></span><br><span class="line">  <span class="literal">Infinity</span> <span class="comment">// HeapNumber</span></span><br><span class="line">       <span class="literal">NaN</span> <span class="comment">// HeapNumber</span></span><br></pre></td></tr></table></figure><p>如上所示，一些JavaScript数字表示为<code>Smi</code>，而另一些则表示为<code>HeapNumber</code>. V8特意为<code>Smi</code>优化过，因为小整数在实际JavaScript程序中太常见了。<code>Smi</code>不需要在内存中额外分配专门的实体, 可以进行快速的整型操作.</p><p>这里更重要的一点是，<strong>即使是相同Javascript类型的值，为了优化，背后可能会以完全不同的方式进行表示</strong>。</p><p><br><br><br></p><h2 id="smi-vs-heapnumber-vs-mutableheapnumber"><a href="#smi-vs-heapnumber-vs-mutableheapnumber" class="headerlink" title="Smi vs. HeapNumber vs. MutableHeapNumber"></a>Smi vs. HeapNumber vs. MutableHeapNumber</h2><p>下面介绍它们底层是怎么工作的。假设你有下列对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  x: <span class="number">42</span>,  <span class="comment">// Smi</span></span><br><span class="line">  y: <span class="number">4.2</span>, <span class="comment">// HeapNumber</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>x</code>的值<code>42</code>可以被编码为<code>Smi</code>，所以你可以在对象自己内部进行保存。另一方面，值<code>4.2</code>则需要一个单独的实体来保存，然后对象再指向这个实体.</p><p><img src="/images/react-cliff/04-smi-vs-heapnumber.svg" alt></p><p>现在开始执行下面的Javascript片段:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">o.x += <span class="number">10</span>;</span><br><span class="line"><span class="comment">// → o.x 现在是 52</span></span><br><span class="line">o.y += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// → o.y 现在是 5.2</span></span><br></pre></td></tr></table></figure><p>这种情况下，<code>x</code>的值可以被原地(in-place)更新，因为新的值<code>52</code>还是符合<code>Smi</code>的范围.</p><p><img src="/images/react-cliff/05-update-smi.svg" alt></p><p>然而，新值<code>y=5.2</code>不符合<code>Smi</code>，且和之前的值<code>4.2</code>不一样，所以V8必须分配一个新的<code>HeapNumber</code>实体，再赋值给y。</p><p><img src="/images/react-cliff/06-update-heapnumber.svg" alt></p><p><code>HeapNumber</code>是不可变的，这也让某些优化成为可能。举个例子，如果我们将y的值赋给x:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">o.x = o.y;</span><br><span class="line"><span class="comment">// → o.x 现在是 5.2</span></span><br></pre></td></tr></table></figure><p>…我们现在可以简单地链接到同一个HeapNumber，而不是分配一个新的.</p><p><img src="/images/react-cliff/07-heapnumbers.svg" alt></p><p><code>HeapNumbers</code>不可变的一个缺点是，频繁更新字段不在<code>Smi</code>范围内的值会比较慢，如下例所示:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 `HeapNumber` 实例.</span></span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">0.1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 创建另一个 `HeapNumber` 实例.</span></span><br><span class="line">  o.x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行通过初始化值<code>0.1</code>创建一个<code>HeapNumber</code>实例。循环体将它的值改变为<code>1.1</code>、<code>2.1</code>、<code>3.1</code>、<code>4.1</code>、最后是<code>5.1</code>，这个过程总共创建了6个<code>HeapNumber</code>实例，其中5个会在循环结束后被垃圾回收。</p><p><img src="/images/react-cliff/08-garbage-heapnumbers.svg" alt></p><p>为了避免这个问题，V8也提供了一种机制来原地更新非<code>Smi</code>数字字段作为优化。当一个数字字段保存的值超出了<code>Smi</code>的范围后，V8会在<code>Shape</code>中将这个字段标记为<code>Double</code>, 并且分配一个称为<code>MutableHeapNumber</code>实体来保存实际的值。</p><p><img src="/images/react-cliff/09-mutableheapnumber.svg" alt></p><blockquote><p>译注: 关于<code>Shape</code>是什么，可以阅读这篇<a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">文章</a>, 简单说<code>Shape</code>就是一个对象的‘外形’，JavaScript引擎可以通过<code>Shape</code>来优化对象的属性访问。</p></blockquote><p>现在当字段的值变动时，V8不需要在分配一个新的<code>HeapNumber</code>，而是直接原地更新<code>MutableHeapNumber</code>.</p><p><img src="/images/react-cliff/10-update-mutableheapnumber.svg" alt></p><p>然而，这种方式也有一个缺陷。因为MutableHeapNumber的值可以被修改，所以这些值不能安全传递给其他变量</p><p><img src="/images/react-cliff/11-mutableheapnumber-to-heapnumber.svg" alt></p><p>举个例子，如果你将<code>o.x</code>赋值给其他变量<code>y</code>，你可不想下一次<code>o.x</code>变动时影响到<code>y</code>的值 —— 这违反了JavaScript规范！因此，当<code>o.x</code>被访问后，在将其赋值给<code>y</code>之前，必须将该数字重新装箱(re-boxed)成一个常规的<code>HeapNumber</code>。</p><p>对于浮点数，V8会在背后执行所有上面提到的“包装(boxing)”魔法。但是对于小整数来说，使用<code>MutableHeapNumber</code>就是浪费，因为<code>Smi</code>是更高效的表示。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// → 不需要‘包装’x字段</span></span><br><span class="line"></span><br><span class="line">object.x += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// → 直接在对象内部更新</span></span><br></pre></td></tr></table></figure><p>为了避免低效率，对于小整数，我们必须在<code>Shape</code>上将该字段标记为<code>Smi</code>表示，只要符合小整数的范围，我们就可以简单地原地更新数字值。</p><p><img src="/images/react-cliff/12-smi-no-boxing.svg" alt></p><p><br></p><h2 id="shape-废弃和迁移"><a href="#shape-废弃和迁移" class="headerlink" title="Shape 废弃和迁移"></a>Shape 废弃和迁移</h2><p>那么，如果一个字段初始化时是<code>Smi</code>，但是后续保存了一个超出小整数方位的值呢？比如下面这种情况，两个对象都使用相同的<code>Shape</code>，即<code>x</code>在初始化时表示为<code>Smi</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// → 对象现在将 `x`字段 表示为 `Smi`</span></span><br><span class="line"></span><br><span class="line">b.x = <span class="number">0.2</span>;</span><br><span class="line"><span class="comment">// → `b.x` 现在表示为 `Double`</span></span><br><span class="line"></span><br><span class="line">y = a.x;</span><br></pre></td></tr></table></figure><p>一开始两个对象都指向同一个<code>Shape</code>，<code>x</code>被标记为<code>Smi</code>表示：</p><p><img src="/images/react-cliff/13-shape.svg" alt></p><p>当<code>b.x</code>修改为<code>Double</code>表示时，V8会分配一个新的<code>Shape</code>，将<code>x</code>设置为<code>Double</code>表示，并且它会指向回<code>空Shape</code>(译注：Shape是树结构)。另外V8还会分配一个<code>MutableHeapNumber</code>来保存<code>x</code>的新值<code>0.2</code>. 接着我们更新对象<code>b</code>指向新的<code>Shape</code>，并且修改对象的<code>x</code>指向刚才分配的<code>MutableHeapNumber</code>。最后，我们标记旧的<code>Shape</code>为废弃状态，并从转换树(transition tree)中移除。这是通过将<code>“x”</code>从空<code>Shape</code>转换为新创建的<code>Shape</code>的方式来完成的。</p><p><img src="/images/react-cliff/14-shape-transition.svg" alt></p><p>这个时候我们还不能完全将<code>旧Shape</code>删除掉，因为它还被<code>a</code>使用着，而且你不能着急遍历内存来找出所有指向<code>旧Shape</code>的对象，这种做法太低效。所以V8采用惰性方式: 对于<code>a</code>的任意属性的访问和赋值，会首先迁移到新的<code>Shape</code>。这样做, 最终可以将废弃的Shape变成‘不能到达(unreachable)’, 让垃圾回收器释放掉它。</p><p><img src="/images/react-cliff/15-shape-deprecation.svg" alt></p><p>如果修改表示的字段不是链中的最后一个字段，则会出现更棘手的情况：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span>,</span><br><span class="line">  z: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.y = <span class="number">0.1</span>;</span><br></pre></td></tr></table></figure><p>这种情况，V8需要找到所谓的<code>分割Shape</code>(split shape), 即相关属性在被引入到<code>Shape</code>链之前的<code>Shape</code>。这里我们修改的是<code>y</code>，所以我们可以找到引入<code>y</code>之前的最后一个<code>Shape</code>，在上面的例子中这个<code>Shape</code>就是<code>x</code>：</p><p><img src="/images/react-cliff/16-split-shape.svg" alt></p><p>从<code>分割Shape</code>(即x)开始，我们为y创建一个新的转换链, 它将y标记为<code>Double</code>表示，并重放(replay)之前的其他转换. 我们将对<code>y</code>应用这个新的转换链，将旧的树标记为废弃。在最后一步，我们将实例<code>o</code>迁移到新的<code>Shape</code>，现在使用一个<code>MutableHeapNumber</code>来保存<code>y</code>的值。后面新创建的对象都不会使用旧的<code>Shape</code>的路径，一旦所有旧<code>Shape</code>的引用都移除了，<code>Shape</code>树的废弃部分就会被销毁。</p><h2 id="可扩展性和完整性级别转换"><a href="#可扩展性和完整性级别转换" class="headerlink" title="可扩展性和完整性级别转换"></a>可扩展性和完整性级别转换</h2><p><code>Object.preventExtensions()</code>阻止新的属性添加到对象中, 否则它就会抛出异常。(如果你不在严格模式，它将不会抛出异常，而是什么都不干)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(object);</span><br><span class="line">object.y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot add property y;</span></span><br><span class="line"><span class="comment">//            object is not extensible</span></span><br></pre></td></tr></table></figure><p><code>Object.seal</code>和<code>Object.preventExtensions</code>类似，只不过它将所有属性标记为<code>non-configurable</code>, 这意味着你不能删除它们, 或者改变它们的<code>Configurable</code>、<code>Enumerable</code>、<code>Writable</code>属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(object);</span><br><span class="line">object.y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot add property y;</span></span><br><span class="line"><span class="comment">//            object is not extensible</span></span><br><span class="line"><span class="keyword">delete</span> object.x;</span><br><span class="line"><span class="comment">// TypeError: Cannot delete property x</span></span><br></pre></td></tr></table></figure><p><code>Object.freeze</code>和<code>Object.seal</code>差不多, 只不过它还会阻止已存在的属性被修改。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(object);</span><br><span class="line">object.y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot add property y;</span></span><br><span class="line"><span class="comment">//            object is not extensible</span></span><br><span class="line"><span class="keyword">delete</span> object.x;</span><br><span class="line"><span class="comment">// TypeError: Cannot delete property x</span></span><br><span class="line">object.x = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot assign to read-only property x</span></span><br></pre></td></tr></table></figure><p>让我们考虑这样一个具体的例子，下面两个对象都包含单个<code>x</code>属性，后者还阻止了对象扩展。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(b);</span><br></pre></td></tr></table></figure><p>我们都知道它一开始会从空<code>Shape</code>转换为一个包含<code>x</code>(表示为Smi)的新<code>Shape</code>。当我们阻止<code>b</code>被扩展时，我们会执行一项特殊的转换，创建一个新的<code>Shape</code>并标记为’不可扩展’。这个特殊的转换不会引入任何新的属性 —— 它只是一个标记</p><p><img src="/images/react-cliff/17-shape-nonextensible.svg" alt></p><p>注意，我们不能原地更新<code>x</code>的<code>Shape</code>，因为它还被<code>a</code>对象引用，<code>a</code>对象还是可扩展的。</p><p><br></p><h2 id="react的性能问题"><a href="#react的性能问题" class="headerlink" title="React的性能问题"></a>React的性能问题</h2><p>让我们将上述所有东西都放在一起，用我们学到的知识来理解<a href="https://github.com/facebook/react/issues/14365" target="_blank" rel="noopener">最近的React Issue #14365</a>. 当React团队在分析一个真实的应用时，他们发现了V8一个影响React 核心的奇怪性能问题. 下面是这个bug的简单复现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(o);</span><br><span class="line">o.y = <span class="number">0.2</span>;</span><br></pre></td></tr></table></figure><p>一开始我们这个对象有两个<code>Smi</code>表示的字段。接着我们还阻止了对象扩展，最后还强制将第二个字段转换为<code>Double</code>表示。</p><p>按照我们上面描述的，这大概会创建以下东西：</p><p><img src="/images/react-cliff/18-repro-shape-setup.svg" alt></p><p>两个属性都会被标记为<code>Smi</code>表示，最后一个转换是可扩展性转换，用于将Shape标记为不可扩展。</p><p>现在我们需要将<code>y</code>转换为<code>Double</code>表示，这意味着我们又要开始找出<code>分割Shape</code>. 在这个例子中，<code>分割Shape</code>就是引入<code>x</code>的那个<code>Shape</code>。但是V8会有点迷惑，因为<code>分割Shape</code>是可扩展的，而当前<code>Shape</code>却被标记为不可扩展。在这种情况下，V8并不知道如何正确地重放转换。所以V8干脆上放弃了尝试理解它，直接创建了一个单独的Shape，它没有连接到现有的Shape树，也没有与任何其他对象共享。可以把它想象成一个<code>孤儿Shape</code>：</p><p><img src="/images/react-cliff/19-orphaned-shape.svg" alt></p><p>你可以想象一下，如果有很多对象都这样子有多糟糕，这会让整个<code>Shape</code>系统变得毫无用处。</p><p>在React的场景中，每个FiberNode在打开分析器时都会有好几个字段用于保存时间戳.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node1 = <span class="keyword">new</span> FiberNode();</span><br><span class="line"><span class="keyword">const</span> node2 = <span class="keyword">new</span> FiberNode();</span><br></pre></td></tr></table></figure><p>这些字段(例如actualStartTime)被初始化为0或-1，即一开始时是<code>Smi</code>表示。后来，这些字段赋值为<code>performance.now()</code>输出的时间戳，这些时间戳实际是浮点型的。因为不符合<code>Smi</code>范围，它们需要转换为<code>Double</code>表示。恰好在这里，React还阻止了FiberNode实例的可扩展性。</p><p>上面例子的初始状态如下:</p><p><img src="/images/react-cliff/20-fibernode-shape.svg" alt></p><p>按照我们设想的一样, 这两个实例共享了同一个Share树. 后面，当你保存真正的时间戳时，V8找到<code>分割Shape</code>就迷惑了：</p><p><img src="/images/react-cliff/21-orphan-islands.svg" alt></p><p>V8给<code>node1</code>分配了一个新的<code>孤儿Shape</code>，<code>node2</code>同理，这样就生成了两个孤岛，每个孤岛都有自己不相交的Shape。大部分真实的React应用有上千上万个FiberNode。可以想象到，这种情况对V8的性能不是特别乐观。</p><p>幸运的是，我们在V8 <a href="https://v8.dev/blog/v8-release-74" target="_blank" rel="noopener">v7.4</a>修复了这个<a href="https://chromium-review.googlesource.com/c/v8/v8/+/1442640/" target="_blank" rel="noopener">性能问题</a>, 我们也正在研究<a href="https://bit.ly/v8-in-place-field-representation-changes" target="_blank" rel="noopener">如何降低修改字段表示的成本</a>，以消灭剩余的性能瓶颈. 经过修复后，V8可以正确处理这种情况:</p><p><img src="/images/react-cliff/22-fix.svg" alt></p><p>两个FiberNode实例都指向了’actualStartTime’为<code>Smi</code>的不可扩展<code>Shape</code>. 当第一次给<code>node1.actualStartTime</code>赋值时，将创建一个新的转换链，并将之前的链标记为废弃。</p><p><img src="/images/react-cliff/23-fix-fibernode-shape-1.svg" alt></p><p>注意, 现在扩展性转换可以在新链中正确重放。</p><p><img src="/images/react-cliff/24-fix-fibernode-shape-2.svg" alt></p><p>在赋值<code>node2.actualStartTime</code>之后，两个节点都引用到了新的Shape，转换树中废弃的部分将被垃圾回收器回收。</p><p>在Bug未修复之前，React团队通过确保FiberNode上的所有时间和时间段字段都初始化为Double表示，来缓解了这个问题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 在一开始强制为Double表示.</span></span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="built_in">Number</span>.NaN;</span><br><span class="line">    <span class="comment">// 后面依旧可以按照之前的方式初始化值</span></span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node1 = <span class="keyword">new</span> FiberNode();</span><br><span class="line"><span class="keyword">const</span> node2 = <span class="keyword">new</span> FiberNode();</span><br></pre></td></tr></table></figure><p>除了<code>Number.NaN</code>, 任何浮点数值都不在<code>Smi</code>的范围内, 可以用于强制<code>Double</code>表示。例如<code>0.000001</code>, <code>Number.MIN_VALUE</code>, <code>-0</code>和<code>Infinity</code></p><p>值得指出的是，这个具体的React bug是V8特有的，一般来说，开发人员不应该针对特定版本的JavaScript引擎进行优化。不过，当事情不起作用的时候有个把柄总比没有好。</p><p>记住这些Javascript引擎背后执行的一些魔法，<strong>如果可能，尽量不要混合类型，举个例子，不要将你的数字字段初始化为null，因为这样会丧失跟踪字段表示的所有好处</strong>。不混合类型也可以让你的代码更具可读性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Don’t do this!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">null</span>;</span><br><span class="line">  y = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line">p.x = <span class="number">0.1</span>;</span><br><span class="line">p.y = <span class="number">402</span>;</span><br></pre></td></tr></table></figure><blockquote><p>译注：如果你使用Typescript，应该开启strictNull模式</p></blockquote><p>换句话说，编写高可读的代码，是可以提高性能的！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们深入讨论了下列内容：</p><ul><li>JavaScript 区分了‘原始类型’和‘对象类型’，typeof是一个骗子</li><li>即使是相同Javascript类型的值，底层可能有不同的表示</li><li>V8尝试给你的Javascript程序的每个属性找出一个最优的表示</li><li>我们还讨论了V8是如何处理Shape废弃和迁移的，另外还包括扩展性转换</li></ul><p>基于这些知识，我们总结出了一些可以帮助提升性能的JavaScript编程技巧：</p><ul><li>始终按照一致的方式初始化你的对象，这样Shape会更有效</li><li>为字段选择合理的初始值，以帮助JavaScript引擎选择最佳的表示。</li></ul><p><br><br><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;译注: 原文作者是&lt;a href=&quot;https://twitter.com/mathias&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mathias Bynens&lt;/a&gt;, 他是V8开发者，这篇文章也发布在&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端团队 Leader，怎么做好概要设计</title>
    <link href="https://bobi.ink/2019/09/06/fe-design/"/>
    <id>https://bobi.ink/2019/09/06/fe-design/</id>
    <published>2019-09-05T16:00:00.000Z</published>
    <updated>2019-09-26T23:20:18.993Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范?</a>在掘金目前已经突破740个👍了, 谢谢大家的支持，这篇文章是前者延展。继续介绍我在前端团队管理方面的思考和探索。</p><p>软件工程中有一个软件设计阶段，通俗的讲就是在开工之前将能确定的确定下来，把该考虑的考虑了。这相比在开发阶段发现问题，解决的成本要低很多。</p><p>如果按照教科书上的定义，软件设计就是<strong>是一个将需求转变为软件陈述（表达）的过程</strong>。一般有<strong>概要设计(或者初步设计， Preliminary design)</strong>和<strong>详细设计(Detail design)</strong>. 概要设计将需求转换成数据和软件框架，而详细设计将框架逐步求精细化为具体的数据结构和软件的算法表达。本文讲述的是前端项目的概要设计。</p><p>相比后端开发, 对于前端，’软件设计‘很少被提及，也有可能是一直以来前端的工作都比较’简单’，所以比较粗放。一般给了原型和接口文档就直接开干了。但是随着前端开发者的工作越来越复杂，或者项目/团队的规模变大，我们越来越需要在编码之前进行合理的设计。</p><p>作为<strong>前端入门Leader</strong>, 最近面临了一些问题: 比如项目分工问题、项目维护缺乏文档问题, 让我开始重视软件设计阶段. 就目前看来，做好前端<strong>概要设计</strong>，至少有以下好处:</p><ul><li><strong>事前</strong>. 设计文档是开发的蓝图，后续开发可以按照这个文档逐步展开。良好的设计可以保证开发沿着正常轨道迈进。<ul><li>我们在设计阶段会进一步梳理业务流程，加深对业务流程的理解，甚至可以找出业务流程中的不合理的东西。</li><li>模块拆分。这个阶段我们会识别各个模块之间边界和重叠，将重叠的(共享的)部分抽离出来。另外模块是基本的开发工作单元，也是我们团队分工和时间评估的基础。</li><li>考察关键的技术点。提出多种备选方案，充分考虑各种风险, 选择符合实际需求的方案</li></ul></li><li><strong>事后</strong>. 设计文档对事后的软件维护、功能新增，有很大的帮助</li></ul><p><br></p><p>下面开始介绍，前端在<strong>软件设计阶段</strong>应该考虑东西，或者说前端的<code>概要设计文档</code>里面应该包含哪些东西. 当然这些只是一些初步的想法，随着后面深入实践后，本文会持续更新迭代.</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#关键业务流程的梳理">关键业务流程的梳理</a></li><li><a href="#关键技术点">关键技术点</a></li><li><a href="#模块设计">模块设计</a><ul><li><a href="#入口层">入口层</a></li><li><a href="#页面层">页面层</a></li><li><a href="#组件层">组件层</a></li><li><a href="#分工">分工</a></li></ul></li><li><a href="#状态设计">状态设计</a></li><li><a href="#接口设计">接口设计</a></li><li><a href="#版本规划">版本规划</a></li><li><a href="#验证">验证</a></li><li><a href="#项目要求和目标">项目要求和目标</a></li><li><a href="#文档索引">文档索引</a></li><li><a href="#构建说明">构建说明</a></li><li><a href="#持续迭代">持续迭代</a></li><li><a href="#模板">模板</a></li><li><a href="#总结">总结</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><p><br></p><p><strong>系列文章</strong></p><ul><li><a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范? 🔥</a></li><li><a href="https://juejin.im/post/5d71cec6e51d4561b674c4d0" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么做好概要设计</a></li><li><a href="https://juejin.im/post/5d8d4557e51d4577fe41b62d" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么用好看板进行任务管理?</a></li></ul><p><br></p><blockquote><p>这方面我的经验实践比较少, 也没有在大厂待过，所以本文只是我的一些思考和尝试, 可能不太现实。如果你或你的团队有这方面的更好的实践，欢迎分享给我。感激🙏</p></blockquote><p><br><br><br></p><h2 id="关键业务流程的梳理"><a href="#关键业务流程的梳理" class="headerlink" title="关键业务流程的梳理"></a>关键业务流程的梳理</h2><p>开发任何一个产品之前，首先要确保的是对业务流程的理解，否则就会出现南辕北辙的情况。</p><p>在现实项目中发生过多次这类情况：<em>项目到达测试阶段，测试人员才发现应用的业务实现和产品定义不一样，或者业务流程不合理</em>。<br>这其实是一种很低级的失误，改动的成本可能很高，甚至会让你的所有工作白干。</p><p>管理比较成熟的公司会有很多手段来规避这种失误。</p><p>比如定义明确需求文档，这方面可以模仿一些标准/规范(Spec)的写作方法，严格定义一些关键字，避免模棱两可的描述;</p><p>另外可以通过各种宣贯会议，将相关人员聚集在一起，统一导入需求。在这些会议中可以进行头脑风暴，优化或细化需求的定义、发现缺陷和风险，分析可行性等等。通过不断沟通，成员之间可以分享交叉知识，确保对业务一致理解.</p><p><img src="/images/fe-design/doc.png" alt></p><p><br></p><p>因此，我觉得<strong>前端在设计阶段也应该像后端一样，用流程图或者时序图这类工具，将关键业务流程描述清楚. 尤其是涉及到前后端, 跨系统/跨页面/跨终端之间的业务交互的场景</strong>.</p><p>举个例子，比如我们在做一个’扫码登录‘功能。我们可以将跨终端的业务梳理出来：</p><p><img src="/images/fe-design/scan-login.png" alt></p><p><br></p><p>从上面的业务梳理中我们可以识别出业务对象的基本行为和状态. 例如二维码的状态转换图:</p><p><img src="/images/fe-design/scan-login-state.png" alt></p><p><br></p><p>当然, 简单的增删查改花篇幅去阐述没有意义。<strong>我们只关注应用关键的业务流程</strong>.</p><p>总之，业务流程的梳理，可以加深我们对业务的理解，是后续设计步骤和开发的基础.</p><p><br><br><br></p><h2 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h2><p>描述应用采用的或者涉及到关键技术/算法, 也可以认为是<strong>技术选型</strong>.</p><p>比如典型的有视频直播应用，涉及到的各种直播方案:</p><ul><li>RTMP 协议</li><li>RTP协议</li><li>HLS 协议</li><li>flv.js</li><li>WebRTC协议</li><li>等等</li></ul><p><strong>在开启一个项目之前, 我们需要对项目涉及到的关键技术点进行调研和测试，最好多找几个替代方案，横向地比较它们的优势和劣势</strong>。选择符合项目或团队自己情况的方案. 如果时间充足, 可以写一些Demo，实地踩一下坑.</p><p>如果有多个备选方案，最后要甄选出推荐方案，并说明选择的原因和考虑。</p><p><strong>提前做好技术的调研和选型，确定可行性，不至于开发处于被动的境地</strong>.</p><p>关于如何进行技术选型，我在<a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed#heading-10" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范?</a>进行了简单的讨论，可以参考一下.</p><p><br><br><br></p><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>现代前端一般都使用<strong>组件化思维</strong>进行开发，<strong>这时候我们的应用其实就是一颗由不同粒度的组件复合起来的组件树</strong>，这颗组件树最终会体现到项目的目录结构上。 <strong>在设计阶段我们可以根据产品原型或UI设计稿，识别出各种页面和组件</strong>。</p><p><img src="/images/fe-design/module-tree-map.png" alt></p><p>正常的应用，我们可以分三个层级进行拆分:</p><p><img src="/images/fe-design/module.png" alt></p><h3 id="入口层"><a href="#入口层" class="headerlink" title="入口层"></a>入口层</h3><p>稍微复杂一点的应用可能有多个入口，这些入口呈现的页面可能差异很大. 下面是一个常见的划分方法:</p><ul><li>按子系统划分: 比如前台和后台。</li><li>按角色划分：比如管理员、普通用户</li><li>按入口划分：比如移动端、桌面端等等</li></ul><p><br></p><h3 id="页面层"><a href="#页面层" class="headerlink" title="页面层"></a>页面层</h3><p>下一步就是识别各种页面，这些页面即对应到我们的前端路由配置规则. 以下面简单的应用为例:</p><p><img src="/images/fe-design/sample-pages.png" alt></p><p>关于模块的划分，我建议使用<strong>思维导图</strong>进行组织。<strong>模块划分这个环节，你可以召集团队的其他成员开个会议，一起进行头脑风暴。大家参照着产品原型，识别出各种模块或组件的边界和交集, 讨论怎么设计页面的数据流、组件的接口等等</strong>, 这样可以利用集体智慧，让模块拆分更加合理，另外可以促进团队成员提前熟悉项目的结构。</p><p>所以说<strong>软件设计不是架构师或设计人员一个人的事，应该鼓励大家一起参与，设计文档是整个软件团队的产出, 是团队的知识沉淀</strong>。</p><p>上面的应用通过页面层划分后，结果大概如下：</p><p><img src="/images/fe-design/pages.png" alt></p><p>在这个阶段我们会确定以下内容:</p><ul><li><strong>页面以及路由设计, 确定页面之间的层级关系</strong></li><li><strong>页面之间交互流程、数据传递</strong></li></ul><p><strong>关于路由设计，可以遵循一些规范，笔者比较推荐<a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">Restful URL规范</a></strong>, 这篇<a href="https://novoland.github.io/设计/2015/08/17/Restful%20API%20的设计规范.html" target="_blank" rel="noopener">文章</a>写得也不错.</p><p>路由之间的数据传递一般有以下几种方式:</p><ul><li>少量数据：可以通过路由变量(例如<code>/posts/:id</code>)或者查询字符串形式传递. 还有如果你使用的是<a href="https://react-router.docschina.org/web/api/BrowserRouter" target="_blank" rel="noopener">基于History API的前端路由模式</a>，可以使用History的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">state</a>对象来存储一些状态(最大640k)</li><li>大量数据：可以通过全局变量，或者状态管理器的机制进行存储, 不管这种存储在内存的方式，一旦页面刷新就会丢失。所以也可以考虑存储在本地缓存中, 例如LocalStorage</li></ul><p><br></p><h3 id="组件层"><a href="#组件层" class="headerlink" title="组件层"></a>组件层</h3><p>Ok，再往下拆分，不过要量力而行。对于一个非常复杂的项目来说，可能有成千上百个组件，而且这些组件在未来可能会不断变化，在设计阶段考虑这些拆分可能需要花费很多时间，而且收益并不明显。</p><p>那么需要怎么把握粒度呢？其实组件层设计阶段的主要目的是<strong>找出重复的、或者结构类似的组件，将它们抽取出来统一的设计，在多个页面进行复用. 并不是把所有的组件都列举出来</strong>。</p><p>我在<a href="https://juejin.im/post/5cd8fb916fb9a03218556fc1" target="_blank" rel="noopener">React组件设计实践总结02 - 组件的组织</a>这篇文章中，专门介绍React组件如何进行组织和拆分。其中提出了以下集中模式:</p><ul><li>容器组件和展示组件分离。或者说分离视图和逻辑, 业务组件和傻瓜组件. 纯逻辑的东西放在Hooks中，使用起来会更加方便</li><li>纯组件和非纯组件. 可以认为纯组件完全依赖外部输入</li><li>有状态组件和无状态组件</li><li>布局组件和内容组件</li><li>统一设计同一类型组件的接口. 比如表单组件应该保持接口统一</li></ul><p><img src="/images/fe-design/sample-pages2.png" alt></p><p>还是上面的示例应用，申报页面有非常多的表单项，而且经常变动，另外你会发现它和预览页面的结构是差不多的，而且后面可能会有桌面端页面。</p><p>经过讨论，我们决定采用配置文件的方式来动态渲染表单页和预览页。实现一套配置控制移动端申请表单、桌面端申请表单、移动端预览、桌面端预览页面。</p><p>类似上面这种应用场景，前期的组件层设计就很有必要了。</p><p><br></p><p><img src="/images/fe-design/components.png" alt></p><p><br></p><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>将模块拆分清楚后，我们就可以针对这些模块进行合理的分工和时间评估。基本上有三个步骤：</p><p><img src="/images/fe-design/module-plan.png" alt></p><p>通过上面的步骤，我们识别出来了各种模块，接着我们要确定下来这些模块之间的依赖关系，这些依赖关系影响它们是否要作为一个整体进行实现。最后再根据业务的优先级或依赖关系决定这些<strong>模块簇</strong>的实现优先级。</p><p>Ok, 现在可以将这些模块簇按照优先级排序, 加上评估时间(人天)，整理成一个清单。 如果你们使用看板来进行项目管理, 可以将它们作为一个任务单元，贴到看板中.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. Foo 功能</span><br><span class="line">  - c 2d</span><br><span class="line">  - d 1d</span><br><span class="line">  - f 3d</span><br><span class="line">2. Bar 功能</span><br><span class="line">  - e 1d</span><br><span class="line">  - h 0.5d</span><br><span class="line">3. Baz 功能</span><br><span class="line">  - g 1d</span><br><span class="line">4. Fu 功能</span><br><span class="line">  - a 4d</span><br><span class="line">  - b 1d</span><br><span class="line"></span><br><span class="line">总计人天: 13.5</span><br></pre></td></tr></table></figure><p><br></p><p>任务的分工有很多策略, 例如：</p><ul><li>横向划分<ul><li>公共组件 vs 业务组件(对接业务)</li><li>自上而下 vs 自下而上(指的是组件树)</li></ul></li><li>垂直划分: 按照独立的垂直模块分工</li></ul><p><img src="/images/fe-design/module-tree.png" alt></p><p><br><br><br></p><h2 id="状态设计"><a href="#状态设计" class="headerlink" title="状态设计"></a>状态设计</h2><p><img src="/images/fe-design/redux.png" alt></p><p>前端组件化伴随而来的是各种<code>数据驱动</code>或<code>数据流驱动</code>的开发模式。这种模式下，前端应用可以总结为这样一个等式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view = f(state)</span><br></pre></td></tr></table></figure><p>也就是说<strong>视图是数据或者数据流的映射</strong>. 可见状态管理对现代前端开发的重要性。</p><p>状态的设计和后端对象模型设计差不多。<strong>你需要根据业务和页面渲染要求抽象出各种对象模型，以及缕清对象模型之间的关系</strong>。这个阶段可能需要和后端紧密结合，才能确定出合理的对象结构。</p><p>当然状态的设计还跟你选择的状态管理方案也有关系, 不同状态管理器方案体现的思想差异较大：<em>如果你选择Redux，那么应用的状态就是一颗对象树；如果你选择Mobx，应用的状态可能由多个模型对象组成，更接近传统的OOP模式</em>。</p><p>如果采用OOP设计方法，可以绘制<code>UML</code>图，可视化表现对象的结构和关系:</p><p><img src="/images/fe-design/uml-sample.png" alt><br><i>(图片来源: <a href="https://zongren.me/2016/12/30/uml-diagram-sample/" target="_blank" rel="noopener">https://zongren.me/2016/12/30/uml-diagram-sample/</a>)</i></p><p><br></p><p>我在<a href="https://juejin.im/post/5ce3ee436fb9a07f070e0220" target="_blank" rel="noopener">React组件设计实践总结05 - 状态管理</a>这篇文章花了很多篇幅来介绍各种状态管理器的思想和开发模式, 所以这里就不展开了:</p><p><strong>Redux 状态设计</strong>:</p><p><img src="/images/fe-design/redux-design.png" alt></p><p><strong>Mobx 状态设计</strong>:</p><p><img src="/images/fe-design/mobx-design.png" alt></p><p><br><br><br></p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>如果前端团队在接口设计方面有主导权, 或者使用<a href="https://www.phodal.com/blog/architecture-101-bff-for-legacy-system-migrate/" target="_blank" rel="noopener">BFF架构(服务于前端的后端)</a>，在设计阶段我们需要对各类接口进行设计。</p><p>不过一般主导权都掌握在后端手里，因为前端对业务的关心程度较低，后端一般会综合考虑各端的接口需求、数据库存储效率、可维护性等多个方面来设计接口, 这时候前端就是接口的用户，我们有责任来验证后端接口是否符合需求.</p><p>我在<a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed#heading-45" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范?</a>已经提及了各种接口规范. 这里不予赘述。</p><p><br><br><br></p><h2 id="版本规划"><a href="#版本规划" class="headerlink" title="版本规划"></a>版本规划</h2><p>通过上面的步骤，我们基本已经了解我们需要做什么、需要花多久。接下来，</p><p>应该制定一个版本计划，对于一个大项目可以拆分为多个<strong>里程碑</strong>, 估计版本发布的时间. 加不加班就看你了，作为Leader要综合考虑各种影响因素，实事求是合理地安排版本发布计划。</p><p>这个发布计划可能还需要经过PM和项目经理审核, 作为前端项目，开发计划通常还依赖于后端团队.</p><p><img src="/images/fe-design/roadmap.png" alt></p><p><br></p><p>这个版本计划中会包含这些内容:</p><ul><li>版本号</li><li>发布时间</li><li>包含的主要模块</li></ul><p><br><br><br></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证，或者称为’测试指导‘。 除了测试团队提供的测试用例，从开发(白盒)的角度还需要注意哪些东西?</p><p>产品或者测试可能只会从业务的层次考虑应用的运行，我们需要从研发的角度，充分考虑各种<strong>异常情况</strong>、<strong>性能瓶颈</strong>、进行<strong>风险评估</strong>. 阐明风险的应对方案等待.</p><p>这些情况也可以反馈给测试团队，以完善测试的用例.</p><p><br></p><h2 id="项目要求和目标"><a href="#项目要求和目标" class="headerlink" title="项目要求和目标"></a>项目要求和目标</h2><p>一些需求是要提前确定下来的，对于前端来说，比较典型的就是浏览器兼容性要求。你可不要等到项目上线后，才跟我提用户要求兼容IE6!</p><p>这些项目要求可能会影响我们的开发成本、选型、测试和其他因素的评估。基本上，对于一个前端项目来说，这些要求是要提前问清楚的:</p><ul><li>浏览器兼容性</li><li>运行环境. 例如操作系统、小程序等等</li><li>时间点</li><li>性能指标要求. 例如首屏指标、数据量指标</li></ul><p><br><br><br></p><h2 id="文档索引"><a href="#文档索引" class="headerlink" title="文档索引"></a>文档索引</h2><p>前端项目开发可能会关联很多文档，这些文档是分散的，在设计文档中最好把它们聚合起来，方便查阅和引用. 例如:</p><ul><li>需求文档</li><li>DEMO, UI设计稿</li><li>测试用例</li><li>接口文档</li><li>UI设计规范文档</li><li>前端规范文档</li><li>…</li></ul><p><br><br><br></p><h2 id="构建说明"><a href="#构建说明" class="headerlink" title="构建说明"></a>构建说明</h2><p>如果你的项目需要设计构建流程，也可以在设计文档中简单提及。</p><p>例如<strong>如何编译和运行</strong>? <strong>如何测试和调试</strong>? <strong>如何部署或发布</strong>？ <strong>代码如何组织</strong>？<strong>开发工作流</strong>、<strong>编码约定</strong>等等</p><p>新成员通过这些说明可以快速上手开发.</p><p><br></p><h2 id="持续迭代"><a href="#持续迭代" class="headerlink" title="持续迭代"></a>持续迭代</h2><p>设计文档不是一次性的，它应该跟随项目不断的迭代，不然就失去了文档的意义。</p><p><br><br><br></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>最后，规范一些设计文档的格式和内容</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># XXX 概要设计文档</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 背景</span></span><br><span class="line"></span><br><span class="line">填写项目的背景, 或者开发或重构的目的/出发点.</span><br><span class="line"></span><br><span class="line"><span class="section">## 关键业务流程</span></span><br><span class="line"></span><br><span class="line">可以放置关键的业务流程图、状态图、对象图等等. 梳理关键的业务流程</span><br><span class="line"></span><br><span class="line"><span class="section">## 关键技术描述</span></span><br><span class="line"></span><br><span class="line">可选, 描述项目中使用到的关键技术、算法、选型结论等等</span><br><span class="line"></span><br><span class="line"><span class="section">## 模块拆分</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>入口</span><br><span class="line"><span class="bullet">- </span>页面路由</span><br><span class="line"><span class="bullet">- </span>组件设计</span><br><span class="line"></span><br><span class="line">可以使用思维导图描述</span><br><span class="line"></span><br><span class="line"><span class="section">## 状态设计</span></span><br><span class="line"></span><br><span class="line">描述应用涉及的关键领域对象, 比如外形、行为和关系. 如果是OOP方式，可以使用UML描述</span><br><span class="line"></span><br><span class="line"><span class="section">## 接口设计</span></span><br><span class="line"></span><br><span class="line">可选，如题</span><br><span class="line"></span><br><span class="line"><span class="section">## 项目要求和目标</span></span><br><span class="line"></span><br><span class="line">项目目标、运行环境、兼容性要求、性能指标等等</span><br><span class="line"></span><br><span class="line"><span class="section">## 验证</span></span><br><span class="line"></span><br><span class="line">可选, 风险评估、异常情况考虑、特殊测试规则、测试指导等等</span><br><span class="line"></span><br><span class="line"><span class="section">## 分工和版本计划</span></span><br><span class="line"></span><br><span class="line">可选, 可以在单独文档或者看板中维护</span><br><span class="line"></span><br><span class="line"><span class="section">## 构建说明</span></span><br><span class="line"></span><br><span class="line">可选, 项目组织、构建、测试说明</span><br><span class="line"></span><br><span class="line"><span class="section">## 文档索引</span></span><br><span class="line"></span><br><span class="line">相关文档的索引和链接</span><br><span class="line"></span><br><span class="line"><span class="section">## 参考资料</span></span><br><span class="line"></span><br><span class="line">文档中索引页的外部参考资料</span><br><span class="line"></span><br><span class="line"><span class="section">## CHANGELOG</span></span><br><span class="line"></span><br><span class="line">列出本文档修改的历史纪录。必须指明修改的内容、日期以及修改人</span><br></pre></td></tr></table></figure><p>很多开发人员都不喜欢写文档，包括我以前也是这样的。我们会找各种借口：’时间紧张，没时间做设计‘、’用来写设计文档的时间，我的开发早就做完了‘。</p><p>这些想法显然是不正确的，给我的启示是<strong>我们要根据团队情况而定，不要求设计文档有多么详尽，在时间紧张的时候可以粗略一点。等时间充裕再回顾补充也是可以接受的; 或者如果项目划分为多个周期进行开发，我们也可以在每个周期开始时进行详细的设计</strong>。</p><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章差不多写完了，看到了知乎<a href="https://www.zhihu.com/people/zhang-ming-yun-88/activities" target="_blank" rel="noopener">@张明云</a><a href="https://www.zhihu.com/question/300407894" target="_blank" rel="noopener">现代软件开发中，详细设计这一步要如何来做？</a>下面的一个回答:</p><p><br></p><p><img src="/images/fe-design/zhihu.png" alt></p><p><br></p><p>和我上文所介绍基本吻合。一个软件’概要‘设计文档基本就包含这几大块。</p><p>本文完。</p><p><br></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.infoq.cn/article/how-to-write-a-good-software-design-document" target="_blank" rel="noopener">如何才能写出好的软件设计文档？</a></li><li><a href="https://blog.csdn.net/lori2004/article/details/80011806" target="_blank" rel="noopener">软件设计文档编写概述</a></li><li><a href="https://www.zhihu.com/question/300407894" target="_blank" rel="noopener">现代软件开发中，详细设计这一步要如何来做？</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d3a7134f265da1b5d57f1ed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;if 我是前端团队 Leader，怎么制定前端协作规范?&lt;/a&gt;在掘金目前已经突破740个👍了
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器和Node中的JavaScript是如何工作的? 可视化解释</title>
    <link href="https://bobi.ink/2019/08/29/js-bs/"/>
    <id>https://bobi.ink/2019/08/29/js-bs/</id>
    <published>2019-08-28T16:00:00.000Z</published>
    <updated>2019-08-30T15:12:30.729Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址: <a href="https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f" target="_blank" rel="noopener">How JavaScript works in browser and node?</a></p><p>有非常多满怀激情的开发者，他们搞前端或者搞后端，为JavaScript奉献自己青春和血汗。JavaScript是一种非常容易理解语言，毫无疑问它是前端开发中一个非常关键的部分。但是和其他语言不同的是， 它是单线程的，这就意味着，同一时间只能有一个代码片段在执行。因为代码执行是线性的，如果当中有任何代码执行很长时间，将会阻塞后面需要被执行的代码。因此有时候你会在Google Chrome中看到这样的界面:</p><p><br></p><p><img src="/images/js-bs/crashed.png" alt></p><p><br></p><p>当你在浏览器打开一个网站时，它会使用一个JavaScript执行线程。这个线程负责响应一切操作，比如页面滚动、页面渲染、监听DOM事件(比如用户点击按钮)等等。但是如果JavaScript执行被阻塞了，那浏览器就什么事情也做不了，即意味着浏览器会呈现为卡死，无法响应的现象。</p><p>不信你就在控制台输入试试:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>你会上面语句之后的任何代码都不会被执行，这个‘死循环’会霸占着系统资源, 让浏览器无法响应用户操作. 无限递归调用也会出现这种情况, 不过下文会介绍，Javascript引擎对调用栈长度进行限制，无限递归会抛出RangeError异常, 而不会无休止地运行。</p><p><br></p><p><img src="/images/js-bs/crashed2.png" alt></p><p><br></p><p>感谢现代浏览器，现在不是所有打开的标签页都依赖于一个JavaScript线程。而是每个标签页或者域名都会有独立的JavaScript线程。这样每个标签页之间不会互相阻塞。比如你可以在Chrome中打开多个标签页，在某个标签页下执行上面的死循环，你会发现只有执行了上面语句的标签卡死，其他不受影响。</p><p><br><br><br></p><h2 id="调用栈-call-stack"><a href="#调用栈-call-stack" class="headerlink" title="调用栈(Call Stack)"></a>调用栈(Call Stack)</h2><p>为了可视化JavaScript 如何执行程序，我们首先要理解JavaScript运行时。</p><p><img src="/images/js-bs/vis1.png" alt></p><p><br></p><p>和其他编程语言一样，JavaScript运行时有一个栈(Stack)和一个堆(Heap)存储器。</p><p><img src="/images/js-bs/stack-vs-heap.jpg" alt></p><p>上图来源于<a href="Confused about Stack and Heap?">Fhinkel</a>文章，关于栈和堆之间的差异讲得比较清晰. 举个例子:</p><p><em>在Java或者C#中， 值类型(primitives原始类型)存储在栈中，而引用类型(reference)则存储在堆中。C++规范没有规定栈和堆的内存分配，而是使用<code>自动存储(automatic)期</code>和<code>动态存储(dynamic)期</code>来作区分，局部变量是自动存储期，编译器会将它们存储在栈中。而动态分配的对象则通常保存在堆中。放在栈中的数据会在函数执行完毕后自动回收，而放在堆中的对象，如果没有释放就会造成<strong>内存泄露</strong></em></p><p><br></p><p>本文不会深入解释Heap，你可以看<a href="https://hashnode.com/post/does-javascript-use-stack-or-heap-for-memory-allocation-or-both-cj5jl90xl01nh1twuv8ug0bjk" target="_blank" rel="noopener">这里</a>. 在本文我们感兴趣的是栈，<strong>栈是一个LIFO(后进先出)的数据结构，用来保存程序当前的函数执行上下文, 换句话说，它表示的是当前程序执行的位置. 每次开始执行一个函数，就会将该函数推入栈中，当函数返回时从栈中弹出。 当栈为空时表示没有程序正在执行。所以栈常常也称为‘调用栈’</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Hello from baz'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>因此, 当上面的程序加载进内存时，会开始执行第一个函数，即<code>foo</code>。 因此第一个栈元素就是<code>foo()</code>, 因为<code>foo</code>函数会调用<code>bar</code>函数，第二个栈元素就是<code>bar()</code>; 同理<code>bar</code>函数会调用<code>baz</code>，第三个栈元素就是<code>baz()</code>. 最后，<code>baz</code>调用<code>console.log</code>，最后一个栈元素就是<code>console.log(&#39;Hello from baz&#39;)</code></p><p>栈会在函数执行完毕时(到达函数底部或者调用return)弹出。然后继续执行函数调用后续的语句:</p><p><img src="/images/js-bs/vis1.gif" alt></p><p><br></p><p>每个栈元素中，元素的状态也被称为栈帧(Stack Frame). 如果在函数调用抛出错误，JavaScript会输出栈跟踪记录(Stack trace)，表示代码执行时的栈帧的快照。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something went wrong.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的程序，我们在<code>baz</code>中抛出错误，JavaScript会打印出栈跟中记录，指出错误发生的地方和错误信息。</p><p><img src="/images/js-bs/err-msg.png" alt></p><p><br></p><p><strong>栈的大小不是无限的。例如Chrome就会限定栈的最大为16,000帧。所以无限递归会导致Chrome抛出<code>Maximum Call Stack size exceeded</code></strong>:</p><p><img src="/images/js-bs/overstack.png" alt></p><p><br><br><br></p><h2 id="事件循环与web-api"><a href="#事件循环与web-api" class="headerlink" title="事件循环与Web API"></a>事件循环与Web API</h2><p><strong>因为JavaScript是单线程的，所以它只有一个栈和堆</strong>。因此，如果其他程序想要执行一些东西，需要等待上一个程序执行完毕</p><p>对比其他语言，这可能是一个糟糕的设计，但是JavaScript的定位就是通用编程语言，而不是用于非常复杂的场景</p><p>考虑这样一个场景。假设浏览器发送一个HTTP请求到服务器，加载图片并展示到页面。浏览器会卡死等待请求完成吗？显然不会，这样用户体验太差了</p><p>浏览器通过JavaScript引擎来提供JavaScript运行环境。比如Chrome使用V8 引擎。但是浏览器内部可不只有JavaScript引擎。下面是浏览器的底层结构：</p><p><br></p><p><img src="/images/js-bs/underhood.png" alt></p><p><br></p><p>看起来很复杂，但是它也很好理解。JavaScript引擎需要和其他2个组件协作，即<strong>事件循环(EventLoop)</strong>和<strong>回调队列(CallbackQueue)</strong>，回调队列也被称为消息队列或任务队列。</p><p>除了JavaScript引擎，浏览器还包含了许多不同的应用来做各种各样的事情，比如HTTP请求、DOM事件监听、通过setTimeout、setInterval延迟执行、缓存、数据存储等等。这些特性可以帮助我们创建丰富的Web应用。</p><p>想一下，如果浏览器只使用同一个JavaScript线程来处理上面这些特性，用户体验会有多糟糕。因为用户即使只是简单的滚动页面，背后是需要处理很多事情的, 单个Javascript线程压根忙不过来。因此浏览器会使用低级的语言，比如C++，来执行这些操作，并暴露简洁的JavaScript API给开发者。这些API统称为<strong>Web API</strong>。</p><p><strong>这些Web API通常是异步的</strong>。这意味着，你可以命令这些API在’后台’(独立线程)去做一些事情，完成任务之后再通知Javascript运行时. 在此同时，Javascript引擎会继续执行剩下的JavaScript代码. 在命令这些API在后台做事情时，我们通常需要给它们提供一个回调。这个回调的职责就是在Web API完成任务后执行JavaScript代码。让我们将上述的所有东西整合起来理解一下:</p><p><img src="/images/js-bs/webapi-call.png" alt></p><p>当你调用一个函数时，它会被推进栈中。如果这个函数中包含了Web API调用，JavaScript会代理Web API的调用, 通知Web API执行任务，接着继续执行下一行代码直到函数返回。一旦函数到达return语句或者函数底部，这个函数就会从调用栈中弹出来。</p><p>与此同时，如果Web API在后台完成了它的工作，且有一个回调和这个工作绑定，Web API会将消息结果和回调进行绑定，并推入到消息队列中(或者称为回调队列).</p><p><strong>事件循环, 就像一个无限循环，它的唯一工作是检查回调队列，一旦回调队列中有待处理的任务，就将该回调推送到调用栈</strong>。不过因为Javascript是单线程的, 事件循环一次只能推送一个回调到调用栈，栈将会执行回调函数，<strong>一旦调用栈为空，事件循环才会将下一个回调函数推送到调用堆</strong>。</p><p>事件循环的伪代码大概如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> task</span><br><span class="line">   <span class="keyword">while</span>(task = popCallbackQueue()) &#123;<span class="comment">// 弹出回调队列任务</span></span><br><span class="line">      executeTask(task) <span class="comment">// 执行任务, 这里面可能会触发新的Web API调用</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasAnyPendingTask()) &#123;</span><br><span class="line">      sleep() <span class="comment">// 睡一觉，有新任务推送到回调队列时时再唤醒我哦</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span> <span class="comment">// 终止程序, 没什么好干的拜拜了</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我们通过setTimeout Web API这个例子一步一步看看上述的一切是怎么运作的。setTimeout Web API主要用于延时执行一些操作，但是回调真正被执行, 需要等待当前程序执行完毕(即栈为空), 也就是说，<strong>setTimeout函数回调执行时间未必等于你指定的延时时间</strong>。setTimeout的语法如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(callbackFunction, timeInMilliseconds);</span><br></pre></td></tr></table></figure><p>callbackFunction是一个回调函数，它将会在timeInMilliseconds之后执行. 我们修改上面的代码来调用setTimeout:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello from baz'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(printHello, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码延时调用了console.log. 栈还是会像之前一样，如<code>foo() =&gt; bar() =&gt; baz()</code>, 当baz开始执行并到达setTimeout时，Javascript会将回调函数传递给Web API，并且继续执行下一行。 因为这里没有下一行了，栈会弹出baz，接着弹出bar和foo。</p><p>在这期间，Web API正在进行3s等待，当时间到达时，它会将回调推进回调队列中。 因为这时候调用栈为空，事件循环会将这个回调推进栈中，并执行这个回调。</p><p><br></p><p><strong>🎉🎉<a href="http://latentflip.com/" target="_blank" rel="noopener">Philip Robers</a>创建了一个神奇的在线工具<a href="http://latentflip.com/loupe/" target="_blank" rel="noopener">Loupe</a>，来可视化Javascript的底层运行。上面的实例可以查看这个<a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gcHJpbnRIZWxsbygpIHsNCiAgICBjb25zb2xlLmxvZygnSGVsbG8gZnJvbSBiYXonKTsNCn0NCg0KZnVuY3Rpb24gYmF6KCkgew0KICAgIHNldFRpbWVvdXQocHJpbnRIZWxsbywgMzAwMCk7DQp9DQoNCmZ1bmN0aW9uIGJhcigpIHsNCiAgICBiYXooKTsNCn0NCg0KZnVuY3Rpb24gZm9vKCkgew0KICAgIGJhcigpOw0KfQ0KDQpmb28oKTs%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">链接</a>🎉🎉</strong></p><p><img src="/images/js-bs/vis2.gif" alt></p><p><strong>所以说我们Javascript是单线程的，但是很多Web API的执行是多线程的。也就是说Javascript的单线程指的是‘Javascript代码’的执行是单线程</strong>.</p><p><br></p><h2 id="node-js"><a href="#node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>通过Node.js我们可以做更多的事情, 而不仅限于浏览器的端。那么它是怎么运作的？</p><p>Node.js 和Chrome一样，同样使用Google的V8引擎来提供Javascript运行时. 它使用<a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>(C++编写)来和V8的事件循环配合，扩展更多可以在后台执行的东西, 比如文件系统I/O, 网络I/O。Node的标准库API遵循了浏览器Web API的类似回调风格。</p><p><img src="/images/js-bs/node.jpg" alt></p><p>如果你比较了浏览器和node的结构图，你会发现两者非常相似。右侧的部分类似于Web API，同样包含事件队列(或者称为回调队列/消息队列)和事件循环。</p><p>V8、事件循环、事件队列都在单线程中运行，最右侧还有工作线程(Worker Thread)负责提供异步的I/O操作。这就是为什么说Node.js拥有非阻塞的、事件驱动的异步I/O架构。</p><p>上面的内容都来源于<a href="http://latentflip.com/" target="_blank" rel="noopener">Philip Roberts</a>30min的高光<a href="https://youtu.be/8aGhZQkoFbQ" target="_blank" rel="noopener">演讲</a>(五年前)</p><p>本文完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址: &lt;a href=&quot;https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How JavaScript wor
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Typescript版图解Functor , Applicative 和 Monad</title>
    <link href="https://bobi.ink/2019/08/22/ts-fam/"/>
    <id>https://bobi.ink/2019/08/22/ts-fam/</id>
    <published>2019-08-21T16:00:00.000Z</published>
    <updated>2019-08-24T14:25:35.093Z</updated>
    
    <content type="html"><![CDATA[<p>本文是经典的<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures</a>的Typescript翻译版本。</p><p>Functor/Applicative/Monad是函数式编程中的一些比较‘基础’的概念，反正我是不认同‘基础’这个说法的，笔者也阅读过很多类似介绍Monad的文章，最后都不了了之，这些概念是比较难以理解的，而且平时编程实践中也很难会接触到这些东西。</p><p>后来拜读了<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures</a>, 不错，好像懂了。于是自己想通过翻译，再深入消化消化这篇文章，这里使用<code>Typescript</code>作为描述语言，对于前端来说会更好理解。</p><p>有理解不正确的地方，敬请指正. 开始吧！</p><p><br></p><p>这是一个简单的值:</p><p><img src="/images/ts-fam/value.png" alt></p><p>例如这些</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>        <span class="comment">// number</span></span><br><span class="line"><span class="string">'string'</span> <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>大家都知道怎么将一个函数应用到这个值上面:</p><p><img src="/images/ts-fam/value_apply.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// So easy</span></span><br><span class="line"><span class="keyword">const</span> add3 = <span class="function">(<span class="params">val: <span class="built_in">number</span></span>) =&gt;</span> val + <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(add3(<span class="number">2</span>)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>很简单了. 我们来扩展一下, 让任意的值是可以包装在一个<strong>上下文(context)</strong>当中. 现在的情况你可以想象一个可以把值放进去的盒子:</p><p><img src="/images/ts-fam/value_and_context.png" alt></p><p>现在你<strong>把一个函数应用到这个包装值的时候, 根据其上下文类型你会得到不同的结果</strong>. 这就是 <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, <code>Arrow</code> 之类概念的基础. </p><p><code>Maybe</code> 就是一个典型的数据类型, 它定义了两种相关的‘<strong>上下文</strong>’, Maybe本身也是一个‘上下文’(除了值，其他类型都可以是一个上下文？):</p><p><img src="/images/ts-fam/context.png" alt></p><p>原文基于Haskell，它的Maybe类型有两个上下文Just(蓝色盒子)和None(红色空盒子)。仿造Haskell在Typescript中我们可以使用<code>可选类型(Maybe)</code>来表示:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Maybe&lt;T&gt; = Just&lt;T&gt; | Nothing <span class="comment">// Just 表示值‘存在’，Nothing表示空值，类似于null、undefined的概念</span></span><br></pre></td></tr></table></figure><p>Just和Nothing的基本结构:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们只用None来取代null, 这里我们将None作为一个值，而不是一个类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> None &#123;&#125;</span><br><span class="line"><span class="comment">// 对应None的类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Nothing = <span class="keyword">typeof</span> None</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是Nothing，这里使用Typescript的 `Type Guards`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isNothing = (val: <span class="built_in">any</span>): val is Nothing =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> val === None</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Just类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Just&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> of&lt;T&gt;(val: T) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Just(val)</span><br><span class="line">  &#125;</span><br><span class="line">  value: T</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: Maybe&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">a = None;</span><br><span class="line">a = Just.of(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><blockquote><p>说实在这个实现有点挫, 但是为了更加贴近原文描述，暂且使用这个实现。之前考虑过的一个版本是下面这样的, 因为无法给它们扩展方法，就放弃了这个方案:<br>  <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Optional&lt;T&gt; = NonNullable&lt;T&gt; | nul</span><br><span class="line"><span class="keyword">let</span> a: Optional&lt;<span class="built_in">number</span>&gt; = <span class="number">1</span>;</span><br><span class="line">a = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p></blockquote><p><br></p><p>很快我们会看到对一个 <code>Just&lt;a&gt;</code> 和一个 Nothing 来说, 函数应用有何不同. 首先我们来看看 Functor!</p><p><br><br><br></p><h2 id="functors"><a href="#functors" class="headerlink" title="Functors"></a>Functors</h2><p>当一个值被包装在一个上下文中时, 你就不能拿普通函数来应用了:</p><p><img src="/images/ts-fam/no_fmap_ouch.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> a: Just&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add3 = <span class="function">(<span class="params">v: <span class="built_in">number</span></span>) =&gt;</span> v + <span class="number">3</span></span><br><span class="line">add3(a) <span class="comment">// ❌ 类型“Just&lt;number&gt;”的参数不能赋给类型“number”的参</span></span><br></pre></td></tr></table></figure><p>这时候, 该 <code>fmap</code> 出场了. fmap 翩翩而来，从容应对上下文(fmap is from the street, fmap is hip to contexts). 还有谁? fmap 知道怎样将一个函数应用到一个包装在上下文的值上. <strong>你可以对任何一个类型为 Functor 的类型使用 fmap</strong>， 换句话说，Functor都定义了fmap.</p><p>比如说, 想一下你想把 add3 应用到 Just 2. 用 fmap:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">2</span>).fmap(add3) <span class="comment">// Just 5</span></span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/fmap_apply.png" alt></p><p><strong>💥嘭！</strong> fmap 向我们展示了它的成果。 但是 fmap 怎么知道如何应用该函数的呢？</p><p><br></p><h2 id="究竟什么是-functor-呢？"><a href="#究竟什么是-functor-呢？" class="headerlink" title="究竟什么是 Functor 呢？"></a>究竟什么是 Functor 呢？</h2><p>在 Haskell 中 <code>Functor</code> 是一个<a href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101" target="_blank" rel="noopener">类型类(typeclass)</a>。 其定义如下：</p><p><img src="/images/ts-fam/functor_def.png" alt></p><p>在Typescript中， 一个Functor认为是<strong>定义了fmap的任意类型</strong>. 看看<code>fmap</code>是如何工作的:</p><p><img src="/images/ts-fam/fmap_def.png" alt></p><ol><li>一个Functor类型的 fa, 例如Just 2</li><li>fa 定义了一个fmap, fmap 接受一个函数fn，例如add3</li><li>fmap 直到如何将fa应用到fn中， 返回一个Functor类型的 fb. <strong>fa和fb的包装上下文类型一样</strong>, 例如fa是Just, 那么fb也是Just; 反之fa是Nothing，fb也是Nothing;</li></ol><p>用Typescript的函数签名描述一下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;Functor T&gt;.fmap&lt;U&gt;<span class="function">(<span class="params">fn: (<span class="params">val: T</span>) =&gt; U</span>): &lt;<span class="params">Functor</span> <span class="params">U</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们可以这么做：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">2</span>).fmap(add3) <span class="comment">// Just 5</span></span><br></pre></td></tr></table></figure><p>而 fmap 神奇地应用了这个函数，因为 Maybe 是一个 Functor, 它指定了 fmap 如何应用到 Just 上与 Nothing 上:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Just&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 实现fmap</span></span><br><span class="line">  fmap&lt;U&gt;<span class="function">(<span class="params">fn: (<span class="params">val: T</span>) =&gt; U</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">Just</span>.<span class="params">of</span>(<span class="params">fn(<span class="params"><span class="keyword">this</span>.value</span>)</span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">class</span> <span class="params">None</span> &#123;</span></span><br><span class="line"><span class="function">  // <span class="params">None</span> 接受任何函数都返回<span class="params">None</span></span></span><br><span class="line"><span class="function">  <span class="params">static</span> <span class="params">fmap</span>(<span class="params">fn: <span class="built_in">any</span></span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">None</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>当我们写 <code>Just.of(2).fmap(add3)</code> 时，这是幕后发生的事情：</p><p><img src="/images/ts-fam/fmap_just.png" alt></p><p>那么然后，就像这样，fmap，请将 add3 应用到 Nothing 上如何？</p><p><img src="/images/ts-fam/fmap_nothing.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">None.fmap(add3) <span class="comment">// Nothing</span></span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/bill.png" alt></p><p>就像《黑客帝国》中的 Morpheus，fmap 知道都要做什么；如果你从 Nothing 开始，那么你会以 Nothing 结束！ fmap 是禅。</p><p>现在它告诉我们了 Maybe 数据类型存在的意义。 例如，这是在一个没有 Maybe 的语言中处理一个数据库记录的方式, 比如Javascript:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> post = Post.findByID(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (post != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> post.title</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了fmap后:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设findPost返回Maybe&lt;Article&gt;</span></span><br><span class="line">findPost(<span class="number">1</span>).fmap(getPostTitle)</span><br></pre></td></tr></table></figure><p>如果 findPost 返回一篇文章，我们就会通过 getPostTitle 获取其标题。 如果它返回 Nothing，我们就也返回 Nothing！ 较之前简洁了很多对吧?</p><blockquote><p>Typescript有了Optional Chaining后，处理null也可以很简洁:<br> <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">findPost(<span class="number">1</span>)?.title <span class="comment">// 异曲同工</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>原文还有定义了一个fmap的重载操作符版本，因为JavaScript不支持操作符重载，所以这里简单带过<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getPostTitle &lt;$&gt; findPost(1) // 使用操作符重载&lt;$&gt; 来简化fmap. 等价于上面的代码</span><br></pre></td></tr></table></figure></p></blockquote><p><br></p><p>再看一个示例：如果将一个函数应用到一个 Array（Haksell 中是 List）上会发生什么？</p><p><img src="/images/ts-fam/fmap_list.png" alt></p><p>Array 也是 functor！</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(add3) <span class="comment">// [4, 5, 6]. fa是Array，输出fb也是Array，符合Functor的定义吧，所以Javascript的map就是fmap，Array就是Functor</span></span><br></pre></td></tr></table></figure><p><br></p><p>好了，好了，最后一个示例：如果将一个函数应用到另一个函数上会发生什么？</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply3 = <span class="function">(<span class="params">v: <span class="built_in">number</span></span>) =&gt;</span> v * <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> add3 = <span class="function">(<span class="params">v: <span class="built_in">number</span></span>) =&gt;</span> v + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">add3.fmap(multiply3) <span class="comment">// ❓</span></span><br></pre></td></tr></table></figure><p>这是一个函数：</p><p><img src="/images/ts-fam/function_with_value.png" alt></p><p>这是一个应用到另一个函数上的函数：</p><p><img src="/images/ts-fam/fmap_function.png" alt></p><p>其结果是又一个函数！</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅作示例，不要模仿</span></span><br><span class="line"><span class="keyword">interface</span> Function &#123;</span><br><span class="line">  fmap&lt;V, T, U&gt;<span class="function">(<span class="params"><span class="keyword">this</span>: (<span class="params">val: V</span>) =&gt; T, fn: (<span class="params">val: T</span>) =&gt; U</span>): (<span class="params">val: V</span>) =&gt;</span> U</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">v</span> =&gt;</span> fn(<span class="keyword">this</span>(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以函数也是 Functor！ 对一个函数使用 fmap，其实就是函数组合(compose)！ 也就是说: <code>f.fmap(g)</code> 等价于 <code>compose(f, g)</code></p><p><br></p><h3 id="functor总结"><a href="#functor总结" class="headerlink" title="Functor总结"></a>Functor总结</h3><p>通过上面的例子，可以知道Functor其实并没有那么难以理解, 一个Functor就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Functor T&gt;.fmap(fn: (v: T) =&gt; U): &lt;Functor U&gt;</span><br></pre></td></tr></table></figure><p>Functor会定义一个‘fmap’操作，这个fmap接受一个函数fn，fn接收的是具体的值，返回另一个具体的值，例如上面的add3. <strong>fmap决定如何来应用fn到源Functor(a)</strong>， 返回一个新的Functor(b)。 也就是fmap的源和输出的值‘上下文’类型是一样的。比如</p><ul><li><code>Just -&gt; fmap -&gt; Just</code></li><li><code>Nothing -&gt; fmap -&gt; Nothing</code></li><li><code>Maybe -&gt; fmap -&gt; Maybe</code></li><li><code>Array -&gt; fmap -&gt; Array</code></li></ul><p><br><br><br></p><h2 id="applicative"><a href="#applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>现在练到二重天了。 Applicative 又提升了一个层次。</p><p>对于 Applicative，我们的值依然和 Functor 一样包装在一个上下文中</p><p><img src="/images/ts-fam/value_and_context.png" alt></p><p>不一样的是，我们<strong>将Functor中的函数(例如add3)也包装在一个上下文中</strong>！</p><p><img src="/images/ts-fam/function_and_context.png" alt></p><p>嗯。 我们继续深入。 Applicative 并没有开玩笑。不像Haskell，Typescript并没有内置方式来处理Applicative。我们可以给需要支持Applicative的类型定义一个apply函数。<strong>apply函数知道怎么将<code>包装在上下文的函数</code>应用到一个<code>包装在上下文的值</code></strong>：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> None &#123;</span><br><span class="line">  <span class="keyword">static</span> apply(fn: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> None;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Just&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 使用方法重载，让Typescript更好推断</span></span><br><span class="line">  <span class="comment">// 如果值和函数都是Just类型，结果也是Just类型</span></span><br><span class="line">  apply&lt;U&gt;<span class="function">(<span class="params">fn: Just&lt;(<span class="params">a: T</span>) =&gt; U&gt;</span>): <span class="params">Just</span>&lt;<span class="params">U</span>&gt;;</span></span><br><span class="line"><span class="function">  // 如果函数是<span class="params">Nothing</span>类型，结果是<span class="params">Nothing</span>.</span></span><br><span class="line"><span class="function">  // 严格上<span class="params">apply</span>只应该接收同一个上下文类型的函数，即<span class="params">Just</span>,</span></span><br><span class="line"><span class="function">  // 因为<span class="params">Maybe</span>是<span class="params">Typescript</span>的<span class="params">Union</span>类型，没办法给它扩展方法，这里将<span class="params">Maybe</span>和<span class="params">Just</span>混在一起了</span></span><br><span class="line"><span class="function">  <span class="params">apply</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: Nothing</span>): <span class="params">Nothing</span>;</span></span><br><span class="line"><span class="function">  // 如果值和函数都是<span class="params">Maybe</span>类型, 返回一个<span class="params">Maybe</span>类型</span></span><br><span class="line"><span class="function">  <span class="params">apply</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: Maybe&lt;(<span class="params">a: T</span>) =&gt; U&gt;</span>): <span class="params">Maybe</span>&lt;<span class="params">U</span>&gt; &#123;</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">!isNothing(<span class="params">fn</span>)</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">return</span> <span class="params">Just</span>.<span class="params">of</span>(<span class="params">fn.value(<span class="params"><span class="keyword">this</span>.value</span>)</span>);</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">None</span>.<span class="params">apply</span>(<span class="params">fn</span>);</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>再来看看数组:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅作示例</span></span><br><span class="line"><span class="keyword">interface</span> Array&lt;T&gt; &#123;</span><br><span class="line">  apply&lt;U&gt;<span class="function">(<span class="params">fns: <span class="built_in">Array</span>&lt;(<span class="params">e: T</span>) =&gt; U&gt;</span>): <span class="params">U</span>[]</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 接收一个函数‘数组(<span class="params">上下文</span>)’，返回一个应用了‘函数’的新的数组</span></span><br><span class="line"><span class="function"><span class="params">Array</span>.<span class="params">prototype</span>.<span class="params">apply</span> = <span class="params">function</span>&lt;<span class="params">T</span>, <span class="params">U</span>&gt;(<span class="params">fns: <span class="built_in">Array</span>&lt;(<span class="params">e: T</span>) =&gt; U&gt;</span>) &#123;</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">res</span>: <span class="params">U</span>[] = []</span></span><br><span class="line"><span class="function">  <span class="params">for</span> (<span class="params"><span class="keyword">const</span> fn of fns</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">this</span>.<span class="params">forEach</span>(<span class="params">el =&gt; res.push(<span class="params">fn(<span class="params">el</span>)</span>)</span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="params">return</span> <span class="params">res</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>在Haskell中，使用<code>&lt;*&gt;</code>来表示apply操作: <code>Just (+3) &lt;*&gt; Just 2 == Just 5</code>. Typescript不支持操作符重载，所以忽略.</p><p>Just类型的Applicative应用图解：</p><p><img src="/images/ts-fam/applicative_just.png" alt></p><p>数组类型的Applicative应用图解：</p><p><img src="/images/ts-fam/applicative_list.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(num.apply([multiply2, add3]))</span><br><span class="line"><span class="comment">// [2, 4, 6, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p><strong>这里有 Applicative 能做到而 Functor 不能做到的事情</strong>。 如何将一个接受两个参数的函数应用到两个已包装的值上？</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个支持两个参数的Curry型加法函数</span></span><br><span class="line"><span class="keyword">const</span> curriedAddition = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> (b: <span class="built_in">number</span>) =&gt; a + b</span><br><span class="line"></span><br><span class="line">Just.of(<span class="number">5</span>).fmap(curriedAddition) <span class="comment">// 返回 `Just.of((b: number) =&gt; 5 + b)`</span></span><br><span class="line"><span class="comment">// Ok 继续</span></span><br><span class="line">Just.of(<span class="number">4</span>).fmap(Just.of(<span class="function">(<span class="params">b: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">5</span> + b))  <span class="comment">// ❌不行了，报错了，Functor没办法处理包装在上下文的fn</span></span><br></pre></td></tr></table></figure><p>但是Applicative可以：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">5</span>).fmap(curriedAddition) <span class="comment">// 返回 `Just.of((b: number) =&gt; 5 + b)`</span></span><br><span class="line"><span class="comment">// ✅当当当</span></span><br><span class="line">Just.of(<span class="number">3</span>).apply(Just.of(<span class="function">(<span class="params">b: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">5</span> + b)) <span class="comment">// Just.of(8)</span></span><br></pre></td></tr></table></figure><p>这时候Applicative 把 Functor 推到一边。 “大人物可以使用具有任意数量参数的函数，”它说。 “装备了 &lt;$&gt;(fmap) 与 &lt;*&gt;(apply) 之后，我可以接受具有任意个数未包装值参数的任意函数。 然后我传给它所有已包装的值，而我会得到一个已包装的值出来！ 啊啊啊啊啊！”</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">3</span>).apply(Just.of(<span class="number">5</span>).fmap(curriedAddition)) <span class="comment">// 返回 `Just.of(8)`</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="applicative总结"><a href="#applicative总结" class="headerlink" title="Applicative总结"></a>Applicative总结</h3><p>我们重申一个Applicative的定义, <strong>如果Functor要求实现fmap的话，Applicative就是要求实现apply</strong>，apply符合以下定义:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这是Functor的fmap定义</span><br><span class="line">&lt;Functor T&gt;.fmap(fn: (v: T) =&gt; U): &lt;Functor U&gt;</span><br><span class="line"></span><br><span class="line">// 这是Applicative的apply定义，和上面对比，fn变成了一个包装在上下文的函数</span><br><span class="line">&lt;Applicative T&gt;.apply(fn: &lt;Applicative (v: T) =&gt; U&gt;): &lt;Applicative U&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="monad"><a href="#monad" class="headerlink" title="Monad"></a>Monad</h2><p>终于练到三重天了！继续⛽加油️</p><p>如何学习 Monad 呢：</p><ol><li>你要取得计算机科学博士学位。</li><li>然后把它扔掉，因为在本文你并不需要它！</li></ol><p>Monad 增加了一个新的转变。</p><p><code>Functor</code> 将一个<code>函数</code>应用到一个<code>已包装的值</code>上：</p><p><img src="/images/ts-fam/fmap.png" alt></p><p><code>Applicative</code> 将一个<code>已包装的函数</code>应用到一个<code>已包装的值</code>上：</p><p><img src="/images/ts-fam/applicative.png" alt></p><p>Monad 将一个<code>返回已包装值的函数</code>应用到一个<code>已包装的值</code>上。 Monad 定义一个函数<code>flatMap</code>（在 Haskell 中是使用操作符 <code>&gt;&gt;=</code> 来应用Monad，读作“bind”）来做这个。</p><p>让我们来看个示例。 老搭档 Maybe 是一个 Monad：</p><p><img src="/images/ts-fam/context.png" alt></p><p>假设 <code>half</code> 是一个只适用于偶数的函数：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这就是一个典型的: "返回已包装值"的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">half</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">Maybe</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Just.of(value / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> None</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/half.png" alt></p><p>如果我们喂给它一个<code>已包装的值</code>会怎样？</p><p><img src="/images/ts-fam/half_ouch.png" alt></p><p>我们需要使用flatMap(Haskell 中的&gt;&gt;=)来将我们已包装的值塞进该函数。 这是 &gt;&gt;= 的照片：</p><p><img src="/images/ts-fam/plunger.jpg" alt></p><p>以下是它的工作方式：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">3</span>).flatMap(half) <span class="comment">// =&gt; Nothing, Haskell中使用操作符这样操作: Just 3 &gt;&gt;= half</span></span><br><span class="line">Just.of(<span class="number">4</span>).flatMap(half) <span class="comment">// =&gt; Just 2</span></span><br><span class="line">None.flatMap(half)       <span class="comment">// =&gt; Nothing</span></span><br></pre></td></tr></table></figure><p>内部发生了什么？我们再看看flatMap的方法签名:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Maybe</span></span><br><span class="line">Maybe&lt;T&gt;.flatMap&lt;U&gt;<span class="function">(<span class="params">fn: (<span class="params">val: T</span>) =&gt; Maybe&lt;U&gt;</span>): <span class="params">Maybe</span>&lt;<span class="params">U</span>&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="params">Array</span></span></span><br><span class="line"><span class="function"><span class="params">Array</span>&lt;<span class="params">T</span>&gt;.<span class="params">flatMap</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: (<span class="params">val: T</span>) =&gt; U[]</span>): <span class="params">U</span>[]</span></span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/bind_def.png" alt></p><p><strong>Array是一个Monad</strong>, Javascript的Array的flatMap已经正式成为标准， 看看它的使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]); </span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// only one level is flattened</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><p><br></p><p>Maybe 也是一个 Monad：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> None &#123;</span><br><span class="line">  <span class="keyword">static</span> flatMap(fn: <span class="built_in">any</span>): Nothing &#123;</span><br><span class="line">    <span class="keyword">return</span> None;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Just&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 和上面的apply差不多</span></span><br><span class="line">  <span class="comment">// 使用方法重载，让Typescript更好推断</span></span><br><span class="line">  <span class="comment">// 如果函数返回Just类型，结果也是Just类型</span></span><br><span class="line">  flatMap&lt;U&gt;<span class="function">(<span class="params">fn: (<span class="params">a: T</span>) =&gt; Just&lt;U&gt;</span>): <span class="params">Just</span>&lt;<span class="params">U</span>&gt;;</span></span><br><span class="line"><span class="function">  // 如果函数返回值是<span class="params">Nothing</span>类型，结果是<span class="params">Nothing</span>.</span></span><br><span class="line"><span class="function">  <span class="params">flatMap</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: (<span class="params">a: T</span>) =&gt; Nothing</span>): <span class="params">Nothing</span>;</span></span><br><span class="line"><span class="function">  // 如果函数返回值是<span class="params">Maybe</span>类型, 返回一个<span class="params">Maybe</span>类型</span></span><br><span class="line"><span class="function">  <span class="params">flatMap</span>&lt;<span class="params">U</span>&gt;(<span class="params">fn: (<span class="params">a: T</span>) =&gt; Maybe&lt;U&gt;</span>): <span class="params">Maybe</span>&lt;<span class="params">U</span>&gt; &#123;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">fn</span>(<span class="params"><span class="keyword">this</span>.value</span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 示例</span></span><br><span class="line"><span class="function"><span class="params">Just</span>.<span class="params">of</span>(<span class="params">3</span>).<span class="params">flatMap</span>(<span class="params">half</span>) // <span class="params">Nothing</span></span></span><br><span class="line"><span class="function"><span class="params">Just</span>.<span class="params">of</span>(<span class="params">4</span>).<span class="params">flatMap</span>(<span class="params">half</span>) // <span class="params">Just</span>.<span class="params">of</span>(<span class="params">4</span>)</span></span><br></pre></td></tr></table></figure><p>这是与 Just 3 运作的情况！</p><p><img src="/images/ts-fam/monad_just.png" alt></p><p>如果传入一个 Nothing 就更简单了：</p><p><img src="/images/ts-fam/monad_nothing.png" alt></p><p>你还可以将这些调用串联起来：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Just.of(<span class="number">20</span>).flatMap(half).flatMap(half).flatMap(falf) <span class="comment">// =&gt; Nothing</span></span><br></pre></td></tr></table></figure><p><img src="/images/ts-fam/monad_chain.png" alt><br><img src="/images/ts-fam/whoa.png" alt></p><p><br></p><p>很炫酷哈！所以我们现在知道Maybe既是一个Functor、Applicative，还是一个Monad。</p><p>原文还示范了另一个例子: <code>IO</code> Monad, 我们这里就简单了解一下</p><p><img src="/images/ts-fam/io.png" alt></p><p>IO的签名大概如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> IO&lt;T&gt; &#123;</span><br><span class="line">  val: T</span><br><span class="line">  <span class="comment">// 具体实现我们暂不关心</span></span><br><span class="line">  flatMap(fn: <span class="function">(<span class="params">val: T</span>) =&gt;</span> IO&lt;U&gt;): IO&lt;U&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来看三个函数。 getLine 没有参数, 用来获取用户输入：</p><p><img src="/images/ts-fam/getLine.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLine</span>(<span class="params"></span>): <span class="title">IO</span>&lt;<span class="title">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>readFile 接受一个字符串（文件名）并返回该文件的内容：</p><p><img src="/images/ts-fam/readFile.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename: <span class="built_in">string</span></span>): <span class="title">IO</span>&lt;<span class="title">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>putStrLn 输出字符串到控制台：</p><p><img src="/images/ts-fam/putStrLn.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putStrLn</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title">IO</span>&lt;<span class="title">void</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有这三个函数都接受普通值（或无值）并返回一个已包装的值，即IO。 我们可以使用 flatMap 将它们串联起来！</p><p><img src="/images/ts-fam/monad_io.png" alt></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">getLine().flatMap(readFile).flatMap(putStrLn)</span><br></pre></td></tr></table></figure><p>太棒了！ 前排占座来看 monad 展示！我们不需要在取消包装和重新包装 IO monad 的值上浪费时间. flatMap 为我们做了那些工作!</p><p>Haskell 还为 monad 提供了语法糖, 叫做 do 表达式:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foo</span> = <span class="keyword">do</span></span><br><span class="line">    filename &lt;- getLine</span><br><span class="line">    contents &lt;- readFile filename</span><br><span class="line">    putStrLn contents</span><br></pre></td></tr></table></figure><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>functor 是实现了 <code>fmap</code> 的数据类型。</li><li>applicative 是实现了 <code>apply</code> 的数据类型。</li><li>monad 是实现了 <code>flatMap</code> 的数据类型。</li><li>Maybe 实现了这三者，所以它是 functor、 applicative、 以及 monad。</li></ol><p>这三者有什么区别呢？</p><p><img src="/images/ts-fam/recap.png" alt></p><ol><li><strong>functor</strong>: 可通过 fmap 将一个<code>函数</code>应用到一个<code>已包装的值</code>上。</li><li><strong>applicative</strong>: 可通过 apply 将一个<code>已包装的函数</code>应用到<code>已包装的值</code>上。</li><li><strong>monad</strong>: 可通过 flatMap 将一个<code>返回已包装值的函数</code>应用到<code>已包装的值</code>上。</li></ol><p>综合起来看看它们的签名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这是Functor的fmap定义</span><br><span class="line">&lt;Functor T&gt;.fmap(fn: (v: T) =&gt; U): &lt;Functor U&gt;</span><br><span class="line"></span><br><span class="line">// 这是Applicative的apply定义，和上面对比，fn变成了一个包装在上下文的函数</span><br><span class="line">&lt;Applicative T&gt;.apply(fn: &lt;Applicative (v: T) =&gt; U&gt;): &lt;Applicative U&gt;</span><br><span class="line"></span><br><span class="line">// Monad的定义, 而接受一个函数， 这个函数返回一个包装在上下文的值</span><br><span class="line">&lt;Monad T&gt;.flatmap(fn: (v: T) =&gt; &lt;Monad U&gt;): &lt;Monad U&gt;</span><br></pre></td></tr></table></figure><p>所以，亲爱的朋友（我觉得我们现在是朋友了），我想我们都同意 monad 是一个简单且高明的主意（SMART IDEA(tm)）。 现在你已经通过这篇指南润湿了你的口哨，为什么不拉上 Mel Gibson 并抓住整个瓶子呢。 参阅《Haskell 趣学指南》的《来看看几种 Monad》。 很多东西我其实掩饰了因为 Miran 深入这方面做得很棒.</p><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>本文在<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">原文</a>的基础上, 参考了下列这些翻译版本，再次感谢这些作者:</p><ul><li><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html#translations" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures</a> - 原文</li><li><a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="noopener">Swift Functors, Applicatives, and Monads in Pictures</a> - Swift版本, 本文主要参考这篇文章</li><li><a href="https://hltj.me/kotlin/2017/08/25/kotlin-functor-applicative-monad-cn.html" target="_blank" rel="noopener">Kotlin 版图解 Functor、Applicative 与 Monad</a> - Kotlin版本，翻译非常棒</li><li><a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="noopener">Functor, Applicative, 以及 Monad 的图片阐释</a> - 中文版本，<strong>题叶</strong>翻译</li><li><a href="https://medium.com/@lettier/your-easy-guide-to-monads-applicatives-functors-862048d61610" target="_blank" rel="noopener">Your easy guide to Monads, Applicatives, &amp; Functors</a> - Medium上一篇动图图解Monad的文章，写得也不错. 读完本文可以再读这篇文章</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是经典的&lt;a href=&quot;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Functo
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年了，整理了N个实用案例帮你快速迁移到React Hooks(收藏慢慢看系列)</title>
    <link href="https://bobi.ink/2019/08/10/react-hooks/"/>
    <id>https://bobi.ink/2019/08/10/react-hooks/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-18T06:14:32.162Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><img src="/images/react-hooks/cover.png" alt></p><p><br></p><p>在<a href="https://www.youtube.com/channel/UCz5vTaEhvh7dOHEyd1efcaQ" target="_blank" rel="noopener">React Conf 2018</a>宣布React Hooks后，我第一时间开始尝试使用React Hooks，现在新项目基本不写Class组件了。对我来说，它确实让我的开发效率提高了很多，改变了已有的组件开发思维和模式.</p><p>我在<a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-3" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a>中已经总结过<strong>React Hooks的意义，以及一些应用场景</strong>。</p><p>那这篇文章就完全是介绍<strong>React Hooks的应用实例</strong>，列举了我使用React Hooks的一些实践。 希望通过这些案例，可以帮助你快速熟练，并迁移到React Hooks开发模式. </p><blockquote><p><strong>文章篇幅很长，建议收藏不看, 至少看看目录吧</strong></p></blockquote><p><br></p><p>把之前文章整理的<code>React Hooks应用场景</code>总结拿过来, 本文基本按照<strong>这个范围进行组织</strong>:</p><p><img src="/images/react-hooks/apply.png" alt></p><p><br></p><p><strong>如果你想要了解React Hooks的原理可以阅读这些文章</strong>:</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fmedium.com%2F%40ryardley%2Freact-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a></li><li><a href="https://juejin.im/post/5cfa29e151882539c33e4f5e#heading-8" target="_blank" rel="noopener">从Preact中了解组件和hooks基本原理</a></li></ul><p><br></p><p><strong>目录索引</strong></p><!-- TOC --><ul><li><a href="#1-组件状态"><strong>1. 组件状态</strong></a><ul><li><a href="#1-1-usesetstate-模拟传统的setstate">1-1 useSetState 模拟传统的setState</a></li><li><a href="#1-2-usereducer-redux风格状态管理">1-2 useReducer Redux风格状态管理</a></li><li><a href="#1-3-useforceupdate-强制重新渲染">1-3 useForceUpdate 强制重新渲染</a></li><li><a href="#1-4-usestorage-简化localstorage存取">1-4 useStorage 简化localStorage存取</a></li><li><a href="#1-5-userefstate-引用state的最新值">1-5 useRefState 引用state的最新值</a><ul><li><a href="#1-5-1-每次重新渲染都创建闭包会影响效率吗">1-5-1 每次重新渲染都创建闭包会影响效率吗?</a></li></ul></li><li><a href="#1-6-userefprops-引用最新的props">1-6 useRefProps 引用最新的Props</a></li><li><a href="#1-7-useinstance-实例变量存取">1-7 useInstance ‘实例’变量存取</a></li><li><a href="#1-9-useprevious-获取上一次渲染的值">1-9 usePrevious 获取上一次渲染的值</a></li><li><a href="#1-10-useimmer-简化不可变数据操作">1-10 useImmer 简化不可变数据操作</a></li><li><a href="#1-11-封装工具hooks简化state的操作">1-11 封装’工具Hooks’简化State的操作</a><ul><li><a href="#1-11-1-usetoggle-开关">1-11-1 useToggle 开关</a></li><li><a href="#1-11-2-usearray-简化数组状态操作">1-11-2 useArray 简化数组状态操作</a></li></ul></li></ul></li><li><a href="#2-模拟生命周期函数"><strong>2. 模拟生命周期函数</strong></a><ul><li><a href="#2-1-useonmount-模拟componentdidmount">2-1 useOnMount 模拟componentDidMount</a></li><li><a href="#2-2-useonunmount-模拟componentwillunmount">2-2 useOnUnmount 模拟componentWillUnmount</a></li><li><a href="#2-3-useonupdate-模拟componentdidupdate">2-3 useOnUpdate 模拟componentDidUpdate</a></li></ul></li><li><a href="#3-事件处理"><strong>3. 事件处理</strong></a><ul><li><a href="#3-1-usechange-简化onchange表单双向绑定">3-1 useChange 简化onChange表单双向绑定</a></li><li><a href="#3-2-usebind-绑定回调参数">3-2 useBind 绑定回调参数</a></li><li><a href="#3-3-自定义事件封装">3-3 自定义事件封装</a><ul><li><a href="#3-3-1-useactive">3-3-1 useActive</a></li><li><a href="#3-3-2-usetouch-手势事件封装">3-3-2 useTouch 手势事件封装</a></li><li><a href="#3-3-3-usedraggable-拖拽事件封装">3-3-3 useDraggable 拖拽事件封装</a></li><li><a href="#3-3-4-react-events-面向未来的高级事件封装">3-3-4 react-events 面向未来的高级事件封装</a></li></ul></li><li><a href="#3-4-usesubscription-通用事件源订阅">3-4 useSubscription 通用事件源订阅</a></li><li><a href="#3-5-useobservable-hooks和rxjs优雅的结合rxjs-hooks">3-5 useObservable Hooks和RxJS优雅的结合(rxjs-hooks)</a></li><li><a href="#3-6-useeventemitter-对接eventemitter">3-6 useEventEmitter 对接eventEmitter</a></li></ul></li><li><a href="#4-context的妙用"><strong>4. Context的妙用</strong></a><ul><li><a href="#4-1-usetheme-主题配置">4-1 useTheme 主题配置</a></li><li><a href="#4-2-unstated-简单状态管理器">4-2 unstated 简单状态管理器</a></li><li><a href="#4-3-usei18n-国际化">4-3 useI18n 国际化</a></li><li><a href="#4-4-userouter-简化路由状态的访问">4-4 useRouter 简化路由状态的访问</a></li><li><a href="#4-5-react-hook-form-hooks和表单能擦出什么火花">4-5 react-hook-form Hooks和表单能擦出什么火花?</a></li></ul></li><li><a href="#5-副作用封装"><strong>5. 副作用封装</strong></a><ul><li><a href="#5-1-usetimeout-超时修改状态">5-1 useTimeout 超时修改状态</a></li><li><a href="#5-2-useonlinestatus-监听在线状态">5-2 useOnlineStatus 监听在线状态</a></li></ul></li><li><a href="#6-副作用衍生"><strong>6. 副作用衍生</strong></a><ul><li><a href="#6-1-usetitle-设置文档title">6-1 useTitle 设置文档title</a></li><li><a href="#6-2-usedebounce">6-2 useDebounce</a></li><li><a href="#6-3-usethrottle">6-3 useThrottle</a></li></ul></li><li><a href="#7-简化业务逻辑"><strong>7. 简化业务逻辑</strong></a><ul><li><a href="#7-1-usepromise-封装异步请求">7-1 usePromise 封装异步请求</a></li><li><a href="#7-2-usepromiseeffect-自动进行异步请求">7-2 usePromiseEffect 自动进行异步请求</a></li><li><a href="#7-3-useinfinitelist-实现无限加载列表">7-3 useInfiniteList 实现无限加载列表</a></li><li><a href="#7-4-usepoll-用hook实现轮询">7-4 usePoll 用hook实现轮询</a></li><li><a href="#7-5-业务逻辑抽离">7-5 业务逻辑抽离</a></li></ul></li><li><a href="#8-开脑洞"><strong>8. 开脑洞</strong></a><ul><li><a href="#8-1-usescript-hooks--suspend--❤️">8-1 useScript: Hooks + Suspend = ❤️</a></li><li><a href="#8-2-usemodal-模态框数据流管理">8-2 useModal 模态框数据流管理</a></li></ul></li><li><a href="#react-hooks-技术地图"><strong>React Hooks 技术地图</strong></a></li><li><a href="#总结">总结</a></li></ul><!-- /TOC --><p><br></p><h2 id="1-组件状态"><a href="#1-组件状态" class="headerlink" title="1. 组件状态"></a><strong>1. 组件状态</strong></h2><p>React提供了一个很基本的组件状态设置Hook:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure><p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener">useState</a>返回<strong>一个state，以及更新state的函数</strong>. setState可以接受一个新的值，会触发组件重新渲染.</p><blockquote><p><strong>React会确保setState函数是稳定的，不会在组件重新渲染时改变</strong>。下面的useReducer的dispatch函数、useRef的current属性也一样。<br><strong>这就意味着setState、dispatch、ref.current, 可以安全地在useEffect、useMemo、 useCallback中引用</strong></p></blockquote><p><br></p><h3 id="1-1-usesetstate-模拟传统的setstate"><a href="#1-1-usesetstate-模拟传统的setstate" class="headerlink" title="1-1 useSetState 模拟传统的setState"></a>1-1 useSetState 模拟传统的setState</h3><p>useState和Class组件的setState不太一样.</p><p>Class组件的state属性一般是一个对象，调用setState时，会浅拷贝到state属性, 并触发更新, 比如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    name: <span class="string">'_sx_'</span>,</span><br><span class="line">    age: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleIncrementAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只更新age</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">age</span>: <span class="keyword">this</span>.state.age + <span class="number">1</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>而<strong>useState会直接覆盖state值</strong>。为了实现和setState一样的效果, 可以这样子做:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;name: <span class="string">'sx'</span>, age: <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">const</span> MyComp: FC = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(initialState)</span><br><span class="line">  <span class="keyword">const</span> handleIncrementAge = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// setState方法支持接收一个函数，通过这个函数可以获取最新的state值</span></span><br><span class="line">    <span class="comment">// 然后使用...操作符实现对象浅拷贝</span></span><br><span class="line">    setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;...preState, age: prevState.age + <span class="number">1</span>&#125;) )</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Ok，现在把它封装成通用的hooks，在其他组件中复用。这时候就体现出来Hooks强大的逻辑抽象能力：<strong>Hooks 旨在让组件的内部逻辑组织成可复用的更小单元，这些单元各自维护一部分组件‘状态和逻辑’</strong></p><p>看看我们的<code>useSetState</code>, 我会使用Typescript进行代码编写:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useSetState</span>&lt;<span class="title">S</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initalState: S | ((</span>) =&gt; <span class="title">S</span>),</span></span><br><span class="line">): [S, (state: Partial&lt;S&gt; | ((state: S) =&gt; Partial&lt;S&gt;)) =&gt; void] &#123;</span><br><span class="line">  <span class="keyword">const</span> [_state, _setState] = useState&lt;S&gt;(initalState)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setState = useCallback(<span class="function">(<span class="params">state: Partial&lt;S&gt; | ((state: S</span>) =&gt;</span> Partial&lt;S&gt;)) =&gt; &#123;</span><br><span class="line">    _setState(<span class="function">(<span class="params">prev: S</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> nextState = state</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> state === <span class="string">'function'</span>) &#123;</span><br><span class="line">        nextState = state(prev)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; ...prev, ...nextState &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [_state, setState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseSetState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useSetState&lt;&#123; <span class="attr">name</span>: string; age: number &#125;&gt;(&#123; <span class="attr">name</span>: <span class="string">'sx'</span>, <span class="attr">age</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> incrementAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setState(<span class="function"><span class="params">prev</span> =&gt;</span> (&#123; <span class="attr">age</span>: prev.age + <span class="number">1</span> &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onClick=&#123;incrementAge&#125;&gt;</span><br><span class="line">      &#123;state.name&#125;: &#123;state.age&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>hooks命名以<code>use</code>为前缀</p></blockquote><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-2-usereducer-redux风格状态管理"><a href="#1-2-usereducer-redux风格状态管理" class="headerlink" title="1-2 useReducer Redux风格状态管理"></a>1-2 useReducer Redux风格状态管理</h3><p>如果组件状态比较复杂，推荐使用useReducer来管理状态。如果你熟悉Redux，会很习惯这种方式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义初始状态</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Reducer</span></span><br><span class="line"><span class="comment">// ruducer接受当前state，以及一个用户操作，返回一个'新'的state</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回state，以及dispatch函数</span></span><br><span class="line">  <span class="comment">// dispatch函数可以触发reducer执行，给reducer传递指令和载荷</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>了解更多reducer的思想可以参考<a href="https://redux.js.org/basics/reducers" target="_blank" rel="noopener">Redux文档</a></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-3-useforceupdate-强制重新渲染"><a href="#1-3-useforceupdate-强制重新渲染" class="headerlink" title="1-3 useForceUpdate 强制重新渲染"></a>1-3 useForceUpdate 强制重新渲染</h3><p>Class组件可以通过<code>forceUpdate</code>实例方法来触发强制重新渲染。使用useState也可以模拟相同的效果：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useForceUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [, setValue] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 递增state值，强制React进行重新渲染</span></span><br><span class="line">    setValue(<span class="function"><span class="params">val</span> =&gt;</span> (val + <span class="number">1</span>) % (<span class="built_in">Number</span>.MAX_SAFE_INTEGER - <span class="number">1</span>))</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ForceUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> forceUpdate = useForceUpdate()</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    somethingChange(forceUpdate)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-4-usestorage-简化localstorage存取"><a href="#1-4-usestorage-简化localstorage存取" class="headerlink" title="1-4 useStorage 简化localStorage存取"></a>1-4 useStorage 简化localStorage存取</h3><p>通过自定义Hooks，可以将状态代理到其他数据源，比如localStorage。 下面案例展示如果使用Hooks封装和简化localStorage的存取:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useCallback, Dispatch, SetStateAction &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useStorage</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 默认值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue?: T | (() =&gt; T),</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 是否在窗口关闭后保持数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">  keepOnWindowClosed: <span class="built_in">boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">T</span> | <span class="title">undefined</span>, <span class="title">Dispatch</span>&lt;<span class="title">SetStateAction</span>&lt;<span class="title">T</span>&gt;&gt;, (<span class="params"></span>) =&gt; <span class="title">void</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> storage = keepOnWindowClosed ? localStorage : sessionStorage</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试从Storage恢复值</span></span><br><span class="line">  <span class="keyword">const</span> getStorageValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> storageValue = storage.getItem(key)</span><br><span class="line">      <span class="keyword">if</span> (storageValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(storageValue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultValue) &#123;</span><br><span class="line">        <span class="comment">// 设置默认值</span></span><br><span class="line">        <span class="keyword">const</span> value = <span class="keyword">typeof</span> defaultValue === <span class="string">'function'</span> ? <span class="function">(<span class="params">defaultValue <span class="keyword">as</span> (<span class="params"></span>) =&gt; T</span>)<span class="params">()</span> : <span class="params">defaultValue</span></span></span><br><span class="line"><span class="function">        <span class="params">storage</span>.<span class="params">setItem</span>(<span class="params">key, <span class="built_in">JSON</span>.stringify(<span class="params">value</span>)</span>)</span></span><br><span class="line"><span class="function">        <span class="params">return</span> <span class="params">value</span></span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125; <span class="params">catch</span> (<span class="params">err</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">console</span>.<span class="params">warn</span>(<span class="params">`useStorage 无法获取$&#123;key&#125;: `, err</span>)</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="params">return</span> <span class="params">undefined</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">const</span> [<span class="params">value</span>, <span class="params">setValue</span>] = <span class="params">useState</span>&lt;<span class="params">T</span> | <span class="params">undefined</span>&gt;(<span class="params">getStorageValue</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 更新组件状态并保存到<span class="params">Storage</span></span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">save</span> = <span class="params">useCallback</span>&lt;<span class="params">Dispatch</span>&lt;<span class="params">SetStateAction</span>&lt;<span class="params">T</span>&gt;&gt;&gt;(<span class="params">value =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    setValue(<span class="params">prev =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">const</span> finalValue = <span class="keyword">typeof</span> value === '<span class="keyword">function</span>' ? (<span class="params">value <span class="keyword">as</span> (<span class="params">prev: T | <span class="literal">undefined</span></span>) =&gt; T</span>)(<span class="params">prev</span>) : value</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      storage.setItem(<span class="params">key, <span class="built_in">JSON</span>.stringify(<span class="params">finalValue</span>)</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">return</span> finalValue</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 移除状态</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">clear</span> = <span class="params">useCallback</span>(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    storage.removeItem(<span class="params">key</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    setValue(<span class="params"><span class="literal">undefined</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> [<span class="params">value</span>, <span class="params">save</span>, <span class="params">clear</span>]</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// --------</span></span><br><span class="line"><span class="function">// <span class="params">EXAMPLE</span></span></span><br><span class="line"><span class="function">// --------</span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">Demo</span><span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">  // 保存登录状态</span></span><br><span class="line"><span class="function">  <span class="params">const</span> [<span class="params">use</span>, <span class="params">setUser</span>, <span class="params">clearUser</span>] = <span class="params">useStorage</span>(<span class="params">'user'</span>)</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">handleLogin</span> = (<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    setUser(user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleLogout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearUser()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-5-userefstate-引用state的最新值"><a href="#1-5-userefstate-引用state的最新值" class="headerlink" title="1-5 useRefState 引用state的最新值"></a>1-5 useRefState 引用state的最新值</h3><p><br></p><p><img src="/images/react-hooks/vue-api.png" alt></p><p><br></p><p>上图是今年六月份<a href="https://vue.w3ctech.com" target="_blank" rel="noopener">VueConf</a>，尤雨溪的Slide截图，他对比了Vue最新的<a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener">FunctionBase API</a>和React Hook. 它<strong>指出React Hooks有很多问题</strong>:</p><ul><li>每个Hooks在组件每次渲染时都执行。也就是说每次渲染都要重新创建闭包和对象</li><li>需要理解闭包变量</li><li>内容回调/对象会导致纯组件props比对失效, 导致组件永远更新</li></ul><p><br></p><p>闭包变量问题是你掌握React Hooks过程中的重要一关。闭包问题是指什么呢？举个简单的例子, Counter:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> handleIncr = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;: <span class="tag">&lt;<span class="name">ComplexButton</span> <span class="attr">onClick</span>=<span class="string">&#123;handleIncr&#125;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">ComplexButton</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设ComplexButton是一个非常复杂的组件，每一次点击它，我们会递增count，从而触发组将重新渲染。<strong>因为Counter每次渲染都会重新生成handleIncr，所以也会导致ComplexButton重新渲染，不管ComplexButton使用了<code>PureComponent</code>还是使用<code>React.memo</code>包装</strong>。</p><p><br></p><p>为了解决这个问题，<strong>React也提供了一个<code>useCallback</code> Hook, 用来‘缓存’函数, 保持回调的不变性</strong>. 比如我们可以这样使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> handleIncr = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;: <span class="tag">&lt;<span class="name">ComplexButton</span> <span class="attr">onClick</span>=<span class="string">&#123;handleIncr&#125;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">ComplexButton</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是有bug的，不过怎么点击，count会一直显示为1！</p><p>再仔细阅读useCallback的文档，useCallback支持第二个参数，当这些值变动时更新缓存的函数, <strong>useCallback的内部逻辑大概是这样的</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memoFn, memoArgs</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果变动则更新缓存函数</span></span><br><span class="line">  <span class="keyword">if</span> (!isEqual(memoArgs, args)) &#123;</span><br><span class="line">    memoArgs = args</span><br><span class="line">    <span class="keyword">return</span> (memoFn = fn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memoFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok, 现在理解一下为什么会一直显示1？</p><p><img src="/images/react-hooks/usecallback.png" alt></p><p>首次渲染时缓存了闭包，这时候闭包捕获的count值是0。在后续的重新渲染中，因为useCallback第二个参数指定的值没有变动，handleIncr闭包会永远被缓存。这就解释了为什么每次点击，count只能为1.</p><p>解决办法也很简单，让我们在count变动时，让useCallback更新缓存函数:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> handleIncr = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;&#123;count&#125;: &lt;ComplexButton onClick=&#123;handleIncr&#125;&gt;increment&lt;<span class="regexp">/ComplexButton&gt;&lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>如果useCallback依赖很多值，你的代码可能是这样的：<code>useCallback(fn, [a, b, c, d, e])</code>. 反正我是无法接受这种代码的，很容易遗漏, 而且可维护性很差，尽管通过<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">ESLint插件</a>可以检查这些问题**。</p><p><br></p><p>其实通过<a href="https://reactjs.org/docs/hooks-reference.html#useref" target="_blank" rel="noopener"><code>useRef</code></a> Hook，可以让我们像Class组件一样保存一些‘实例变量’, React会保证useRef返回值的稳定性，我们可以在组件任何地方安全地引用ref。</p><p>基于这个原理，我们尝试封装一个<code>useRefState</code>, 它在useState的基础上扩展了一个返回值，用于获取state的最新值:</p><p><br></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useRef, useCallback, Dispatch, SetStateAction, MutableRefObject &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRefState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ins = useRef()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">typeof</span> initialState === <span class="string">'function'</span> ? initialState() : initialState</span><br><span class="line">    ins.current = value</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setValue = useCallback(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) &#123;</span><br><span class="line">      setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> finalValue = value(prevState)</span><br><span class="line">        ins.current = finalValue</span><br><span class="line">        <span class="keyword">return</span> finalValue</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ins.current = value</span><br><span class="line">      setState(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, setValue, ins]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount, countRef] = useRefState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> handleIncr = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(countRef.current + <span class="number">1</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在组件卸载时保存当前的count</span></span><br><span class="line">      saveCount(countRef.current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;&#123;count&#125;: &lt;ComplexButton onClick=&#123;handleIncr&#125;&gt;increment&lt;<span class="regexp">/ComplexButton&gt;&lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://reactjs.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener"><code>useEffect</code></a>、<a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener"><code>useMemo</code></a>和<code>useCallback</code>一样存在闭包变量问题，它们和useCallback一个支持指定第二个参数，当这个参数变化时执行副作用。</p></blockquote><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="1-5-1-每次重新渲染都创建闭包会影响效率吗"><a href="#1-5-1-每次重新渲染都创建闭包会影响效率吗" class="headerlink" title="1-5-1 每次重新渲染都创建闭包会影响效率吗?"></a>1-5-1 每次重新渲染都创建闭包会影响效率吗?</h4><p>函数组件和Class组件不一样的是，函数组件将所有状态和逻辑都放到一个函数中, 每一次重新渲染会重复创建大量的闭包、对象。而传统的Class组件的render函数则要简洁很多，一般只放置JSX渲染逻辑。相比大家都跟我一样，会怀疑函数组件的性能问题</p><p>我们看看官方是怎么回应的：</p><p><img src="/images/react-hooks/fn-perf.png" alt></p><p><br></p><p>我在SegmentFault的<a href="https://segmentfault.com/q/1010000019644156/a-1020000019706666" target="_blank" rel="noopener"><strong>react function组件与class组件性能问题</strong></a>也进行了详细的回答, 结论是:</p><blockquote><p>目前而言，实现同样的功能，类组件和函数组件的效率是不相上下的。但是函数组件是未来，而且还有优化空间，React团队会继续优化它。而类组件会逐渐退出历史</p></blockquote><p>为了提高函数组件的性能，可以在这些地方做一些<strong>优化</strong>:</p><ul><li><p>能否将函数提取为静态的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1️⃣例如将不依赖于组件状态的回调抽取为静态方法</span></span><br><span class="line"><span class="keyword">const</span> goback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  history.go(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//const goback = () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//  history.go(-1)</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;goback&#125;</span>&gt;</span>back<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 抽离useState的初始化函数</span></span><br><span class="line"><span class="keyword">const</span> returnEmptyObject = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> returnEmptyArray = <span class="function"><span class="params">()</span> =&gt;</span> []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(returnEmptyObject)</span><br><span class="line">  <span class="keyword">const</span> [arr, setArr] = useState(returnEmptyArray)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化组件的复杂度，动静分离</p></li><li>再拆分更细粒度的组件，这些组件使用React.memo缓存</li></ul><p><br><br><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-6-userefprops-引用最新的props"><a href="#1-6-userefprops-引用最新的props" class="headerlink" title="1-6 useRefProps 引用最新的Props"></a>1-6 useRefProps 引用最新的Props</h3><p>现实项目中也有很多这种场景: 我们想<strong>在组件的任何地方获取最新的props值</strong>，这个同样可以通过useRef来实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useRefProps</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef&lt;T&gt;(props)</span><br><span class="line">  <span class="comment">// 每次重新渲染设置值</span></span><br><span class="line">  ref.current = props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ref</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsRef = useRefProps(props)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 永久不变的事件处理器</span></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; onClick &#125; = propsRef.current</span><br><span class="line">    <span class="keyword">if</span> (onClick) &#123;</span><br><span class="line">      onClick()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ComplexButton</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">ComplexButton</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-7-useinstance-‘实例’变量存取"><a href="#1-7-useinstance-‘实例’变量存取" class="headerlink" title="1-7 useInstance ‘实例’变量存取"></a>1-7 useInstance ‘实例’变量存取</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>&lt;<span class="title">T</span>&gt;(<span class="params">initial?: T | (() =&gt; T)</span>): <span class="title">initial</span> <span class="title">is</span> (<span class="params"></span>) =&gt; <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> initial === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInstance</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;&#125;&gt;<span class="function">(<span class="params">initial?: T | (<span class="params">(<span class="params"></span>) =&gt; T</span>)</span>) &#123;</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">instance</span> = <span class="params">useRef</span>&lt;<span class="params">T</span>&gt;<span class="params">()</span></span></span><br><span class="line"><span class="function">  // 初始化</span></span><br><span class="line"><span class="function">  <span class="params">if</span> (<span class="params">instance.current == <span class="literal">null</span></span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">initial</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">instance</span>.<span class="params">current</span> = <span class="params">isFunction</span>(<span class="params">initial</span>) ? <span class="params">initial</span><span class="params">()</span> : <span class="params">initial</span></span></span><br><span class="line"><span class="function">    &#125; <span class="params">else</span> &#123;</span></span><br><span class="line"><span class="function">      <span class="params">instance</span>.<span class="params">current</span> = &#123;&#125; <span class="params">as</span> <span class="params">T</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> <span class="params">instance</span>.<span class="params">current</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// ---------</span></span><br><span class="line"><span class="function">// <span class="params">EXAMPLE</span></span></span><br><span class="line"><span class="function">// ---------</span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">Demo</span><span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">inst</span> = <span class="params">useInstance</span>(<span class="params">&#123; count: 1 &#125;</span>)</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">update</span> = <span class="params">useForceUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="params">useEffect</span>(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> timer = setInterval(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="comment">// 像类组件一样，进行‘实例变量’存储</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="comment">// 在函数组件的任意地方引用</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="comment">// 只不过更新这些数据不会触发组件的重新渲染</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      inst.count++</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;, 1000</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> (<span class="params"></span>) =&gt; clearInterval(<span class="params">timer</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;div&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">      count: &#123;inst.count&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &lt;button onClick=&#123;update&#125;&gt;刷新&lt;/button&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;/div&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意不要滥用</p></blockquote><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-9-useprevious-获取上一次渲染的值"><a href="#1-9-useprevious-获取上一次渲染的值" class="headerlink" title="1-9 usePrevious 获取上一次渲染的值"></a>1-9 usePrevious 获取上一次渲染的值</h3><p>在Class组件中，我们经常会在<code>shouldComponentUpdate</code>或<code>componentDidUpdate</code>这类生命周期方法中对props或state进行比对，来决定做某些事情，例如重新发起请求、监听事件等等.</p><p>Hooks中我们可以使用useEffect或useMemo来响应状态变化，进行状态或副作用衍生. 所以上述比对的场景在Hooks中很少见。但也不是不可能，React官方案例中就有一个<code>usePrevious</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePrevious</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef();</span><br><span class="line">  <span class="comment">// useEffect会在完成这次'渲染'之后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = value;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="keyword">const</span> calculation = count * <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> prevCalculation = usePrevious(calculation);</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-10-useimmer-简化不可变数据操作"><a href="#1-10-useimmer-简化不可变数据操作" class="headerlink" title="1-10 useImmer 简化不可变数据操作"></a>1-10 useImmer 简化不可变数据操作</h3><p>这个案例来源于<a href="https://github.com/immerjs/use-immer" target="_blank" rel="noopener">use-immer</a>, 结合<a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">immer.js</a>和Hooks来简化不可变数据操作, 看看代码示例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [person, updatePerson] = useImmer(&#123;</span><br><span class="line">  name: <span class="string">"Michel"</span>,</span><br><span class="line">  age: <span class="number">33</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  updatePerson(<span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">    draft.name = name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">becomeOlder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  updatePerson(<span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">    draft.age++;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现也非常简单:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useImmer</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [val, updateValue] = useState(initialValue);</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    val,</span><br><span class="line">    useCallback(<span class="function"><span class="params">updater</span> =&gt;</span> &#123;</span><br><span class="line">      updateValue(produce(updater));</span><br><span class="line">    &#125;, [])</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简洁的Hooks配合简洁的Immer，简直完美</strong></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="1-11-封装’工具hooks’简化state的操作"><a href="#1-11-封装’工具hooks’简化state的操作" class="headerlink" title="1-11 封装’工具Hooks’简化State的操作"></a>1-11 封装’工具Hooks’简化State的操作</h3><p>Hooks只是普通函数，所以可以灵活地自定义。下面举一些例子，利用自定义Hooks来简化常见的数据操作场景</p><p><br></p><h4 id="1-11-1-usetoggle-开关"><a href="#1-11-1-usetoggle-开关" class="headerlink" title="1-11-1 useToggle 开关"></a>1-11-1 useToggle 开关</h4><p>实现boolean值切换</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useToggle</span>(<span class="params">initialValue?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(!!initialValue)</span><br><span class="line">  <span class="keyword">const</span> toggler = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setValue(<span class="function"><span class="params">value</span> =&gt;</span> !value), [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [value, toggler]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [enable, toggleEnable] = useToggle()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;Switch value=&#123;enable&#125; onClick=&#123;toggleEnable&#125;&gt;&lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="1-11-2-usearray-简化数组状态操作"><a href="#1-11-2-usearray-简化数组状态操作" class="headerlink" title="1-11-2 useArray 简化数组状态操作"></a>1-11-2 useArray 简化数组状态操作</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">initial?: T[] | (() =&gt; T[]), idKey: <span class="built_in">string</span> = 'id'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(initial || [])</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    setValue,</span><br><span class="line">    push: useCallback(<span class="function"><span class="params">a</span> =&gt;</span> setValue(<span class="function"><span class="params">v</span> =&gt;</span> [...v, a]), []),</span><br><span class="line">    clear: useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setValue(<span class="function"><span class="params">()</span> =&gt;</span> []), []),</span><br><span class="line">    removeById: useCallback(<span class="function"><span class="params">id</span> =&gt;</span> setValue(<span class="function"><span class="params">arr</span> =&gt;</span> arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v &amp;&amp; v[idKey] !== id)), []),</span><br><span class="line">    removeIndex: useCallback(</span><br><span class="line">      index =&gt;</span><br><span class="line">        setValue(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          v.splice(index, <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> v</span><br><span class="line">        &#125;),</span><br><span class="line">      [],</span><br><span class="line">    ),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;value, push, removeById&#125; = useArray&lt;&#123;id: <span class="built_in">number</span>, name: <span class="built_in">string</span>&#125;&gt;()</span><br><span class="line">  <span class="keyword">const</span> handleAdd = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    push(&#123;id: <span class="built_in">Math</span>.random(), name: getName()&#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;value.map(<span class="function"><span class="params">i</span> =&gt;</span> &lt;span key=&#123;i.id&#125; onClick=&#123;<span class="function"><span class="params">()</span> =&gt;</span> removeById(i.id)&#125;&gt;&#123;i.name&#125;&lt;<span class="regexp">/span&gt;)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;button onClick=&#123;handleAdd&#125;&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限于篇幅，其他数据结构, 例如Set、Map, 就不展开介绍了，读者可以自己发挥想象力.</p><p><br><br><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="2-模拟生命周期函数"><a href="#2-模拟生命周期函数" class="headerlink" title="2. 模拟生命周期函数"></a><strong>2. 模拟生命周期函数</strong></h2><p>组件生命周期相关的操作依赖于<code>useEffect</code> Hook. <strong>React在函数组件中刻意淡化了组件生命周期的概念，而更关注‘数据的响应’</strong>.</p><p><code>useEffect</code>名称意图非常明显，就是<strong>专门用来管理组件的副作用</strong>。和useCallback一样，useEffect支持传递第二个参数，告知React在这些值发生变动时才执行父作用. 原理大概如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memoCallback = &#123;<span class="attr">fn</span>: <span class="literal">undefined</span>, <span class="attr">disposer</span>: <span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="keyword">let</span> memoArgs</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果变动则执行副作用</span></span><br><span class="line">  <span class="keyword">if</span> (args == <span class="literal">null</span> || !isEqual(memoArgs, args)) &#123;</span><br><span class="line">    memoArgs = args</span><br><span class="line">    memoCallback.fn = fn</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放进队列等待调度执行</span></span><br><span class="line">    pushIntoEffectQueue(memoCallback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 副作用执行</span></span><br><span class="line"><span class="comment">// 这个会在组件完成渲染，在布局(layout)和绘制(paint)之后被执行</span></span><br><span class="line"><span class="comment">// 如果是useLayoutEffect, 执行的时机会更早一些</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueExecute</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先执行清理函数</span></span><br><span class="line">  <span class="keyword">if</span> (callback.disposer) &#123;</span><br><span class="line">    callback.disposer()</span><br><span class="line">  &#125;</span><br><span class="line">  callback.disposer = callback.fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>关于useEffect官网有详尽的<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener">描述</a>; Dan Abramov也写了一篇<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">useEffect 完整指南</a>, 推荐👍。</p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="2-1-useonmount-模拟componentdidmount"><a href="#2-1-useonmount-模拟componentdidmount" class="headerlink" title="2-1 useOnMount 模拟componentDidMount"></a>2-1 useOnMount 模拟componentDidMount</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useOnMount</span>(<span class="params">fn: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fn()</span><br><span class="line">  &#125;, []) <span class="comment">// 第二个参数设置为[], 表示不必对任何数据， 所以只在首次渲染时调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useOnMount(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> loadList()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// log</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>如果需要在挂载/状态更新时请求一些资源、并且需要在卸载时释放这些资源，还是推荐使用useEffect，因为这些逻辑最好放在一起, 方便维护和理解</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 但是useEffect传入的函数不支持async/await(返回Promise)</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求资源</span></span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放资源</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="2-2-useonunmount-模拟componentwillunmount"><a href="#2-2-useonunmount-模拟componentwillunmount" class="headerlink" title="2-2 useOnUnmount 模拟componentWillUnmount"></a>2-2 useOnUnmount 模拟componentWillUnmount</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useOnUnmount</span>(<span class="params">fn: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="2-3-useonupdate-模拟componentdidupdate"><a href="#2-3-useonupdate-模拟componentdidupdate" class="headerlink" title="2-3 useOnUpdate 模拟componentDidUpdate"></a>2-3 useOnUpdate 模拟componentDidUpdate</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnUpdate</span>(<span class="params">fn: () =&gt; <span class="built_in">void</span>, dep?: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(&#123; fn, mounted: <span class="literal">false</span> &#125;)</span><br><span class="line">  ref.current.fn = fn</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 首次渲染不执行</span></span><br><span class="line">    <span class="keyword">if</span> (!ref.current.mounted) &#123;</span><br><span class="line">      ref.current.mounted = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.current.fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  useOnUpdate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dosomethingwith(props.a)</span><br><span class="line">  &#125;, [props.a])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>其他生命周期函数的模拟:</p><ul><li><code>shouldComponentUpdate</code> - React.memo包裹组件</li><li><code>componentDidCatch</code> - 暂不支持</li></ul><p><br><br><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="3-事件处理"><a href="#3-事件处理" class="headerlink" title="3. 事件处理"></a><strong>3. 事件处理</strong></h2><h3 id="3-1-usechange-简化onchange表单双向绑定"><a href="#3-1-usechange-简化onchange表单双向绑定" class="headerlink" title="3-1 useChange 简化onChange表单双向绑定"></a>3-1 useChange 简化onChange表单双向绑定</h3><p>表单值的双向绑定在项目中非常常见，通常我们的代码是这样的:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback&lt;React.ChangeEventHandler&lt;HTMLInputElement&gt;&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(evt.target.value)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;input value=&#123;value&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要维护多个表单，这种代码就会变得难以接受。幸好有Hooks，我们可以简化这些代码:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useChange</span>&lt;<span class="title">S</span>&gt;(<span class="params">initial?: S | (() =&gt; S)</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState&lt;S | <span class="literal">undefined</span>&gt;(initial)</span><br><span class="line">  <span class="keyword">const</span> onChange = useCallback(<span class="function"><span class="params">e</span> =&gt;</span> setValue(e.target.value), [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    setValue,</span><br><span class="line">    onChange,</span><br><span class="line">    <span class="comment">// 绑定到原生事件</span></span><br><span class="line">    bindEvent: &#123;</span><br><span class="line">      onChange,</span><br><span class="line">      value,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 绑定到自定义组件</span></span><br><span class="line">    bind: &#123;</span><br><span class="line">      onChange: setValue,</span><br><span class="line">      value,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userName = useChange(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> password = useChange(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input &#123;...userName.bindEvent&#125; /&gt;</span><br><span class="line">      &lt;input <span class="keyword">type</span>=<span class="string">"password"</span> &#123;...password.bindEvent&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-2-usebind-绑定回调参数"><a href="#3-2-usebind-绑定回调参数" class="headerlink" title="3-2 useBind 绑定回调参数"></a>3-2 useBind 绑定回调参数</h3><p>绑定一些回调参数，并利用useMemo给下级传递一个缓存的回调, 避免重新渲染:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useBind</span>(<span class="params">fn?: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>): (<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt; <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;fn &amp;&amp; fn.bind(<span class="literal">null</span>, ...args)&#125;, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;id, onClick&#125; = props</span><br><span class="line">  <span class="keyword">const</span> handleClick = useBind(onClick, id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;ComplexComponent onClick=&#123;handleClick&#125;&gt;&lt;<span class="regexp">/ComplexComponent&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 等价于</span></span><br><span class="line"><span class="regexp">function Demo(props) &#123;</span></span><br><span class="line"><span class="regexp">  const &#123;id, onClick&#125; = props</span></span><br><span class="line"><span class="regexp">  const handleClick = useCallback(() =&gt; onClick(id), [id])</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return &lt;ComplexComponent onClick=&#123;handleClick&#125;&gt;&lt;/</span>ComplexComponent&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-3-自定义事件封装"><a href="#3-3-自定义事件封装" class="headerlink" title="3-3 自定义事件封装"></a>3-3 自定义事件封装</h3><p>Hooks也可以用于封装一些高级事件或者简化事件的处理，比如拖拽、手势、鼠标Active/Hover等等；</p><p><br></p><h4 id="3-3-1-useactive"><a href="#3-3-1-useactive" class="headerlink" title="3-3-1 useActive"></a>3-3-1 useActive</h4><p>举个简单的例子, useActive, 在鼠标按下时设置状态为true，鼠标释放时恢复为false:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useActive</span>(<span class="params">refEl: React.RefObject&lt;HTMLElement&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="literal">false</span>)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleMouseDown = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setValue(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> handleMouseUp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setValue(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DOM 事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (refEl &amp;&amp; refEl.current) &#123;</span><br><span class="line">      refEl.current.addEventListener(<span class="string">'mousedown'</span>, handleMouseDown)</span><br><span class="line">      refEl.current.addEventListener(<span class="string">'mouseup'</span>, handleMouseUp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (refEl &amp;&amp; refEl.current) &#123;</span><br><span class="line">        refEl.current.removeEventListener(<span class="string">'mousedown'</span>, handleMouseDown)</span><br><span class="line">        refEl.current.removeEventListener(<span class="string">'mouseup'</span>, handleMouseUp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elRef = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> active = useActive(inputRef)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div ref=&#123;elRef&#125;&gt;&#123;active ? <span class="string">"Active"</span> : <span class="string">"Nop"</span>&#125;&lt;<span class="regexp">/div&gt;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="3-3-2-usetouch-手势事件封装"><a href="#3-3-2-usetouch-手势事件封装" class="headerlink" title="3-3-2 useTouch 手势事件封装"></a>3-3-2 useTouch 手势事件封装</h4><p>更复杂的自定义事件, 例如手势。限于篇幅就不列举它们的实现代码，我们可以看看它们的Demo:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;ref&#125; = useTouch(&#123;</span><br><span class="line">    onTap: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* 点击 */</span> &#125;,</span><br><span class="line">    onLongTap: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* 长按 */</span> &#125;,</span><br><span class="line">    onRotate: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* 旋转 */</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div className=<span class="string">"box"</span> ref=&#123;ref&#125;&gt;&lt;<span class="regexp">/div&gt;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useTouch的实现可以参考<a href="https://github.com/GDJiaMi/hooks/blob/master/src/useTouch.ts" target="_blank" rel="noopener">useTouch.ts</a></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="3-3-3-usedraggable-拖拽事件封装"><a href="#3-3-3-usedraggable-拖拽事件封装" class="headerlink" title="3-3-3 useDraggable 拖拽事件封装"></a>3-3-3 useDraggable 拖拽事件封装</h4><p>拖拽也是一个典型的自定义事件, 下面这个例子来源于<a href="https://stackblitz.com/edit/usedraggable" target="_blank" rel="noopener">这里</a></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDraggable</span>(<span class="params">ref: React.RefObject&lt;HTMLElement&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [&#123; dx, dy &#125;, setOffset] = useState(&#123; dx: <span class="number">0</span>, dy: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`[useDraggable] ref未注册到组件中`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> el = ref.current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleMouseDown = <span class="function">(<span class="params">event: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> startX = event.pageX - dx</span><br><span class="line">      <span class="keyword">const</span> startY = event.pageY - dy</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> handleMouseMove = <span class="function">(<span class="params">event: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newDx = event.pageX - startX</span><br><span class="line">        <span class="keyword">const</span> newDy = event.pageY - startY</span><br><span class="line">        setOffset(&#123; dx: newDx, dy: newDy &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, handleMouseMove)</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(</span><br><span class="line">        <span class="string">'mouseup'</span>,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">          <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, handleMouseMove)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; once: <span class="literal">true</span> &#125;,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    el.addEventListener(<span class="string">'mousedown'</span>, handleMouseDown)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      el.removeEventListener(<span class="string">'mousedown'</span>, handleMouseDown)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [dx, dy])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref.current) &#123;</span><br><span class="line">      ref.current.style.transform = <span class="string">`translate3d(<span class="subst">$&#123;dx&#125;</span>px, <span class="subst">$&#123;dy&#125;</span>px, 0)`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [dx, dy])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = useRef();</span><br><span class="line">  useDraggable(el);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"box"</span> ref=&#123;el&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可运行<a href="https://stackblitz.com/edit/usedraggable" target="_blank" rel="noopener">例子</a></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h4 id="3-3-4-react-events-面向未来的高级事件封装"><a href="#3-3-4-react-events-面向未来的高级事件封装" class="headerlink" title="3-3-4 react-events 面向未来的高级事件封装"></a>3-3-4 react-events 面向未来的高级事件封装</h4><p>我在<a href="https://juejin.im/post/5d44e3745188255d5861d654" target="_blank" rel="noopener">&lt;谈谈React事件机制和未来(react-events)&gt;</a>介绍了<code>React-Events</code>这个<strong>实验性</strong>的API。当这个API成熟后，我们可以基于它来实现更优雅的高级事件的封装：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PressResponder, usePressListener &#125; <span class="keyword">from</span> <span class="string">'react-events/press'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">const</span> listener = usePressListener(&#123;  <span class="comment">// ⚛️ 通过hooks创建Responder</span></span><br><span class="line">    onPressStart,</span><br><span class="line">    onPress,</span><br><span class="line">    onPressEnd,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div listeners=&#123;listener&#125;&gt;</span><br><span class="line">      &#123;subtrees&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-4-usesubscription-通用事件源订阅"><a href="#3-4-usesubscription-通用事件源订阅" class="headerlink" title="3-4 useSubscription 通用事件源订阅"></a>3-4 useSubscription 通用事件源订阅</h3><p>React官方维护了一个<a href="https://github.com/facebook/react/tree/master/packages/use-subscription" target="_blank" rel="noopener">use-subscription</a>包，支持使用Hooks的形式来监听事件源. 事件源可以是DOM事件、RxJS的Observable等等.</p><p>先来看看使用示例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听rxjs behaviorSubject</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = useMemo(</span><br><span class="line">    () =&gt; (&#123;</span><br><span class="line">      getCurrentValue: <span class="function"><span class="params">()</span> =&gt;</span> behaviorSubject.getValue(),</span><br><span class="line">      subscribe: <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当事件触发时调用callback</span></span><br><span class="line">        <span class="keyword">const</span> subscription = behaviorSubject.subscribe(callback);</span><br><span class="line">        <span class="comment">// 和useEffect一样，返回一个函数来取消订阅</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> subscription.unsubscribe();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 在behaviorSubject变化后重新订阅</span></span><br><span class="line">    [behaviorSubject]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value = useSubscription(subscription);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看看实现:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useSubscription</span>&lt;<span class="title">T</span>&gt;(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  getCurrentValue,</span></span></span><br><span class="line"><span class="function"><span class="params">  subscribe,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 获取当前值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  getCurrentValue?: () =&gt; T</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 用于订阅事件源</span></span></span></span><br><span class="line"><span class="function"><span class="params">  subscribe: (callback: <span class="built_in">Function</span>) =&gt; () =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; getCurrentValue, subscribe, value: getCurrentValue() &#125;))</span><br><span class="line">  <span class="keyword">let</span> valueToReturn = state.value</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新getCurrentValue和subscribe</span></span><br><span class="line">  <span class="keyword">if</span> (state.getCurrentValue !== getCurrentValue || state.subscribe !== subscribe) &#123;</span><br><span class="line">    valueToReturn = getCurrentValue()</span><br><span class="line">    setState(&#123; getCurrentValue, subscribe, value: valueToReturn &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> didUnsubscribe = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> checkForUpdates = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (didUnsubscribe) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 检查getCurrentValue和subscribe是否变动</span></span><br><span class="line">        <span class="comment">// setState时如果返回值没有变化，则不会触发重新渲染</span></span><br><span class="line">        <span class="keyword">if</span> (prevState.getCurrentValue !== getCurrentValue || prevState.subscribe !== subscribe) &#123;</span><br><span class="line">          <span class="keyword">return</span> prevState</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值没变动</span></span><br><span class="line">        <span class="keyword">const</span> value = getCurrentValue()</span><br><span class="line">        <span class="keyword">if</span> (prevState.value === value) &#123;</span><br><span class="line">          <span class="keyword">return</span> prevState</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123; ...prevState, value &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> unsubscribe = subscribe(checkForUpdates)</span><br><span class="line">    checkForUpdates()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      didUnsubscribe = <span class="literal">true</span></span><br><span class="line">      unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [getCurrentValue, subscribe])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> valueToReturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现也不复杂，甚至可以说有点啰嗦.</p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-5-useobservable-hooks和rxjs优雅的结合-rxjs-hooks"><a href="#3-5-useobservable-hooks和rxjs优雅的结合-rxjs-hooks" class="headerlink" title="3-5 useObservable Hooks和RxJS优雅的结合(rxjs-hooks)"></a>3-5 useObservable Hooks和RxJS优雅的结合(rxjs-hooks)</h3><p>如果要配合RxJS使用，LeetCode团队封装了一个<a href="https://github.com/LeetCode-OpenSource/rxjs-hooks/blob/master/README.md" target="_blank" rel="noopener">rxjs-hooks</a>库，用起来则要优雅很多, 非常推荐:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useObservable(<span class="function"><span class="params">()</span> =&gt;</span> interval(<span class="number">500</span>).pipe(map(<span class="function">(<span class="params">val</span>) =&gt;</span> val * <span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Incremental <span class="built_in">number</span>: &#123;value&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="3-6-useeventemitter-对接eventemitter"><a href="#3-6-useeventemitter-对接eventemitter" class="headerlink" title="3-6 useEventEmitter 对接eventEmitter"></a>3-6 useEventEmitter 对接eventEmitter</h3><p>我在<a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-3" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a>这篇文章里面提过：<strong>自定义 hook 和函数组件的代码结构基本一致, 所以有时候hooks 写着写着原来越像组件, 组件写着写着越像 hooks. 我觉得可以认为组件就是一种特殊的 hook, 只不过它输出 Virtual DOM</strong></p><p>Hooks跟组件一样，是一个逻辑和状态的聚合单元。可以维护自己的状态、有自己的’生命周期’.</p><p><code>useEventEmitter</code>就是一个典型的例子，可以独立地维护和释放自己的资源:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">function</span><span class="title">ReturnObject</span> = (<span class="params"></span>) =&gt; (<span class="params">&#123;&#125;</span>)</span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="function"><span class="keyword">function</span><span class="title">ReturnArray</span> = (<span class="params"></span>) =&gt; []</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEventEmitter</span>(<span class="params">emmiter: EventEmitter</span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">disposers</span> = <span class="title">useRef</span>&lt;<span class="title">Function</span>[]&gt;(<span class="params">[]</span>)</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">listeners</span> = <span class="title">useRef</span>&lt;</span>&#123; [<span class="title">name</span>: <span class="title">string</span>]: <span class="title">Function</span> &#125;&gt;(<span class="params">&#123;&#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">const</span> <span class="title">on</span> = <span class="title">useCallback</span>(<span class="params">&lt;P&gt;(name: <span class="built_in">string</span>, cb: (data: P) =&gt; <span class="built_in">void</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (!(name <span class="keyword">in</span> listeners.current)) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> call = (...args: <span class="built_in">any</span>[]) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> fn = listeners.current[name]</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> (fn) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">          fn(...args)</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="comment">// 监听eventEmitter</span></span></span></span><br><span class="line"><span class="function"><span class="params">      emmiter.on(name, call)</span></span></span><br><span class="line"><span class="function"><span class="params">      disposers.current.push(() =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        emmiter.off(name, call)</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    listeners.current[name] = cb</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">useEffect</span>(<span class="params">() =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// 资源释放</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> () =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      disposers.current.forEach(i =&gt; i())</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">return</span> </span>&#123;</span><br><span class="line">    on,</span><br><span class="line">    emit: emmiter.emit,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; on, emit &#125; = useEventEmitter(eventBus)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件监听</span></span><br><span class="line">  on(<span class="string">'someEvent'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 事件触发</span></span><br><span class="line">    emit(<span class="string">'anotherEvent'</span>, someData)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div onClick=&#123;handleClick&#125;&gt;...&lt;<span class="regexp">/div&gt;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>更多脑洞：</p><ul><li><a href="https://github.com/mfrachet/use-socketio" target="_blank" rel="noopener">use-socketio</a></li></ul><p><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="4-context的妙用"><a href="#4-context的妙用" class="headerlink" title="4. Context的妙用"></a><strong>4. Context的妙用</strong></h2><p>通过<a href="https://reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener"><code>useContext</code></a>可以方便地引用Context。不过需要注意的是如果上级<code>Context.Provider</code>的value变化，使用useContext的组件就会被强制重新渲染。</p><h3 id="4-1-usetheme-主题配置"><a href="#4-1-usetheme-主题配置" class="headerlink" title="4-1 useTheme 主题配置"></a>4-1 useTheme 主题配置</h3><p>原本需要使用高阶组件注入或Context.Consumer获取的Context值，现在变得非常简洁：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传统方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 通过高阶组件注入</span></span><br><span class="line">withTheme(MyComponent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取利用Context.Consumer</span></span><br><span class="line"><span class="keyword">const</span> MyComponentWithTheme = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;<span class="function"><span class="params">value</span> =&gt;</span> &lt;MyComponent theme=&#123;value&#125; &#123;...props&#125;&gt;&lt;<span class="regexp">/MyComponent&gt;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>ThemeContext.Consumer&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hooks方式</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext, FC &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext&lt;object&gt;(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeProvider: FC&lt;&#123; theme: object &#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;ThemeContext.Provider value=&#123;props.theme&#125;&gt;&#123;props.children&#125;&lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export function useTheme&lt;T extends object&gt;(): T &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(ThemeContext)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ---------</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ EXAMPLE</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ---------</span></span><br><span class="line"><span class="regexp">const theme = &#123;</span></span><br><span class="line"><span class="regexp">  primary: '#000',</span></span><br><span class="line"><span class="regexp">  secondary: '#444',</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemeProvider theme=&#123;theme&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;...&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeProvider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Button: FC = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const t = useTheme&lt;typeof theme&gt;()</span></span><br><span class="line"><span class="regexp">  const style = &#123;</span></span><br><span class="line"><span class="regexp">    color: t.primary,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return &lt;button style=&#123;style&#125;&gt;&#123;props.children&#125;&lt;/</span>button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="4-2-unstated-简单状态管理器"><a href="#4-2-unstated-简单状态管理器" class="headerlink" title="4-2 unstated 简单状态管理器"></a>4-2 unstated 简单状态管理器</h3><p>Hooks + Context 也可以用于实现简单的状态管理。</p><p>我在<a href="https://juejin.im/post/5ce3ee436fb9a07f070e0220#heading-2" target="_blank" rel="noopener">React组件设计实践总结05 - 状态管理</a>就提到过<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Funstated-next" target="_blank" rel="noopener">unstated-next</a>， 这个库只有主体代码十几行，<strong>利用了React本身的机制来实现状态管理</strong>.</p><p>先来看看使用示例</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContainer &#125; <span class="keyword">from</span> <span class="string">"unstated-next"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCounter</span>(<span class="params">initialState = 0</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [count, setCount] = useState(initialState)</span><br><span class="line">  <span class="keyword">let</span> decrement = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123; count, decrement, increment &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Counter = createContainer(useCounter)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterDisplay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = Counter.useContainer()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;counter.decrement&#125;&gt;-&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;&#123;counter.count&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;button onClick=&#123;counter.increment&#125;&gt;+&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看它的源码:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params">useHook</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只是创建一个Context</span></span><br><span class="line"><span class="keyword">let</span> Context = React.createContext(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Provider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> value = useHook(props.initialState)</span><br><span class="line"><span class="keyword">return</span> &lt;Context.Provider value=&#123;value&#125;&gt;&#123;props.children&#125;&lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function useContainer() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 只是使用useContext</span></span><br><span class="line"><span class="regexp">let value = React.useContext(Context)</span></span><br><span class="line"><span class="regexp">if (value === null) &#123;</span></span><br><span class="line"><span class="regexp">throw new Error("Component must be wrapped with &lt;Container.Provider&gt;")</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">return value</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return &#123; Provider, useContainer &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export function useContainer(container) &#123;</span></span><br><span class="line"><span class="regexp">return container.useContainer()</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>到这里，你会说，我靠，就这样? 这个库感觉啥事情都没干啊?</p><p>需要注意的是, <strong>Context不是万金油，它作为状态管理有一个比较致命的缺陷</strong>，我在<a href="https://juejin.im/post/5d045350f265da1b695d5bf2#heading-14" target="_blank" rel="noopener">浅谈React性能优化的方向</a>文章中也提到了这一点:<br><strong>它是可以穿透React.memo或者shouldComponentUpdate的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate</strong></p><p>所以如果你打算使用Context作为状态管理，一定要注意规避这一点. 它可能会导致组件频繁重新渲染.</p><p><br></p><p>其他状态管理方案:</p><ul><li><a href="https://github.com/ctrlplusb/easy-peasy" target="_blank" rel="noopener">easy-peasy</a></li><li><a href="https://github.com/dai-shi/react-hooks-global-state" target="_blank" rel="noopener">react-hooks-global-state</a></li></ul><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="4-3-usei18n-国际化"><a href="#4-3-usei18n-国际化" class="headerlink" title="4-3 useI18n 国际化"></a>4-3 useI18n 国际化</h3><p>I18n是另一个Context的典型使用场景。<a href="https://github.com/formatjs/react-intl/blob/master/docs/API.md#useintl-hook-currently-available-in-300-beta" target="_blank" rel="noopener">react-intl</a>和<a href="https://react.i18next.com/latest/usetranslation-hook" target="_blank" rel="noopener">react-i18next</a>都与时俱进，推出了自己的Hook API, <strong>基本上原本使用高阶组件(HOC)实现的功能都可以用Hooks代替，让代码变得更加简洁</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useTranslation &#125; <span class="keyword">from</span> <span class="string">'react-i18next'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; t, i18n &#125; = useTranslation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;t('my translated text')&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="4-4-userouter-简化路由状态的访问"><a href="#4-4-userouter-简化路由状态的访问" class="headerlink" title="4-4 useRouter 简化路由状态的访问"></a>4-4 useRouter 简化路由状态的访问</h3><p>React Hooks 推出已经接近一年，ReactRouter竟然还没有正式推出Hook API。不过它们也提上了计划 —— <a href="https://reacttraining.com/blog/reach-react-router-future/" target="_blank" rel="noopener">The Future of React Router and @reach/router</a>，5.X版本会推出Hook API. 我们暂时先看看一些代码示例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SomeComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 访问路由变量</span></span><br><span class="line">  <span class="keyword">const</span> &#123; userId &#125; = useParams()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePageViews</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 访问location对象</span></span><br><span class="line">  <span class="comment">// 原本对于非路由组件，需要访问路由信息需要通过withRouter高阶组件注入</span></span><br><span class="line">  <span class="keyword">const</span> &#123; location &#125; = useLocation()</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>, location.pathname)</span><br><span class="line">  &#125;, [location])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再等等吧!</p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="4-5-react-hook-form-hooks和表单能擦出什么火花"><a href="#4-5-react-hook-form-hooks和表单能擦出什么火花" class="headerlink" title="4-5 react-hook-form Hooks和表单能擦出什么火花?"></a>4-5 react-hook-form Hooks和表单能擦出什么火花?</h3><p><a href="https://github.com/react-hook-form/react-hook-form" target="_blank" rel="noopener">react-hook-form</a>是Hooks+Form的典型案例，比较符合我理想中的表单管理方式:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> useForm <span class="keyword">from</span> <span class="string">'react-hook-form'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; register, handleSubmit, errors &#125; = useForm(); <span class="comment">// initialise the hook</span></span><br><span class="line">  <span class="keyword">const</span> onSubmit = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;; <span class="comment">// callback when validation pass</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt;</span><br><span class="line">      &lt;input name=<span class="string">"firstname"</span> ref=&#123;register&#125; /&gt; &#123;<span class="comment">/* register an input */</span>&#125;</span><br><span class="line">      </span><br><span class="line">      &lt;input name=<span class="string">"lastname"</span> ref=&#123;register(&#123; <span class="attr">required</span>: <span class="literal">true</span> &#125;)&#125; /&gt;</span><br><span class="line">      &#123;errors.lastname &amp;&amp; <span class="string">'Last name is required.'</span>&#125;</span><br><span class="line">      </span><br><span class="line">      &lt;input name=<span class="string">"age"</span> ref=&#123;register(&#123; <span class="attr">pattern</span>: <span class="regexp">/\d+/</span> &#125;)&#125; /&gt;</span><br><span class="line">      &#123;errors.age &amp;&amp; <span class="string">'Please enter number for age.'</span>&#125;</span><br><span class="line">      </span><br><span class="line">      &lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><p><br></p><h2 id="5-副作用封装"><a href="#5-副作用封装" class="headerlink" title="5. 副作用封装"></a><strong>5. 副作用封装</strong></h2><p>我们可以<strong>利用Hooks来封装或监听组件外部的副作用，将它们转换为组件的状态</strong>。</p><p><br></p><h3 id="5-1-usetimeout-超时修改状态"><a href="#5-1-usetimeout-超时修改状态" class="headerlink" title="5-1 useTimeout 超时修改状态"></a>5-1 useTimeout 超时修改状态</h3><p>useTimeout由用户触发，在指定时间后恢复状态. 比如可以用于’短期禁用’按钮, 避免重复点击:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [disabled, start] = useTimeout(<span class="number">5000</span>)</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    start()</span><br><span class="line">    dosomething()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;Button onClick=&#123;handleClick&#125; disabled=&#123;disabled&#125;&gt;点我&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>实现:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTimeout</span>(<span class="params">ms: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ready, setReady] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> timerRef = useRef&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> start = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timerRef.current)</span><br><span class="line">    setReady(<span class="literal">true</span>)</span><br><span class="line">    timerRef.current = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setReady(<span class="literal">false</span>)</span><br><span class="line">    &#125;, ms)</span><br><span class="line">  &#125;, [ms])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stop = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timeRef.current)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  useOnUnmount(stop)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [ready, start, stop]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="5-2-useonlinestatus-监听在线状态"><a href="#5-2-useonlinestatus-监听在线状态" class="headerlink" title="5-2 useOnlineStatus 监听在线状态"></a>5-2 useOnlineStatus 监听在线状态</h3><p>副作用封装一个比较典型的案例就是监听主机的在线状态：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOnlineStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> navigator.onLine === <span class="string">'boolean'</span> ? navigator.onLine : <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnlineStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [onlineStatus, setOnlineStatus] = useState(getOnlineStatus())</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> online = <span class="function"><span class="params">()</span> =&gt;</span> setOnlineStatus(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> offline = <span class="function"><span class="params">()</span> =&gt;</span> setOnlineStatus(<span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, online)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, offline)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'online'</span>, online)</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'offline'</span>, offline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> onlineStatus</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> onlineStatus = useOnlineStatus();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;网络状态: &#123;onlineStatus ? <span class="string">"在线"</span> : <span class="string">"离线"</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>还有很多案例, 这里就不一一列举，读者可以自己尝试去实现，比如:</p><ul><li>useDeviceOrientation 监听设备方向</li><li>useGeolocation 监听GPS坐标变化</li><li>useScrollPosition 监听滚动位置</li><li>useMotion 监听设备运动</li><li>useMediaDevice 监听媒体设备</li><li>useDarkMode 夜间模式监听</li><li>useKeyBindings 监听快捷键</li><li>….</li></ul><p><br></p><p><a href="#">⤴️回到顶部</a></p><p><br></p><h2 id="6-副作用衍生"><a href="#6-副作用衍生" class="headerlink" title="6. 副作用衍生"></a><strong>6. 副作用衍生</strong></h2><p><strong>和<code>副作用封装</code>相反，副作用衍生是指当组件状态变化时，衍生出其他副作用. 两者的方向是相反的</strong>.</p><p>副作用衍生主要会用到useEffect，使用useEffect来响应状态的变化.</p><h3 id="6-1-usetitle-设置文档title"><a href="#6-1-usetitle-设置文档title" class="headerlink" title="6-1 useTitle 设置文档title"></a>6-1 useTitle 设置文档title</h3><p>useTitle是最简单的，当给定的值变化时，更新<code>document.title</code></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTitle</span>(<span class="params">t: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = t</span><br><span class="line">  &#125;, [t])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  useTitle(props.isEdit ? <span class="string">'编辑'</span> : <span class="string">'新增'</span>)</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="6-2-usedebounce"><a href="#6-2-usedebounce" class="headerlink" title="6-2 useDebounce"></a>6-2 useDebounce</h3><p>再来个复杂一点的，useDebounce：当某些状态变化时，它会延迟执行某些操作：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn: () =&gt; <span class="built_in">void</span>, args?: <span class="built_in">any</span>[], ms: <span class="built_in">number</span> = 100, skipMount?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mounted = useRef(<span class="literal">false</span>)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 跳过挂载执行</span></span><br><span class="line">    <span class="keyword">if</span> (skipMount &amp;&amp; !mounted.current) &#123;</span><br><span class="line">      mounted.current = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> timer = setTimeout(fn, ms)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果args变化，先清除计时器</span></span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="keyword">const</span> returnEmptyArray = <span class="function"><span class="params">()</span> =&gt;</span> []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState(returnEmptyArray)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索</span></span><br><span class="line">  <span class="keyword">const</span> handleSearch = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    setList(<span class="keyword">await</span> fetchList(query))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当query变化时执行搜索</span></span><br><span class="line">  useDebounce(handleSearch, [query], <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">    &lt;SearchBar value=&#123;query&#125; onChange=&#123;setQuery&#125; /&gt;</span><br><span class="line">    &lt;Result list=&#123;list&#125;&gt;&lt;<span class="regexp">/Result&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="6-3-usethrottle"><a href="#6-3-usethrottle" class="headerlink" title="6-3 useThrottle"></a>6-3 useThrottle</h3><p>同理可以实现useThrottle, 下面的例子来源于<a href="https://github.com/streamich/react-use/blob/master/src/useThrottleFn.ts" target="_blank" rel="noopener">react-use</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useThrottleFn = &lt;T&gt;<span class="function">(<span class="params">fn: (<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt; T, ms: <span class="built_in">number</span> = 200, args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState&lt;T&gt;(<span class="literal">null</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">  <span class="keyword">const</span> timeout = useRef&lt;<span class="built_in">any</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> nextArgs = useRef(<span class="literal">null</span>) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">const</span> hasNextArgs = useRef(<span class="literal">false</span>) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timeout.current) &#123;</span><br><span class="line">      setState(fn(...args));</span><br><span class="line">      <span class="keyword">const</span> timeoutCallback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNextArgs.current) &#123;</span><br><span class="line">          hasNextArgs.current = <span class="literal">false</span>;</span><br><span class="line">          setState(fn(...nextArgs.current));</span><br><span class="line">          timeout.current = setTimeout(timeoutCallback, ms);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          timeout.current = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      timeout.current = setTimeout(timeoutCallback, ms);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextArgs.current = args;</span><br><span class="line">      hasNextArgs.current = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, args);</span><br><span class="line"></span><br><span class="line">  useOnUnmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timeout.current);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><p><br></p><h2 id="7-简化业务逻辑"><a href="#7-简化业务逻辑" class="headerlink" title="7. 简化业务逻辑"></a><strong>7. 简化业务逻辑</strong></h2><p><strong>80%的程序员80%的时间在写业务代码</strong>. 有了Hooks，React开发者如获至宝. 组件的代码可以变得很精简，且这些Hooks可以方便地在组件之间复用:</p><p><img src="/images/react-hooks/hooks-transform.png" alt></p><p><br></p><p>下面介绍，如何利用Hooks来简化业务代码</p><h3 id="7-1-usepromise-封装异步请求"><a href="#7-1-usepromise-封装异步请求" class="headerlink" title="7-1 usePromise 封装异步请求"></a>7-1 usePromise 封装异步请求</h3><p>第一个例子，试试封装一下promise，简化简单页面异步请求的流程. 先来看看usePromise的使用示例，我理想中的usePromise应该长这样:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Demo() &#123;</span><br><span class="line">  const list = usePromise(async (id: string) =&gt; &#123;</span><br><span class="line">    return fetchList(id)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return (&lt;div&gt;</span><br><span class="line">    &#123;/* 触发请求 */&#125;</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; list.callIgnoreError(&apos;myId&apos;)&#125;&gt;Get List&lt;/button&gt;</span><br><span class="line">    &#123;/* 错误信息展示和重试 */&#125;</span><br><span class="line">    &#123;!!list.error &amp;&amp; &lt;ErrorMessage error=&#123;list.error&#125; retry=&#123;list.retry&#125;&gt;加载失败:&lt;/ErrorMessage&gt;&#125;</span><br><span class="line">    &#123;/* 加载状态 */&#125;</span><br><span class="line">    &lt;Loader loading=&#123;list.loading&#125;&gt;</span><br><span class="line">      &#123;/* 请求结果 */&#125;</span><br><span class="line">      &lt;Result value=&#123;list.value&#125;&gt;&lt;/Result&gt;</span><br><span class="line">    &lt;/Loader&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>usePromise是我用得比较多的一个Hooks，所以我把它完整的代码，包括Typescript注解都贴出来，供大家参考参考:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义usePromise的返回值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Res&lt;T, S&gt; &#123;</span><br><span class="line">  loading: <span class="built_in">boolean</span></span><br><span class="line">  error?: <span class="built_in">Error</span></span><br><span class="line">  value?: S</span><br><span class="line">  setValue: <span class="function">(<span class="params">v: S</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  call: T</span><br><span class="line">  callIgnoreError: T</span><br><span class="line">  reset: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  retry: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义usePromise 参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UsePromiseOptions &#123;</span><br><span class="line">  <span class="comment">// 如果promise正在加载中则跳过，默认为true</span></span><br><span class="line">  skipOnLoading?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👇 下面是一堆Typescript函数重载声明，为了方便Typescript推断泛型变量. 小白可以跳过</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>&gt;(<span class="params">action: () =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params"></span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>, <span class="title">A</span>&gt;(<span class="params">action: (arg0: A) =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">arg0: A</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">B</span>&gt;(<span class="params">action: (arg0: A, arg1: B) =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">arg0: A, arg1: B</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt;(<span class="params"> action: (arg0: A, arg1: B, arg2: C) =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">arg0: A, arg1: B, arg2: C</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;(<span class="params">action: (arg0: A, arg1: B, arg2: C, arg3: D) =&gt; <span class="built_in">Promise</span>&lt;T&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">arg0: A, arg1: B, arg2: C, arg3: D</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params">action: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;, option?: UsePromiseOptions</span>): <span class="title">Res</span>&lt;(<span class="params">...args: <span class="built_in">any</span></span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">any</span>&gt;, <span class="title">any</span>&gt;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">// 👆 上面是一堆<span class="title">Typescript</span>函数重载声明，可以跳过</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">/**</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"> * 接受一个<span class="title">action</span>，用于执行异步操作</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"> */</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params"></span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  action: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;,</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  option: UsePromiseOptions = &#123; skipOnLoading: <span class="literal">true</span> &#125;,</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params"></span>): <span class="title">Res</span>&lt;(<span class="params">...args: <span class="built_in">any</span></span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">any</span>&gt;, <span class="title">any</span>&gt; </span>&#123;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">actionRef</span> = <span class="title">useRefProps</span>(<span class="params">action</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">optionRef</span> = <span class="title">useRefProps</span>(<span class="params">option</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> [<span class="title">loading</span>, <span class="title">setLoading</span>, <span class="title">loadingRef</span>] = <span class="title">useRefState</span>(<span class="params"><span class="literal">false</span></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">taskIdRef</span> = <span class="title">useRef</span>&lt;<span class="title">number</span>&gt;(<span class="params"></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">argsRef</span> = <span class="title">useRef</span>&lt;<span class="title">any</span>[]&gt;(<span class="params"></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> [<span class="title">value</span>, <span class="title">setValue</span>] = <span class="title">useState</span>(<span class="params"></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> [<span class="title">error</span>, <span class="title">setError</span>, <span class="title">errorRef</span>] = <span class="title">useRefState</span>&lt;<span class="title">Error</span> | <span class="title">undefined</span>&gt;(<span class="params"></span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">caller</span> = <span class="title">useCallback</span>(<span class="params"><span class="keyword">async</span> (...args: <span class="built_in">any</span>[]) =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    argsRef.current = args</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">if</span> (loadingRef.current &amp;&amp; optionRef.current.skipOnLoading) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">return</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">const</span> taskId = getUid()</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    taskIdRef.current = taskId</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params"></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="comment">// 已经有新的任务在执行了，什么都不做</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">const</span> shouldContinue = () =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">if</span> (taskId !== taskIdRef.current) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        <span class="keyword">return</span> <span class="literal">false</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">return</span> <span class="literal">true</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params"></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">try</span> &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      setLoading(<span class="literal">true</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      setError(<span class="literal">undefined</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">const</span> res = <span class="keyword">await</span> actionRef.current(...args)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params"></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">if</span> (!shouldContinue()) <span class="keyword">return</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      setValue(res)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">return</span> res</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125; <span class="keyword">catch</span> (err) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">if</span> (shouldContinue()) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        setError(err)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">throw</span> err</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125; <span class="keyword">finally</span> &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">if</span> (shouldContinue()) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        setLoading(<span class="literal">false</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  &#125;, []</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  // 不抛出异常</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">callIgnoreError</span> = <span class="title">useCallback</span>(<span class="params"></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">async</span> (...args: <span class="built_in">any</span>[]) =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">try</span> &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        <span class="keyword">return</span> <span class="keyword">await</span> caller(...args)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125; <span class="keyword">catch</span> &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">        <span class="comment">// ignore</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;,</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    [caller],</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  </span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">reset</span> = <span class="title">useCallback</span>(<span class="params">() =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    setLoading(<span class="literal">false</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    setValue(<span class="literal">undefined</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    setError(<span class="literal">undefined</span>)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  &#125;, []</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  // 失败后重试</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">retry</span> = <span class="title">useCallback</span>(<span class="params">() =&gt; &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">if</span> (argsRef.current &amp;&amp; errorRef.current) &#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">      <span class="keyword">return</span> callIgnoreError(...argsRef.current)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(`not call yet`)</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  &#125;, []</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">return</span> </span>&#123;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">loading</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">error</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">call</span>: <span class="title">caller</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">callIgnoreError</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">value</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">setValue</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">reset</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">retry</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">  &#125;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="7-2-usepromiseeffect-自动进行异步请求"><a href="#7-2-usepromiseeffect-自动进行异步请求" class="headerlink" title="7-2 usePromiseEffect 自动进行异步请求"></a>7-2 usePromiseEffect 自动进行异步请求</h3><p>很多时候，我们是在组件一挂载或者某些状态变化时自动进行一步请求的，我们在usePromise的基础上，结合useEffect来实现自动调用:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了缩短篇幅，这里就不考虑跟usePromise一样的函数重载了</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">usePromiseEffect</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  action: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">Promise</span>&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  args?: <span class="built_in">any</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prom = usePromise(action)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用useEffect监听参数变动并执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    prom.callIgnoreError.apply(<span class="literal">null</span>, args)</span><br><span class="line">  &#125;, args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// EXAMPLE</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在挂载或者id变化时请求</span></span><br><span class="line">  <span class="keyword">const</span> list = usePromiseEffect(<span class="function">(<span class="params">id</span>) =&gt;</span> fetchById(id), [id])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同usePromise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，应该惊叹Hooks的抽象能力了吧！😸</p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="7-3-useinfinitelist-实现无限加载列表"><a href="#7-3-useinfinitelist-实现无限加载列表" class="headerlink" title="7-3 useInfiniteList 实现无限加载列表"></a>7-3 useInfiniteList 实现无限加载列表</h3><p>这里例子在之前的文章中也提及过</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useInfiniteList</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: (params: &#123; offset: <span class="built_in">number</span>; pageSize: <span class="built_in">number</span>; list: T[] &#125;) =&gt; <span class="built_in">Promise</span>&lt;T[]&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pageSize: <span class="built_in">number</span> = 20,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;T[]&gt;(returnEmptyArray)</span><br><span class="line">  <span class="comment">// 列表是否全部加载完毕</span></span><br><span class="line">  <span class="keyword">const</span> [hasMore, setHasMore, hasMoreRef] = useRefState(<span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 列表是否为空</span></span><br><span class="line">  <span class="keyword">const</span> [empty, setEmpty] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> promise = usePromise(<span class="function"><span class="params">()</span> =&gt;</span> fn(&#123; list, offset: list.length, pageSize &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> load = useCallback(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasMoreRef.current) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> promise.call()</span><br><span class="line">    <span class="keyword">if</span> (res.length &lt; pageSize) &#123;</span><br><span class="line">      setHasMore(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setList(<span class="function"><span class="params">l</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.length === <span class="number">0</span> &amp;&amp; l.length === <span class="number">0</span>) &#123;</span><br><span class="line">        setEmpty(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> [...l, ...res]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空列表</span></span><br><span class="line">  <span class="keyword">const</span> clean = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setList([])</span><br><span class="line">    setHasMore(<span class="literal">true</span>)</span><br><span class="line">    setEmpty(<span class="literal">false</span>)</span><br><span class="line">    promise.reset()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 刷新列表</span></span><br><span class="line">  <span class="keyword">const</span> refresh = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clean()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      load()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    list,</span><br><span class="line">    hasMore,</span><br><span class="line">    empty,</span><br><span class="line">    loading: promise.loading,</span><br><span class="line">    error: promise.error,</span><br><span class="line">    load,</span><br><span class="line">    refresh,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Item &#123;</span><br><span class="line">  id: <span class="built_in">number</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; load, list, hasMore, refresh &#125; = useInfiniteList&lt;Item&gt;<span class="function">(<span class="params"><span class="keyword">async</span> (<span class="params">&#123; offset, pageSize &#125;</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> list = []</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> (<span class="params"><span class="keyword">let</span> i = offset; i &lt; offset + pageSize; i++</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">if</span> (<span class="params">i === 200</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">break</span></span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      list.push(<span class="params">&#123; id: i, name: `$&#123;i&#125;-----` &#125;</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> list</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">useEffect</span>(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    load(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;div className="App"&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">      &lt;button onClick=&#123;refresh&#125;&gt;Refresh&lt;/button&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;list.map(<span class="params">i =&gt; (<span class="params"></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        &lt;div key=&#123;i.id&#125;&gt;&#123;i.name&#125;&lt;/div&gt;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">      </span>)</span>)&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;hasMore ? &lt;button onClick=&#123;load&#125;&gt;Load more&lt;/button&gt; : &lt;div&gt;No more&lt;/div&gt;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;/div&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="7-4-usepoll-用hook实现轮询"><a href="#7-4-usepoll-用hook实现轮询" class="headerlink" title="7-4 usePoll 用hook实现轮询"></a>7-4 usePoll 用hook实现轮询</h3><p>下面使用Hooks实现一个定时轮询器</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UsePollOptions&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 决定是否要继续轮询</span></span><br><span class="line"><span class="comment">   * @param arg 上一次轮询返回的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  condition: <span class="function">(<span class="params">arg?: T, error?: <span class="built_in">Error</span></span>) =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">boolean</span>&gt;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 轮询操作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  poller: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>&lt;T&gt;</span><br><span class="line">  onError?: <span class="function">(<span class="params">err: <span class="built_in">Error</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 轮询间隔. 默认 5000</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  duration?: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听的参数，当这些参数变化时，重新检查轮询条件，决定是否继续轮询</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  args?: <span class="built_in">any</span>[]</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否立即轮询</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  immediately?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现页面轮询机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">usePoll</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params">options: UsePollOptions&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [polling, setPolling, pollingRef] = useRefState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState&lt;<span class="built_in">Error</span>&gt;()</span><br><span class="line">  <span class="keyword">const</span> state = useInstance&lt;&#123; timer?: <span class="built_in">number</span>; unmounted?: <span class="built_in">boolean</span> &#125;&gt;(&#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> optionsRef = useRefProps(options)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> poll = useCallback(<span class="keyword">async</span> (immediate?: <span class="built_in">boolean</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 已经卸载，或其他轮询器正在轮询</span></span><br><span class="line">    <span class="keyword">if</span> (state.unmounted || pollingRef.current) <span class="keyword">return</span></span><br><span class="line">    setPolling(<span class="literal">true</span>)</span><br><span class="line">    state.timer = <span class="built_in">window</span>.setTimeout(</span><br><span class="line">      <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.unmounted) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res: T | <span class="literal">undefined</span></span><br><span class="line">          <span class="keyword">let</span> error: <span class="built_in">Error</span> | <span class="literal">undefined</span></span><br><span class="line">          setError(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            res = <span class="keyword">await</span> optionsRef.current.poller()</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            error = err</span><br><span class="line">            setError(err)</span><br><span class="line">            <span class="keyword">if</span> (optionsRef.current.onError) &#123;</span><br><span class="line">              optionsRef.current.onError(err)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 准备下一次轮询</span></span><br><span class="line">          <span class="keyword">if</span> (!state.unmounted &amp;&amp; (<span class="keyword">await</span> optionsRef.current.condition(res, error))) &#123;</span><br><span class="line">            setTimeout(poll)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          !state.unmounted &amp;&amp; setPolling(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate ? <span class="number">0</span> : optionsRef.current.duration || <span class="number">5000</span>,</span><br><span class="line">    )</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  useOnUpdate(</span><br><span class="line">    <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">await</span> optionsRef.current.condition()) poll(options.immediately)</span><br><span class="line">    &#125;,</span><br><span class="line">    options.args || [],</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  useOnUnmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    state.unmounted = <span class="literal">true</span></span><br><span class="line">    clearTimeout(state.timer)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; polling, error &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">')</span></span><br><span class="line"><span class="string">  const [result, setResult] = useState&lt;Result&gt;()</span></span><br><span class="line"><span class="string">  usePoll(&#123;</span></span><br><span class="line"><span class="string">    poller: await() =&gt; &#123;</span></span><br><span class="line"><span class="string">      const res =await fetch(query)</span></span><br><span class="line"><span class="string">      setResult(res)</span></span><br><span class="line"><span class="string">      return res</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    condition: async () =&gt; &#123;</span></span><br><span class="line"><span class="string">      return query !== '</span><span class="string">'</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    args: [query],</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="7-5-业务逻辑抽离"><a href="#7-5-业务逻辑抽离" class="headerlink" title="7-5 业务逻辑抽离"></a>7-5 业务逻辑抽离</h3><p>通过上面的案例可以看到, Hooks非常适合用于抽离重复的业务逻辑。</p><p>在<a href="https://juejin.im/post/5cd8fb916fb9a03218556fc1#heading-6" target="_blank" rel="noopener">React组件设计实践总结02 - 组件的组织</a>介绍了容器组件和展示组件分离，Hooks时代，<strong>我们可以自然地将逻辑都放置到Hooks中，实现逻辑和视图的分离</strong>。</p><p>抽离的后业务逻辑可以复用于不同的’展示平台’, 例如 web 版和 native 版:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Login/</span><br><span class="line">  useLogin.ts   // 将所有逻辑都抽取到Hooks中</span><br><span class="line">  index.web.tsx // 只保留视图</span><br><span class="line">  index.tsx</span><br></pre></td></tr></table></figure><p><br><br><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="8-开脑洞"><a href="#8-开脑洞" class="headerlink" title="8. 开脑洞"></a><strong>8. 开脑洞</strong></h2><p>一些奇奇怪怪的东西，不知道怎么分类。作者想象力非常丰富!</p><h3 id="8-1-usescript-hooks-suspend-❤️"><a href="#8-1-usescript-hooks-suspend-❤️" class="headerlink" title="8-1 useScript: Hooks + Suspend = ❤️"></a>8-1 useScript: Hooks + Suspend = ❤️</h3><p>这个案例来源于<a href="https://github.com/palmerhq/the-platform#usescript" target="_blank" rel="noopener">the-platform</a>, 使用script标签来加载外部脚本:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意: 这还是实验性特性</span></span><br><span class="line"><span class="keyword">import</span> &#123;createResource&#125; <span class="keyword">from</span> <span class="string">'react-cache'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ScriptResource = createResource(<span class="function">(<span class="params">src: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line">    script.onload = <span class="function"><span class="params">()</span> =&gt;</span> resolve(script);</span><br><span class="line">    script.onerror = reject;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useScript</span>(<span class="params">options: &#123; src: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ScriptResource.read(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useScript &#125; <span class="keyword">from</span> <span class="string">'the-platform'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   useScript(&#123; src: <span class="string">'bundle.js'</span> &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Suspend</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Suspense fallback=&#123;<span class="string">'loading...'</span>&#125;&gt;&lt;Example&gt;&lt;<span class="regexp">/Example&gt;&lt;/</span>Suspense&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理还可以实现</p><ul><li><a href="https://github.com/palmerhq/the-platform/blob/master/src/Stylesheet.tsx" target="_blank" rel="noopener">useStylesheet</a> 用于加载样式表</li><li><a href="https://github.com/CharlesStover/fetch-suspense" target="_blank" rel="noopener">fetch-suspense</a></li></ul><p><br></p><p><a href="#">⤴️回到顶部</a></p><h3 id="8-2-usemodal-模态框数据流管理"><a href="#8-2-usemodal-模态框数据流管理" class="headerlink" title="8-2 useModal 模态框数据流管理"></a>8-2 useModal 模态框数据流管理</h3><p>我在<a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-6" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a>也举到一个使用<code>Hooks + Context</code>来巧妙实现模态框管理的例子。</p><p>先来看看如何使用Context来渲染模态框, 很简单, ModalContext.Provider给下级组件暴露一个render方法，通过这个方法来传递需要渲染的模态框组件和props:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模态框组件要实现的接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> BaseModalProps &#123;</span><br><span class="line">  visible: <span class="built_in">boolean</span></span><br><span class="line">  onHide: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ModalContextValue &#123;</span><br><span class="line">  render(Component: React.ComponentType&lt;<span class="built_in">any</span>&gt;, props: <span class="built_in">any</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = React.createContext&lt;ModalContextValue&gt;(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"useModal 必须在ModalRenderer 下级"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模态框渲染器</span></span><br><span class="line"><span class="keyword">const</span> ModalRenderer: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [modal, setModal] = useState&lt;</span><br><span class="line">    | &#123; Comp: React.ComponentType&lt;<span class="built_in">any</span>&gt;; props: <span class="built_in">any</span>; visible?: <span class="built_in">boolean</span> &#125;</span><br><span class="line">    | <span class="literal">undefined</span></span><br><span class="line">  &gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hide = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setModal(<span class="function"><span class="params">prev</span> =&gt;</span> prev &amp;&amp; &#123; ...prev, visible: <span class="literal">false</span> &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由下级组件调用，传递需要渲染的组件和props</span></span><br><span class="line">  <span class="keyword">const</span> render = useCallback&lt;ModalContextValue[<span class="string">"render"</span>]&gt;<span class="function">(<span class="params">(<span class="params">Comp, props</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    setModal(<span class="params">&#123; Comp, props, visible: <span class="literal">true</span> &#125;</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">value</span> = <span class="params">useMemo</span>(<span class="params">(<span class="params"></span>) =&gt; (<span class="params">&#123;render&#125;</span>), []</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;Context.Provider value=&#123;value&#125;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;props.children&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &lt;div className="modal-container"&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#123;<span class="comment">/*模态框渲染 */</span>&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#123;!!modal &amp;&amp;</span></span></span><br><span class="line"><span class="function"><span class="params">          React.createElement(<span class="params">modal.Comp, &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            ...modal.props,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            visible: modal.visible,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            onHide: hide,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span>)&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &lt;/div&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    &lt;/Context.Provider&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>再看看Hooks的实现, 也很简单，就是使用useContext来访问ModalContext， 并调用render方法:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useModal</span>&lt;<span class="title">P</span> <span class="title">extends</span> <span class="title">BaseModalProps</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Modal: React.ComponentType&lt;P&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> renderer = useContext(Context)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> useCallback(</span><br><span class="line">    (props: Omit&lt;P, keyof BaseModalProps&gt;) =&gt; &#123;</span><br><span class="line">      renderer.render(Modal, props || &#123;&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    [Modal],</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyModal: FC&lt;BaseModalProps &amp; &#123; a: <span class="built_in">number</span> &#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Modal visible=&#123;props.visible&#125; onOk=&#123;props.onHide&#125; onCancel=&#123;props.onHide&#125;&gt;</span><br><span class="line">      &#123;props.a&#125;</span><br><span class="line">    &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Home: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const showMyModal = useModal(MyModal)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  const handleShow = useCallback(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 显示模态框</span></span><br><span class="line"><span class="regexp">    showMyModal(&#123;</span></span><br><span class="line"><span class="regexp">      a: 123,</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;, [])</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      showMyModal: &lt;button onClick=&#123;handleShow&#125;&gt;show&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可运行的完整示例可以看<a href="https://codesandbox.io/s/lryom9617l?fontsize=14" target="_blank" rel="noopener">这里</a></p><p><br></p><p><a href="#">⤴️回到顶部</a></p><h2 id="react-hooks-技术地图"><a href="#react-hooks-技术地图" class="headerlink" title="React Hooks 技术地图"></a><strong>React Hooks 技术地图</strong></h2><p><strong>全家桶和Hooks的结合</strong>:</p><ul><li><a href="https://react-redux.js.org/api/hooks" target="_blank" rel="noopener">Redux + Hooks</a></li><li><a href="https://github.com/mobxjs/mobx-react-lite" target="_blank" rel="noopener">Mobx + Hooks</a></li><li><a href="https://www.react-spring.io/docs/hooks/basics" target="_blank" rel="noopener">ReactSpring + Hooks</a></li><li><a href="https://www.apollographql.com/docs/react/api/react-hooks/" target="_blank" rel="noopener">Appoll</a></li><li><a href="https://react.i18next.com/latest/usetranslation-hook" target="_blank" rel="noopener">react-i18next</a></li><li><a href="https://reacttraining.com/blog/reach-react-router-future/" target="_blank" rel="noopener">react-router</a> Come in soon</li></ul><p><br></p><p><strong>一些有趣的Hooks集合</strong>:</p><ul><li><a href="https://github.com/palmerhq/the-platform#usescript" target="_blank" rel="noopener">the-platform</a></li><li><a href="https://github.com/streamich/react-use" target="_blank" rel="noopener">react-use</a></li><li><a href="https://github.com/rehooks/ideas/issues" target="_blank" rel="noopener">rehooks/ideas</a> 一起开脑洞</li><li><a href="https://github.com/kitze/react-hanger" target="_blank" rel="noopener">react-hanger</a></li></ul><p><br></p><p><strong>Awesome</strong></p><ul><li><a href="https://github.com/rehooks/awesome-react-hooks" target="_blank" rel="noopener">Awesome React Hooks</a></li><li><a href="https://www.hooks.guide/rehooks/useComponentSize" target="_blank" rel="noopener">Hooks.Guide</a></li><li><a href="https://usehooks.com/" target="_blank" rel="noopener">useHooks</a></li></ul><p><br></p><p><strong>FAQ</strong></p><ul><li><a href="https://zh-hans.reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">官方Hooks FAQ</a> 可以解答大部分的疑问</li></ul><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文篇幅很长、代码很多。能滑到这里相当不容易, 给你点个赞。</p><p>你用React Hook遇到过什么问题？ 开过什么脑洞，下方评论告诉我.</p><p>欢迎关注我, 和我交流. 我有社恐, 但想多交些圈内朋友(<code>atob(&#39;YmxhbmstY2FybmV5&#39;)</code>, 备注掘金，我不喝茶，近期也不换工作)</p><p>本文完!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/react-hooks/cover.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.youtube.com/channel/UCz5vTaEhvh7dOHEyd
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>100来行代码, 自己动手写一个模板引擎</title>
    <link href="https://bobi.ink/2019/08/09/ejs/"/>
    <id>https://bobi.ink/2019/08/09/ejs/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-14T01:29:53.703Z</updated>
    
    <content type="html"><![CDATA[<p>一张图说明Ejs模板引擎的原理</p><p><img src="/images/ejs/ejs.png" alt></p><p><br></p><p>上面一张图，已经大概把一个简单模板引擎(这里以<a href="https://ejs.co/" target="_blank" rel="noopener">EJS</a>为例)的原理解释得七七八八了。本文将描述一个简单的模板引擎是怎么运作的？包含实现的关键步骤、以及其背后的思想。</p><p>基本上模板引擎的套路也就这样了，但这些思想是通用的，比如你在看vue的模板编译器源码、也可以套用这些思想和方法.</p><p><br></p><h2 id="基本api设计"><a href="#基本api设计" class="headerlink" title="基本API设计"></a>基本API设计</h2><p>我们将实现一个简化版的EJS, 这个模板引擎支持这些标签:</p><ul><li><p><code>&lt;% script %&gt;</code> - 脚本执行. 一般用于控制语句，不会输出值 例如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">user</span>) &#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>some thing<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;%= expression %&gt;</code> - 输出表达式的值，但是会转义HTML:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;%= title %&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;%- expression %&gt;</code> -  和<code>&lt;%= expr %&gt;</code>一样，只不过不会对HTML进行转义</p></li><li><code>&lt;%%</code> 和<code>%%&gt;</code> - 表示标签转义, 比如<code>&lt;%%</code>会输出为<code>&lt;%</code></li><li><code>&lt;%# 注释 %&gt;</code> - 不会有内容输出</li></ul><p><br></p><p>下面是一个完整的模板示例，下文会基于这个模板进行讲解:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%%</span> 转义 %%&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%#</span> 这里是注释 %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">before</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">show</span>) &#123; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>root<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>基本API设计</strong></p><p>我们将模板解析和渲染相关的逻辑放到一个Template类中，它的基本接口如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Template &#123;</span><br><span class="line">  <span class="keyword">public</span> template: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> tokens: <span class="built_in">string</span>[] = [];</span><br><span class="line">  <span class="keyword">private</span> source: <span class="built_in">string</span> = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">private</span> state?: State;</span><br><span class="line">  <span class="keyword">private</span> fn?: <span class="built_in">Function</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">template: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.template = template;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 模板编译</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> compile() &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseTemplateText();</span><br><span class="line">    <span class="keyword">this</span>.transformTokens();</span><br><span class="line">    <span class="keyword">this</span>.wrapit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 渲染方法，由用户指定一个对象来渲染字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> render(local: object) &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * token解析</span></span><br><span class="line"><span class="comment">   * 将&lt;% if (codintion) &#123; %&gt;</span></span><br><span class="line"><span class="comment">   * 解析为token数组，例如['&lt;%', ' if (condition) &#123; ', '%&gt;']</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> parseTemplateText() &#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将Token转换为Javascript语句</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> transformTokens() &#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将上一个步骤转换出来的Javascript语句，封装成一个渲染方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> wrapit() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="token解析"><a href="#token解析" class="headerlink" title="token解析"></a>token解析</h2><p>第一步我们需要将所有的开始标签(start tag)和结束标签(end tag)都解析出来，我们期望的解析结果是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"\n&lt;html&gt;\n  &lt;head&gt;"</span>,</span><br><span class="line">  <span class="string">"&lt;%="</span>,</span><br><span class="line">  <span class="string">" title "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"&lt;/head&gt;\n  &lt;body&gt;\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%%"</span>,</span><br><span class="line">  <span class="string">" 转义 "</span>,</span><br><span class="line">  <span class="string">"%%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%#"</span>,</span><br><span class="line">  <span class="string">" 这里是注释 "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%-"</span>,</span><br><span class="line">  <span class="string">" before "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%"</span>,</span><br><span class="line">  <span class="string">" if (show) &#123; "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n      &lt;div&gt;root&lt;/div&gt;\n    "</span>,</span><br><span class="line">  <span class="string">"&lt;%"</span>,</span><br><span class="line">  <span class="string">" &#125; "</span>,</span><br><span class="line">  <span class="string">"%&gt;"</span>,</span><br><span class="line">  <span class="string">"\n  &lt;/body&gt;\n&lt;/html&gt;\n"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>因为我们的模板引擎语法非常简单, 压根就不需要解析成什么抽象语法树(AST)(即省去了语法解析, 只进行词法解析). 直接通过<code>正则表达式</code>就可以实现将标签抽取出来。</p><p>先定义正则表达式, 用来匹配我们所有支持的标签：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;%% %%&gt; 用于转义</span></span><br><span class="line"><span class="comment">// &lt;% 脚本</span></span><br><span class="line"><span class="comment">// &lt;%= 输出脚本值</span></span><br><span class="line"><span class="comment">// &lt;%- 输出脚本值，unescape</span></span><br><span class="line"><span class="comment">// &lt;%# 注释</span></span><br><span class="line"><span class="comment">// %&gt; 结束标签</span></span><br><span class="line"><span class="keyword">const</span> REGEXP = <span class="regexp">/(&lt;%%|%%&gt;|&lt;%=|&lt;%-|&lt;%#|&lt;%|%&gt;)/</span>;</span><br></pre></td></tr></table></figure><p>使用正则表达式逐个进行匹配，将字符串拆分出来. 代码也很简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseTemplateText() &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="keyword">this</span>.template;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">this</span>.tokens;</span><br><span class="line">  <span class="comment">// 通过exec方法可以获取匹配的位置, 如果匹配失败则返回null</span></span><br><span class="line">  <span class="keyword">let</span> res = REGEXP.exec(str);</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (res) &#123;</span><br><span class="line">    index = res.index;</span><br><span class="line">    <span class="comment">// 前置字符串</span></span><br><span class="line">    <span class="keyword">if</span> (index !== <span class="number">0</span>) &#123;</span><br><span class="line">      arr.push(str.substring(<span class="number">0</span>, index));</span><br><span class="line">      str = str.slice(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.push(res[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 截断字符串，继续匹配</span></span><br><span class="line">    str = str.slice(res[<span class="number">0</span>].length);</span><br><span class="line">    res = REGEXP.exec(str);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (str) &#123;</span><br><span class="line">    arr.push(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="简单的语法检查"><a href="#简单的语法检查" class="headerlink" title="简单的语法检查"></a>简单的语法检查</h2><p>Ok，将标签解析出来后，就可以开始准备将它们转换称为‘渲染’函数了.</p><p>首先进行一下<strong>简单的语法检查</strong>，检查标签是否<strong>闭合</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> start = <span class="string">"&lt;%"</span>;           <span class="comment">// 开始标签</span></span><br><span class="line"><span class="keyword">const</span> end = <span class="string">"%&gt;"</span>;             <span class="comment">// 结束标签</span></span><br><span class="line"><span class="keyword">const</span> escpStart = <span class="string">"&lt;%%"</span>;      <span class="comment">// 开始标签转义</span></span><br><span class="line"><span class="keyword">const</span> escpEnd = <span class="string">"%%&gt;"</span>;        <span class="comment">// 结束标签转义</span></span><br><span class="line"><span class="keyword">const</span> escpoutStart = <span class="string">"&lt;%="</span>;   <span class="comment">// 转义的表达式输出</span></span><br><span class="line"><span class="keyword">const</span> unescpoutStart = <span class="string">"&lt;%-"</span>; <span class="comment">// 不转义的表达式输出</span></span><br><span class="line"><span class="keyword">const</span> comtStart = <span class="string">"&lt;%#"</span>;      <span class="comment">// 注释</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tok.includes(start) &amp;&amp; !tok.includes(escpStart)) &#123;</span><br><span class="line">  closing = <span class="keyword">this</span>.tokens[idx + <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (closing == <span class="literal">null</span> || !closing.includes(end)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;tok&#125;</span> 未找到对应的闭合标签`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>现在开始遍历token。我们可以使用一个有限的状态机(Finite-state machine, FSM)来描述转换的逻辑.</p><p><code>状态机</code>是表示<strong>有限个状态以及在这些状态之间的转移和动作等行为的数学模型</strong>。简单而言，有限状态机由一组状态、一个初始状态、输入和根据输入及现有状态转换为下一个状态的转换函数组成。它有三个特征:</p><ul><li>状态总数是有限的。</li><li>任一时刻，只处在一种状态之中。</li><li>某种条件下，会从一种状态转变到另一种状态</li></ul><p><br></p><p>稍微分析一下，我们模板引擎的状态转换图如下:</p><p><img src="/images/ejs/state.png" alt></p><p><br></p><p>通过上图可以抽取出以下状态:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum State &#123;</span><br><span class="line">  EVAL,    <span class="comment">// 脚本执行</span></span><br><span class="line">  ESCAPED, <span class="comment">// 表达式输出</span></span><br><span class="line">  RAW,     <span class="comment">// 表达式输出不转义</span></span><br><span class="line">  COMMENT, <span class="comment">// 注释</span></span><br><span class="line">  LITERAL  <span class="comment">// 字面量，直接输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Ok, 现在开始遍历token:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.tokens.forEach(<span class="function">(<span class="params">tok, idx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> (tok) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标签识别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> start:</span><br><span class="line">      <span class="comment">// 脚本开始</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.EVAL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> escpoutStart:</span><br><span class="line">      <span class="comment">// 转义输出</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.ESCAPED;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> unescpoutStart:</span><br><span class="line">      <span class="comment">// 非转义输出</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.RAW;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> comtStart:</span><br><span class="line">      <span class="comment">// 注释</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.COMMENT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> escpStart:</span><br><span class="line">      <span class="comment">// 标签转义</span></span><br><span class="line">      <span class="keyword">this</span>.state = State.LITERAL;</span><br><span class="line">      <span class="keyword">this</span>.source += <span class="string">`;__append('&lt;%');\n`</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> escpEnd:</span><br><span class="line">      <span class="keyword">this</span>.state = State.LITERAL;</span><br><span class="line">      <span class="keyword">this</span>.source += <span class="string">`;__append('%&gt;');\n`</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> end:</span><br><span class="line">      <span class="comment">// 恢复初始状态</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 转换输出</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">          <span class="keyword">case</span> State.EVAL:</span><br><span class="line">            <span class="comment">// 代码</span></span><br><span class="line">            <span class="keyword">this</span>.source += <span class="string">`;<span class="subst">$&#123;tok&#125;</span>\n`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> State.ESCAPED:</span><br><span class="line">            <span class="comment">// stripSemi 将多余的分号移除</span></span><br><span class="line">            <span class="keyword">this</span>.source += <span class="string">`;__append(escapeFn(<span class="subst">$&#123;stripSemi(tok)&#125;</span>));\n`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> State.RAW:</span><br><span class="line">            <span class="keyword">this</span>.source += <span class="string">`;__append(<span class="subst">$&#123;stripSemi(tok)&#125;</span>);\n`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> State.LITERAL:</span><br><span class="line">            <span class="comment">// 因为我们把字符串放到单引号中，所以transformString将tok中的单引号、换行符、转义符进行转移</span></span><br><span class="line">            <span class="keyword">this</span>.source += <span class="string">`;__append('<span class="subst">$&#123;transformString(tok)&#125;</span>');\n`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> State.COMMENT:</span><br><span class="line">            <span class="comment">// 什么都不做</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 字面量</span></span><br><span class="line">        <span class="keyword">this</span>.source += <span class="string">`;__append('<span class="subst">$&#123;transformString(tok)&#125;</span>');\n`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>经过上面的转换，我们可以得到这样的结果:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;__append(<span class="string">'\n&lt;html&gt;\n  &lt;head&gt;'</span>);</span><br><span class="line">;__append(escapeFn( title ));</span><br><span class="line">;__append(<span class="string">'&lt;/head&gt;\n  &lt;body&gt;\n    '</span>);</span><br><span class="line">;__append(<span class="string">'&lt;%'</span>);</span><br><span class="line">;__append(<span class="string">' 转义 '</span>);</span><br><span class="line">;__append(<span class="string">'%&gt;'</span>);</span><br><span class="line">;__append(<span class="string">'\n    '</span>);</span><br><span class="line">;__append(<span class="string">'\n    '</span>);</span><br><span class="line">;__append( before );</span><br><span class="line">;__append(<span class="string">'\n    '</span>);</span><br><span class="line">; <span class="keyword">if</span> (show) &#123;</span><br><span class="line">;__append(<span class="string">'\n      &lt;div&gt;root&lt;/div&gt;\n    '</span>);</span><br><span class="line">; &#125;</span><br><span class="line">;__append(<span class="string">'\n  &lt;/body&gt;\n&lt;/html&gt;\n'</span>);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="最后一步，生成函数"><a href="#最后一步，生成函数" class="headerlink" title="最后一步，生成函数"></a>最后一步，生成函数</h2><p>现在我们把转换结果包裹成函数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrapit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.source = <span class="string">`\</span></span><br><span class="line"><span class="string">const __out = [];</span></span><br><span class="line"><span class="string">const __append = __out.push.bind(__out);</span></span><br><span class="line"><span class="string">with(local||&#123;&#125;) &#123;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="keyword">this</span>.source&#125;</span></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return __out.join('');\</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">    <span class="keyword">this</span>.fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"local"</span>, <span class="string">"escapeFn"</span>, <span class="keyword">this</span>.source);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里使用到了<code>with</code>语句，来包裹上面转换的代码，这样可以免去local对象访问限定前缀。</p><p>渲染方法就很简单了，直接调用上面包裹的函数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render(local: object) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.fn.call(<span class="literal">null</span>, local, <span class="built_in">escape</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = <span class="keyword">new</span> Template(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;&lt;%= title %&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;%% 转义 %%&gt;</span></span><br><span class="line"><span class="string">    &lt;%# 这里是注释 %&gt;</span></span><br><span class="line"><span class="string">    &lt;%- before %&gt;</span></span><br><span class="line"><span class="string">    &lt;% if (show) &#123; %&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;root&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line">temp.compile();</span><br><span class="line">temp.render(&#123; <span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">title</span>: <span class="string">"hello"</span>, <span class="attr">before</span>: <span class="string">"&lt;div&gt;xx&lt;/div&gt;"</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;html&gt;</span></span><br><span class="line"><span class="comment">//   &lt;head&gt;hello&lt;/head&gt;</span></span><br><span class="line"><span class="comment">//   &lt;body&gt;</span></span><br><span class="line"><span class="comment">//     &lt;% 转义 %&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;xx&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//       &lt;div&gt;root&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;/body&gt;</span></span><br><span class="line"><span class="comment">// &lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>你可以在CodeSandbox运行完整的代码:</p><p><a href="https://codesandbox.io/s/ejs-wp11m?fontsize=14" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit ejs"></a></p><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文其实受到了<a href="https://github.com/jamiebuilds/the-super-tiny-compiler" target="_blank" rel="noopener">the-super-tiny-compiler</a>启发，实现了一个极简的模板引擎，其实模板引擎本质上也是一个Compiler，通过上文可以了解到一个模板引擎编译有三个步骤：</p><ol><li><p><strong>解析</strong> 将模板代码解析成抽象的表示形式。复杂的编译器会有<code>词法解析(Lexical Analysis)</code>和<code>语法解析(Syntactic Analysis)</code></p><p> <strong>词法解析</strong>, 上文我们将模板内容解析成token的过程就可以认为是‘词法解析’，它会将源代码拆分称为token数组，token是一个小单元，表示独立的‘语法片段’。</p><p> <strong>语法解析</strong>，语法解析器接收token数组，将它们重新格式化称为抽象语法树(Abstract Syntax Tree, AST), 抽象语法树可以用于描述语法单元, 以及单元之间的关系。 语法解析阶段可以发现语法问题。</p><p> <img src="/images/ejs/ast.png" alt></p><p> (图片来源: <a href="https://ruslanspivak.com/lsbasi-part7" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part7</a>)</p><p> 本文介绍的模板引擎，因为语法太简单了，所以不需要AST这个中间表示形式。直接在tokens上进行转换</p></li><li><p><strong>转换</strong> 将上个步骤抽象的表示形式，转换成为编译器想要的。比如上文模板引擎会转换为对应语言的语句。复杂的编译器会基于AST进行‘转换’，也就是对AST进行‘增删查改’. 通常会配合Visitors模式来遍历/访问AST的节点</p></li><li><strong>代码生成</strong> 将转换后的抽象表示转换为新的代码。 比如模板引擎最后一步会封装成为一个渲染函数. 复杂的编译器会将AST转换为目标代码</li></ol><p>编译器相关的东西确实很有趣，后续有机会可以讲讲怎么编写babel插件。</p><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://github.com/mde/ejs/tree/master/lib" target="_blank" rel="noopener">Ejs源代码</a></li><li><a href="https://github.com/jamiebuilds/the-super-tiny-compiler" target="_blank" rel="noopener">the-super-tiny-compiler</a></li><li><a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">Let’s Build A Simple Interpreter. Part 7: Abstract Syntax Trees</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一张图说明Ejs模板引擎的原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ejs/ejs.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上面一张图，已经大概把一个简单模板引擎(这里以&lt;a href=&quot;https://ejs.co/&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>揭开Electron的remote模块的面纱</title>
    <link href="https://bobi.ink/2019/08/04/electron-remote/"/>
    <id>https://bobi.ink/2019/08/04/electron-remote/</id>
    <published>2019-08-03T16:00:00.000Z</published>
    <updated>2019-08-09T13:28:24.883Z</updated>
    
    <content type="html"><![CDATA[<p>Electron的remote模块是一个比较神奇的东西，为<code>渲染进程</code>和<code>主进程</code>通信封装了一种简单方法，通过remote你可以’直接’获取主进程对象或者调用主进程函数或对象的方法, 而不必显式发送进程间消息, 类似于 Java 的 RMI. 例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; remote &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="keyword">const</span> myModal = remote.require(<span class="string">'myModal'</span>) <span class="comment">// 让主进程require指定模块，并返回到渲染进程</span></span><br><span class="line">myModal.dosomething()                     <span class="comment">// 调用方法</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>本质上，remote模块是基于Electron的IPC机制的，进程之间的通信的数据必须是可序列化的，比如JSON序列化</strong>。所以本文的目的是介绍Electron是如何设计remote模块的，以及里面有什么坑。</p><p><br></p><p><img src="/images/electron-remote/ipc.png" alt></p><p><br></p><p><strong>文章大纲</strong></p><ul><li><a href="#%e9%80%9a%e4%bf%a1%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%ae%9a%e4%b9%89">通信协议的定义</a></li><li><a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96">对象的序列化</a></li><li><a href="#%e5%bd%b1%e5%ad%90%e5%af%b9%e8%b1%a1">影子对象</a></li><li><a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">对象的生命周期</a></li><li><a href="#%e6%b8%b2%e6%9f%93%e8%bf%9b%e7%a8%8b%e6%80%8e%e4%b9%88%e7%bb%99%e4%b8%bb%e8%bf%9b%e7%a8%8b%e4%bc%a0%e9%80%92%e5%9b%9e%e8%b0%83">渲染进程怎么给主进程传递回调</a></li><li><a href="#%e4%b8%80%e4%ba%9b%e7%bc%ba%e9%99%b7">一些缺陷</a></li><li><a href="#remote%e6%a8%a1%e5%9d%97%e5%ae%9e%e8%b7%b5%e5%92%8c%e4%bc%98%e5%8c%96">remote模块实践和优化</a></li><li><a href="#%e6%80%bb%e7%bb%93">总结</a></li><li><a href="#%e6%89%a9%e5%b1%95">扩展</a></li></ul><p><br></p><h2 id="通信协议的定义"><a href="#通信协议的定义" class="headerlink" title="通信协议的定义"></a>通信协议的定义</h2><p>上文说到，remote本质上基于序列化的IPC通信的，所以首先关键需要<strong>定义一个协议来描述一个模块/对象的外形</strong>，其中包含下列类型:</p><ul><li>原始值。例如字符串、数字、布尔值</li><li>数组。</li><li>对象。对象属性、对象的方法、以及对象的原型</li><li>函数。普通函数和构造方法、异常处理</li><li>特殊对象。Date、Buffer、Promise、异常对象等等</li></ul><p><br></p><p>Electron使用MetaData(元数据)来描述这些对象外形的协议. 下面是一些转换的示例:</p><ul><li><p><strong>基本对象</strong>: 基本对象很容易处理，直接值拷贝传递即可</p><ul><li><p>输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">Buffer.from(<span class="string">'hello world'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'message'</span>);</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>: <span class="string">"value"</span>, <span class="attr">value</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"date"</span>, <span class="attr">value</span>: <span class="number">1565002306662</span>&#125;;  <span class="comment">// 序列化为时间戳</span></span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"buffer"</span>, <span class="attr">value</span>: &#123;<span class="attr">data</span>: <span class="built_in">Uint8Array</span>(<span class="number">11</span>), <span class="attr">length</span>: <span class="number">11</span>, <span class="attr">type</span>: <span class="string">"Buffer"</span>&#125;&#125;; <span class="comment">// 序列化为数组</span></span><br><span class="line">&#123;</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">"stack"</span>,</span><br><span class="line">      value: <span class="string">"Error: message\n    at Object.&lt;anonymous&gt; (省略调用栈)"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"message"</span>, <span class="attr">value</span>: <span class="string">"message"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"name"</span>, <span class="attr">value</span>: <span class="string">"Error"</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  type: <span class="string">"error"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p></li></ul></li><li><p><strong>数组</strong>: 数组也是值拷贝</p><ul><li><p>输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></li><li><p>输出</p><p>数组会递归对成员进行转换. 注意数组和基本类型没什么区别，它也是值拷贝，也就是说修改数组不会影响到对端进程的数组值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"members"</span>: [</span><br><span class="line">    &#123;<span class="string">"type"</span>:<span class="string">"value"</span>,<span class="string">"value"</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"type"</span>:<span class="string">"value"</span>,<span class="string">"value"</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"type"</span>:<span class="string">"value"</span>,<span class="string">"value"</span>:<span class="number">3</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"type"</span>:<span class="string">"array"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><br></p><ul><li><p><strong>纯对象</strong>: </p><ul><li><p>输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="string">'d'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这里有一个id，用于标识主进程的一个对象</span></span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// 对象成员</span></span><br><span class="line">  members: [</span><br><span class="line">    &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"a"</span>, <span class="attr">type</span>: <span class="string">"get"</span>, <span class="attr">writable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"b"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    <span class="comment">// electron只会转换一层，不会递归转换内嵌对象</span></span><br><span class="line">    &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"c"</span>, <span class="attr">type</span>: <span class="string">"get"</span>, <span class="attr">writable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  name: <span class="string">"Object"</span>,</span><br><span class="line">  <span class="comment">// 对象的上级原型的MetaData</span></span><br><span class="line">  proto: <span class="literal">null</span>,</span><br><span class="line">  type: <span class="string">"object"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p></li></ul></li><li><p><strong>函数</strong>:</p><ul><li><p>输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 函数也有一个唯一id标识，因为它也是对象，主进程需要保持该对象的引用</span></span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 函数属性成员</span></span><br><span class="line">  members: [],</span><br><span class="line">  name: <span class="string">"Function"</span>,</span><br><span class="line">  type: <span class="string">"function"</span></span><br><span class="line">  <span class="comment">// Electron解析对象的原型链</span></span><br><span class="line">  proto: &#123;</span><br><span class="line">    members: [</span><br><span class="line">      <span class="comment">// 构造函数</span></span><br><span class="line">      &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        name: <span class="string">"constructor"</span>,</span><br><span class="line">        type: <span class="string">"method"</span>,</span><br><span class="line">        writable: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"apply"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"bind"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"call"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"toString"</span>, <span class="attr">type</span>: <span class="string">"method"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    proto: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p></li></ul></li><li><p><strong>Promise</strong>：Promise只需描述then函数</p><ul><li><p>输入:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure></li><li><p>输入:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise这里关键在于then，详见上面的函数元数据</span></span><br><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"promise"</span></span><br><span class="line">  then: &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    members: [],</span><br><span class="line">    name: <span class="string">"Function"</span>,</span><br><span class="line">    proto: &#123;<span class="comment">/*见上面*/</span>&#125;,</span><br><span class="line">    type: <span class="string">"function"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><br></p><p>了解remote的数据传输协议后，有经验的开发者应该心里有底了，它的原理大概是这样的：</p><p><img src="/images/electron-remote/meta-transform.png" alt></p><p>主进程和渲染进程之间需要将对象序列化成MetaData描述，转换的规则上面已经解释的比较清楚了。这里面需要特殊处理是对象和函数，渲染进程拿到MetaData后需要封装成一个影子对象/函数，来供渲染进程应用调用。</p><p>其中比较复杂的是对象和函数的处理，Electron为了防止对象被垃圾回收，需要将这些对象放进一个注册表中，在这个表中每个对象都有一个唯一的id来标识。这个id有点类似于‘指针’，渲染进程会拿着这个id向主进程请求访问对象。</p><p>那什么时候需要释放这些对象呢？下文会讲具体的实现细节。</p><p>还有一个上图没有展示出来的细节是，Electron不会递归去转换对象，也就是说它只会转换一层。这样可以安全地引用存在循环引用的对象、另外所有属性值应该从远程获取最新的值，不能假设它的结构不可变。</p><p><br><br><br></p><h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><p>先来看看主进程的实现，它的代码位于<a href="https://github.com/electron/electron/blob/master/lib/browser/rpc-server.js" target="_blank" rel="noopener">/lib/browser/rpc-server.js</a>，代码很少而且很好理解，读者可以自己读一下。</p><p>这里我们不关注对象序列化的细节，重点关注对象的生命周期和调用的流程. </p><p><br></p><p>以<code>remote.require</code>为例, 这个方法用于让主进程去require指定模块，然后返回模块内容给渲染进程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleRemoteCommand(<span class="string">'ELECTRON_BROWSER_REQUIRE'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, contextId, moduleName</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用require</span></span><br><span class="line">  <span class="keyword">const</span> returnValue = process.mainModule.require(moduleName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将returnValue序列化为MetaData</span></span><br><span class="line">  <span class="keyword">return</span> valueToMeta(event.sender, contextId, returnValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>handleRemoteCommand</code> 使用<a href="https://electronjs.org/docs/api/ipc-main" target="_blank" rel="noopener">ipcMain</a>监听renderer发送的请求，<code>contextId</code>用于标识一个渲染进程。</p><p><br></p><p><code>valueToMeta</code>方法将值序列化为MetaData:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> valueToMeta = <span class="function"><span class="keyword">function</span> (<span class="params">sender, contextId, value, optimizeSimpleObject = false</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Determine the type of value.</span></span><br><span class="line">  <span class="keyword">const</span> meta = &#123; <span class="attr">type</span>: <span class="keyword">typeof</span> value &#125;</span><br><span class="line">  <span class="keyword">if</span> (meta.type === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="comment">// Recognize certain types of objects.</span></span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">      meta.type = <span class="string">'value'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bufferUtils.isBuffer(value)) &#123;</span><br><span class="line">      <span class="comment">// ... 🔴 基本类型</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (meta.type === <span class="string">'array'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴 数组转换</span></span><br><span class="line">    meta.members = value.map(<span class="function">(<span class="params">el</span>) =&gt;</span> valueToMeta(sender, contextId, el, optimizeSimpleObject))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'object'</span> || meta.type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    meta.name = value.constructor ? value.constructor.name : <span class="string">''</span></span><br><span class="line">    <span class="comment">// 🔴 将对象保存到注册表中，并返回唯一的对象id.</span></span><br><span class="line">    <span class="comment">// Electron会假设渲染进程会一直引用这个对象, 直到渲染进程退出</span></span><br><span class="line">    meta.id = objectsRegistry.add(sender, contextId, value)</span><br><span class="line">    meta.members = getObjectMembers(value)</span><br><span class="line">    meta.proto = getObjectPrototype(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'buffer'</span>) &#123;</span><br><span class="line">    meta.value = bufferUtils.bufferToMeta(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'promise'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴promise</span></span><br><span class="line">    value.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">    meta.then = valueToMeta(sender, contextId, <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">      value.then(onFulfilled, onRejected)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'error'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴错误对象</span></span><br><span class="line">    meta.members = plainObjectToMeta(value)</span><br><span class="line">    meta.members.push(&#123;</span><br><span class="line">      name: <span class="string">'name'</span>,</span><br><span class="line">      value: value.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.type === <span class="string">'date'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴日期</span></span><br><span class="line">    meta.value = value.getTime()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他</span></span><br><span class="line">    meta.type = <span class="string">'value'</span></span><br><span class="line">    meta.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> meta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="影子对象"><a href="#影子对象" class="headerlink" title="影子对象"></a>影子对象</h2><p><img src="/images/electron-remote/naruto.jpeg" alt></p><p>渲染进程会从MetaData中反序列化的对象或函数, 不过这只是一个‘影子’，我们也可以将它们称为<strong>影子对象</strong>或者<strong>代理对象</strong>、<strong>替身</strong>. 类似于火影忍者中的影分身之术，主体存储在主进程中，影子对象不包含任何实体数据，当访问这些对象或调用函数/方法时，影子对象直接远程请求。</p><blockquote><p>渲染进程的代码可以看<a href="https://github.com/electron/electron/blob/master/lib/renderer/api/remote.js" target="_blank" rel="noopener">这里</a></p></blockquote><p>来看看渲染进程怎么创建‘影子对象’:</p><p><strong>函数的处理</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (meta.type === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// 🔴创建一个'影子'函数</span></span><br><span class="line">  <span class="keyword">const</span> remoteFunction = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> command</span><br><span class="line">    <span class="comment">// 通过new Obj形式调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.constructor === remoteFunction) &#123;</span><br><span class="line">      command = <span class="string">'ELECTRON_BROWSER_CONSTRUCTOR'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      command = <span class="string">'ELECTRON_BROWSER_FUNCTION_CALL'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 🔴同步IPC远程</span></span><br><span class="line">    <span class="comment">// wrapArgs将函数参数序列化为MetaData</span></span><br><span class="line">    <span class="keyword">const</span> obj = ipcRendererInternal.sendSync(command, contextId, meta.id, wrapArgs(args))</span><br><span class="line">    <span class="comment">// 🔴反序列化返回值</span></span><br><span class="line">    <span class="keyword">return</span> metaToValue(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  ret = remoteFunction</span><br></pre></td></tr></table></figure><p><br></p><p><strong>对象成员的处理</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setObjectMembers</span> (<span class="params">ref, object, metaId, members</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> member <span class="keyword">of</span> members) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(member.name)) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> descriptor = &#123; <span class="attr">enumerable</span>: member.enumerable &#125;</span><br><span class="line">    <span class="keyword">if</span> (member.type === <span class="string">'method'</span>) &#123;</span><br><span class="line">      <span class="comment">// 🔴创建‘影子’方法. 和上面的函数调用差不多</span></span><br><span class="line">      <span class="keyword">const</span> remoteMemberFunction = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> command</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.constructor === remoteMemberFunction) &#123;</span><br><span class="line">          command = <span class="string">'ELECTRON_BROWSER_MEMBER_CONSTRUCTOR'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          command = <span class="string">'ELECTRON_BROWSER_MEMBER_CALL'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> ret = ipcRendererInternal.sendSync(command, contextId, metaId, member.name, wrapArgs(args))</span><br><span class="line">        <span class="keyword">return</span> metaToValue(ret)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (member.type === <span class="string">'get'</span>) &#123;</span><br><span class="line">      <span class="comment">// 🔴属性的获取</span></span><br><span class="line">      descriptor.get = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> command = <span class="string">'ELECTRON_BROWSER_MEMBER_GET'</span></span><br><span class="line">        <span class="keyword">const</span> meta = ipcRendererInternal.sendSync(command, contextId, metaId, member.name)</span><br><span class="line">        <span class="keyword">return</span> metaToValue(meta)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 🔴属性的设置</span></span><br><span class="line">      <span class="keyword">if</span> (member.writable) &#123;</span><br><span class="line">        descriptor.set = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> args = wrapArgs([value])</span><br><span class="line">          <span class="keyword">const</span> command = <span class="string">'ELECTRON_BROWSER_MEMBER_SET'</span></span><br><span class="line">          <span class="keyword">const</span> meta = ipcRendererInternal.sendSync(command, contextId, metaId, member.name, args)</span><br><span class="line">          <span class="keyword">if</span> (meta != <span class="literal">null</span>) metaToValue(meta)</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(object, member.name, descriptor)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><p><strong>主进程的<code>valueToMeta</code>会将每一个对象和函数都放入注册表中，包括每次函数调用的返回值</strong>。</p><p>这是否意味着，如果频繁调用函数，会导致注册表暴涨占用太多内存呢？这些对象什么时候释放?</p><p><br></p><p>首先<strong>当渲染进程销毁时，主进程会集中销毁掉该进程的所有对象引用</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染进程退出时会通过这个事件告诉主进程，但是这个并不能保证收到</span></span><br><span class="line">handleRemoteCommand(<span class="string">'ELECTRON_BROWSER_CONTEXT_RELEASE'</span>, (event, contextId) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 清空对象注册表</span></span><br><span class="line">  objectsRegistry.clear(event.sender, contextId)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为<code>ELECTRON_BROWSER_CONTEXT_RELEASE</code>不能保证能够收到，所以<code>objectsRegistry</code>还会监听对应渲染进程的销毁事件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectsRegistry</span> </span>&#123;</span><br><span class="line">    registerDeleteListener (webContents, contextId) &#123;</span><br><span class="line">    <span class="comment">// contextId =&gt; $&#123;processHostId&#125;-$&#123;contextCount&#125;</span></span><br><span class="line">    <span class="keyword">const</span> processHostId = contextId.split(<span class="string">'-'</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> listener = <span class="function">(<span class="params">event, deletedProcessHostId</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (deletedProcessHostId &amp;&amp;</span><br><span class="line">          deletedProcessHostId.toString() === processHostId) &#123;</span><br><span class="line">        webContents.removeListener(<span class="string">'render-view-deleted'</span>, listener)</span><br><span class="line">        <span class="keyword">this</span>.clear(webContents, contextId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//🔴 监听渲染进程销毁事件, 确保万无一失</span></span><br><span class="line">    webContents.on(<span class="string">'render-view-deleted'</span>, listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>等<strong>到渲染进程销毁再去释放这些对象显然是无法接受的</strong>，和网页不一样，桌面端应用可能会7*24不间断运行，如果要等到渲染进程退出才去回收对象, 最终会导致系统资源被消耗殆尽。</p><p>所以<strong>Electron会在渲染进程中监听对象的垃圾回收事件，再通过IPC通知主进程来递减对应对象的引用计数</strong>， 看看渲染进程是怎么做的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渲染进程，反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">metaToValue</span> (<span class="params">meta</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对象类型转换</span></span><br><span class="line">    <span class="keyword">let</span> ret</span><br><span class="line">    <span class="keyword">if</span> (remoteObjectCache.has(meta.id)) &#123;</span><br><span class="line">      <span class="comment">// 🔴 对象再一次被访问，递增对象引用计数. </span></span><br><span class="line">      <span class="comment">// v8Util是electron原生模块</span></span><br><span class="line">      v8Util.addRemoteObjectRef(contextId, meta.id)</span><br><span class="line">      <span class="keyword">return</span> remoteObjectCache.get(meta.id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个影子类表示远程函数对象</span></span><br><span class="line">    <span class="keyword">if</span> (meta.type === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> remoteFunction = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      ret = remoteFunction</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setObjectMembers(ret, ret, meta.id, meta.members)</span><br><span class="line">    setObjectPrototype(ret, ret, meta.id, meta.proto)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(ret.constructor, <span class="string">'name'</span>, &#123; <span class="attr">value</span>: meta.name &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔴 监听对象的生命周期，当对象被垃圾回收时，通知到主进程</span></span><br><span class="line">    v8Util.setRemoteObjectFreer(ret, contextId, meta.id)</span><br><span class="line">    v8Util.setHiddenValue(ret, <span class="string">'atomId'</span>, meta.id)</span><br><span class="line">    <span class="comment">// 🔴 添加对象引用计数</span></span><br><span class="line">    v8Util.addRemoteObjectRef(contextId, meta.id)</span><br><span class="line">    remoteObjectCache.set(meta.id, ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>简单了解一下ObjectFreer代码:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// atom/common/api/remote_object_freer.cc</span></span><br><span class="line"><span class="comment">// 添加引用计数</span></span><br><span class="line"><span class="keyword">void</span> RemoteObjectFreer::AddRef(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; context_id, <span class="keyword">int</span> object_id) &#123;</span><br><span class="line">  ref_mapper_[context_id][object_id]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象释放事件处理器</span></span><br><span class="line"><span class="keyword">void</span> RemoteObjectFreer::RunDestructor() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">auto</span>* channel = <span class="string">"ELECTRON_BROWSER_DEREFERENCE"</span>;</span><br><span class="line">  base::ListValue args;</span><br><span class="line">  args.AppendString(context_id_);</span><br><span class="line">  args.AppendInteger(object_id_);</span><br><span class="line">  args.AppendInteger(ref_mapper_[context_id_][object_id_]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 清空引用表</span></span><br><span class="line">  ref_mapper_[context_id_].erase(object_id_);</span><br><span class="line">  <span class="keyword">if</span> (ref_mapper_[context_id_].empty())</span><br><span class="line">    ref_mapper_.erase(context_id_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 ipc通知主进程</span></span><br><span class="line">  electron_ptr-&gt;Message(<span class="literal">true</span>, channel, args.Clone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>再回到主进程, 主进程监听<code>ELECTRON_BROWSER_DEREFERENCE</code>事件，并递减指定对象的引用计数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleRemoteCommand(<span class="string">'ELECTRON_BROWSER_DEREFERENCE'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, contextId, id, rendererSideRefCount</span>) </span>&#123;</span><br><span class="line">  objectsRegistry.remove(event.sender, contextId, id, rendererSideRefCount)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>如果被上面的代码绕得优点晕，那就看看下面的流程图, 消化消化：</p><p><img src="/images/electron-remote/lifetime.png" alt></p><p><br><br><br></p><h2 id="渲染进程怎么给主进程传递回调"><a href="#渲染进程怎么给主进程传递回调" class="headerlink" title="渲染进程怎么给主进程传递回调"></a>渲染进程怎么给主进程传递回调</h2><p>在渲染进程中，通过remote还可以给主进程的函数传递回调。其实跟主进程暴露函数/对象给渲染进程的原理一样，渲染进程在将回调传递给主进程之前会放置到<strong>回调注册表</strong>中，然后给主进程暴露一个callbackID。</p><p>渲染进程会调用<code>wrapArgs</code>将函数调用参数序列化为MetaData:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapArgs</span> (<span class="params">args, visited = new Set(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> valueToMeta = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 🔴 防止循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (visited.has(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        type: <span class="string">'value'</span>,</span><br><span class="line">        value: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略其他类型的处理，这些类型基本都是值拷贝</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        type: <span class="string">'function'</span>,</span><br><span class="line">        <span class="comment">// 🔴 给主进程传递callbackId，并添加到回调注册表中</span></span><br><span class="line">        id: callbacksRegistry.add(value),</span><br><span class="line">        location: v8Util.getHiddenValue(value, <span class="string">'location'</span>),</span><br><span class="line">        length: value.length</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>回到主进程，这里也有一个对应的<code>unwrapArgs</code>函数来反序列化函数参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unwrapArgs = <span class="function"><span class="keyword">function</span> (<span class="params">sender, frameId, contextId, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> metaToValue = <span class="function"><span class="keyword">function</span> (<span class="params">meta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (meta.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'value'</span>:</span><br><span class="line">        <span class="keyword">return</span> meta.value</span><br><span class="line">      <span class="comment">// ... 省略</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'function'</span>: &#123;</span><br><span class="line">        <span class="keyword">const</span> objectId = [contextId, meta.id]</span><br><span class="line">        <span class="comment">// 回调缓存</span></span><br><span class="line">        <span class="keyword">if</span> (rendererFunctions.has(objectId)) &#123;</span><br><span class="line">          <span class="keyword">return</span> rendererFunctions.get(objectId)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 🔴 封装影子函数</span></span><br><span class="line">        <span class="keyword">const</span> callIntoRenderer = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> succeed = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">if</span> (!sender.isDestroyed()) &#123;</span><br><span class="line">            <span class="comment">// 🔴 调用时，通过IPC通知渲染进程</span></span><br><span class="line">            <span class="comment">// 忽略回调返回值</span></span><br><span class="line">            succeed = sender._sendToFrameInternal(frameId, <span class="string">'ELECTRON_RENDERER_CALLBACK'</span>, contextId, meta.id, valueToMeta(sender, contextId, args))</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!succeed) &#123;</span><br><span class="line">            <span class="comment">// 没有发送成功则表明渲染进程的回调可能被释放了，输出警告信息</span></span><br><span class="line">            <span class="comment">// 这种情况比较常见，比如被渲染进程刷新了</span></span><br><span class="line">            removeRemoteListenersAndLogWarning(<span class="keyword">this</span>, callIntoRenderer)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v8Util.setHiddenValue(callIntoRenderer, <span class="string">'location'</span>, meta.location)</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(callIntoRenderer, <span class="string">'length'</span>, &#123; <span class="attr">value</span>: meta.length &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 🔴 监听回调函数垃圾回收事件</span></span><br><span class="line">        v8Util.setRemoteCallbackFreer(callIntoRenderer, contextId, meta.id, sender)</span><br><span class="line">        rendererFunctions.set(objectId, callIntoRenderer)</span><br><span class="line">        <span class="keyword">return</span> callIntoRenderer</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Unknown type: <span class="subst">$&#123;meta.type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> args.map(metaToValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染进程响应就比较简单了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleMessage(<span class="string">'ELECTRON_RENDERER_CALLBACK'</span>, (id, args) =&gt; &#123;</span><br><span class="line">  callbacksRegistry.apply(id, metaToValue(args))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>那回调什么时候释放呢？这个相比渲染进程的对象引用要简单很多，因为主进程只有一个。通过上面的代码可以知道, <code>setRemoteCallbackFreer</code>会监听影子回调是否被垃圾回收，一旦被垃圾回收了则通知渲染进程:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染进程</span></span><br><span class="line">handleMessage(<span class="string">'ELECTRON_RENDERER_RELEASE_CALLBACK'</span>, (id) =&gt; &#123;</span><br><span class="line">  callbacksRegistry.remove(id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>按照惯例，来个流程图:</p><p><img src="/images/electron-remote/callback.png" alt></p><p><br><br><br></p><h2 id="一些缺陷"><a href="#一些缺陷" class="headerlink" title="一些缺陷"></a>一些缺陷</h2><p>remote机制只是对远程对象的一个‘影分身’，无法百分百和远程对象的行为保持一致，下面是一些比较常见的缺陷:</p><ul><li>当渲染进程调用远程对象的方法/函数时，是进行同步IPC通信的。换言之，同步IPC调用会阻塞用户代码的执行，而且跨端的通信效率无法和原生函数调用相比，所以频繁的IPC调用会影响主进程和渲染进程的性能.</li><li>主进程会保持引用每一个渲染进程访问的对象，包括函数的返回值。同理，频繁的远程对象请求，对内存的占用和垃圾回收造成不小的压力</li><li>无法完全模拟JavaScript对象的行为。比如在remote模块中存在这些问题:<ul><li>数组属于’基本对象’，它是通过值拷贝传递给对端的。也就是说它不是一个‘引用对象’，在对端修改它们时，无法反应到原始的数组.</li><li>对象在第一次引用时，只有可枚举的属性可以远程访问。这也意味着，一开始对象的外形就确定下来了，如果远程对象动态扩展了属性，是无法被远程访问到的</li><li>渲染进程传递的回调会被异步调用，而且主进程会忽略它的返回值。异步调用是为了避免产生死锁</li></ul></li><li>对象泄露。<ul><li>如果远程对象在渲染进程中泄露（例如存储在映射中，但从未释放），则主进程中的相应对象也将被泄漏，所以您应该非常小心，不要泄漏远程对象。</li><li>在给主进程传递回调时也要特别小心，主进程会保持回调的引用，直到它被释放。所以在使用remote模块进行一些‘事件订阅’时，切记要解除事件订阅.</li><li>还有一种场景，下文会提到</li></ul></li></ul><p><br><br><br></p><h2 id="remote模块实践和优化"><a href="#remote模块实践和优化" class="headerlink" title="remote模块实践和优化"></a>remote模块实践和优化</h2><p><img src="/images/electron-remote/gzb.png" alt></p><p>上面是我参与过的某个项目的软件架构图，<code>Hybrid</code>层使用C/C++编写，封装了跨平台的核心业务逻辑，在此之上来构建各个平台的视图。其中桌面端我们使用的是Electron技术。</p><p>如上图，Bridge进是对Hybrid的一层Node桥接封装。一个应用中只能有一个Bridge实例，因此我们的做法是使用Electron的remote模块，让渲染进程通过主进程间接地访问Bridge.</p><p><br></p><p>页面需要监听Bridge的一些事件，最初我们的代码是这样的:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bridge.ts</span></span><br><span class="line"><span class="comment">// 使用remote的一个好处时，可以配合Typescript实现较好的类型检查</span></span><br><span class="line"><span class="keyword">const</span> bridge = electron.remote.require(<span class="string">'bridge'</span>) <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="keyword">import</span>(<span class="string">'bridge'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> bridge</span><br></pre></td></tr></table></figure><p>监听Bridge事件:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bridge <span class="keyword">from</span> <span class="string">'~/bridge'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Store <span class="keyword">extends</span> MobxStore &#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  pageReady() &#123;</span><br><span class="line">    <span class="keyword">this</span>.someEventDispose = bridge.addListener(<span class="string">'someEvent'</span>, <span class="keyword">this</span>.handleSomeEvent)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 页面关闭</span></span><br><span class="line">  pageWillClose() &#123;</span><br><span class="line">    <span class="keyword">this</span>.someEventDispose()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图如下:</p><p><img src="/images/electron-remote/addListener.png" alt></p><p>这种方式存在很多问题:</p><ul><li><p>主进程需要为每一个addListener回调都维持一个引用。上面的代码会在页面关闭时释放订阅，但是它没有考虑用户刷新页面或者页面崩溃的场景。这会导致回调在主进程泄露。</p><p>然而就算Electron可以在调用回调时发现回调在渲染进程已经被释放掉了，但是开发者却获取不到这些信息， Bridge会始终保持对影子回调的引用.</p></li><li><p>另外一个比较明显的是调用效率的问题。假设页面监听了N次A事件，当A事件触发时，主进程需要给这个页面发送N个通知。</p></li></ul><p><br></p><p>后来我们抛弃了使用remote进行事件订阅这种方式，让主进程来维护这种订阅关系, 如下图:</p><p><img src="/images/electron-remote/addListener2.png" alt></p><p>我们改进了很多东西：</p><p><strong>主进程现在只维护‘哪个页面’订阅了哪个事件，从‘绑定回调’进化成为‘绑定页面’</strong>。这样可以解决上面调用效率和回调泄露问题、比如不会因为页面刷新导致回调泄露, 并且当事件触发时只会通知一次页面。</p><p>另外这里参考了remote本身的实现，在页面销毁时移除该页面的所有订阅。相比比remote黑盒，我们自己来实现这种事件订阅关系比之前要更好调试。</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>remote模块对于Electron开发有很重要的意义，毕竟很多模块只有在主进程才能访问，比如BrowserWindow、dialog. </p><p>相比ipc通信，remote实在方面很多。通过上文我们也了解了它的基本原理和缺陷，所以remote虽好，切忌不要滥用。</p><p>remote的源码也很容易理解，值得学习. 毕竟前端目前跨端通信非常常见，例如WebViewBridge、Worker. </p><p>remote可以给你一些灵感，但是要完全照搬它是不可行的，因为比如它依赖一些v8 ‘Hack’来监听对象的垃圾回收，普通开发场景是做不到的。</p><p>本文完.</p><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://electronjs.org/docs/api/remote" target="_blank" rel="noopener">Electron remote 文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Electron的remote模块是一个比较神奇的东西，为&lt;code&gt;渲染进程&lt;/code&gt;和&lt;code&gt;主进程&lt;/code&gt;通信封装了一种简单方法，通过remote你可以’直接’获取主进程对象或者调用主进程函数或对象的方法, 而不必显式发送进程间消息, 类似于 Java 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>谈谈React事件机制和未来(react-events)</title>
    <link href="https://bobi.ink/2019/07/29/react-event/"/>
    <id>https://bobi.ink/2019/07/29/react-event/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-08-04T08:19:59.764Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react-event/sample.png" alt></p><p>当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发. </p><p>具体来讲，React利用事件委托机制在Document上统一监听DOM事件，再根据触发的target将事件分发到具体的组件实例。另外上面e是一个合成事件对象(SyntheticEvent), 而不是原始的DOM事件对象.</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#那为什么要自定义一套事件系统">那为什么要自定义一套事件系统?</a></li><li><a href="#基本概念">基本概念</a><ul><li><a href="#整体的架构">整体的架构</a></li><li><a href="#事件分类与优先级">事件分类与优先级</a></li></ul></li><li><a href="#实现细节">实现细节</a><ul><li><a href="#事件是如何绑定的">事件是如何绑定的？</a></li><li><a href="#事件是如何分发的">事件是如何分发的？</a><ul><li><a href="#事件触发调度">事件触发调度</a></li><li><a href="#插件是如何处理事件">插件是如何处理事件?</a></li><li><a href="#批量执行">批量执行</a></li></ul></li></ul></li><li><a href="#未来">未来</a><ul><li><a href="#初探responder的创建">初探Responder的创建</a></li><li><a href="#react-events意义何在">react-events意义何在?</a></li></ul></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><blockquote><p>截止本文写作时，React版本是16.8.6</p></blockquote><p><br></p><h2 id="那为什么要自定义一套事件系统"><a href="#那为什么要自定义一套事件系统" class="headerlink" title="那为什么要自定义一套事件系统?"></a>那为什么要自定义一套事件系统?</h2><p>如果了解过Preact(笔者之前写过一篇文章<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">解析Preact的源码</a>)，Preact裁剪了很多React的东西，其中包括事件机制，Preact是直接在DOM元素上进行事件绑定的。</p><p>在研究一个事物之前，我首先要问为什么？了解它的动机，才有利于你对它有本质的认识。</p><p>React自定义一套事件系统的动机有以下几个:</p><ul><li><p><strong>1. 抹平浏览器之间的兼容性差异</strong>。 这是估计最原始的动机，React根据<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C 规范</a>来定义这些合成事件(SyntheticEvent), 意在抹平浏览器之间的差异。</p><p>另外React还会试图通过其他相关事件来模拟一些低版本不兼容的事件, 这才是‘合成’的本来意思吧？。</p></li><li><p><strong>2. 事件‘合成’, 即事件自定义</strong>。事件合成除了处理兼容性问题，还可以用来自定义高级事件，比较典型的是React的onChange事件，它为表单元素定义了统一的值变动事件。另外第三方也可以通过React的事件插件机制来合成自定义事件，尽管很少人这么做。</p></li><li><p><strong>3. 抽象跨平台事件机制</strong>。 和VirtualDOM的意义差不多，VirtualDOM抽象了跨平台的渲染方式，那么对应的SyntheticEvent目的也是想提供一个抽象的跨平台事件机制。</p></li><li><p><strong>4. React打算做更多优化</strong>。比如利用事件委托机制，大部分事件最终绑定到了Document，而不是DOM节点本身. 这样简化了DOM事件处理逻辑，减少了内存开销. 但这也意味着，<strong>React需要自己模拟一套事件冒泡的机制</strong>。</p></li><li><p><strong>5. React打算干预事件的分发</strong>。v16引入Fiber架构，React为了优化用户的交互体验，会干预事件的分发。不同类型的事件有不同的优先级，比如高优先级的事件可以中断渲染，让用户代码可以及时响应用户交互。</p></li></ul><p><br></p><p>Ok, 后面我们会深入了解React的事件实现，我会尽量不贴代码，用流程图说话。</p><p><br></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="整体的架构"><a href="#整体的架构" class="headerlink" title="整体的架构"></a>整体的架构</h3><p><img src="/images/react-event/st.png" alt></p><ul><li><strong>ReactEventListener</strong> - 事件处理器. 在这里进行事件处理器的绑定。当DOM触发事件时，会从这里开始调度分发到React组件树</li><li><strong>ReactEventEmitter</strong> - 暴露接口给React组件层用于添加事件订阅</li><li><strong>EventPluginHub</strong> - 如其名，这是一个‘插件插槽’，负责管理和注册各种插件。在事件分发时，调用插件来生成合成事件</li><li><p><strong>Plugin</strong> - React事件系统使用了插件机制来管理不同行为的事件。这些插件会处理自己感兴趣的事件类型，并生成合成事件对象。目前ReactDOM有以下几种插件类型:</p><ul><li><strong>SimpleEventPlugin</strong> - 简单事件, 处理一些比较通用的事件类型，例如click、input、keyDown、mouseOver、mouseOut、pointerOver、pointerOut</li><li><p><strong>EnterLeaveEventPlugin</strong> - mouseEnter/mouseLeave和pointerEnter/pointerLeave这两类事件比较特殊, 和<code>*over/*leave</code>事件相比, 它们不支持事件冒泡, <code>*enter</code>会给所有进入的元素发送事件, 行为有点类似于<code>:hover</code>; 而<code>*over</code>在进入元素后，还会冒泡通知其上级. 可以通过这个<a href="https://codesandbox.io/s/enter-and-over-608cl" target="_blank" rel="noopener">实例</a>观察enter和over的区别.</p><p>如果树层次比较深，大量的mouseenter触发可能导致性能问题。另外其不支持冒泡，无法在Document完美的监听和分发, 所以ReactDOM使用<code>*over/*out</code>事件来模拟这些<code>*enter/*leave</code>。</p></li><li><p><strong>ChangeEventPlugin</strong> - change事件是React的一个自定义事件，旨在规范化表单元素的变动事件。</p><p>它支持这些表单元素: input, textarea, select </p></li><li><p><strong>SelectEventPlugin</strong> - 和change事件一样，React为表单元素规范化了select(选择范围变动)事件，适用于input、textarea、contentEditable元素.</p></li><li><strong>BeforeInputEventPlugin</strong> - beforeinput事件以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart" target="_blank" rel="noopener">composition</a>事件处理。</li></ul><p>本文主要会关注<code>SimpleEventPlugin</code>的实现，有兴趣的读者可以自己阅读React的源代码.</p></li><li><p><strong>EventPropagators</strong> 按照DOM事件传播的两个阶段，遍历React组件树，并收集所有组件的事件处理器.</p></li><li><strong>EventBatching</strong> 负责批量执行事件队列和事件处理器，处理事件冒泡。</li><li><p><strong>SyntheticEvent</strong> 这是‘合成’事件的基类，可以对应DOM的Event对象。只不过React为了减低内存损耗和垃圾回收，使用一个对象池来构建和释放事件对象， 也就是说SyntheticEvent不能用于异步引用，它在同步执行完事件处理器后就会被释放。</p><p>SyntheticEvent也有子类，和DOM具体事件类型一一匹配:</p><ul><li>SyntheticAnimationEvent</li><li>SyntheticClipboardEvent</li><li>SyntheticCompositionEvent</li><li>SyntheticDragEvent</li><li>SyntheticFocusEvent</li><li>SyntheticInputEvent</li><li>SyntheticKeyboardEvent</li><li>SyntheticMouseEvent</li><li>SyntheticPointerEvent</li><li>SyntheticTouchEvent</li><li>….</li></ul></li></ul><p><br></p><h3 id="事件分类与优先级"><a href="#事件分类与优先级" class="headerlink" title="事件分类与优先级"></a>事件分类与优先级</h3><p>SimpleEventPlugin将事件类型划分成了三类, 对应不同的优先级(<strong>优先级由低到高</strong>):</p><ul><li><strong>DiscreteEvent</strong> 离散事件. 例如blur、focus、 click、 submit、 touchStart. 这些事件都是离散触发的</li><li><strong>UserBlockingEvent</strong> 用户阻塞事件. 例如touchMove、mouseMove、scroll、drag、dragOver等等。这些事件会’阻塞’用户的交互。</li><li><strong>ContinuousEvent</strong> 可连续事件。例如load、error、loadStart、abort、animationEnd. 这个优先级最高，也就是说它们应该是立即同步执行的，这就是Continuous的意义，即可连续的执行，不被打断.</li></ul><p>可能要先了解一下React调度(Schedule)的优先级，才能理解这三种事件类型的区别。截止到本文写作时，React有5个优先级级别:</p><ul><li><code>Immediate</code> - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms timeout) 这些任务一般是用户交互的结果, 需要即时得到反馈 .</li><li><code>Normal</code> (5s timeout) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s timeout) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (no timeout) 一些没有必要做的任务 (e.g. 比如隐藏的内容).</li></ul><p>目前ContinuousEvent对应的是Immediate优先级; UserBlockingEvent对应的是UserBlocking(需要手动开启); 而DiscreteEvent对应的也是UserBlocking, 只不过它在执行之前，先会执行完其他Discrete任务。</p><p>本文不会深入React Fiber架构的细节，有兴趣的读者可以阅读文末的扩展阅读列表.</p><p><br><br><br></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>现在开始进入文章正题，React是怎么实现事件机制？主要分为两个部分: <strong>绑定</strong>和<strong>分发</strong>.</p><h3 id="事件是如何绑定的？"><a href="#事件是如何绑定的？" class="headerlink" title="事件是如何绑定的？"></a>事件是如何绑定的？</h3><p>为了避免后面绕晕了，有必要先了解一下React事件机制中的插件协议。 每个插件的结构如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> EventTypes = &#123;[key: <span class="built_in">string</span>]: DispatchConfig&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PluginModule&lt;NativeEvent&gt; = &#123;</span><br><span class="line">  eventTypes: EventTypes,          <span class="comment">// 声明插件支持的事件类型</span></span><br><span class="line">  extractEvents: (                 <span class="comment">// 对事件进行处理，并返回合成事件对象</span></span><br><span class="line">    topLevelType: TopLevelType,</span><br><span class="line">    targetInst: <span class="literal">null</span> | Fiber,</span><br><span class="line">    nativeEvent: NativeEvent,</span><br><span class="line">    nativeEventTarget: EventTarget,</span><br><span class="line">  ) =&gt; ?ReactSyntheticEvent,</span><br><span class="line">  tapMoveThreshold?: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>eventTypes</strong>声明该插件负责的事件类型, 它通过<code>DispatchConfig</code>来描述:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DispatchConfig = &#123;</span><br><span class="line">  dependencies: <span class="built_in">Array</span>&lt;TopLevelType&gt;, <span class="comment">// 依赖的原生事件，表示关联这些事件的触发. ‘简单事件’一般只有一个，复杂事件如onChange会监听多个, 如下图👇</span></span><br><span class="line">  phasedRegistrationNames?: &#123;    <span class="comment">// 两阶段props事件注册名称, React会根据这些名称在组件实例中查找对应的props事件处理器</span></span><br><span class="line">    bubbled: <span class="built_in">string</span>,             <span class="comment">// 冒泡阶段, 如onClick</span></span><br><span class="line">    captured: <span class="built_in">string</span>,            <span class="comment">// 捕获阶段，如onClickCapture</span></span><br><span class="line">  &#125;,</span><br><span class="line">  registrationName?: <span class="built_in">string</span>      <span class="comment">// props事件注册名称, 比如onMouseEnter这些不支持冒泡的事件类型，只会定义  registrationName，不会定义phasedRegistrationNames</span></span><br><span class="line">  eventPriority: EventPriority,  <span class="comment">// 事件的优先级，上文已经介绍过了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>看一下实例:</p><p><img src="/images/react-event/dispatch-config.png" alt></p><p>上面列举了三个典型的EventPlugin：</p><ul><li><p><strong>SimpleEventPlugin</strong> - 简单事件最好理解，它们的行为都比较通用，没有什么Trick, 例如不支持事件冒泡、不支持在Document上绑定等等. 和原生DOM事件是一一对应的关系，比较好处理.</p></li><li><p><strong>EnterLeaveEventPlugin</strong> - 从上图可以看出来，<code>mouseEnter</code>和<code>mouseLeave</code>依赖的是<code>mouseout</code>和<code>mouseover</code>事件。也就是说<code>*Enter/*Leave</code>事件在React中是通过<code>*Over/*Out</code>事件来模拟的。这样做的好处是可以在document上面进行委托监听，还有避免<code>*Enter/*Leave</code>一些奇怪而不实用的行为。</p></li><li><p><strong>ChangeEventPlugin</strong> - onChange是React的一个自定义事件，可以看出它依赖了多种原生DOM事件类型来模拟onChange事件.</p></li></ul><p><br></p><p>另外每个插件还会定义<code>extractEvents</code>方法，这个方法接受事件名称、原生DOM事件对象、事件触发的DOM元素以及React组件实例, 返回一个合成事件对象，如果返回空则表示不作处理. 关于extractEvents的细节会在下一节阐述.</p><p><br></p><p>在ReactDOM启动时就会向<code>EventPluginHub</code>注册这些插件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EventPluginHubInjection.injectEventPluginsByName(&#123;</span><br><span class="line">  SimpleEventPlugin: SimpleEventPlugin,</span><br><span class="line">  EnterLeaveEventPlugin: EnterLeaveEventPlugin,</span><br><span class="line">  ChangeEventPlugin: ChangeEventPlugin,</span><br><span class="line">  SelectEventPlugin: SelectEventPlugin,</span><br><span class="line">  BeforeInputEventPlugin: BeforeInputEventPlugin,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>Ok, 回到正题，事件是怎么绑定的呢？ 打个断点看一下调用栈:</p><p><img src="/images/react-event/listento.png" alt></p><p>前面调用栈关于React树如何更新和渲染就不在本文的范围内了，通过调用栈可以看出React在props初始化和更新时会进行事件绑定。这里先看一下流程图，忽略杂乱的跳转：</p><p><img src="/images/react-event/binding.png" alt></p><ul><li><strong>1. 在props初始化和更新时会进行事件绑定</strong>。首先React会判断元素是否是<code>媒体类型</code>，<strong>媒体类型的事件是无法在Document监听的，所以会直接在元素上进行绑定</strong></li><li><strong>2. 反之就在Document上绑定</strong>. 这里面需要两个信息，一个就是上文提到的’事件依赖列表’, 比如<code>onMouseEnter</code>依赖<code>mouseover/mouseout</code>; 第二个是ReactBrowserEventEmitter维护的’已订阅事件表’。<strong>事件处理器只需在Document订阅一次，所以相比在每个元素上订阅事件会节省很多资源</strong>.</li></ul><p>代码大概如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">listenTo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  registrationName: <span class="built_in">string</span>,           <span class="comment">// 注册名称，如onClick</span></span></span></span><br><span class="line"><span class="function"><span class="params">  mountAt: Document | Element | Node, <span class="comment">// 组件树容器，一般是Document</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeningSet = getListeningSetForElement(mountAt);             <span class="comment">// 已订阅事件表</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = registrationNameDependencies[registrationName]; <span class="comment">// 事件依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dependency = dependencies[i];</span><br><span class="line">    <span class="keyword">if</span> (!listeningSet.has(dependency)) &#123;                               <span class="comment">// 未订阅</span></span><br><span class="line">      <span class="keyword">switch</span> (dependency) &#123;</span><br><span class="line">        <span class="comment">// ... 特殊的事件监听处理</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">const</span> isMediaEvent = mediaEventTypes.indexOf(dependency) !== <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">if</span> (!isMediaEvent) &#123;</span><br><span class="line">            trapBubbledEvent(dependency, mountAt);                     <span class="comment">// 设置事件处理器</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      listeningSet.add(dependency);                                    <span class="comment">// 更新已订阅表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>接下来就是根据事件的’优先级’和’捕获阶段’(是否是capture)来设置事件处理器</strong>:</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trapEventForPluginEventSystem</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: Document | Element | Node,   <span class="comment">// 绑定到元素，一般是Document</span></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType: DOMTopLevelEventType,   <span class="comment">// 事件名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">  capture: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> listener;</span><br><span class="line">  <span class="keyword">switch</span> (getEventPriority(topLevelType)) &#123;</span><br><span class="line">    <span class="comment">// 不同优先级的事件类型，有不同的事件处理器进行分发, 下文会详细介绍</span></span><br><span class="line">    <span class="keyword">case</span> DiscreteEvent:                      <span class="comment">// ⚛️离散事件</span></span><br><span class="line">      listener = dispatchDiscreteEvent.bind(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        topLevelType,</span><br><span class="line">        PLUGIN_EVENT_SYSTEM,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingEvent:                 <span class="comment">// ⚛️用户阻塞事件</span></span><br><span class="line">      listener = dispatchUserBlockingUpdate.bind(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        topLevelType,</span><br><span class="line">        PLUGIN_EVENT_SYSTEM,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ContinuousEvent:                   <span class="comment">// ⚛️可连续事件</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      listener = dispatchEvent.bind(<span class="literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rawEventName = getRawEventName(topLevelType);</span><br><span class="line">  <span class="keyword">if</span> (capture) &#123;                            <span class="comment">// 绑定事件处理器到元素</span></span><br><span class="line">    addEventCaptureListener(element, rawEventName, listener);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addEventBubbleListener(element, rawEventName, listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件绑定的过程还比较简单, 接下来看看事件是如何分发的。</p><p><br></p><h3 id="事件是如何分发的？"><a href="#事件是如何分发的？" class="headerlink" title="事件是如何分发的？"></a>事件是如何分发的？</h3><p>按惯例还是先上流程图:</p><p><img src="/images/react-event/binding.png" alt></p><h4 id="事件触发调度"><a href="#事件触发调度" class="headerlink" title="事件触发调度"></a>事件触发调度</h4><p>通过上面的<code>trapEventForPluginEventSystem</code>函数可以知道，不同的事件类型有不同的事件处理器, 它们的区别是调度的优先级不一样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 离散事件</span></span><br><span class="line"><span class="comment">// discrentUpdates 在UserBlocking优先级中执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchDiscreteEvent</span>(<span class="params">topLevelType, eventSystemFlags, nativeEvent</span>) </span>&#123;</span><br><span class="line">  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);</span><br><span class="line">  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchUserBlockingUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果开启了enableUserBlockingEvents, 则在UserBlocking优先级中调度，</span></span><br><span class="line">  <span class="comment">// 开启enableUserBlockingEvents可以防止饥饿问题，因为阻塞事件中有scroll、mouseMove这类频繁触发的事件</span></span><br><span class="line">  <span class="comment">// 否则同步执行</span></span><br><span class="line">  <span class="keyword">if</span> (enableUserBlockingEvents) &#123;</span><br><span class="line">    runWithPriority(</span><br><span class="line">      UserBlockingPriority,</span><br><span class="line">      dispatchEvent.bind(<span class="literal">null</span>, topLevelType, eventSystemFlags, nativeEvent),</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dispatchEvent(topLevelType, eventSystemFlags, nativeEvent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可连续事件则直接同步调用dispatchEvent</span></span><br></pre></td></tr></table></figure><p><br></p><p>最终不同的事件类型都会调用<code>dispatchEvent</code>函数. <code>dispatchEvent</code>中会从DOM原生事件对象获取事件触发的target，再根据这个target获取关联的React节点实例.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatchEvent</span>(<span class="params">topLevelType: DOMTopLevelEventType, eventSystemFlags: EventSystemFlags, nativeEvent: AnyNativeEvent</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取事件触发的目标DOM</span></span><br><span class="line">  <span class="keyword">const</span> nativeEventTarget = getEventTarget(nativeEvent);</span><br><span class="line">  <span class="comment">// 获取离该DOM最近的组件实例(只能是DOM元素组件)</span></span><br><span class="line">  <span class="keyword">let</span> targetInst = getClosestInstanceFromNode(nativeEventTarget);</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>接着(中间还有一些步骤，这里忽略)会调用<code>EventPluginHub</code>的<code>runExtractedPluginEventsInBatch</code>，这个方法遍历插件列表来处理事件，生成一个SyntheticEvent列表:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runExtractedPluginEventsInBatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst: <span class="literal">null</span> | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历插件列表, 调用插件的extractEvents，生成SyntheticEvent列表</span></span><br><span class="line">  <span class="keyword">const</span> events = extractPluginEvents(</span><br><span class="line">    topLevelType,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件处理器执行, 见后文批量执行</span></span><br><span class="line">  runEventsInBatch(events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="插件是如何处理事件"><a href="#插件是如何处理事件" class="headerlink" title="插件是如何处理事件?"></a>插件是如何处理事件?</h4><p>现在来看看插件是如何处理事件的，我们以<code>SimpleEventPlugin</code>为例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleEventPlugin: PluginModule&lt;MouseEvent&gt; &amp; &#123;</span><br><span class="line">  getEventPriority: <span class="function">(<span class="params">topLevelType: TopLevelType</span>) =&gt;</span> EventPriority,</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  eventTypes: eventTypes,</span><br><span class="line">  <span class="comment">// 抽取事件对象</span></span><br><span class="line">  extractEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">    targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEvent: MouseEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">null</span> | <span class="title">ReactSyntheticEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事件配置</span></span><br><span class="line">    <span class="keyword">const</span> dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1️⃣ 根据事件类型获取SyntheticEvent子类事件构造器</span></span><br><span class="line">    <span class="keyword">let</span> EventConstructor;</span><br><span class="line">    <span class="keyword">switch</span> (topLevelType) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_DOWN:</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_UP:</span><br><span class="line">        EventConstructor = SyntheticKeyboardEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_BLUR:</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_FOCUS:</span><br><span class="line">        EventConstructor = SyntheticFocusEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ... 省略</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_GOT_POINTER_CAPTURE:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_UP:</span><br><span class="line">        EventConstructor = SyntheticPointerEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        EventConstructor = SyntheticEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2️⃣ 构造事件对象, 从对象池中获取</span></span><br><span class="line">    <span class="keyword">const</span> event = EventConstructor.getPooled(</span><br><span class="line">      dispatchConfig,</span><br><span class="line">      targetInst,</span><br><span class="line">      nativeEvent,</span><br><span class="line">      nativeEventTarget,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3️⃣ 根据DOM事件传播的顺序获取用户事件处理器</span></span><br><span class="line">    accumulateTwoPhaseDispatches(event);</span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>SimpleEventPlugin</code>的<code>extractEvents</code>主要做以下三个事情:</p><ul><li>1️⃣ 根据事件的类型确定SyntheticEvent构造器</li><li>2️⃣ 构造SyntheticEvent对象。</li><li>3️⃣ 根据DOM事件传播的顺序获取用户事件处理器列表</li></ul><p><br></p><p><strong>为了避免频繁创建和释放事件对象导致性能损耗(对象创建和垃圾回收)，React使用一个事件池来负责管理事件对象，使用完的事件对象会放回池中，以备后续的复用</strong>。</p><p>这也意味着，<strong>在事件处理器同步执行完后，SyntheticEvent对象就会马上被回收</strong>，所有属性都会无效。所以一般不会在异步操作中访问SyntheticEvent事件对象。你也可以通过以下方法来保持事件对象的引用：</p><ul><li>调用<code>SyntheticEvent#persist()</code>方法，告诉React不要回收到对象池</li><li>直接引用<code>SyntheticEvent#nativeEvent</code>, nativeEvent是可以持久引用的，不过为了不打破抽象，建议不要直接引用nativeEvent</li></ul><p><br></p><p>构建完SyntheticEvent对象后，就需要<strong>遍历组件树来获取订阅该事件的用户事件处理器</strong>了:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateTwoPhaseDispatchesSingle</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以_targetInst为基点, 按照DOM事件传播的顺序遍历组件树</span></span><br><span class="line">  traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历方法其实很简单：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverseTwoPhase</span>(<span class="params">inst, fn, arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="keyword">while</span> (inst) &#123;           <span class="comment">// 从inst开始，向上级回溯</span></span><br><span class="line">    path.push(inst);</span><br><span class="line">    inst = getParent(inst);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="comment">// 捕获阶段，先从最顶层的父组件开始, 向下级传播</span></span><br><span class="line">  <span class="keyword">for</span> (i = path.length; i-- &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">    fn(path[i], <span class="string">'captured'</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 冒泡阶段，从inst，即事件触发点开始, 向上级传播</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">    fn(path[i], <span class="string">'bubbled'</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>accumulateDirectionalDispatches</code>函数则是简单查找当前节点是否有对应的事件处理器:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateDirectionalDispatches</span>(<span class="params">inst, phase, event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否存在事件处理器</span></span><br><span class="line">  <span class="keyword">const</span> listener = listenerAtPhase(inst, event, phase);</span><br><span class="line">  <span class="comment">// 所有处理器都放入到_dispatchListeners队列中，后续批量执行这个队列</span></span><br><span class="line">  <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">    event._dispatchListeners = accumulateInto(</span><br><span class="line">      event._dispatchListeners,</span><br><span class="line">      listener,</span><br><span class="line">    );</span><br><span class="line">    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>例如下面的组件树, 遍历过程是这样的：</p><p><img src="/images/react-event/event-delivery.png" alt></p><p>最终计算出来的<code>_dispatchListeners</code>队列是这样的：<code>[handleB, handleC, handleA]</code></p><p><br></p><h4 id="批量执行"><a href="#批量执行" class="headerlink" title="批量执行"></a>批量执行</h4><p>遍历执行插件后，会得到一个SyntheticEvent列表，<code>runEventsInBatch</code>就是批量执行这些事件中的<code>_dispatchListeners</code>事件队列</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runEventsInBatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  events: Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👇</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> executeDispatchesAndRelease = <span class="function"><span class="keyword">function</span>(<span class="params">event: ReactSyntheticEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event) &#123;</span><br><span class="line">    <span class="comment">// 按顺序执行_dispatchListeners</span></span><br><span class="line">    <span class="comment">// 👇</span></span><br><span class="line">    executeDispatchesInOrder(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有调用persist()方法则直接回收</span></span><br><span class="line">    <span class="keyword">if</span> (!event.isPersistent()) &#123;</span><br><span class="line">      event.constructor.release(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">executeDispatchesInOrder</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历dispatchListeners</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 通过调用 stopPropagation 方法可以禁止执行下一个事件处理器</span></span><br><span class="line">    <span class="keyword">if</span> (event.isPropagationStopped()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行事件处理器</span></span><br><span class="line">    executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/react-event/dispatch.png" alt></p><p>OK, 到这里React的事件机制就基本介绍完了，这里只是简单了介绍了一下<code>SimpleEventPlugin</code>, 实际代码中还有很多事件处理的细节，限于篇幅，本文就不展开去讲了。有兴趣的读者可以亲自去观摩React的源代码.</p><p><br><br><br></p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>React内部有一个实验性的事件API，React内部称为<code>React Flare</code>、正式名称是<a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener"><code>react-events</code></a>, <strong>通过这个API可以实现跨平台、跨设备的高级事件封装</strong>.</p><p>react-events定义了一个<strong>事件响应器(Event Responders)</strong>的概念，这个事件响应器可以捕获子组件树或应用根节点的事件，然后转换为自定义事件.</p><p>比较典型的高级事件是press、longPress、swipe这些手势。通常我们需要自己或者利用第三方库来实现这一套手势识别, 例如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Gesture <span class="keyword">from</span> <span class="string">'rc-gesture'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Gesture</span><br><span class="line">    onTap=&#123;handleTap&#125;</span><br><span class="line">    onSwipe=&#123;onSwipe&#125;</span><br><span class="line">    onPinch=&#123;handlePinch&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;div&gt;container&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Gesture&gt;,</span><br><span class="line">container);</span><br></pre></td></tr></table></figure><p><br></p><p>那么react-events的目的就是<strong>提供一套通用的事件机制给开发者来实现’高级事件’的封装, 甚至实现事件的跨平台、跨设备</strong>, 现在你可以通过react-events来封装这些手势事件.</p><p>react-events除了核心的<code>Responder</code>接口，还封装了一些内置模块, 实现跨平台的、常用的高级事件封装：</p><ul><li>Focus module</li><li>Hover module</li><li>Press module</li><li>FocusScope module</li><li>Input module</li><li>KeyBoard module</li><li>Drag module</li><li>Pan module</li><li>Scroll module</li><li>Swipe module</li></ul><p>举<code>Press</code>模块作为例子, <a href="https://github.com/facebook/react/blob/master/packages/react-events/docs/Press.md" target="_blank" rel="noopener">Press模块</a>会响应它包裹的元素的press事件。press事件包括onContextMenu、onLongPress、onPress、onPressEnd、onPressMove、onPressStart等等. 其底层通过mouse、pen、touch、trackpad等事件来转换.</p><p>看看使用示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PressResponder, usePressListener &#125; <span class="keyword">from</span> <span class="string">'react-events/press'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">const</span> listener = usePressListener(&#123;  <span class="comment">// ⚛️通过hooks创建Responder</span></span><br><span class="line">    onPressStart,</span><br><span class="line">    onPress,</span><br><span class="line">    onPressEnd,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div listeners=&#123;listener&#125;&gt;</span><br><span class="line">      &#123;subtrees&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><p>react-events的运作流程图如下, <strong>事件响应器(Event Responders)会挂载到host节点，它会在host节点监听host或子节点分发的原生事件(DOM或React Native), 并将它们转换/合并成高级的事件</strong>:</p><p><img src="/images/react-event/responder.png" alt></p><p><br></p><blockquote><p>你可以通过这个Codesanbox玩一下<code>react-events</code>: <a href="https://codesandbox.io/s/github/ivan-94/react-events-playground" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit react-events-playground"></a></p></blockquote><p><br></p><h3 id="初探responder的创建"><a href="#初探responder的创建" class="headerlink" title="初探Responder的创建"></a>初探Responder的创建</h3><p>我们挑一个简单的模块来了解一些react-events的核心API, 目前最简单的是Keyboard模块. Keyboard模块的目的就是规范化keydown和keyup事件对象的key属性(部分浏览器key属性的行为不一样)，它的实现如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Responder的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> keyboardResponderImpl = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1️⃣定义Responder需要监听的子树的DOM事件，对于Keyboard来说是['keydown', 'keyup';]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  targetEventTypes,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 2️⃣监听子树触发的事件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onEvent(</span><br><span class="line">    event: ReactDOMResponderEvent,     <span class="comment">// 包含了当前触发事件的相关信息，如原生事件对象，事件触发的节点，事件类型等等</span></span><br><span class="line">    context: ReactDOMResponderContext, <span class="comment">// Responder的上下文，给Responder提供了一些方法来驱动事件分发</span></span><br><span class="line">    props: KeyboardResponderProps,     <span class="comment">// 传递给Responder的props</span></span><br><span class="line">  ): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;responderTarget, type&#125; = event;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (props.disabled) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'keydown'</span>) &#123;</span><br><span class="line">      dispatchKeyboardEvent(</span><br><span class="line">        <span class="string">'onKeyDown'</span>,</span><br><span class="line">        event,</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">'keydown'</span>,</span><br><span class="line">        ((responderTarget: any): Element | Document),</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'keyup'</span>) &#123;</span><br><span class="line">      dispatchKeyboardEvent(</span><br><span class="line">        <span class="string">'onKeyUp'</span>,</span><br><span class="line">        event,</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">'keyup'</span>,</span><br><span class="line">        ((responderTarget: any): Element | Document),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看看dispatchKeyboardEvent:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchKeyboardEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  eventPropName: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  event: ReactDOMResponderEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: ReactDOMResponderContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: KeyboardEventType,</span></span></span><br><span class="line"><span class="function"><span class="params">  target: Element | Document,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️创建合成事件对象，在这个函数中会规范化事件的key属性</span></span><br><span class="line">  <span class="keyword">const</span> syntheticEvent = createKeyboardEvent(event, context, type, target);</span><br><span class="line">  <span class="comment">// ⚛️通过Responder上下文分发事件</span></span><br><span class="line">  context.dispatchEvent(eventPropName, syntheticEvent, DiscreteEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出Responder:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️createResponder把keyboardResponderImpl转换为组件形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> KeyboardResponder = React.unstable_createResponder(</span><br><span class="line">  <span class="string">'Keyboard'</span>,</span><br><span class="line">  keyboardResponderImpl,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️创建hooks形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useKeyboardListener</span>(<span class="params">props: KeyboardListenerProps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  React.unstable_useListener(KeyboardResponder, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在读者应该对<strong>Responder的职责</strong>有了一些基本的了解，它主要做以下几件事情:</p><ul><li>声明要监听的原生事件(如DOM), 如上面的<code>targetEventTypes</code></li><li>处理和转换合成事件，如上面的<code>onEvent</code></li><li>创建并分发自定义事件。如上面的<code>context.dispatchEvent</code></li></ul><p><br></p><p>和上面的Keyboard模块相比，现实中的很多高级事件，如longPress, 它们的实现则要复杂得多. 它们可能要维持一定的<strong>状态</strong>、也可能要独占响应的<strong>所有权</strong>(即同一时间只能有一个Responder可以对事件进行处理, 这个常用于移动端触摸手势，例如React Native的<a href="https://reactnative.cn/docs/gesture-responder-system/" target="_blank" rel="noopener">GestureResponderSystem</a>)。</p><p>react-events目前都考虑了这些场景, 看一下API概览:</p><p><img src="/images/react-event/react-events.png" alt></p><p><br></p><p>详细可以看react-events<a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener">官方仓库</a></p><p><br></p><h3 id="react-events意义何在"><a href="#react-events意义何在" class="headerlink" title="react-events意义何在?"></a>react-events意义何在?</h3><p>上文提到了React事件内部采用了插件机制，来实现事件处理和合成，比较典型的就是onChange事件。onChange事件其实就是所谓的‘高级事件’，它是通过表单组件的各种原生事件来模拟的。</p><p>也就是说，React通过插件机制本质上是可以实现高级事件的封装的。但是如果读者看过源代码，就会觉得里面逻辑比较绕，而且依赖React的很多内部实现。<strong>所以这种内部的插件机制并不是面向普通开发者的</strong>。</p><p><code>react-events</code>接口就简单很多了，它屏蔽了很多内部细节，面向普通开发者。我们可以利用它来实现高性能的自定义事件分发，更大的意义是通过它可以实现跨平台/设备的事件处理方式.</p><p>目前react-events还是实验阶段，特性是默认关闭，API可能会出现变更, 所以不建议在生产环境使用。可以通过这个<a href="https://github.com/facebook/react/issues/15257" target="_blank" rel="noopener">Issue</a>来关注它的进展。</p><p><br></p><p>最后赞叹一下React团队的创新能力！</p><p><br></p><p>完！</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://segmentfault.com/a/1190000013094932" target="_blank" rel="noopener">input事件中文触发多次问题研究</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">完全理解React Fiber</a></li><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark – A Cartoon Intro to Fiber – React Conf 2017</a></li><li><a href="https://philippspiess.com/scheduling-in-react/" target="_blank" rel="noopener">Scheduling in React</a></li><li><a href="https://github.com/facebook/react/issues/15257" target="_blank" rel="noopener">[Umbrella] React Flare</a></li><li><a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener">react-events</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react-event/sample.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发. &lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端团队Leader，怎么制定前端协作规范?</title>
    <link href="https://bobi.ink/2019/07/19/frontend-standard/"/>
    <id>https://bobi.ink/2019/07/19/frontend-standard/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2019-09-26T23:19:55.258Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢</p></blockquote><p><br></p><p>笔者长期单枪匹马在前端领域厮杀(言外之意就是团队就一个人)，自己就是规范。随着公司业务的扩展，扩充了一些人员，这时候就要开始考虑协作和编码规范问题了。本文记录了笔者在制定<code>前端协作规范</code>时的一些思考，希望能给你们也带来一些帮助.</p><p><strong>一个人走的更快，一群人可以走得更远，前提是统一的策略，还要不断地反省和优化</strong>。</p><p><br></p><p><strong>以下是目录概览, 看出这是一篇浩浩荡荡的长文</strong></p><!-- TOC --><ul><li><a href="#1-工作流规范">1 工作流规范</a><ul><li><a href="#11-开发">1.1 开发</a><ul><li><a href="#111-版本规范">1.1.1 版本规范</a></li><li><a href="#112-版本控制系统规范">1.1.2 版本控制系统规范</a></li><li><a href="#113-提交信息规范">1.1.3 提交信息规范</a></li></ul></li><li><a href="#12-构建规范">1.2 构建规范</a></li><li><a href="#13-发布工作流规范">1.3 发布工作流规范</a></li><li><a href="#14-持续集成">1.4 持续集成</a></li><li><a href="#15-任务管理">1.5 任务管理</a></li></ul></li><li><a href="#2-技术栈规范">2 技术栈规范</a><ul><li><a href="#21-技术选型">2.1 技术选型</a></li><li><a href="#22-迎接新技术">2.2 迎接新技术</a></li></ul></li><li><a href="#3-浏览器兼容规范">3 浏览器兼容规范</a><ul><li><a href="#31-确定兼容策略">3.1 确定兼容策略</a></li><li><a href="#32-确定浏览器分级">3.2 确定浏览器分级</a></li><li><a href="#33-获取统计数据">3.3 获取统计数据</a></li></ul></li><li><a href="#4-项目组织规范">4 项目组织规范</a><ul><li><a href="#41-通用的项目组织规范">4.1 通用的项目组织规范</a></li><li><a href="#42-目录组织的风格">4.2 目录组织的风格</a></li><li><a href="#43-脚手架和项目模板">4.3 脚手架和项目模板</a></li></ul></li><li><a href="#5-编码规范">5 编码规范</a><ul><li><a href="#51-javascript">5.1 Javascript</a></li><li><a href="#52-html">5.2 HTML</a></li><li><a href="#53-css">5.3 CSS</a></li><li><a href="#54-代码格式化">5.4 代码格式化</a></li><li><a href="#55-集大成的">5.5 集大成的</a></li><li><a href="#56-特定框架风格指南">5.6 特定框架风格指南</a></li><li><a href="#57-code-review">5.7 Code Review</a></li></ul></li><li><a href="#6-文档规范">6 文档规范</a><ul><li><a href="#61-建立文档中心">6.1 建立文档中心</a></li><li><a href="#62-文档格式">6.2 文档格式</a></li><li><a href="#63-定义文档的模板">6.3 定义文档的模板</a></li><li><a href="#64-讨论即文档">6.4 讨论即文档</a></li><li><a href="#65-注释即文档">6.5 注释即文档</a></li><li><a href="#66-代码即文档">6.6 代码即文档</a></li></ul></li><li><a href="#7-ui设计规范">7 UI设计规范</a></li><li><a href="#8-测试规范">8 测试规范</a><ul><li><a href="#81-测试的流程">8.1 测试的流程</a></li><li><a href="#82-单元测试">8.2 单元测试</a></li></ul></li><li><a href="#9-异常处理监控和调试规范">9 异常处理、监控和调试规范</a><ul><li><a href="#91-异常处理">9.1 异常处理</a></li><li><a href="#92-日志">9.2 日志</a></li><li><a href="#93-异常监控">9.3 异常监控</a></li></ul></li><li><a href="#10-前后端协作规范">10 前后端协作规范</a><ul><li><a href="#101-协作流程规范">10.1 协作流程规范</a></li><li><a href="#102-接口规范">10.2 接口规范</a></li><li><a href="#103-接口文档规范">10.3 接口文档规范</a></li><li><a href="#104-接口测试与模拟">10.4 接口测试与模拟</a></li></ul></li><li><a href="#11-培训知识管理技术沉淀">11 培训/知识管理/技术沉淀</a><ul><li><a href="#111-新人培训">11.1 新人培训</a></li><li><a href="#112-营造技术氛围">11.2 营造技术氛围</a></li></ul></li><li><a href="#12-反馈">12 反馈</a></li></ul><!-- /TOC --><p><br></p><p><strong>CHANGELOG</strong></p><ul><li>2019.7.28<br>新增<a href="#tech-select">技术选型</a></li><li>2019.7.29<br>新增<a href="#brw-anly">浏览器统计数据获取</a></li><li>2019.9.6<br>建立技术氛围一节 新增面试题库</li><li>2019.9.27<br>更新系列文章</li></ul><p><br></p><p><strong>系列文章</strong></p><ul><li><a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范? 🔥</a></li><li><a href="https://juejin.im/post/5d71cec6e51d4561b674c4d0" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么做好概要设计</a></li><li><a href="https://juejin.im/post/5d8d4557e51d4577fe41b62d" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么用好看板进行任务管理?</a></li></ul><p><br></p><p><strong>什么是规范?</strong></p><p>规范，名词意义上：即明文规定或约定俗成的标准，如：道德规范、技术规范等。 动词意义上：是指按照既定标准、规范的要求进行操作，使某一行为或活动达到或超越规定的标准，如：规范管理、规范操作.</p><p><br></p><p><strong>为什么需要规范?</strong></p><ul><li>降低新成员融入团队的成本, 同时也一定程度避免挖坑</li><li>提高开发效率、团队协作效率, 降低沟通成本</li><li>实现高度统一的代码风格，方便review, 另外一方面可以提高项目的可维护性</li><li>规范是实现自动化的基础</li><li>规范是一个团队知识沉淀的直接输出</li></ul><p><br></p><p><strong>规范包含哪些内容?</strong></p><p>如文章标题，<strong>前端协作规范并不单单指‘编码规范’，这个规范涉及到前端开发活动的方方面面</strong>，例如代码库的管理、前后端协作、代码规范、兼容性规范；</p><p>不仅仅是前端团队内部需要协作，一个完整的软件生命周期内，我们需要和产品/设计、后端(或者原生客户端团队)、测试进行协作, 我们需要覆盖这些内容.</p><p><br></p><p>下面就开始介绍，<strong>如果我是前端团队的Leader，我会怎么制定前端规范，这个规范需要包含哪些内容</strong>?</p><p><br></p><h2 id="1-工作流规范"><a href="#1-工作流规范" class="headerlink" title="1 工作流规范"></a>1 工作流规范</h2><h3 id="1-1-开发"><a href="#1-1-开发" class="headerlink" title="1.1 开发"></a>1.1 开发</h3><h4 id="1-1-1-版本规范"><a href="#1-1-1-版本规范" class="headerlink" title="1.1.1 版本规范"></a>1.1.1 版本规范</h4><p>项目的版本号应该根据某些规则进行迭代, 这里推荐使用<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a>规范, <strong>通过这个规范，用户可以了解版本变更的影响范围</strong>。 规则如下:</p><ul><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h4 id="1-1-2-版本控制系统规范"><a href="#1-1-2-版本控制系统规范" class="headerlink" title="1.1.2 版本控制系统规范"></a>1.1.2 版本控制系统规范</h4><p>大部分团队都使用git作为版本库，管理好代码也是一种学问。尤其是涉及多人并发协作、需要管理多个软件版本的情况下，定义良好的版本库管理规范，可以让大型项目更有组织性，也可以提高成员协作效率.</p><p>比较流行的git分支模型/工作流是<a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" target="_blank" rel="noopener">git-flow</a>, 但是大部分团队会根据自己的情况制定自己的git工作流规范, 例如我们团队的<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/development.md#git-%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">分支规范</a></p><p><strong>Git 有很多工作流方法论，这些工作流的选择可能依赖于项目的规模、项目的类型以及团队成员的结构</strong>.</p><p>比如一个简单的个人项目可能不需要复杂的分支划分，我们的变更都是直接提交到 master 分支;</p><p>再比如开源项目，除了核心团队成员，其他贡献者是没有提交的权限的，而且我们也需要一定的手段来验证和讨论贡献的代码是否合理。 所以对于开源项目 fork 工作流更为适合.</p><p>了解常见的工作流有利于组织或创建适合自己团队的工作流, 提交团队协作的效率:</p><p><img src="/images/frontend-standard/branch.png" alt></p><ul><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/centralized.md" target="_blank" rel="noopener">简单的集中式</a></li><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/feature.md" target="_blank" rel="noopener">基于功能分支的工作流</a></li><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/gitflow.md" target="_blank" rel="noopener">Git Flow</a> 🔥</li><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/fork.md" target="_blank" rel="noopener">Fork/Pull Request 工作流</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h4 id="1-1-3-提交信息规范"><a href="#1-1-3-提交信息规范" class="headerlink" title="1.1.3 提交信息规范"></a>1.1.3 提交信息规范</h4><p><img src="/images/frontend-standard/commit.png" alt></p><p>组织好的提交信息, 可以提高项目的整体质量. 至少具有下面这些优点:</p><ul><li><strong>格式统一的提交信息有助于自动化生成CHANGELOG</strong></li><li><strong>版本库不只是存放代码的仓库, 它记录项目的开发日志, 它应该要清晰表达这次提交的做了什么</strong>. 这些记录应该可以帮助后来者快速地学习和回顾代码, 也应该方便其他协作者review你的代码</li><li><strong>规范化提交信息可以促进提交者提交有意义的、粒度合适的’提交’</strong>. 提交者要想好要怎么描述这个提交，这样被动促进了他们去把控<strong>提交的粒度</strong></li></ul><p><br></p><p>社区上比较流行的提交信息规范是<a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit" target="_blank" rel="noopener">Angular的提交信息规范</a>, 除此之外，这些也很不错:</p><ul><li><a href="https://github.com/atom/atom/blob/master/CONTRIBUTING.md#git-commit-messages" target="_blank" rel="noopener">Atom</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-ember" target="_blank" rel="noopener">Ember</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-eslint" target="_blank" rel="noopener">Eslint</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-jquery" target="_blank" rel="noopener">JQuery</a></li></ul><p><br></p><p>另外这些工具可以帮助你检验提交信息, 以及生成CHANGELOG:</p><ul><li><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener">conventional-changelog</a> - 从项目的提交信息中生成CHANGELOG和发布信息</li><li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">commitlint</a> - 检验提交信息</li><li><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">commitizen</a> - 🔥简单的提交规范和提交帮助工具，推荐</li><li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">standard-changelog</a> - angular风格的提交命令行工具 </li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-2-构建规范"><a href="#1-2-构建规范" class="headerlink" title="1.2 构建规范"></a>1.2 构建规范</h3><p>对于团队、或者需要维护多个项目场景，统一的构建工具链很重要, <strong>这套工具应该强调”约定大于配置”，让开发者更专注于业务的开发</strong>。笔者在<a href="https://juejin.im/post/5d2fcaacf265da1b95708f63" target="_blank" rel="noopener">&lt;为什么要用vue-cli3?&gt;</a>文章中提出了<code>vue-cli3</code>更新有很多亮点，非常适合作为团队构建工具链的基础:</p><ul><li><strong>首先这类工具是推崇’约定大于配置’</strong>。即按照他们的规范，可以实现开箱即用，快速开发业务. 在团队协作中这点很重要，我们不推荐团队成员去关心又臭又长的webpack构建配置</li><li><strong><code>vue-cli3</code>抽离了<code>cli service层</code>，可以独立更新工具链</strong>。也就是说项目的构建脚本和配置在一个独立的service项目中维护，而不是像以前一样在每个项目目录下都有webpack配置和依赖. 这样做的好处是独立地、简单地升级整个构建链</li><li><strong>灵活的插件机制</strong>。对于团队的定制化构建应该封装到插件中，这样也可以实现独立的更新。</li></ul><p><strong>我们可以选择第三方CLI, 当然也定制自己的构建链，按照上面说的这个构建链应该有以下特点</strong>:</p><ul><li><strong>强约定，体现团队的规范</strong>。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 <em>另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能</em>。</li><li><strong>方便升级</strong>。尤其是团队需要维护多个项目场景, 这一点很有意义</li></ul><p>下面是社区上比较流行的构建工具. 当然，你也可以根据自己的团队情况开发自己的CLI, 但是下面的工具依然很有<em>参考价值</em>：</p><ul><li><a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> - 🔥零配置开始React开发</li><li><a href="https://cli.vuejs.org/" target="_blank" rel="noopener">vue-cli</a> - 🔥零配置、渐进增强的项目构建CLI</li><li><a href="https://parceljs.org/" target="_blank" rel="noopener">parcel</a> - 零配置的Web应用打包工具</li><li><a href="https://github.com/fuse-box/fuse-box" target="_blank" rel="noopener">Fusebox</a> - 高速易用的打包工具</li><li><a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> - 零配置, 基于Rollup，适合用于打包‘库’</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-3-发布工作流规范"><a href="#1-3-发布工作流规范" class="headerlink" title="1.3 发布工作流规范"></a>1.3 发布工作流规范</h3><p>发布工作流指的是将‘软件成品’对外发布(如测试或生产)的一套流程, 将这套流程规范化后，可以实现自动化.</p><p>举个例子, 一个典型的发布工作流如下：</p><p><img src="/images/frontend-standard/pub.png" alt></p><ul><li>代码变更</li><li>提交代码变更到远程版本库</li><li>程序通过CI测试(例如Travis变绿)</li><li>提升package.json中的版本</li><li>生成CHANGELOG</li><li>提交package.json和CHANGELOG.md文件</li><li>打上Tag</li><li>推送</li></ul><p>如果你遵循上面的规范，那么就可以利用社区上现有的工具来自动化这个流程. 这些工具有:</p><ul><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli" target="_blank" rel="noopener">conventional-changelog-cli</a></li><li><a href="https://github.com/conventional-changelog/conventional-github-releaser" target="_blank" rel="noopener">conventional-github-releaser</a></li><li>实际上自己开发一个也不是特别难的事情.</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-4-持续集成"><a href="#1-4-持续集成" class="headerlink" title="1.4 持续集成"></a>1.4 持续集成</h3><p>将整套开发工作流确定下来之后, 就可以使用<code>持续集成服务</code>来自动化执行整个流程。比如一个典型的CI流程:</p><p><img src="/images/frontend-standard/ci.png" alt></p><p><strong>持续集成是什么，有什么意义呢</strong>?</p><p>我们需要<code>持续集成</code>拆成两个词分别来理解, 什么是<code>持续</code>? 什么是<code>集成</code>?</p><p><strong>持续(Continuous), 可以理解为’频繁’或者‘连续性’</strong>. 不管是持续集成还是敏捷开发思维、看板，都认为‘持续’是它们的基础。</p><p>举一个通俗的例子，<strong>比如代码检查，‘持续的’的代码检查就是代码一变动(如保存，或者IDE实时检查、或者提交到版本库时)就马上检查代码，而‘非持续’的代码检查就是在完成所有编码后，再进行检查</strong>。对比两者可以发现，持续性的代码检查可以尽早地发现错误，而且错误也比较容易理解和处理，反之非持续性的代码检查，可能会发现一堆的错误，失之毫厘谬以千里，错误相互牵连，最终会变得难以收拾。</p><p><strong>‘持续’的概念，可以用于软件开发的方方面面，本质上就是把传统瀑布式的软件开发流程打碎，形成一个个更小的开发闭环，持续地输出产品，同时产品也持续地给上游反馈和纠正</strong>。</p><p><img src="/images/frontend-standard/continous.png" alt></p><p><strong>那什么是‘集成’呢</strong>？狭义的集成可以简单认为是<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe#heading-26" target="_blank" rel="noopener">‘集成测试’</a>吧. 集成测试可以对代码静态测试、单元测试、通过单元测试后可以进行集成测试，在应用组成一个整体后在模拟环境中跑E2E测试等等。也就是说，在这里进行一系列的自动化测试来验证软件系统。</p><p>广义的持续集成服务，不仅仅是测试，它还衍生出很多概念，例如持续交付、持续部署，如下图</p><p><img src="/images/frontend-standard/devops.png" alt></p><p>OK, <strong>总结一下为什么持续集成的好处</strong>:</p><ul><li>尽早发现错误，快速试错。越早发现错误，处理错误的成本越低</li><li>自动化工作流，减少人工干预。人类比机器容易犯错, 而且机器擅长做重复的事情</li></ul><p><br></p><p><strong>对于持续集成规范一般会定义这些内容</strong>:</p><ul><li>执行的环境. 比如容器、Node版本、操作系统等等</li><li>触发的条件。比如定时触发、在哪个分支触发、会触发什么任务等等</li><li>执行的任务</li><li>划分持续集成的阶段. 比如<ul><li>检查：包括单元测试和代码lint. 所有push到版本库的代码都会跑这个阶段. 一般可以在提交title中包含[ci skip]来跳过这个阶段</li><li>构建: 对前端项目进行构建. 只有打上版本tag的提交或release分支会跑构建任务</li><li>发布: 将前端的构建结果进行交付/发布.  只有打上版本tag的提交或者release分支在构建成功后会跑发布任务</li></ul></li><li>定义持续集成脚本模板</li></ul><p><br></p><p>常用的CI服务:</p><ul><li>Github<ul><li><a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a></li><li><a href="https://github.com/marketplace/circleci" target="_blank" rel="noopener">CircleCI</a></li><li><a href="https://github.com/marketplace/category/continuous-integration" target="_blank" rel="noopener">完整列表</a></li></ul></li><li>GitLab: <a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">Gitlab-CI</a></li><li>通用<ul><li><a href="https://jenkins.io" target="_blank" rel="noopener">Jenkins</a></li></ul></li></ul><p><br></p><p>扩展</p><ul><li><a href="https://juejin.im/post/58f9ee860ce46300611be392" target="_blank" rel="noopener">持续集成是什么</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-5-任务管理"><a href="#1-5-任务管理" class="headerlink" title="1.5 任务管理"></a>1.5 任务管理</h3><p><img src="/images/frontend-standard/kanban.png" alt></p><p>作为前端Leader少不了任务管理。<strong>看板是目前最为流行的任务管理工具，它可以帮助我们了解项目的进度、资源的分配情况、还原开发现场</strong>.</p><p>笔者毕业第一年在一家很小的外包公司中工作，初生牛犊不怕虎，我竟然给老板推销起了看板和敏捷项目管理，想要改善项目管理这块效率低下问题，老板表示很支持，但是其他成员积极性并不高, 结果当然是失败的。</p><p>当时还起草了一份<a href="https://github.com/ivan-94/kanban_enforcement/blob/master/README.md#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%8B%E6%9D%BF" target="_blank" rel="noopener">‘看板实施细则’</a>, 所以任务管理这一块也算小有心得吧.</p><p>说说一些比较好用的工具吧：</p><ul><li><strong>基于issue看板</strong> - 可以基于Gitlab或Github的Issue来做任务管理，它们都支持看板。很Geek，推荐</li><li><a href="https://tower.im/" target="_blank" rel="noopener"><strong>Tower</strong></a> - 专门做看板任务管理的。小团队基本够用。我们现在就使用这款产品</li><li><a href="https://www.teambition.com/" target="_blank" rel="noopener"><strong>teambition</strong></a> - 和Tower差不多，没有深入使用过</li><li><a href="https://trello.com/" target="_blank" rel="noopener"><strong>Trello</strong></a> - 颜值高.</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="2-技术栈规范"><a href="#2-技术栈规范" class="headerlink" title="2 技术栈规范"></a>2 技术栈规范</h2><p>笔者现在所在的公司之前前端技术栈就非常混乱，Vue、React和AngularJS三大框架都有, 而且风格相差也很大. 当时我就想收包裹走人. 关于技术栈不规范的下场可以参考印度的飞机: <a href="https://www.zhihu.com/question/26042167/answer/690035402" target="_blank" rel="noopener">&lt;为什么印度的飞机频繁被摔？&gt;</a></p><p>很少有人能精通这三个框架的，更别说是一个团队。</p><p><strong>三大框架跟编程语言一样都有自己的设计哲学，这跟库是不一样, 一个库的替换成本很低；而框架的背后是一个架构、一个生态。每个框架背后牵涉着开发思维、生态系统、配套工具、最佳实践、性能调优。要精通和熟练一个框架需要付出的成本是很高</strong>。</p><p><strong>所以说团队的开发效率是基于稳定且熟练的技术栈的</strong>。稳定的技术栈规范有利于团队协作和沟通; 另外如果团队精通这个技术栈，当出现问题或者需要深入调优, 会相对轻松。</p><p>前端技术栈规范主要包含下面这些类型:</p><ul><li>编程语言 - Typescript或Javascript</li><li>UI框架及其配套生态, 以及备选方案。其背后的生态非常庞大:<ul><li>UI框架</li><li>路由</li><li>状态管理</li><li>组件库</li><li>国际化</li><li>动画</li><li>服务端渲染</li><li>脚手架、CLI工具</li><li>组件测试</li></ul></li><li>样式. 包含了命名规范、预处理器、方法论等等</li><li>动画引擎</li><li>QA. 包含了测试、Lint、格式化工具、监控</li><li>项目构建工具流. 例如webpack、vue-cli</li><li>包管理器。npm、yarn</li><li>项目管理工具</li><li>时间处理。例如Moment.js</li><li>模板引擎</li><li>开发工具</li><li>后端开发框架</li><li>工具库</li><li>开发/调试工具</li><li>等等</li></ul><p>可以参考一下我们团队的<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/tech-stack.md" target="_blank" rel="noopener">技术栈规范</a></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="2-1-技术选型"><a href="#2-1-技术选型" class="headerlink" title="2.1 技术选型"></a>2.1 技术选型</h3><p><a id="tech-select"></a></p><p><strong>如何从零对团队的技术栈进行规范, 或者说怎么进行选型呢</strong>？举个例子, 先确定备选项, 你现在要选Vue还是选React(一个可能引起论战的主题)？</p><p>恰好前几天在SegmentFault回答了一个问题: <a href="https://segmentfault.com/q/1010000019762657/a-1020000019775888" target="_blank" rel="noopener">&lt;什么时候用vue什么时候用react？&gt;</a>, 我讲了一个我们<strong>几年前</strong>是如何决定要使用React还是Vue的例子(注意结果不重要！)：</p><p><img src="/images/frontend-standard/vue-vs-react.png" alt></p><p><br></p><p><a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a>这篇文章写得非常好，给了我一些启发。结合上面的回答的例子, 来讲一讲在对相关技术进行选型的一些方法(评分项):</p><ul><li><p><strong>选择你最熟悉的技术</strong>。上面说到团队如果熟悉该技术，则可以很好地控制使用过程中的风险，方便对程序进行调优。所以成员熟悉、或至少Leader熟悉程度，是技术选型的一个打分项。</p><p>我们团队最终选择React的一个原因，就是我们熟悉它，它已经在现有的几个应用中良好的运行了，所以 React + 1</p></li><li><p><strong>选择拥有强大生态和社区支撑的开源技术</strong>。有强大的生态和社区意味着，很多东西你不需要重复去造轮子，或者遇到问题可以很快解决，有更多的选择。从公司层面、使用活跃的技术也比较好招人。</p><p>上面的例子也提到了这点，几年前React的生态是强于Vue的，所以 React + 1</p></li><li><p><strong>选择成长期的技术</strong>。<a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a>里面有一句话：’选择一个技术的最低标准是，技术的生命周期必须显著长于项目的生命周期’</p><p> 我们选择的技术应该是向前发展的、面向未来的, 这是选型的基本原则。所以我们一般不会去选择那些’过气’的技术，比如<code>AngularJS</code>(1.x)、<code>Backbone</code>. 因为现在有更好的选择，不必过于保守。</p><p> ‘向前’还意味着Leader要能够预判该技术未来走向，这里有很多参考因素，比如大厂的支撑、目前社区的活跃度、开发活跃度等等</p><p> React、Vue都非常有动力，比如React最近的React Hook、还有未来的ConcurrentMode、Async Rendering… 在这点上Vue和React打成平手吧</p></li><li><p><strong>API的稳定性</strong>。比较典型的例子就是Angular和Python，API不稳定会导致社区的割裂，也会导致项目升级成本变高、或者无法升级, 最终成为技术债。</p><p>不过值得庆幸的是因为有这么多历史教训，现在开源项目在API变更上面是非常谨慎的，参考<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">[译] Vue 最黑暗的一天</a>事件. </p><p>这点上React和Vue依旧打平</p></li><li><p><strong>基础设施配合</strong>。一个技术往往不是孤立存在的，它需要和其他技术相互配合，这种技术之间的融合度也是需要考虑的。</p><p>这个根据团队使用情况来定，比如我们团队统一使用Typescript，Vue跟Typescript配合使用其实不理想，所以 React + 1</p></li><li><p><strong>业务考虑</strong> <a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a> 提到一点就是‘学会从业务端开始思考’. 意思<strong>就是选型需要充分地理解业务，理解用户需求，当下需要解决的首要问题，以及可能的风险有哪些，再将目标进行分解，进行具体的技术选型、模型设计、架构设计</strong>.</p><p>一个典型的例子就是10年前火遍世界的<code>Rails</code>, 后端是使用Rails还是Java/C#/PHP这些传统后端技术? 很多初创公司(如Github、Gitlab、Twitter)选择了前者，他们需要快速开发原型、快速占领市场, Rails开发很爽很快啊, 这种选型就是符合‘业务需求的’。</p><p>那么前端好像跟业务离得有点远? 随着‘大前端’的发展，我们的工作对公司业务的影响只会越来越大。</p><p>比如上面提到的React Native，我们当时有考虑在移动端应用React Native技术，实现客户端的跨平台，这就是业务影响啊。这时候React是不是又要 +1? 同理还有什么服务端渲染、Serverless等等，期待前端的地位会越来越高</p></li></ul><p>综上，在这个案例中，React是胜出的。</p><p>扩展:</p><ul><li><a href="https://www.infoq.cn/article/2017/02/Technology-selection" target="_blank" rel="noopener">谈谈技术选型</a></li><li><a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">谈谈技术选型的注意事项</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="2-2-迎接新技术"><a href="#2-2-迎接新技术" class="headerlink" title="2.2 迎接新技术"></a>2.2 迎接新技术</h3><p>当然，对于团队而言也要鼓励学习新的技术、淘汰旧的技术栈。因为一般而言新的技术或解决方案，是为了更高的生产力而诞生的。<strong>当团队容纳一个新的技术选型需要考虑以下几点</strong>：</p><ul><li><strong>学习成本</strong>。考虑团队成员的接纳能力。如果成本小于收获的利益，在团队里面推行估计阻力会比较大</li><li><strong>收益</strong>。是否能够解决当前的某些痛点</li><li><strong>考虑风险</strong>。一般我们不能将一个实验阶段的技术使用的生产环境中</li></ul><p>就我们团队而言，每个成员都有自己感兴趣的方向和领域，所以我们可以分工合作，探索各自的领域，再将成果分享出来，如果靠谱的话则可以在实验项目中先试验一下，最后才推广到其他项目.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="3-浏览器兼容规范"><a href="#3-浏览器兼容规范" class="headerlink" title="3 浏览器兼容规范"></a>3 浏览器兼容规范</h2><p>前端团队应该根据针对应用所面对的用户情况、应用类型、开发成本、浏览器市场统计数据等因素，来制定自己的浏览器兼容规范，并写入应用使用手册中.</p><p><strong>有了浏览器兼容规范，前端开发和兼容性测试就有理有据，避免争议; 同时它也是前端团队的一种对外声明，除非特殊要求，不符合浏览器兼容规范的浏览器，前端开发人员可以选择忽略</strong>。</p><p><br></p><h3 id="3-1-确定兼容策略"><a href="#3-1-确定兼容策略" class="headerlink" title="3.1 确定兼容策略"></a>3.1 确定兼容策略</h3><p><img src="/images/frontend-standard/g-p.jpg" alt></p><p><strong>渐进增强</strong>还是<strong>优雅降级</strong>. 这是两个不同方向策略，<strong>渐进增强保证低版本浏览器的体验，对于支持新特性的新浏览器提供稍好的体验</strong>；<strong>优雅降级则是相反的，为现代浏览器提供最好的体验，而旧浏览器则退而求之次，保证大概的功能</strong>.</p><p>选择不同的策略对前端开发的影响是比较大的，但是开发者没有选择权。<strong>确定哪种兼容策略，应该取决于用户比重，如果大部分用户使用的是现代浏览器，就应该使用优雅降级，反之选择渐进增强</strong>.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="3-2-确定浏览器分级"><a href="#3-2-确定浏览器分级" class="headerlink" title="3.2 确定浏览器分级"></a>3.2 确定浏览器分级</h3><p><img src="/images/frontend-standard/brw-levl.gif" alt></p><p>YUI就曾提出浏览器分级原则，到今天这个原则依然适用。简单说就是将浏览器划分为多个等级，不同等级表示不同的支持程度. 比如我们团队就将浏览器划分为以下<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/browser-compatibility.md" target="_blank" rel="noopener">三个等级</a>:</p><ul><li><strong>完全兼容</strong>: 保证百分百功能正常</li><li><strong>部分兼容</strong>: 只能保证功能、样式与需求大致一致。对于一些不影响主体需求和功能的bug，会做降低优先级处理或者不处理。</li><li><strong>不兼容</strong>: 不考虑兼容性</li></ul><p>一般而言, 根据浏览器市场分布情况、用户占比、开发成本等因素划分等级.</p><p>举个例子，下面是我们对管理系统的兼容规范:</p><p><img src="/images/frontend-standard/cpt.png" alt></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="3-3-获取统计数据"><a href="#3-3-获取统计数据" class="headerlink" title="3.3 获取统计数据"></a>3.3 获取统计数据</h3><p><a id="brw-anly"></a></p><p><img src="/images/frontend-standard/bdtj.png" alt></p><p><br></p><p><a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>是中文网站使用最为广泛的、免费的流量分析平台. 如上图，通过这些统计平台可以获取到终端真实的浏览器使用情况, 点击<a href="https://tongji.baidu.com/web/demo/visit/client?siteId=5503017" target="_blank" rel="noopener">查看示例</a>。</p><p>如果公司没有开发自己监控服务，还是建议使用这些免费的，有大厂支持的监控工具:</p><ul><li><a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a></li><li><a href="https://web.umeng.com/main.php?spm=a211g2.211692.0.0.3a437d23sjzEPv&amp;c=user&amp;a=index" target="_blank" rel="noopener">友盟</a></li><li><a href="https://analytics.google.com/analytics/web/" target="_blank" rel="noopener">Google Analytics</a> 需要kx上网</li></ul><p><br></p><p><strong>可以从这些地方获取通用的浏览器统计数据</strong>:</p><ul><li><a href="http://tongji.baidu.com/data/browser" target="_blank" rel="noopener">百度流量研究院</a>：主要提供国内浏览器统计</li><li><a href="http://gs.statcounter.com/" target="_blank" rel="noopener">statcounter</a>: 国际浏览器统计</li><li><a href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers" target="_blank" rel="noopener">浏览器发布年份统计</a></li></ul><p><br></p><p><strong>确定浏览器是否支持某个特性</strong>:</p><ul><li><a href="https://caniuse.com" target="_blank" rel="noopener">caniuse</a></li><li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="4-项目组织规范"><a href="#4-项目组织规范" class="headerlink" title="4 项目组织规范"></a>4 项目组织规范</h2><p>项目组织规范定义了如何组织一个前端项目, 例如项目的命名、项目的文件结构、版本号规范等等。尤其对于开源项目，规范化的项目组织就更重要了。</p><h3 id="4-1-通用的项目组织规范"><a href="#4-1-通用的项目组织规范" class="headerlink" title="4.1 通用的项目组织规范"></a>4.1 通用的项目组织规范</h3><p>一个典型的项目组织规范如下:</p><ul><li><strong>README.md</strong>: 项目说明, 这个是最重要。你必须在这里提供关于项目的关键信息或者相关信息的入口. 一般包含下列信息:<ul><li>简要描述、项目主要特性</li><li>运行环境/依赖、安装和构建、测试指南</li><li>简单示例代码</li><li>文档或文档入口, 其他版本或相关资源入口</li><li>联系方式、讨论群</li><li>许可、贡献/开发指南</li></ul></li><li><strong>CHANGELOG.md</strong>: 放置每个版本的变动内容, 通常要描述每个版本变更的内容。方便使用者确定应该使用哪个版本. 关于CHANGELOG的规范可以参考<a href="https://keepachangelog.com/en/1.0.0/" target="_blank" rel="noopener">keep a changelog</a></li><li><strong>package.json</strong>: 前端项目必须. 描述当前的版本、<strong>可用的命令</strong>、包名、依赖、环境约束、项目配置等信息.</li><li><strong>.gitignore</strong>: 忽略不必要的文件，避免将自动生成的文件提交到版本库</li><li><strong>.gitattributes</strong>: git配置，有一些跨平台差异的行为可能需要在这里配置一下，如换行规则</li><li><strong>docs/</strong>: 项目的细化文档, 可选.</li><li><strong>examples/</strong>: 项目的示例代码，可选.</li><li><strong>build</strong>: 项目工具类脚本放置在这里，非必须。如果使用统一构建工具，则没有这个目录</li><li><strong>dist/</strong>: 项目构建结果输出目录</li><li><strong>src/</strong>: 源代码目录</li><li><p><strong><strong>tests</strong>/</strong>: 单元测试目录. 按照<a href="http://jestjs.io" target="_blank" rel="noopener">Jest</a>规范, <code>__tests__</code>目录通常和被测试的模块在同一个父目录下, 例如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/src</span><br><span class="line">  __tests__/</span><br><span class="line">    index.ts</span><br><span class="line">    a.ts</span><br><span class="line">  index.ts</span><br><span class="line">  a.ts</span><br></pre></td></tr></table></figure></li><li><p><strong>tests</strong>: 全局的测试目录，通常放应用的集成测试或E2E测试等用例</p></li><li><p><strong>.env*</strong>: 项目中我们通常会使用<code>环境变量</code>来影响应用在不同运行环境下的行为. 可以通过<a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotEnv</a>来从文件中读取环境变量. 通常有三个文件:</p><ul><li><code>.env</code> 通用的环境变量</li><li><code>.env.development</code> 开发环境的环境变量</li><li><code>.env.production</code> 生成环境的环境变量</li></ul><p>基本上这些文件的变动的频率很少，团队成员应该不要随意变动，以免影响其他成员。所以通常会使用<code>.env.*.local</code>文件来覆盖上述的配置, 另外会设置版本库来忽略<code>*.local</code>文件.</p></li></ul><p><br></p><p><strong>对于开源项目通常还包括这些目录</strong>:</p><ul><li><strong>LICENSE</strong>: 说明项目许可</li><li><strong>.github</strong>: 开源贡献规范和指南<ul><li>CONTRIBUTING: 贡献指南, 这里一般会说明贡献的规范、以及项目的基本组织、架构等信息</li><li>CODE_OF_CONDUCT: 行为准则</li><li>COMMIT_CONVENTION: 提交信息规范，上文已经提及</li><li>ISSUE_TEMPLATE: Issue的模板，github可以自动识别这个模板</li><li>PULL_REQUEST_TEMPLATE: PR模板</li></ul></li></ul><p>任意一个优秀的开源项目都是你的老师，例如<a href="https://github.com/facebook/react" target="_blank" rel="noopener">React</a>、<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue</a>…</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="4-2-目录组织的风格"><a href="#4-2-目录组织的风格" class="headerlink" title="4.2 目录组织的风格"></a>4.2 目录组织的风格</h3><p>上面只是一个通用的项目组织规范，具体源代码如何组织还取决于你们使用的技术栈和团队喜好。网上有很多教程，具体可以搜索<code>怎么组织XX项目</code>. 总结一下项目组织主要有三种风格:</p><ul><li><p><strong>Rails-style</strong>: 按照文件的类型划分为不同的目录，例如<code>components</code>、<code>constants</code>、 <code>typings</code>、<code>views</code>. 这个来源于Ruby-on-Rails框架，它按照MVC架构来划分不同的目录类型，典型的目录结构如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  models # 模型</span><br><span class="line">  views # 视图</span><br><span class="line">  controllers # 控制器</span><br><span class="line">  helpers # 帮助程序</span><br><span class="line">  assets  # 静态资源</span><br><span class="line">config     # 配置</span><br><span class="line">  application.rb</span><br><span class="line">  database.yml</span><br><span class="line">  routes.rb      # 路由控制</span><br><span class="line">  locales        # 国际化配置</span><br><span class="line">  environments/</span><br><span class="line">db        # 数据库相关</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>Domain-style</strong>:  按照一个功能特性或业务创建单独的目录，这个目录就近包含多种类型的文件或目录. 比如一个典型的Redux项目，所有项目的文件就近放置在同一个目录下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Users/</span><br><span class="line">Home/</span><br><span class="line">  components/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  constants.js</span><br><span class="line">  index.js</span><br><span class="line">  model.js</span><br><span class="line">  reducer.js</span><br><span class="line">  selectors.js</span><br><span class="line">  style.css</span><br><span class="line">index.js</span><br><span class="line">rootReducer.js</span><br></pre></td></tr></table></figure></li><li><p><strong>Ducks-style</strong>: 优点类似于Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下。Vue的单文件组件就是一个典型的例子，除此之外Vuex也是使用这种风格:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;My Todo App!&lt;/h1&gt;</span><br><span class="line">    &lt;TodoList/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import TodoList from &apos;./components/TodoList.vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    TodoList</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">@import &apos;./variables.scss&apos;;</span><br><span class="line">/* ... */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>大部分情况下, 我们都是使用混合两种方式的目录结构，例如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/      # 🔴 项目通用的‘展示组件’</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx    # 组件的入口, 导出组件</span><br><span class="line">      Groups.tsx   # 子组件</span><br><span class="line">      loading.svg  # 静态资源</span><br><span class="line">      style.css    # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts       # 到处所有组件</span><br><span class="line">  containers/      # 🔴 包含'容器组件'和'页面组件'</span><br><span class="line">    LoginPage/     # 页面组件, 例如登录</span><br><span class="line">      components/  # 页面级别展示组件，这些组件不能复用与其他页面组件。</span><br><span class="line">        Button.tsx # 组件未必是一个目录形式，对于一个简单组件可以是一个单文件形式. 但还是推荐使用目录，方便扩展</span><br><span class="line">        Panel.tsx</span><br><span class="line">      reducer.ts   # redux reduces</span><br><span class="line">      useLogin.ts  # (可选)放置'逻辑', 按照👆分离逻辑和视图的原则，将逻辑、状态处理抽取到hook文件</span><br><span class="line">      types.ts     # typescript 类型声明</span><br><span class="line">      style.css</span><br><span class="line">      logo.png</span><br><span class="line">      message.ts</span><br><span class="line">      constants.ts</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx      # 🔴应用根组件</span><br><span class="line">  hooks/           # 🔴可复用的hook</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.tsx        # 应用入口, 在这里使用ReactDOM对跟组件进行渲染</span><br><span class="line">  stores.ts        # redux stores</span><br><span class="line">  contants.ts      # 全局常量</span><br></pre></td></tr></table></figure><p><br></p><p>框架官方很少会去干预项目的组织方式，读者可以参考下面这些资源来建立自己项目组织规范:</p><ul><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fcn.redux.js.org%2Fdocs%2Ffaq%2FCodeStructure.html" target="_blank" rel="noopener">Redux 常见问题：代码结构</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Freact-boilerplate%2Freact-boilerplate" target="_blank" rel="noopener">react-boilerplate</a></li><li><a href="https://vuex.vuejs.org/zh/guide/structure.html" target="_blank" rel="noopener">vuex 项目结构</a></li><li><a href="https://juejin.im/post/5cd8fb916fb9a03218556fc1#heading-11" target="_blank" rel="noopener">React组件设计实践总结02 - 组件的组织</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="4-3-脚手架和项目模板"><a href="#4-3-脚手架和项目模板" class="headerlink" title="4.3 脚手架和项目模板"></a>4.3 脚手架和项目模板</h3><p>在将项目结构规范确定下来后，可以创建自己的脚手架工具或者项目模板，用于快速初始化一个项目或代码模板。</p><p>相关资源:</p><ul><li><a href="https://yeoman.io" target="_blank" rel="noopener">yeoman</a> - 老牌的项目脚手架工具</li><li><a href="https://github.com/amwmedia/plop" target="_blank" rel="noopener">plop</a> - 代码生成辅助CLI</li><li><a href="https://github.com/jondot/hygen" target="_blank" rel="noopener">hygen</a> - 类似于plop</li><li><a href="https://github.com/diegohaz/generact" target="_blank" rel="noopener">generact</a> - 生成React组件, 大部分组件的文件结构差不多, 这个工具就是帮助你生成这些重复的代码</li><li><a href="https://babeljs.io/docs/en/babel-generator" target="_blank" rel="noopener">babel-code-generator</a> - 利用babel来实现更高级的代码编辑和自动生成</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="5-编码规范"><a href="#5-编码规范" class="headerlink" title="5 编码规范"></a>5 编码规范</h2><p>网络上大部分‘前端规范’指的都是编码规范, 这是一种‘狭义’的前端规范. </p><p><strong>统一的编码规范对团队项目的长远维护不无裨益. 一致性的代码规范可以增强团队开发协作效率、提高代码质量、减少遗留系统维护的负担</strong>。</p><p>最直接的好处就是避免写出糟糕的代码, 糟糕的代码与新手和老手关系不大，我也见过好处工作很多年的‘资深’工程师写出恶心的代码. 这样的代码随着项目的迭代会变得难以控制。</p><p><strong>现代的Lint工具已经非常先进，几乎可以约束各种编码行为</strong>. 比如约束一个文件的长度、函数的复杂度、命名规范、注释规范、接口黑名单、DeadCode、检查简单的逻辑错误…</p><p>每一个程序员心目中对‘好代码’都有自己的主见，统一的编码规范可以像秦始皇统一战国一样，避免不必要的论战和争议。</p><p><br></p><p><strong>其实与其自己建立前端编码规范，笔者推荐选择社区沉淀下来的规范</strong>. 这方面的资源非常多，所以本文也不武断地提出自己的规范建议. 推荐下面这些资源:</p><p><br></p><h3 id="5-1-javascript"><a href="#5-1-javascript" class="headerlink" title="5.1 Javascript"></a>5.1 Javascript</h3><ul><li>Lint工具<ul><li><a href="https://cn.eslint.org" target="_blank" rel="noopener">ESLint</a> - 🔥目前是社区最流行的、通用的Javascript Lint工具，Lint界的Babel。支持定制插件、preset。如果不想折腾可以选择它的一些预定义配置</li><li><a href="https://github.com/palantir/tslint" target="_blank" rel="noopener">TSLint</a> - Typescript Lint工具。不过即将<a href="https://github.com/palantir/tslint/issues/4534" target="_blank" rel="noopener">废弃</a>了, 推荐使用ESLint</li></ul></li><li>规范<ul><li><a href="https://standardjs.com/readme-zhcn.html#why-should-i-use-javascript-standard-style" target="_blank" rel="noopener">JavaScript Standard Style</a> - 🔥 零配置的、‘标准’的Javascript编码规范. 底层基于Eslint。目前不支持Typescript</li><li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb JavaScript Style Guide</a> - Airbnb的编码规范，业界标杆</li></ul></li><li>类型检查. 暂时将它们归类到这里，因为它们同属于<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe#heading-39" target="_blank" rel="noopener">‘静态测试’</a><ul><li><a href="https://www.typescriptlang.org" target="_blank" rel="noopener">Typescript</a> - 🔥 Javascript语言的超集，这是一门‘新’的语言，而不是简单的类型检查器. 不过<strong>它也支持<a href="https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html" target="_blank" rel="noopener">原生Javascript的类型检查</a></strong></li><li><a href="https://flow.org" target="_blank" rel="noopener">Flow</a> - Facebook出品的类型检查器，语法和Typescript类似. 个人推荐使用Typescript</li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-2-html"><a href="#5-2-html" class="headerlink" title="5.2 HTML"></a>5.2 HTML</h3><ul><li>Lint工具<ul><li><a href="https://htmlhint.io" target="_blank" rel="noopener">HTMLHint</a></li><li><a href="https://github.com/twbs/bootlint" target="_blank" rel="noopener">bootlint</a></li></ul></li><li>规范<ul><li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-3-css"><a href="#5-3-css" class="headerlink" title="5.3 CSS"></a>5.3 CSS</h3><ul><li>Lint工具<ul><li><a href="https://stylelint.docschina.org" target="_blank" rel="noopener">stylelint</a> - 🔥 通用的CSS编码检查工具，支持最新的CSS语法、CSS-in-js、以及其他类CSS语法(如SCSS、Less). 它也有预定义配置，推荐使用</li></ul></li><li>规范<ul><li><a href="https://github.com/airbnb/css" target="_blank" rel="noopener">Airbnb CSS / Sass Styleguide</a></li><li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li><li><a href="https://css-tricks.com/css-style-guides/" target="_blank" rel="noopener">更多</a></li></ul></li><li>方法论<ul><li><a href="https://css-tricks.com/bem-101/" target="_blank" rel="noopener">BEM</a> - 🔥 BEM命名规范</li><li><a href="https://github.com/stubbornella/oocss/wiki" target="_blank" rel="noopener">OOCSS</a></li><li><a href="http://smacss.com" target="_blank" rel="noopener">smacss</a></li></ul></li></ul><p><br></p><p>关于CSS可以学习<a href="http://twitter.github.com/bootstrap/" target="_blank" rel="noopener">Bootstrap</a>这些传统UI框架，他们的代码组织性非常好, 值得学习</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-4-代码格式化"><a href="#5-4-代码格式化" class="headerlink" title="5.4 代码格式化"></a>5.4 代码格式化</h3><p><img src="/images/frontend-standard/prt.png" alt></p><ul><li><a href="https://prettier.io" target="_blank" rel="noopener">Prettier</a> - 🔥 关于代码格式化的所有东西都交给它吧！</li></ul><p>基本上，所有代码格式相关的工作都可以交给Prettier来做，在这个基础上再使用Eslint覆盖语义相关的检查</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-5-集大成的"><a href="#5-5-集大成的" class="headerlink" title="5.5 集大成的"></a>5.5 集大成的</h3><ul><li><a href="https://coderlmn.github.io/code-standards/#_code_reviews" target="_blank" rel="noopener">isobar 前端代码规范及最佳实践</a></li><li><a href="https://guide.aotu.io/index.html" target="_blank" rel="noopener">凹凸实验室代码规范</a></li><li><a href="https://github.com/fex-team/styleguide" target="_blank" rel="noopener">百度FEX规范</a></li><li><a href="http://nec.netease.com/standard" target="_blank" rel="noopener">老牌的NEC规范</a> - 有点老</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-6-特定框架风格指南"><a href="#5-6-特定框架风格指南" class="headerlink" title="5.6 特定框架风格指南"></a>5.6 特定框架风格指南</h3><ul><li><a href="https://vue.docschina.org/v2/style-guide/" target="_blank" rel="noopener">vue-style-guide</a></li><li><a href="https://github.com/airbnb/javascript/tree/master/react" target="_blank" rel="noopener">Airbnb React/JSX Style Guide</a></li><li><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715" target="_blank" rel="noopener">React组件设计实践总结</a> - 自荐一下笔者写的React组件设计相关实践</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-7-code-review"><a href="#5-7-code-review" class="headerlink" title="5.7 Code Review"></a>5.7 Code Review</h3><p><img src="/images/frontend-standard/code-review.png" alt></p><p>上述的Lint工具和类型检查器, 可以约束代码风格、避免低级的语法错误。但是即使通过上面的Lint和类型检查，代码也可能未必是‘好代码’。</p><p><strong>很多代码设计的‘最佳实践’是无法通过具象化的自动化工具或文档覆盖的, 这时候，’经验’或者’群体智慧’就派上用场了</strong>. 比如Code Review阶段会检查这些东西:</p><ul><li>编程原则、设计思想. 例如符合SOLID原则? 是否足够DRY？接口设计是否简洁易扩展、</li><li>模块耦合程度、代码重复</li><li>代码健壮性。是否存在内存泄露、是否线程安全、是否有潜在性能问题和异常、错误是否被处理</li><li>代码的性能和效率。</li><li>是否有没有考虑到的场景？</li></ul><p>如果你们是第一次推行Code Review, 可以建立一个检查列表，对照着进行检查。熟练后，心中自然无码。</p><p><br></p><p>Code Review有很多好处，比如：</p><ul><li><strong>Code Review可以让其他成员都熟悉代码</strong>。这样保证其他人都可以较快地接手你的工作，或者帮你解决某些问题</li><li><strong>提高代码质量</strong>。毫无疑问. 一方面是<em>主动性</em>的代码质量提升，比如你的代码需要被人Review，会自觉尽量的提高代码质量；另一方面，其他成员可以检查提交方的代码质量</li><li><strong>检查或提高新成员的编程水平</strong>。培养新人时，由于不信任它们提交的代码，我们会做一次Review检查代码是否过关。另一方面这是一次真实的案例讲解, 可以较快提高他们的能力</li></ul><p><br></p><p><strong>Code Review有两种方式: 一个<code>提交时</code>、一个是<code>定时</code></strong>:</p><ul><li><code>提交时</code>. 大部分开源项目采用这种方式。通俗讲就是Pull Request。只有代码通过测试、和其他成员的Review才可以合进正式版本库。这种方式也称为‘阻塞式’代码检查，一般配合GitFlow使用。</li><li><code>定时</code>. 在项目完结后、项目的某个里程碑、或者固定的时间(每天、每个星期..). 团队成员聚在一起，回顾自己写的代码, 让其他成员进行审查</li></ul><p>Code Review是比较难以推行的，不过这个也要看你们团队的情况，向我们钱少活多的团队，很少的时间去立马去兼顾其他成员的代码. 这时候<code>定时Review</code>会更有用，因为看起来更‘节省时间’.</p><p>而<code>提交时Review</code>则可以针对新人，比如你不信任他们的代码或者希望帮助他们提高编码能力。</p><p><br></p><p><strong>相关资源</strong>:</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTQwNTA3Nw==&amp;mid=400946871&amp;idx=1&amp;sn=5a125337833768d705f9d87ba8cd9fff&amp;scene=1&amp;srcid=0104FLyeXIS6N0EShgDseIfI&amp;key=41ecb04b051110031290b34976240e650f0169d239c89f125162a89c8d3412f2087198612e71fd7685cae9eebe08e295&amp;ascene=0&amp;uin=MTYyMDMzMTAwMA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C5+OSX+OSX+10.10.5+build(14F1509" target="_blank" rel="noopener">Code Review最佳实践</a>&amp;version=11020201&amp;pass_ticket=dc5bBckt1XSthRKTIsukYHIcAvKfv0jninbMlYQ5TWnE6XS%2FrRkdHKlJjNTI2Wsg)</li><li><a href="https://juejin.im/post/5c9740ba6fb9a071090d6a37" target="_blank" rel="noopener">是否要做Code Review？与BAT资深架构师争论之后的思考</a></li><li><a href="https://richardcao.me/2016/09/30/Talk-About-Codereview/" target="_blank" rel="noopener">一些Code Review工具</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="6-文档规范"><a href="#6-文档规范" class="headerlink" title="6 文档规范"></a>6 文档规范</h2><p>文档对于项目开发和维护、学习、重构、以及知识管理非常重要。</p><p>和写测试一样、大部分开发人员会觉得写文档是一件痛苦的事情，不过只有时间能够证明它的价值。比如对于人员流动比较大的公司，如果有规范的文档体系，转交工作就会变动非常轻松.</p><p><strong>广义的文档不单指‘说明文件’本身，它有很多形式、来源和载体，可以描述一个知识、以及知识形成和迭代的过程</strong>。例如版本库代码提交记录、代码注释、决策和讨论记录、CHANGELOG、示例代码、规范、传统文档等等</p><p><br></p><h3 id="6-1-建立文档中心"><a href="#6-1-建立文档中心" class="headerlink" title="6.1 建立文档中心"></a>6.1 建立文档中心</h3><p>我们公司是做IM的，所以之前我们优先使用’自己的’通讯工具来分享文档，这种方式有很大问题:</p><ol><li>如果没有存档习惯(比如后端的API文档，因为由后端维护，一般不会主动去存档), 文档就可能丢失，而且通讯工具是不会永久保存你的文档的。当丢失文件就需要重新和文档维护者索要</li><li>糟糕的是文档维护者也是自己手动在本地存档的，这样导致的问题是: 如果工作转交，其他开发者需要花费一点时间来查找; 丢失了就真的没了</li><li>每一次文档更新要重新发一份, 这很麻烦，而且可能出现漏发的情况, 导致前后不一致.</li><li>关于知识的学习、以及有意义的讨论记录无法归档。</li></ol><p>上面介绍的是一种非常原始的文档共享方式，很多小团队就是这么干的。</p><p><strong>对于项目本身的文档建议放置在关联项目版本库里面，跟随项目代码进行迭代, 当我们在检索或跟踪文档的历史记录时，这种方式是最方便的</strong>。</p><p>然而很多应用是跨越多个团队的，每个团队都会有自己的文档输出(比如需求文档、系统设计文档、API文档、配置文档等等)，而且通常也不会在一个版本库里。这时候文档就比较分散。所以一个统一的文档中心是很有必要。</p><p>我们公司现在选择的方案是<code>Git+Markdown</code>，也就是说所有的文档都放置在一个git版本库下。之前也考虑过商业的方案，譬如<a href="https://shimo.im/welcome" target="_blank" rel="noopener">石墨文档</a>、<a href="https://docs.qq.com" target="_blank" rel="noopener">腾讯文档</a>, 但管理层并不信任这些服务。</p><p>大概的git项目组织如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">规范/</span><br><span class="line">A应用/</span><br><span class="line">  产品/</span><br><span class="line">  设计/</span><br><span class="line">  API文档/</span><br><span class="line">  测试/</span><br><span class="line">  其他/</span><br><span class="line">B应用/</span><br></pre></td></tr></table></figure><p><strong>Git版本库(例如Gitlab)有很多优势，例如历史记录跟踪、版本化、问题讨论(可以关联issue、或者提交)、多人协作、搜索、权限管理(针对不同的版本库或分组为不同人员设置权限)等等</strong>。</p><p><code>Git+Markdown</code>可以满足开发者的大部分需求。但是<strong>Git最擅长的是处理纯文本文件、对于二进制是无能为力的，无法针对这些类型的文档进行在线预览和编辑</strong>。</p><p>所以<code>Git+Markdown</code>并不能满足多样化的文档处理需求，比如思维导图、图表、表格、PPT、白板等需求. 毕竟它不是专业的文档处理工具。所以对于产品、设计人员这些富文档需求场景，通常会按照传统方式或者更专业的工具对文档进行管理.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-2-文档格式"><a href="#6-2-文档格式" class="headerlink" title="6.2 文档格式"></a>6.2 文档格式</h3><p>毫无疑问，对于开发者来说，<a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown</a>是最适合的、最通用的文档格式。支持版本库在线预览和变更历史跟踪。</p><p>下面这些工具可以提高Markdown的开发效率:</p><ul><li>可视化编辑器<ul><li><strong>Visual Code</strong>: 大部分代码编辑都支持Markdown编辑和预览</li><li><a href="https://link.jianshu.com/?t=http://mouapp.com/" target="_blank" rel="noopener"><strong>Mou</strong></a>: Mac下的老牌编辑器</li><li><a href="https://typora.io" target="_blank" rel="noopener"><strong>typora</strong></a>: 跨平台的Markdown编辑器，推荐</li></ul></li><li><strong>markdownlint</strong>: 编码检查器</li><li>扩展(Visual Studio Code):<ul><li><strong>Markdown All in One</strong>: All you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more)</li><li><strong>Markdown TOC</strong>: markdown 目录生成，我最常用的markdown插件</li></ul></li><li>图表绘制工具:<ul><li><a href="https://www.draw.io" target="_blank" rel="noopener"><strong>drawio</strong></a> 基于Web的图表绘制工具、也有离线客户端</li><li><strong>KeyNote/PPT</strong> 临时绘图也不错</li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-3-定义文档的模板"><a href="#6-3-定义文档的模板" class="headerlink" title="6.3 定义文档的模板"></a>6.3 定义文档的模板</h3><p>关于如何写好文档，很难通过标准或规范来进行约束，因为它的主观性比较强, 好的文档取决于编辑者的逻辑总结能力、表达能力、以及有没有站在读者的角度去思考问题。</p><p>所以大部分情况下，我们可以为不同类型的文档提供一个模板，通过模板来说明一个文档需要包含哪些内容, 对文档的编写者进行引导.</p><p>例如一个API文档可能需要这些内容:</p><ul><li>接口的索引</li><li>接口的版本、变更记录</li><li>用法和整体描述, 认证鉴权等等</li><li>描述具体的接口<ul><li>功能说明</li><li>方法名称或者URI</li><li>参数和返回值定义</li><li>调用示例</li><li>注意事项等等</li></ul></li></ul><p>具体规范内容因团队而异，这里点到为止.</p><p><br></p><p>扩展:</p><ul><li><a href="https://github.com/ruanyf/document-style-guide/blob/master/docs/reference.md" target="_blank" rel="noopener">中文技术文档的写作规范</a></li><li><a href="https://github.com/reactjs/rfcs/blob/master/0000-template.md" target="_blank" rel="noopener">React RFC模板</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-4-讨论即文档"><a href="#6-4-讨论即文档" class="headerlink" title="6.4 讨论即文档"></a>6.4 讨论即文档</h3><p><strong>一般情况下，对于一个开源项目来说除了官方文档，Issues也是一个很重要的信息来源。在Issue中我们可以获取其他开发者遇到的问题和解决方案、给官方反馈/投票、关注官方的最新动态、和其他开发者头脑风暴唇枪舌战等等</strong>。</p><p>所以相对于使用IM，笔者更推荐Issue这种沟通模式，因为<strong>它方便归档组织，索引和查找</strong>。而IM上的讨论就像流水一样，一去不复返。</p><p>当然两种工具的适用场景不一样，你拿IM的使用方式来使用Issue，Issue就会变得很水。<strong>Issue适合做有意义的、目的明确的讨论</strong>。 所以要谴责一下在Github Issue上灌水的开发者。</p><p>关于Issue有很多妙用，推荐阅读这篇文章<a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" rel="noopener">&lt;如何使用 Issue 管理软件项目？&gt;</a></p><p>现在很多开源项目都引入了RFC(请求意见稿)流程(参考<a href="https://www.infoq.cn/article/2017/12/react-rfc-process" target="_blank" rel="noopener">React采用新的RFC流程</a>, 以及<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">Vue 最黑暗的一天</a>), 这让开发者有‘翻身农奴、当家做主’的感觉，任何人都可以参与到一个开源项目重大事件的决策之中。<strong>每个RFC会说明决策的动机、详细设计、优缺点。除了官方文档之外，这些RFC是很有价值的学习资料</strong>。</p><p>我觉得如果不涉及机密，团队应该要让更多人参与到项目的设计和决策中，对于新手可以学到很多东西，而对于发起者也可能有考虑不周的情况。</p><p>那对于企业应用开发, Issue有用吗?</p><p>当然有用, 比如我们可以将这类话题从IM转移到Issue:</p><ul><li>设计方案</li><li>决策/建议<ul><li>新功能、新技术引入</li><li>重构</li><li>性能优化</li><li>规范</li></ul></li><li>问题讨论</li><li>重大事件</li><li>计划或进度跟踪</li><li>…</li></ul><p><br></p><p>另外Issue通常通过标签来进行分类，方便组织和检索:</p><p><img src="/images/frontend-standard/issue.png" alt></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-5-注释即文档"><a href="#6-5-注释即文档" class="headerlink" title="6.5 注释即文档"></a>6.5 注释即文档</h3><p><strong>必要和适量的注释对阅读源代码的人来说就是一个路牌, 可以少走很多弯路</strong>.</p><p>关于注释的一些准则，<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6/%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6.md" target="_blank" rel="noopener">&lt;阿里巴巴Java开发手册&gt;</a>总结得非常好, 推荐基于这个来建立注释规范。另外通过ESlint是可以对注释进行一定程度的规范。</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-6-代码即文档"><a href="#6-6-代码即文档" class="headerlink" title="6.6 代码即文档"></a>6.6 代码即文档</h3><p>现在有很多种工具支持从代码中解析和生成文档, 这可以给开发者简化很多文档维护的工作。</p><p>举个例子，我们经常会遇到修改了代码，但是文档忘记同步的情况。通过‘代码即文档’的方式至少可以<strong>保持文档和代码同步更新</strong>；另外<strong>很多工具会分析代码的数据类型</strong>，自动帮我们生成参数和返回值定义，这也可以减少很多文档编写工作以及出错率。</p><p>比如可以通过下面注释方式来生成组件文档:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Props注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> interface ColumnProps extends React.HTMLAttributes&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">/** prop1 description */</span></span><br><span class="line">  prop1?: string;</span><br><span class="line">  <span class="comment">/** prop2 description */</span></span><br><span class="line">  prop2: number;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * prop3 description</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  prop3: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">/** prop4 description */</span></span><br><span class="line">  prop4: <span class="string">'option1'</span> | <span class="string">'option2'</span> | <span class="string">'option3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对组件进行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Column</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ColumnProps</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>相关的工具有:</p><ul><li>API文档<ul><li>Typescript<ul><li><a href="https://github.com/microsoft/tsdoc" target="_blank" rel="noopener">tsdoc</a> Typescript官方的注释文档标准</li><li><a href="https://github.com/TypeStrong/typedoc" target="_blank" rel="noopener">typedoc</a> 基于tsdoc标准的文档生成器</li></ul></li><li>Javascript<ul><li><a href="https://github.com/jsdoc/jsdoc" target="_blank" rel="noopener">jsdoc</a> Javascript文档注释标准和生成器</li></ul></li></ul></li><li>后端接口文档<ul><li><a href="https://swagger.io" target="_blank" rel="noopener">Swagger</a> Restful接口文档规范</li><li>GraphQL: 这个有很多工具，例如<a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener">graphiql</a>, 集成了Playground和文档，很先进</li><li><a href="https://easy-mock.com/login" target="_blank" rel="noopener">Easy Mock</a> 一个可视化，并且能快速生成模拟数据的服务</li></ul></li><li>组件文档<ul><li><a href="https://storybook.js.org" target="_blank" rel="noopener">StoryBook</a> 通用的组件开发、测试、文档工具</li><li>React<ul><li><a href="http://docz.site" target="_blank" rel="noopener">Docz</a></li><li><a href="https://github.com/styleguidist/react-styleguidist" target="_blank" rel="noopener">Styleguidist</a></li></ul></li><li>Vue<ul><li><a href="https://github.com/vue-styleguidist/vue-styleguidist" target="_blank" rel="noopener">vue-styleguidist</a></li><li>有更好的工具请评论告诉我</li></ul></li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="7-ui设计规范"><a href="#7-ui设计规范" class="headerlink" title="7 UI设计规范"></a>7 UI设计规范</h2><p><img src="/images/frontend-standard/ui-design.png" alt></p><p>这是一个容易被忽略的规范类型。笔者就深受其苦，我们公司初期UI并不专业，没有所谓的设计规范，这就导致他们设计出来的产品都是东借西凑，前后不统一，多个应用之间的组件不能复用。这搞得我们不得不浪费时间，写很多定制化样式和组件，为他们的不专业买单.</p><p>关于UI设计规范的重要性有兴趣的读者可以看这篇文章<a href="https://juejin.im/post/5b766ac56fb9a009aa154c27" target="_blank" rel="noopener">&lt;开发和设计沟通有多难？ - 你只差一个设计规范&gt;</a>. </p><p>简单总结一下UI设计规范的意义：</p><ul><li>提供团队协作效率(产品和开发)</li><li>提高组件的复用率. 统一的组件规范可以让组件更好管理</li><li>保持产品迭代过程中品牌一致性</li></ul><p>建立一个定义良好的设计规范需要<code>UI设计和开发</code>的紧密配合，有时候也可以由我们前端来推动。</p><p>比如很多开源的UI框架，一开始都是开发者YY出来的，并没有设计参与，后来组件库慢慢沉淀成型，UI设计师才介入规范一下。</p><p>如果你们团队不打算制定自己的UI设计规范，则推荐使用现成的开源组件库：</p><ul><li><a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant Design</a></li><li><a href="https://material-ui.com" target="_blank" rel="noopener">Material-UI</a></li><li><a href="https://element.eleme.io" target="_blank" rel="noopener">Element UI</a></li><li><a href="https://weui.io" target="_blank" rel="noopener">WeUI</a></li><li><a href="https://developer.microsoft.com/en-us/fabric#/" target="_blank" rel="noopener">Microsoft Fabric</a></li></ul><p>这些开源组件库都经过良好的设计和沉淀, 而且配套了完善的设计原则、最佳实践和设计资源文件（Sketch 和 Axure），可以帮助业务快速设计出高质量的产品原型。</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="8-测试规范"><a href="#8-测试规范" class="headerlink" title="8 测试规范"></a>8 测试规范</h2><p>测试是保障代码质量的重要手段，但是很少有人愿意在这里花太多时间。</p><p>比如笔者，我很少会去给业务代码和组件写单元测试，除非自己对代码非常没有信心，按照我的理念写测试不如将代码写得更简单一点，比如把一个函数拆分为更小的函数，保持单一职责。</p><p>但是<strong>对于一些底层、共享的代码模块还是有测试的必要的</strong>。</p><p>我在<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe" target="_blank" rel="noopener">不知道测试什么？这些是你需要知道的软件测试类型和常识</a>文章中，列举了一些开发者需要关注的测试类型和常识, 如果按照测试的阶段进行分类，大概是这样子的:</p><p><img src="/images/frontend-standard/testing.png" alt></p><p><br></p><p>其中前端开发者需要关注的主要有以下几种测试类型:</p><ul><li><strong>单元测试</strong>: 对独立的软件模块进行测试<ul><li><strong>UI组件测试</strong>: 包括了快照(Snapshot)测试</li></ul></li><li><strong>集成测试</strong>: 在单元测试的基础上，将模块组合起来，测试它们的组合性</li><li><strong>E2E测试</strong>: 在完整、真实的运行环境下模拟真实用户对应用进行测试。<strong>主要测试前端和后端的协调性</strong></li><li><strong>兼容性测试</strong>: 上面提到了浏览器兼容规范，在将版本提交给测试/发布之前，需要确保能符合兼容性要求</li><li><strong>性能测试</strong>: 测试和分析是否存在性能问题</li><li><strong>其他</strong>:<ul><li>安全测试</li><li>SEO测试</li></ul></li></ul><p>因为对于小公司来说整个软件开发流程可能没有那么规范，比如很难构建一个完整的端对端测试环境，这些都不是前端团队可以操作的范围, 所以自动化测试很难推行。但是可以根据团队和业务情况逐步进行开展。</p><p>可实施性比较高的, 也比较简单是单元测试，所以本文也重点关注单元测试.</p><p><br></p><h3 id="8-1-测试的流程"><a href="#8-1-测试的流程" class="headerlink" title="8.1 测试的流程"></a>8.1 测试的流程</h3><p>首先要定义一个合适的软件测试流程, 合适的测试流程可以降低开发和测试团队之间的沟通协作成本、提高测试效率。例如我们团队目前的测试流程:</p><p><img src="/images/frontend-standard/test-proc.png" alt></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="8-2-单元测试"><a href="#8-2-单元测试" class="headerlink" title="8.2 单元测试"></a>8.2 单元测试</h3><p>单元测试有很多<strong>好处</strong>, 比如:</p><ul><li><strong>提高信心，适应变化和迭代</strong>. 如果现有代码有较为完善的单元测试，在代码重构时，可以检验模块是否依然可以工作, 一旦变更导致错误，单元测试也可以帮助我们快速定位并修复错误</li><li><strong>单元测试是集成测试的基础</strong></li><li><strong>测试即文档</strong>。如果文档不能解决你的问题，在你打算看源码之前，可以查看单元测试。通过这些测试用例，开发人员可以直观地理解程序单元的基础API</li><li><strong>提升代码质量。易于测试的代码，一般都是好代码</strong></li></ul><p><br></p><p><strong>测什么?</strong></p><p>业务代码或业务组件是比较难以实施单元测试的，一方面它们比较多变、另一方面很多团队很少有精力维护这部分单元测试。所以<strong>通常只要求对一些基础/底层的组件、框架或者服务进行测试, 视情况考虑是否要测试业务代码</strong></p><p><br></p><p><strong>测试的准则</strong>:</p><ul><li>推荐Petroware的<a href="https://petroware.no/unittesting.html" target="_blank" rel="noopener">Unit Testing Guidelines</a>, 总结了27条单元测试准则，非常受用.</li><li>另外&lt;阿里巴巴的Java开发手册&gt;中总结的<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.md" target="_blank" rel="noopener">单元测试准则</a>, 也不错，虽然书名是Java，准则是通用的.</li></ul><p><br></p><p><strong>单元测试指标</strong>:</p><p>一般使用<a href="https://zh.wikipedia.org/wiki/代碼覆蓋率" target="_blank" rel="noopener"><code>测试覆盖率</code></a>来量化，尽管对于覆盖率能不能衡量单元测试的有效性存在较多争议。</p><p>大部分情况下还是推荐尽可能提高覆盖率, 比如要求<code>语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%</code>. 视团队情况而定</p><p>扩展:</p><ul><li><a href="https://www.infoq.cn/article/test-coverage-rate-role" target="_blank" rel="noopener">测试覆盖（率）到底有什么用？</a></li></ul><p><br></p><p><strong>相关工具</strong></p><ul><li>Headless Browsers: 无头浏览器是网页自动化的重要运行环境。 常用于功能测试、单元测试、网络爬虫<ul><li><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">puppeteer</a></li><li><a href="https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md" target="_blank" rel="noopener">Headless Chromium</a></li></ul></li><li>测试框架<ul><li><a href="http://jest.io/" target="_blank" rel="noopener">Jest</a> 🔥Facebook的单元测试框架. 零配置, 支持组件快照测试、模块Mock、Spy. 一般场景, 单元测试学它一个就行了<ul><li>组件测试<ul><li><a href="https://github.com/testing-library" target="_blank" rel="noopener">testing-library</a> 🔥</li><li><a href="https://github.com/airbnb/enzyme" target="_blank" rel="noopener">Enzyme</a></li></ul></li></ul></li><li><a href="https://theintern.github.io/" target="_blank" rel="noopener">Intern</a></li></ul></li><li>单元测试<ul><li><a href="https://github.com/avajs/ava" target="_blank" rel="noopener">AVA</a></li><li><a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a></li><li><a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a></li><li><a href="https://github.com/substack/tape" target="_blank" rel="noopener">Tape</a></li></ul></li><li>断言库<ul><li><a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a></li><li><a href="https://github.com/Automattic/expect.js" target="_blank" rel="noopener">expect.js</a></li><li><a href="http://shouldjs.github.io/" target="_blank" rel="noopener">should.js</a></li></ul></li><li>Mock/Stubs/Spies<ul><li><a href="http://sinonjs.org/" target="_blank" rel="noopener">sinon.js</a></li></ul></li><li>代码覆盖率<ul><li><a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a></li></ul></li><li>基准测试<ul><li><a href="http://benchmarkjs.com/" target="_blank" rel="noopener">benchmark.js</a></li><li><a href="https://jsperf.com/" target="_blank" rel="noopener">jsperf.com</a></li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="9-异常处理、监控和调试规范"><a href="#9-异常处理、监控和调试规范" class="headerlink" title="9 异常处理、监控和调试规范"></a>9 异常处理、监控和调试规范</h2><p>很多开发者常常误用或者轻视异常的处理, 合理有效的异常处理可以提高应用的健壮性和可用性，另外还可以帮助开发者快速定位异常.</p><h3 id="9-1-异常处理"><a href="#9-1-异常处理" class="headerlink" title="9.1 异常处理"></a>9.1 异常处理</h3><p>&lt;阿里巴巴的Java开发手册&gt;中总结的<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.md" target="_blank" rel="noopener">异常处理规范</a>对JavaScript的异常处理也很有参考意义，比如:</p><ul><li>异常不要用来做流程控制，条件控制。</li><li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li><li>catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。不要对大段代码进行try-catch</li><li>…</li></ul><p>然后再根据JavaScript本身的异常处理特点总结一些规范行为, 例如:</p><ul><li>不要throw非Error对象</li><li>不要忽略异步异常</li><li>全局监控Javascript异常</li><li>…</li></ul><p><br></p><p>资源:</p><ul><li><a href="https://rollbar.com/blog/top-10-javascript-errors/" target="_blank" rel="noopener">从1000+个项目中总结出来的前10个JavaScript错误, 以及如何避免它们</a></li><li><a href="https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6" target="_blank" rel="noopener">Javascript异常处理‘权威’指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/63698500" target="_blank" rel="noopener">前端异常处理最佳实践</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="9-2-日志"><a href="#9-2-日志" class="headerlink" title="9.2 日志"></a>9.2 日志</h3><p>对于前端来说，日志也不是毫无意义(很多框架性能优化建议在生产环境移除console)。尤其是在<strong>生产现场</strong>调试代码时，这时候可贵的控制台日志可以帮助你快速找到异常的线索.</p><p>不过通常我们<strong>只要保留必要的、有意义的日志输出</strong>，比如你不应该将console.log放到一个React渲染函数中、或者放到一个循环中, <strong>DDos式的日志信息并不能帮助我们定位问题，反而会影响运行的性能</strong>. 所以需要一个规范来约束日志输出行为, 比如:</p><ul><li>避免重复打印日志</li><li>谨慎地记录日志, 划分日志级别。比如生产环境禁止输出debug日志；有选择地输出info日志；</li><li>使用前缀对日志进行分类, 例如: <code>[User] xxxx</code></li><li>只记录关键信息, 这些信息可以帮助你诊断问题</li><li>…</li></ul><p>扩展资源</p><ul><li><a href="https://github.com/visionmedia/debug" target="_blank" rel="noopener">debug</a> 适合Node.js和浏览器的debug日志工具, 支持动态开启日志打印</li><li><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">vConsole</a> 移动端调试利器</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="9-3-异常监控"><a href="#9-3-异常监控" class="headerlink" title="9.3 异常监控"></a>9.3 异常监控</h3><p>因为程序跑在不受控的环境，所以对于客户端应用来说，异常监控在生产环境是非常重要的，它可以收集各种意料之外生产环境问题，帮助开发者快速定位异常。</p><p><br></p><p>异常监控通常会通过三种方式来收集异常数据:</p><ol><li>全局捕获。例如使用window.onerror, 或者<code>unhandledrejection</code></li><li>主动上报。在try/catch中主动上报. </li><li>用户反馈。比如弹窗让用户填写反馈信息.</li></ol><p>和日志一样，<strong>不是所有‘异常’都应该上报给异常监控系统，譬如一些预料之内的‘异常’</strong>，比如用户输入错误、鉴权失败、网络错误等等. <strong>异常监控主要用来上报一些意料之外的、或者致命性的异常</strong>.</p><p><br></p><p>要做好前端的异常监控其实并不容易，它需要处理这些东西:</p><ul><li>浏览器兼容性。</li><li>碎片收集(breadcrumbs)。 收集‘灾难’现场的一些线索，这些线索对问题诊断很重要。例如当前用户信息、版本、运行环境、打印的日志、函数调用栈等等</li><li>调用栈的转换。通常在浏览器运行的压缩优化过的代码，这种调用栈基本没什么可读性，通常需要通过SourceMap映射到原始代码. 可以使用这个库: <a href="https://github.com/mozilla/source-map#sourcemapconsumer" target="_blank" rel="noopener">source-map</a></li><li>数据的聚合。后端监控系统需要对前端上报的信息进行分析和聚合</li></ul><p><br></p><p>对于小团队未必有能力开发这一套系统，所以推荐使用一些第三方工具。例如</p><ul><li><a href="https://sentry.io/welcome/" target="_blank" rel="noopener">Sentry</a> 🔥免费基本够用</li><li><a href="https://www.fundebug.com/price" target="_blank" rel="noopener">FunDebug</a> 付费增强</li></ul><p><strong>扩展</strong>:</p><ul><li><a href="https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/" target="_blank" rel="noopener">前端异常监控解决方案研究</a></li><li><a href="https://www.cnblogs.com/warm-stranger/p/9417084.html" target="_blank" rel="noopener">搭建前端监控系统</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="10-前后端协作规范"><a href="#10-前后端协作规范" class="headerlink" title="10 前后端协作规范"></a>10 前后端协作规范</h2><p>前端是Web的一个细分领域，往往不能脱离后端而存在。所以和后端协作的时间是最长的.</p><h3 id="10-1-协作流程规范"><a href="#10-1-协作流程规范" class="headerlink" title="10.1 协作流程规范"></a>10.1 协作流程规范</h3><p>前后端团队经过长期的合作，一般可以总结出一条对于双方开发效率最优的协作流程. 将这个落实为规范，后面的团队成员都遵循这个步调进行协作。</p><p>一个典型的前后端协作流程如下:</p><p><img src="/images/frontend-standard/f-b.png" alt></p><ol><li>需求分析。参与者一般有前后端、测试、以及产品. 由产品主持，对需求进行宣贯，接受开发和测试的反馈，确保大家对需求有一致的认知</li><li>前后端开发讨论。讨论应用的一些开发设计，沟通技术点、难点、以及分工问题.</li><li>设计接口文档。可以由前后端一起设计；或者由后端设计、前端确认是否符合要求</li><li>并行开发。前后端并行开发，在这个阶段，前端可以先实现静态页面; 或者根据接口文档对接口进行Mock, 来模拟对接后端接口</li><li>在联调之前，要求后端做好接口测试</li><li>真实环境联调。前端将接口请求代理到后端服务，进行真实环境联调。</li></ol><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="10-2-接口规范"><a href="#10-2-接口规范" class="headerlink" title="10.2 接口规范"></a>10.2 接口规范</h3><p>首先应该确定下来的是接口规范。其实使用哪种接口标准是其次，重要的是统一，且要满足前后端的开发效率要求.</p><p>笔者不建议后端去定义自己的接口标准，而应该去选择一些通用的、有标准定义接口形式, 例如:</p><ul><li><p><a href="https://zh.wikipedia.org/zh-hans/表现层状态转换" target="_blank" rel="noopener">RESTful</a>: RESTful是目前使用最为广泛的API设计规范, 基于HTTP本身的机制来实现. </p><p>笔者个人是比较喜欢这个API规范，但是我发现很多开发者并不能真正(或者说没心思)理解它，设计出来的接口，跟我想象的相差甚远。换句话说，对于RESTful，开发者之间很难达成一致的理解，容易产生分歧。</p><p>因为是使用最广泛的API形式，所以社区上有很多工具来对RESTful接口进行文档化、测试和模拟.</p></li><li><p><a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html" target="_blank" rel="noopener">JSONRPC</a> 这是一种非常简单、容易理解的接口规范。相对于RESTful我更推荐这个，简单则不容易产生分歧，新手也可以很快接受.</p></li><li><a href="https://graphql.org/learn/" target="_blank" rel="noopener">GraphQL</a> 🔥更为先进、更有前景的API规范。但是你要说服后端配合你使用这种标准可能很有难度</li></ul><p><br></p><p><strong>接口设计需要注意的点</strong>:</p><ul><li>明确区分是正常还是异常, 严格遵循接口的异常原语. 上述接口形式都有明确的异常原语，比如JSONRPC，当出现异常时应该返回<code>错误对象</code>响应，而不是在正常的响应体中返回错误代码. 另外要规范化的错误码, HTTP响应码就是一个不错的学习对象</li><li>明确数据类型。很多后端写的接口都是string和number不分的，如果妥协的话、前端就需要针对这个属性做特殊处理，这也可能是潜在的bug</li><li>明确空值的意义。比如在做更新操作是，空值是表示重置，还是忽略更新？</li><li>响应避免冗余的嵌套。</li><li>接口版本化，保持向下兼容。就像我们上文的‘语义化版本规范’说的，对于后端来说，API就是公共的接口. 公共暴露的接口应该有一个版本号，来说明当前描述的接口做了什么变动，是否向下兼容。<br>现在前端代码可能会在客户端被缓存，例如小程序。如果后端做了break change，就会影响这部分用户。</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="10-3-接口文档规范"><a href="#10-3-接口文档规范" class="headerlink" title="10.3 接口文档规范"></a>10.3 接口文档规范</h3><p>后端通过接口文档向前端暴露接口相关的信息。通常需要包含这些信息：</p><ul><li>版本号</li><li>文档描述</li><li>服务的入口. 例如基本路径</li><li>测试服务器. 可选</li><li>简单使用示例</li><li>安全和认证</li><li>具体接口定义<ul><li>方法名称或者URL</li><li>方法描述</li><li>请求参数及其描述，必须说明类型(数据类型、是否可选等)</li><li>响应参数及其描述, 必须说明类型(数据类型、是否可选等)</li><li>可能的异常情况、错误代码、以及描述</li><li>请求示例，可选</li></ul></li></ul><p><strong>人工维护导致的问题</strong>:</p><p>上文‘代码即文档’就提到了人工维护接口文档可能导致代码和文档不同步问题。</p><p>如果可以从代码或者规范文档(例如OpenAPI这类API描述规范)中生成接口文档，可以解决实现和文档不一致问题, 同时也可以减少文档编写和维护的投入.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="10-4-接口测试与模拟"><a href="#10-4-接口测试与模拟" class="headerlink" title="10.4 接口测试与模拟"></a>10.4 接口测试与模拟</h3><p>为了做到高效率的前后端并行开发，接口的测试与模拟是必要的。</p><ul><li>前端要求后端在联调之前，需要测试验证好自己的接口是否可以正常工作。而不是在联调期间，把前端当‘接口测试员’，阻塞接口联调进度</li><li>另外前端需要在后端接口未准备好之前，通过接口模拟的方式，来编写业务逻辑代码。</li></ul><p>针对接口测试与模拟，存在下图这样一个理想的模型:</p><p><img src="/images/frontend-standard/api-mock.png" alt></p><p>一切从定义良好的接口文档出发，生成<code>Mock Server</code>和<code>Mock Client</code>, Mock Server给前端提供模拟数据，而Mock Client则辅助后端对它们的接口进行测试.</p><p>资源:</p><ul><li>RESTful<ul><li><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 这是最为接近上面理想模型的一个解决方案</li><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">JSON Server</a> 快速生成JSON mock服务器</li><li><a href="https://easy-mock.com" target="_blank" rel="noopener">Easy Mock</a> 可视化的、在线的接口mock服务</li></ul></li><li>GraphQl<ul><li><a href="https://github.com/APIs-guru/graphql-faker" target="_blank" rel="noopener">GraphQL Faker</a></li><li><a href="https://www.apollographql.com/docs/graphql-tools/mocking/" target="_blank" rel="noopener">graphql-tools</a></li></ul></li><li>模拟数据生成<ul><li><a href="https://github.com/Marak/faker.js" target="_blank" rel="noopener">faker.js</a> 🔥强大的模拟数据生成工具，支持Node和浏览器</li><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">Mock.js</a> 数据生成和模拟工具</li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="11-培训-知识管理-技术沉淀"><a href="#11-培训-知识管理-技术沉淀" class="headerlink" title="11 培训/知识管理/技术沉淀"></a>11 培训/知识管理/技术沉淀</h2><p>我觉得一个团队的知识管理是非常重要的. 你要问一个刚入行的新手加入团队希望得到什么？很多人的回答是’学习’,  希望自己的技术可以更加精进, 钱倒还是其次。</p><p>然而现实是目前很多公司的氛围并不是这样的，一天到晚写业务代码、工作量大、每天做重复的事情，而且还加班，工作多年技术也没感觉有多少进步, 确实会让人非常沮丧。包括笔者也是这样的。</p><p>所以为了改善这种情况，我来聊聊最近在‘小团队’做的一些尝试.</p><h3 id="11-1-新人培训"><a href="#11-1-新人培训" class="headerlink" title="11.1 新人培训"></a>11.1 新人培训</h3><p>如果团队有规范的新成员培训手册，可以节省很多培训的时间，避免每次重复口述一样的内容。培训手册包含以下内容:</p><ul><li><p><strong>产品架构与组织架构</strong>. 介绍公司背景和产品，一般组织的团队结构和产品的架构是相关联的. 以笔者所在公司为例, 主要产品是即时通信:</p><p><img src="/images/frontend-standard/org.png" alt></p></li><li><p><strong>产品研发流程</strong>: 介绍产品开发和迭代会涉及到的流程、以及团队之间的协作衔接，例如:</p><p><img src="/images/frontend-standard/dev-proc.png" alt></p></li><li><p><strong>工作范围</strong>: 团队成员的职责范围</p></li><li><strong>建立资源索引</strong>: 开发需要设计到的资源，比如各种文档地址、研发系统入口(例如gitlab、bug跟踪系统、文件共享、发布平台、开发/测试环境、监控系统)、协作规范等等。将这些资源整理好可以减少不必要的沟通成本</li><li><strong>规范</strong>: 即本文的主体’前端协作规范’。有规范可循，可以让成员以较快的速度入手开发、同时也减少培训成本投入。</li></ul><p>培训手册将可以文档具象化的内容整理为文档，和上文说到的Code Review一样，一些东西无法通过文档来说明，所以我们一般会搭配一个‘培训导师’，在试用期间，一对一辅导。</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="11-2-营造技术氛围"><a href="#11-2-营造技术氛围" class="headerlink" title="11.2 营造技术氛围"></a>11.2 营造技术氛围</h3><ul><li><strong>鼓励成员写技术博客，或者建立自己的团队专栏</strong>. 写一篇好的文章不容易</li><li><strong>鼓励参与开源项目</strong></li><li><strong>建立面试题库</strong> 组织一起解一些面试题或算法题，加深对知识点的理解</li><li><p><strong>定期的专题分享</strong>. 鼓励团队成员定期进行专题学习和研究，编写技术博客，并将学习的成果分享给其他成员. 这是一种抱团取暖的学习方式，旨在帮助团队成员一起学习和成长。</p><p>比如开发老手可以分享自己的经验，研究更深层次的技术；新手则可以研究某些开发技巧、新技术，例如CSS Grid，svg动画等等。推荐团队成员有个明确的研究领域，这样分工合作可以学习到更多东西.</p><p><strong>专题怎么来?</strong></p><ul><li>专题请求. 可以请求其他成员完成专题，比如比较深的知识，可以要求团队比较有经验的进行学习分享</li><li>学习总结.</li><li>项目回顾</li><li>难点攻克</li><li>项目规范</li><li>工具使用</li></ul></li><li><p><strong>落实和完善开发规范</strong>. 规范本身就是团队知识沉淀的一种直接输出</p></li><li><strong>图书分享</strong>. 和离散的文章或教程相比，图书的知识会比较系统，另外很多经典的图书是要静下来好好欣赏的。</li><li><strong>鼓励重构和持续优化代码</strong></li><li><strong>抽象一套基础库或框架，减少重复工作, 提高工作效率</strong>. 不加班先从提高工作效率开始</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="12-反馈"><a href="#12-反馈" class="headerlink" title="12 反馈"></a>12 反馈</h2><p>大家有什么要补充或意见可以在下方评论, 一起来完善这篇文章, 谢谢！</p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;笔者长期单枪匹马在前端领
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[问答] 为什么要用vue-cli3?</title>
    <link href="https://bobi.ink/2019/07/18/why-vue-cli3/"/>
    <id>https://bobi.ink/2019/07/18/why-vue-cli3/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T04:20:32.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>[问答]</code>系列主要整理<a href="https://segmentfault.com/q/1010000019785471" target="_blank" rel="noopener">SegmentFault</a>上面比较有价值的问题，以及我的回答</p></blockquote><h2 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a><a href="https://segmentfault.com/q/1010000019785471/a-1020000019793827" target="_blank" rel="noopener">原问题</a></h2><p>其实这个问题主要是想了解vue-cli3与vue-cli2相比是否存在一些不得不升级的好处和优点？</p><p>产生这个问题的原因是在试用完vue-cli3之后并没有觉得好用，反而觉得束手束脚，我cli2时，webpack想怎么配怎么配为什么到了cli3我要在vue.config.js中配置<br>众所周知vue-cli的通用配置并不适合每种情况, 而在vue.config.js只能做增添和覆盖，所以一直没有用vue-cli3构建项目</p><p>所以想请教下 这个版本有没有值得升级的优点</p><p><br></p><h2 id="我的回答"><a href="#我的回答" class="headerlink" title="我的回答"></a>我的回答</h2><p>好问题，vue-cli3相对vue-cli有很多重要的更新。</p><p>首先说一些vue-cli这些工具的<strong>初衷</strong>吧: 这些工具就是为了让开发者能够<strong>开箱即用</strong>快速地进行应用开发而开发的，<strong>它们秉承的是“约定大于配置”思想，简单说就是”能不配置的就不配置，你就按照我的方式来，也不要去争论这个好不好，快速进行业务开发才是正经事”. 它们不建议你去配置，但也不会拦着你去配置</strong>。</p><p>另外Webpack对初学者并不是十分友好，‘又长又臭’的配置，普通开发者很难写入定义良好，性能优化的配置。不然就不会各种cli工具冒出来了，比如parcel，create-react-app。这些工具都宣称零配置，目的就是让开发者能够愉快的进行代码开发。</p><p><br></p><hr><p><br></p><p>现在来看看Vue-cli v3的改进，以及思考这些有什么意义呢？</p><p><br></p><p><strong>1. 抽离cli service层</strong></p><p>Create-React-App是第一个做这种事情的。vue-cli3库现在包含以下两个模块：</p><ul><li><p>CLI: 即vue全局命令，主要用于项目创建和管理，包含了<code>vue create</code>、<code>vue ui</code>这些命令。CLI命令的做的事情比较少，所以更新不会太频繁(开发者也很少会去更新这些命令)</p></li><li><p>Service层: 负责项目的实际构建，也就是webpack项目构建。这一块是频繁更新的，一般作为项目的局部依赖。</p></li></ul><p><br></p><p>OK，这么做有什么意义呢？考虑这样一个场景，这也是答主之前遇到的一个痛点：</p><p><strong>vue-cli3之前不算是一个构建CLI, 它顶多就是一个模板拷贝器, 做的事情非常少</strong>, 所有webpack配置和构建命令都是耦合在具体的项目里面，package.json会包含一大堆开发依赖。</p><p>如果去跟进webpack或相关工具更新的朋友会有这种体会，升级不是一件容易的事情。比如你升级了babel-loader, 可能要连带webpack都升级，webpack升级后可能其他工具又不兼容了。</p><p>升级方面的痛点是其一。如果你的团队需要维护很多项目，你怎么对这些项目进行维护升级？每个项目都拷贝一下？如果某个项目做了特殊配置呢？</p><p><strong>对于团队而言，项目构建这一块是应该尽量做到的统一和傻瓜化的，没有必要在这方面投入太多的精力，应该把事情外包给擅长这种事情的人去做</strong>。</p><p><strong>另外不要排斥更新，更新可以获得更好的开发体验和构建速度、运行性能, 别人在这方面比你了解的更多</strong>。</p><p><strong>分离了vue-cli-service之后，项目构建更新只是一个命令的事情，除非做了很多特殊化操作</strong>。<strong>特殊化操作应该封装到vue-cli的插件中</strong>。这就引出了vue-cli3的另外一个特色：插件</p><p><br></p><hr><p><br></p><p><strong>2. 插件化</strong></p><p>相比create-react-app, vue-cli是在太仁慈了。vue-cli的插件机制很灵活，通过<code>webpack-chain</code>和<code>webpack-merge</code>可以实现webpack完全定制化。</p><p>可以对比一下市面上流行的cli工具的可扩展性：</p><table><thead><tr><th></th><th>Vue CLI</th><th>create-react-app</th><th>parcel</th></tr></thead><tbody><tr><td>快速原型开发</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>全局模式</td><td>零配置原型开发就是全局的</td><td>-</td><td>支持</td></tr><tr><td>插件</td><td>支持</td><td>-</td><td>支持，扩展文件类型和文件输出</td></tr><tr><td>扩展性</td><td>强，通过插件扩展 wepack 配置</td><td>弱, 强约定, 无法配置 webpack，可以 eject, 然后手工配置；支持 babel-macro;(严格说可以通过<a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">react-app-rewired</a>进行扩展)</td><td>中(可以配置 babel，postcss，Typescript); 提供了 Node API; 支持插件扩展文件类型</td></tr><tr><td>多页面</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>适用范围</td><td>Vue 组件的第一公民。通过扩展可以支持任意前端框架</td><td>针对 React 开发，不支持其他框架</td><td>parcel 是一个通用的打包工具，它的竞争对手是 webpack</td></tr><tr><td>编译速度</td><td>cache-loader,thread-loader 来加速 JS 和 TS 编译</td><td>babel-loader 开启了 cache</td><td>编译速度号称是 webpack 的两倍</td></tr><tr><td>可升级性</td><td>支持升级 cli-service, 插件需要单独升级, 插件需要遵循语义化版本. 太多插件存在升级风险</td><td>支持升级 react-script, 官方维护，且强约定基本可以保障向下兼容</td><td>支持升级 parcel-bundler</td></tr><tr><td>UI</td><td>图形化管理是 CLI 的特色之一</td><td>-</td><td>-</td></tr></tbody></table><p><br></p><p>对于vue-cli的插件实现机制可以看这篇<a href="https://juejin.im/post/5cedb26451882566477b7235" target="_blank" rel="noopener">文章</a>。</p><p>因为vue-cli灵活的扩展性，所以它不仅限于vue本身，可以扩展支持react、anything…</p><p>按照上文说的，<strong>如果你要做深度的vue-cli定制化，不建议直接写在vue.config.js中，而是封装在插件中，独立的维护这个插件，然后项目再依赖这个插件。这样就可以简化升级的成本和复杂度</strong>。</p><p><br></p><hr><p><br></p><p><strong>3. GUI界面</strong></p><p>虽然大部分人都觉得作用不大，因为确实对开发效率并实际的提升效果。就是看着舒服直观，这就够了。</p><p><br></p><hr><p><br></p><p><strong>4. 快速原型开发</strong></p><p>vue-cli3也支持直接将一个vue文件跑起来，快速原型开发或验证某些想法时，挺不错。</p><p><br></p><hr><p><br></p><p><strong>5. <a href="https://cli.vuejs.org/guide/browser-compatibility.html#modern-mode" target="_blank" rel="noopener">现代模式</a></strong></p><p>给先进的浏览器配合先进的代码(ES6之后),同时兼容旧版本的浏览器，先进的代码不管从文件体积还是脚本解析效率、运行效率都有较高的提升。</p><p>体积对比:</p><table><thead><tr><th>Version</th><th>Size (minified)</th><th>Size (minified + gzipped)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>80K</td><td>21K</td></tr><tr><td>ES5 (main.es5.js)</td><td>175K</td><td>43K</td></tr></tbody></table><p><br></p><p>解析效率:</p><table><thead><tr><th>Version</th><th>Parse/eval time (individual runs)</th><th>Parse/eval time (avg)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>184ms, 164ms, 166ms</td><td>172ms</td></tr><tr><td>ES5 (main.es5.js)</td><td>389ms, 351ms, 360ms</td><td>367ms</td></tr></tbody></table><p><br></p><hr><p><br></p><p><strong>6. Standard Tooling for Vue.js Development</strong></p><p>这是vue-cli的官方介绍，vue标准开发工具. 跟进vue-cli就是跟进官方的最佳实践和前沿技术，vue团队已经为你考虑很多应用场景, why not?</p><p><br></p><hr><p><br></p><p><strong>总结一下</strong>：</p><ul><li><p>如果我们喜欢折腾，肯定会觉得vue-cli3束手束脚，这时候我们不是vue-cli3的目标用户；</p><p>就比如我们团队就自己搞了一一个CLI构建工具: <a href="https://github.com/GDJiaMi/jm-cli" target="_blank" rel="noopener">jm-cli</a>, 根据自己的团队需求进行深度定制，不过我们这个工具是强约定的，包括目录结构、编码规范等等. 因为我们不推荐团队成员去搞特殊化定制，而且为了方便进行更新，所以干脆就不让扩展了，<strong>统一和规范对团队来说才是最重要的</strong>.</p><p><strong>如果你有类似的开发经验，你会觉得vue-cli可能是所有构建CLI的最终归宿或者典范</strong>。</p></li><li><p>如果不想折腾，只想写代码, 而且想跟进vue官方最新实践，那就直接拿来用吧；</p></li><li>如果想折腾，又要考虑团队协作和构建工具链的维护成本，vue-cli是很适合的。当然你也可以造轮子</li><li>如果想学webpack的构建项目，也不推荐你使用vue-cli</li></ul><p><br></p><p>最后给vue团队点个赞👍</p><p>欢迎关注我，和我交流</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;[问答]&lt;/code&gt;系列主要整理&lt;a href=&quot;https://segmentfault.com/q/1010000019785471&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SegmentFault&lt;/a&gt;
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>现代脚本的加载</title>
    <link href="https://bobi.ink/2019/07/17/modern-module/"/>
    <id>https://bobi.ink/2019/07/17/modern-module/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-18T23:21:49.165Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址: <a href="https://jasonformat.com/modern-script-loading/" target="_blank" rel="noopener">Modern Script Loading</a>, 文章作者是Preact作者<a href="https://twitter.com/_developit" target="_blank" rel="noopener">Jason Miller</a></p><p><br></p><p><img src="/images/modern-module/modern-script-loading.jpg" alt></p><p><br></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>先简单介绍一下<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener"><code>模块script(Module script)</code></a>, 它指的是<strong>现代浏览器支持通过<code>&lt;script type=module src=main.js&gt;&lt;/script&gt;</code>来加载现代的ES6模块</strong>. 现代浏览器对ES6现代语法有良好的支持，这意味着<strong>我们可以给这些现代浏览器提供更紧凑的‘现代代码’，一方面可以减小打包的体积，减少网络传输的带宽，另外还可以提高脚本解析的效率和运行效率</strong>.</p><p>下图来源于<a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/" target="_blank" rel="noopener"><code>module/nomodule pattern</code></a>, 对比了<strong>模块script</strong>和<strong>传统(legacy) script</strong>的性能:</p><p>体积对比:</p><table><thead><tr><th>Version</th><th>Size (minified)</th><th>Size (minified + gzipped)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>80K</td><td>21K</td></tr><tr><td>ES5 (main.es5.js)</td><td>175K</td><td>43K</td></tr></tbody></table><p><br></p><p>解析效率:</p><table><thead><tr><th>Version</th><th>Parse/eval time (individual runs)</th><th>Parse/eval time (avg)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>184ms, 164ms, 166ms</td><td>172ms</td></tr><tr><td>ES5 (main.es5.js)</td><td>389ms, 351ms, 360ms</td><td>367ms</td></tr></tbody></table><p><br></p><p>Ok，为了兼容旧浏览器, <a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/" target="_blank" rel="noopener">module/nomodule pattern</a>这篇文章介绍了一种<strong>module/nomodule 模式</strong>, 简单说就是<strong>同时提供两个script, 由浏览器来决定加载哪个文件</strong>：</p><p><br></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 支持模块script的浏览器会加载这个文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"main.mjs"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 旧浏览器会加载这个文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为加了nomdule, 所以现代浏览器不会加载该文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"main.es5.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来很美好是吧? 现实是：<strong>中间存在一些浏览器，它们可以识别<code>模块script</code>但是不认识<code>nomodule</code>属性, 这就导致了这些浏览器会同时加载这两个文件(下文统一称为‘双重加载’(over-fetching))</strong>.</p><p><br><br><br></p><blockquote><p>OK，正式进入正文. 给正确的浏览器交付正确代码是一件棘手的事情。本文会介绍几种方式, 来解决上述的问题:</p></blockquote><p>给现代浏览器伺服’现代的代码’对性能有很大的帮助。所以你应该针对现代浏览器提供包含更紧凑和优化的现代语法的Javascript包，同时又可以保持对旧浏览器的支持</p><p>现有的工具链的生态系统基本都是在<code>module/nomodule模式</code>上整合的，它声明式加载现代和传统代码(legacy code)，即给浏览器提供两个源代码，让它来自己来决定用哪个:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"/modern.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"/legacy.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而现实总是给你当头一棒，它没我们期望的那么简单直接。上述基于HTML的加载方式在<a href="https://gist.github.com/jakub-g/5fc11af85a061ca29cc84892f1059fec" target="_blank" rel="noopener"><strong>Edge和Safari中会被同时加载</strong></a>!</p><p><br></p><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办?"></a>怎么办?</h2><p>怎么办？我们想依赖浏览器来交付不同的编译目标，但是一些旧浏览器并不能优雅地支持这种简洁的写法。</p><p>首先，Safari 在10.1开始支持JS模块, 但不支持nomodule属性。值得庆幸的是，Sam找到了一种方法，可以通过Safari 10和11中非标准的beforeload事件来模拟 nomodule, 也就是可以认为Safari 10.1开始是可以支持<code>module/nomodule模式</code></p><p><br></p><h2 id="选项1-动态加载"><a href="#选项1-动态加载" class="headerlink" title="选项1: 动态加载"></a>选项1: 动态加载</h2><p>我们可以实现一个小型script加载器来规避这个问题，工作原理类似于<a href="https://github.com/filamentgroup/loadCSS" target="_blank" rel="noopener">LoadCSS</a>。只不过这里需要依靠浏览器的来实现ES模块和nomodule属性.</p><p>我们首先尝试执行一个模块script进行’石蕊试验’(litmus test), 然后由这个试验的结果来决定加载现代代码还是传统代码:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用一个模块script来检测是否是现代浏览器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  self.modern = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 现在根据这个检测结果来决定加载现代代码还是传统代码: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (self.modern) &#123;</span></span><br><span class="line"><span class="javascript">      s.src = <span class="string">'/modern.js'</span></span></span><br><span class="line"><span class="javascript">      s.type = <span class="string">'module'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      s.src = <span class="string">'/legacy.js'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(s)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，这个解决方案必须等待进行‘石蕊试验’模块script执行完成, 才能开始注入script。这是因为<code>&lt;script type=module&gt;</code>始终是异步的，所以别无它法(延迟到load事件后)。</p><p>另一种实现方式是检查浏览器是否支持<code>nomodule</code>, 这是方式可以避免上述的延迟加载问题, 只不过这意味着像Safari 10.1这些支持模块, 却不支持nomodule的浏览器也会被当做传统浏览器，这也许<a href="https://github.com/web-padawan/polymer3-webpack-starter/issues/33#issuecomment-474993984" target="_blank" rel="noopener">可能</a>是<a href="https://jasonformat.com/modern-script-loading/" target="_blank" rel="noopener">好事</a>(相对于两个脚本都加载以及有一些bug)，代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)  </span><br><span class="line"><span class="keyword">if</span> (<span class="string">'noModule'</span> <span class="keyword">in</span> s) &#123;  <span class="comment">// 注意这里的大小写</span></span><br><span class="line">  s.type = <span class="string">'module'</span></span><br><span class="line">  s.src = <span class="string">'/modern.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">  s.src = <span class="string">'/legacy.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(s)</span><br></pre></td></tr></table></figure><p>现在把它们封装成函数，并确保两种方式都统一使用异步的方式加载(上文提到模块script是异步的，而传统script不是):</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  $loadjs(<span class="string">"/modern.js"</span>,<span class="string">"/legacy.js"</span>)</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">$loadjs</span>(<span class="params">src,fallback,s</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="string">'noModule'</span> <span class="keyword">in</span> s) s.type = <span class="string">'module'</span>, s.src = src</span></span><br><span class="line"><span class="javascript">    <span class="keyword">else</span> s.async = <span class="literal">true</span>, s.src = fallback   <span class="comment">// 统一使用异步方式加载</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(s)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来已经很完美了，还有什么问题呢？<strong>我们还没考虑预加载(preloading)</strong></p><p>这个有点蛋疼， 因为一般浏览器只会静态地扫描HTML，然后查找它可以预加载的资源。 我们上面介绍的模块加载器是完全动态的，所以浏览器在没有运行我们的代码之前，是没办法发现我们要预加载现代还是传统的Javascript资源的。</p><p>不过有一个解决办法，就是不完美：就是使用<code>&lt;link rel=modulepreload&gt;</code>来预加载现代版本的包, 旧浏览器会忽略这条规则，然而目前<a href="https://developers.google.com/web/updates/2017/12/modulepreload" target="_blank" rel="noopener">只有Chrome支持这么做</a>:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"modulepreload"</span> <span class="attr">href</span>=<span class="string">"/modern.js"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">self.modern=1</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- etc --&gt;</span></span><br></pre></td></tr></table></figure><p><strong>其实预加载这种技术是否有效，取决于嵌入你的脚本的HTML文档的大小</strong>。</p><p>如果你的HTML载荷很小, 比如只是一个启动屏或者只是简单启动客户端应用，那么放弃预加载扫描对你的应用性能影响很小。<br>如果你的应用使用服务器渲染大量有意义的HTML, 并以流(stream)的方式传输给浏览器，那么预加载扫描就是你的朋友，但这也未必是最佳方法。</p><blockquote><p>译注: 现代浏览器都支持分块编码传输，等服务端完全输出html可能有一段空闲时间，这时候可以通过预加载技术，让浏览器预先去请求资源</p></blockquote><p>大概代码如下:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"modulepreload"</span> <span class="attr">href</span>=<span class="string">"/modern.js"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">self.modern=1</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  $loadjs(<span class="string">"/modern.js"</span>,<span class="string">"/legacy.js"</span>)</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">$loadjs</span>(<span class="params">e,d,c</span>)</span>&#123;c=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>),self.modern?(c.src=e,c.type=<span class="string">"module"</span>):c.src=d,<span class="built_in">document</span>.head.appendChild(c)&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还要指出的是，支持<a href="https://caniuse.com/#feat=es6-module" target="_blank" rel="noopener">JS模块的浏览器</a>一般也<a href="https://caniuse.com/#feat=link-rel-preload" target="_blank" rel="noopener">支持</a><code>&lt;link rel = preload&gt;</code>。对于某些网站，相比依靠<code>modulepreload</code>, 使用<code>&lt;link rel=preload as=script crossorigin&gt;</code>可能更有意义。不过性能上面可能欠点，因为传统的脚本预加载不会像<code>modulepreload</code>一样随着时间的推移而去展开解析工作(<code>rel=preload</code>只是下载，不会尝试去解析脚本)。</p><p><br></p><h2 id="选项2-用户代理嗅探"><a href="#选项2-用户代理嗅探" class="headerlink" title="选项2: 用户代理嗅探"></a>选项2: 用户代理嗅探</h2><p>我办法拿出一个简洁的代码示例，因为用户代理检测不在本文的范围之内，推荐阅读这篇<a href="https://www.smashingmagazine.com/2018/10/smart-bundling-legacy-code-browsers/" target="_blank" rel="noopener">Smashing Magazine文章</a></p><p>本质上，<strong>这种技术在每个浏览器上都使用<code>&lt;script src=bundle.js&gt;</code>来加载代码，当<code>bundle.js</code>被请求时，服务器会解析浏览器的用户代理，并选择返回现代代码还是传统代码，取决于浏览器是否能被识别为现代浏览器</strong>.</p><p>尽管这种方法比较通用，但它也有一些严重的缺点：</p><ul><li>因为依赖于服务端实现，所以前端资源不能被静态部署(例如静态网站生成器(如github page)，Netlify等等)</li><li>很难进行有效的缓存. 现在这些JavaScript URL的缓存会因用户代理而异，这是非常不稳定的, 而很多缓存机制只是将URL作为缓存键，现在这些缓存中间件可能就没办法工作了。</li><li>UA检测很难，容易出现误报</li><li>用户代理字符串容易被篡改，而且每天都有新的UA出现</li></ul><p>解决这些限制的一种方法就是<strong>将<code>module/nomodule模式</code>与’用户代理区分’结合起来</strong>，首先这可以避免单纯的<code>module/nomodule模式</code>需要发送多个软件包问题，尽管这种方法仍然会降低页面(这时候指HTML，而不是Javascript包)的可缓存性，但是它可以有效地触发预加载，因为生成HTML的服务器根据用户代理知道应该使用<code>modulepreload</code>还是<code>preload</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderPage</span>(<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">`&lt;html&gt;&lt;head&gt;...`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> agent = request.headers.userAgent;</span><br><span class="line">  <span class="keyword">const</span> isModern = userAgent.isModern(agent);</span><br><span class="line">  <span class="keyword">if</span> (isModern) &#123;</span><br><span class="line">    html += <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;link rel=modulepreload href=modern.mjs&gt;</span></span><br><span class="line"><span class="string">      &lt;script type=module src=modern.mjs&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    html += <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;link rel=preload as=script href=legacy.js&gt;</span></span><br><span class="line"><span class="string">      &lt;script src=legacy.js&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  response.end(html);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于那些已经在使用服务端渲染的网站来说，用户代理嗅探是一个比较有效的解决方案</p><p><br></p><h2 id="选项-3-不考虑旧版本浏览器"><a href="#选项-3-不考虑旧版本浏览器" class="headerlink" title="选项 3:不考虑旧版本浏览器"></a>选项 3:不考虑旧版本浏览器</h2><p><strong>注意这里的‘旧版本浏览器’特指那些出现双重加载的浏览器</strong>. 对于<code>module/nomodule模式</code>支持比较差(即双重加载)的主要是一些旧版本的Chrome、Firefox和Safari. 幸运的是这部分浏览器的市场范围通常是比较窄，因为用户会自动升级到最新的版本。Edge 16-18是例外, 但还有希望： 新版本的Edge会使用基于Chromium的渲染器，可以不受该问题的影响.</p><p>对于某些应用程序来说，接受这一点妥协是完全合理的：你可以给90％的浏览器中提供现代代码，让他们获得更好的体验，而极少数旧浏览器不得不抛弃它们，它们只是付出的额外带宽(即双重加载)，并不影响功能。值得注意的是，占据移动端主要市场份额的用户代理不会有双重加载问题，所以这些流量不太可能来自于低速或者高昂流量费的手机。</p><p>如果你的网站用户主要使用移动设备或较新版本的浏览器，那么最简单的<code>module/nomodule</code>模式将适用于你的绝大多数用户, 其他用户就不考虑了，反正也是可以跑起来的, 优先考虑大多数用户的体验。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修复Safari 10.1 不支持 `nomodule` 问题: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;!(<span class="string">"noModule"</span><span class="keyword">in</span>(t=e.createElement(<span class="string">"script"</span>)))&amp;&amp;<span class="string">"onbeforeload"</span><span class="keyword">in</span> t&amp;&amp;(n=!<span class="number">1</span>,e.addEventListener(<span class="string">"beforeload"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">if</span>(e.target===t)n=!<span class="number">0</span>;<span class="keyword">else</span> <span class="keyword">if</span>(!e.target.hasAttribute(<span class="string">"nomodule"</span>)||!n)<span class="keyword">return</span>;e.preventDefault()&#125;,!<span class="number">0</span>),t.type=<span class="string">"module"</span>,t.src=<span class="string">"."</span>,e.head.appendChild(t),t.remove())&#125;(<span class="built_in">document</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 适用于90+% 的浏览器: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">modern.js</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 部分支持module但是不支持nomodule的浏览器，也会加载下面脚本，范围可能很小，我们可以选择忽略它们: --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- IE, Edge &lt;16, Safari &lt;10.1, old desktop: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">legacy.js</span> <span class="attr">nomodule</span> <span class="attr">async</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="选项-4-使用条件包"><a href="#选项-4-使用条件包" class="headerlink" title="选项 4: 使用条件包"></a>选项 4: 使用条件包</h2><p><strong><code>nomodule</code>可以巧妙地用来<em>条件加载</em>那些现代浏览器不需要的代码</strong>， 例如polyfills。通过这种方法，最坏的情况就是polyfill和bundle都会被加载(例如Safari 10.1)，但这毕竟是少数。鉴于目前通行的做法就是在所有浏览器中一致同仁地加载polyfills，相比而言, <em>条件polyfills</em>可以让大部分现代浏览器用户避免加载polyfill代码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- newer browsers won't load this bundle: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"polyfills.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- all browsers load this one: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Angular CLI支持配置这种方式来加载polyfill, 查看<a href="https://blog.mgechev.com/2019/02/06/5-angular-cli-features/#conditional-polyfill-serving" target="_blank" rel="noopener">Minko Gechev的代码示例</a>.<br>了解了这种方式之后，我决定在preact-cli中支持自动polyfill注入，你可以查看这个<a href="https://github.com/preactjs/preact-cli/pull/833/files" target="_blank" rel="noopener">PR</a></p><p>如果你使用Webpack，这里有一个html-webpack-plugin<a href="https://github.com/swimmadude66/webpack-nomodule-plugin" target="_blank" rel="noopener">插件</a>可以方便地为polyfill包添加<code>nomodule</code>属性.</p><p><br></p><h2 id="你应该怎么做"><a href="#你应该怎么做" class="headerlink" title="你应该怎么做?"></a>你应该怎么做?</h2><p>答案取决于你的使用场景, 选择和你们的架构匹配的选项:<br>如果你的应用只是客户端渲染, 而且你的HTML不超过一个<code>&lt;script&gt;</code>，选项1比较合适；<br>如果你的应用使用服务端渲染，而且可以接受缓存问题，那么可以选择选项2；<br>如果你开发的是<a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#rehydration" target="_blank" rel="noopener">同构应用</a>，预加载的功能可能对你很重要，这时你可以考虑选项3和4.</p><p>就我个人而言，相比考虑桌面端浏览器资源下载成本，我更倾向于优化移动设备解析时间. 移动用户体验会受到数据解析、流量费用，电池消耗等因素的影响，而桌面用户往往不需要考虑这些因素。<br>另外这些优化适用于90%的用户，比如我工作面对的大部分用户都是使用现代或移动浏览器的。</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>有兴趣继续深入？可以从下面的文章开始挖掘：</p><ul><li>Phil的<a href="https://github.com/philipwalton/webpack-esnext-boilerplate/issues/1" target="_blank" rel="noopener">webpack-esnext-boilerplate</a>的一些附加的背景.</li><li>Ralph<a href="https://github.com/zeit/next.js/pull/7704" target="_blank" rel="noopener">在Next.js中实现了module/nomodule</a>, 并努力解决了上面的问题.</li></ul><p>感谢<a href="https://twitter.com/philwalton" target="_blank" rel="noopener">Phil</a>, <a href="https://twitter.com/shubhie" target="_blank" rel="noopener">Shubhie</a>, <a href="https://twitter.com/atcastle" target="_blank" rel="noopener">Alex</a>, <a href="https://twitter.com/hdjirdeh" target="_blank" rel="noopener">Houssein</a>, <a href="https://twitter.com/Janicklas" target="_blank" rel="noopener">Ralph</a> 以及 <a href="https://twitter.com/addyosmani" target="_blank" rel="noopener">Addy</a> 的反馈.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址: &lt;a href=&quot;https://jasonformat.com/modern-script-loading/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Modern Script Loading&lt;/a&gt;, 文章作者是Preact作者&lt;a 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript竟然没有标准库?</title>
    <link href="https://bobi.ink/2019/07/16/js-stdlib/"/>
    <id>https://bobi.ink/2019/07/16/js-stdlib/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-08-12T04:27:48.955Z</updated>
    
    <content type="html"><![CDATA[<p>最近在SegmentFault热心解题，一个问题比较让我比较印象深刻：<em>一个初学者试图在浏览器中导入Node.js的net模块。结果在控制台打印后是一个空对象</em>。</p><p>对于有点Javascript经验的人来说，这是一个‘弱智’问题，怎么可以在浏览器端运行Node程序呢？因为这些Node模块经过<a href="http://webpack.docschina.org/configuration/node/#其他-node-js-核心库-node-js-core-libraries-" target="_blank" rel="noopener">Webpack处理</a>, 所以变成了一个空对象，更好的处理方式应该是抛出异常.</p><p><strong>仔细反思一下，对于这些刚入门Javascript的或者从其他语言切换过来的开发者，他们压根就没有概念，比如Python、Ruby、Java这些语言都有强大的标准库，可以满足80%的开发需求，不管它在什么环境、什么平台运行，基本上都可以统一使用这套标准库。而Javascript目前的现状是：不同的运行环境，API结构是割裂的</strong>。</p><p>Javascript这门十几天开发出来的、专供浏览器的语言，可能当初设计是根本就没有考虑标准库这些玩意，比如文件系统，网络等等。<strong>因为这个背景, Javascript长期不具备独立性，它深度依赖于浏览器这个运行环境, 处于一种给浏览器打辅助的角色</strong>, 所以Javascript很多年没有走出浏览器玩具语言这个范围.</p><p>当然这既是劣势，也是优势, 现在没任何语言能撼动Javascript在浏览器中的地位。</p><p>我想很多人跟我当初一样认为<strong>浏览器提供的Web API === Javascript的标准库</strong>, 比如<code>console.log</code>、<code>setTimeout</code>(下文会介绍这些功能都不在Javascript规范里面). 正如当年那些把JQuery当成‘Javascript’的人.</p><p>直到NodeJS的出现，Javascript才挣脱浏览器约束，延伸到服务器领域, 不再是一个’沙盒语言’。NodeJS定义了很多模块来支撑服务端的开发, 如fs、os、Buffer、net。但是这些API一样不是Javascript的标准、也就是说<strong>NodeJS !== Javascript</strong>.</p><p>再到后来，学不动了，NodeJS原作者吐槽了一通NodeJS，又搞出了一个<a href="https://deno.land" target="_blank" rel="noopener">Deno</a>, 它也会有自己标准库，会定义自己的文件系统、网络API。从名字上就暗示着这些API不可能和NodeJS兼容。Ok，现在回到文章开始那个问题，<strong>如果deno发展起来，说不定哪天又有人尝试在浏览器引用Deno的模块</strong>？</p><p><br><br><br></p><h2 id="现有的javascript-api结构"><a href="#现有的javascript-api结构" class="headerlink" title="现有的Javascript API结构"></a>现有的Javascript API结构</h2><p><img src="/images/js-stdlib/outline.png" alt></p><p>如上图, Javascript其实是有一层比较薄全局的、通用的、<strong>标准的</strong>、核心的API层，即<code>标准内置对象</code>，这是一些语言核心的内置对象，可以全局访问。关键的是这些是标准的，它们在<a href="https://tc39.es/ecma262/#sec-global-object" target="_blank" rel="noopener">ECMAScript规范</a>中被定义. 在这个基础之上，不同的运行环境拓展了自己的API。</p><p>以浏览器为例:</p><p><img src="/images/js-stdlib/brw.png" alt></p><p>浏览器端的Web API是一个非常复杂API集合，上图总结了一下，基本就包含两块东西:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" target="_blank" rel="noopener">Core DOM</a>. DOM是一个通用的技术，不仅仅局限于浏览器，这个规范定义了结构化(structured document)文档的解析和操作规范。定义了基本的节点类型和操作方法。不局限于HTML的操作</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM" target="_blank" rel="noopener">HTML DOM</a>. 可以认为是Core DOM的扩展，这里面定义了各种HTML元素对象类型、扩展了元素的操作方法，另外还包含了浏览器相关的接口，如XMLHttpRequest。这一块通常也被统称为BOM</li></ul><p>WebAPI基本概览:</p><p><img src="/images/js-stdlib/webAPI.png" alt></p><p>如果你有留心查看MDN文档下面的规范引用，你会发现有些规范引用了<a href="https://www.w3.org/TR/" target="_blank" rel="noopener">W3C</a>, 有些则引用了<a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="noopener">WHATWG</a>. 到底谁说了算?</p><p>如果你掀开锅盖，就会发现这是一场闹剧. 如果前阵子有关注新闻，会看到这些标题‘<em>WHATWG 击败 W3C，赢得 HTML 和 DOM 的控制权</em>’、’<em>W3C将与WHATWG合作制定最新HTML和DOM规范标准</em>‘. 大概可以猜出这两个组织之间的关系. 本文就不扯这些‘八卦’了，相关背景可以看这篇文章<a href="https://www.infoq.cn/article/bsvFxt96DOh-SBZphBwJ" target="_blank" rel="noopener">WHATWG 击败 W3C，赢得 HTML 和 DOM 的控制权</a></p><p>相对而言, 语言层则由ECMAScript规范定义的，比较独立, 近些年成果也比较显著.</p><p><br></p><h3 id="标准内置对象层主要包含这些东西"><a href="#标准内置对象层主要包含这些东西" class="headerlink" title="标准内置对象层主要包含这些东西"></a>标准内置对象层主要包含这些东西</h3><ul><li>特殊值<ul><li>Infinity</li><li>NaN</li><li>undefined</li><li>null</li><li>globalThis</li></ul></li><li>函数<ul><li>eval()</li><li>uneval() </li><li>isFinite()</li><li>isNaN()</li><li>parseFloat()</li><li>parseInt()</li><li>decodeURI()</li><li>decodeURIComponent()</li><li>encodeURI()</li><li>encodeURIComponent()</li></ul></li><li>基础对象<ul><li>Object</li><li>Function</li><li>Boolean</li><li>Symbol</li><li>Error</li><li>EvalError</li><li>InternalError </li><li>RangeError</li><li>ReferenceError</li><li>SyntaxError</li><li>TypeError</li><li>URIError</li></ul></li><li>数值和时间<ul><li>Number</li><li>BigInt</li><li>Math</li><li>Date</li></ul></li><li>文本处理<ul><li>String</li><li>RegExp</li></ul></li><li>索引容器<ul><li>Array</li><li>‘TypedArray’</li></ul></li><li>键值容器<ul><li>Map</li><li>Set</li><li>WeakMap</li><li>WeakSet</li></ul></li><li>结构化数据<ul><li>ArrayBuffer</li><li>SharedArrayBuffer </li><li>Atomics </li><li>DataView</li><li>JSON</li></ul></li><li>控制抽象化对象<ul><li>Promise</li><li>Generator</li><li>GeneratorFunction</li><li>AsyncFunction </li></ul></li><li>反射<ul><li>Reflect</li><li>Proxy</li></ul></li><li>国际化<ul><li>Intl</li></ul></li><li>WebAssembly</li><li>其他<ul><li>arguments</li></ul></li></ul><p><br></p><p>这些全局基本对象数量很少, 这些对象是每个JavaScript开发者必须掌握的. </p><p>平时我们使用的非常频繁的Timer和Console都不再此列.</p><p>这些对象只能满足很基本开发需求, 根本不能和其他语言的标准库相比. <strong>当然这和语言的定位也有一定关系</strong></p><p><br><br><br></p><h2 id="什么是标准库"><a href="#什么是标准库" class="headerlink" title="什么是标准库?"></a>什么是标准库?</h2><p>标准库没有一个严格的定义，按照Wiki的说法标准库就是<strong>该语言在不同实现中都按例提供的库</strong>, 比如Ruby官方实现cRuby和基于JVM的JRuby都按照官方标准库规范实现了标准库。 <strong>标准库怎么设计，需要包含什么内容取决于语言各自秉持的哲学和定位</strong>。 我认为标准库应该有以下特征:</p><ul><li>标准化的. 有规范明确定义它的内容和行为</li><li>内容经过仔细雕琢和挑选，可以覆盖大部分使用场景或者符合的语言定位</li><li>可选的、按需导入. 标准库不是全局的，需要通过模块导入, 非强制性使用</li></ul><p><br></p><p>至于标准库需要包含什么内容，可以参考其他语言的实现。比如：</p><ul><li><a href="https://golang.org/pkg/" target="_blank" rel="noopener">go</a></li><li><a href="http://ruby-doc.org/stdlib-2.6.3/" target="_blank" rel="noopener">ruby</a></li><li><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">python</a></li></ul><p><br></p><p>大概分析一下，它们标准库大致都有这些内容：</p><ul><li>网络协议</li><li>文件系统<ul><li>文件系统</li><li>流</li><li>标准输入输出</li><li>二进制处理</li></ul></li><li>算法<ul><li>密码算法</li><li>编码</li><li>压缩、归档</li><li>排序</li><li>数学</li><li>字符串、文本</li></ul></li><li>数据结构, 例如树、堆、队列等等</li><li>数据持久化和序列化. 比如JSON序列化，二进制序列化，数据库操作等等</li><li>调试/辅助</li><li>单元测试</li><li>文档处理</li><li>设计模式. 标准库中经常会携带(或辅助设计)该语言的最佳实践和设计模式, 例如go中的context, Ruby中的singleton</li><li>国际化</li><li>时间、日期</li><li>操作系统<ul><li>命令行</li><li>环境变量</li><li>系统资源</li></ul></li><li>并发<ul><li>进程</li><li>线程</li><li>协程</li></ul></li><li>语言或运行时的底层接口</li></ul><p>大部分语言的核心都很小(C++除外)，我们学一门语言，大部分时间是花在标准库上和语言的生态上面，但是你会发现这些标准库一般都是大同小异，这就是为什么有经验的开发者可以很快地入手一门语言.</p><p>显然上面这些功能大部分在NodeJS中已经实现了，<strong>鉴于NodeJS这么广泛的使用率，NodeJS可以算是事实上的标准了</strong></p><p><br></p><h2 id="我们需要标准库"><a href="#我们需要标准库" class="headerlink" title="我们需要标准库?"></a>我们需要标准库?</h2><p><img src="/images/js-stdlib/dep.png" alt></p><p>显然要结合当前的背景来辩证地考虑。</p><p><strong>有标准库有什么好处?</strong></p><ul><li>标准库提供通用、定义良好、优化的功能和行为，减少第三方模块依赖, 而且第三方库很难保证质量</li><li>避免社区割裂, 抚平不同运行环境的差异. 现在有NodeJS、后面有Deno，可能还会有Aeno、Beno, 尽管取代NodeJS的可能性很低，有规范化的标准库可以避免重复造轮子，不然真会学不动</li><li>安全性. <a href="https://mp.weixin.qq.com/s/UEPZwFuousrRVj17zZU80w" target="_blank" rel="noopener">近期npm安全事件频发</a>，投毒、删库(left-pad事件)、npm商业运作, 给社区带了不少麻烦。而标准库由运行环境内置，可以避免引用第三方库导致的安全问题</li><li>今天的Javascript应用会有很多依赖(node_modules hell)，打包出来的体积很大，网络加载和脚本解析需要耗费一定的资源，而且这些资源不能在多个应用之间被缓存. 一个很大的原因是npm的依赖过于零碎(比如几行代码的包)和重复(依赖不同的版本、Dead Code)，使用标准库可以减少这部分依赖</li><li>选择困难症. 没有标准库，可以选择npm上的第三方库，在npm上挑选靠谱、高质量的库是需要一定的时间成本的. 有时候我们就是懒得去比较和选择</li><li>优雅的标准库，是学习的榜样. 网上很多教程都是钻研标准库算法和实现的，对语言的开发者来说标准库是一块宝藏</li><li>学习成本。其他语言的开发者，可以较快入手</li></ul><p><br></p><p><strong>标准库可能会有什么问题?</strong></p><ul><li>标准可能滞后跟不上社区发展. Javascript正处于快速发展阶段，很多规范的定义是由社区驱动的，比如Promise、async/await. 跟不上社区的发展结果可能就是没人用</li><li>想下WebComponent目前的境遇</li><li>标准库不可能满足所有人的口味</li></ul><p><br></p><p><strong>如何设计标准库? 标准库推进进程可能会有什么障碍?</strong></p><ul><li>NodeJS已经是事实上的标准, 怎么兼容现有的生态?</li><li>标准库应该包含什么内容，如何保持和社区同步?</li><li><p>如何把控标准库内容的尺度? </p><p>最小化的标准库容易被维护和升级，但可能出现’没什么卵用’的情况；</p><p>最大化的标准库，例如Java的标准库，几乎包含了所有的东西，开发者可以快速开发一个东西, 但是过了几年很多API就会变得过时，一般为了保持向下兼容，这些API会一直像一根刺一样卡在那里.<br>另一个非常典型的反例就是PHP的标准库，这里可以看到各种风格的API.</p><p>标准库是跟随语言发布的，如果你的项目中使用了过时的API，又想升级语言版本，就需要重构项目。而使用第三方库则可能可以保持不动。</p></li><li><p>Javascript的主要战场还是浏览器, 标准库是否应该有一个’基本版’(用于浏览器或者一些抽象操作系统的运行环境), 还有个’旗舰版’(服务端), 或者只提供一个跨越所有平台的标准库?</p></li><li>如何处理兼容性问题? 老旧浏览器如何Polyfill?</li><li>如何与现有的全局对象或用户模块分离？</li></ul><p><br></p><h2 id="近期的一些尝试"><a href="#近期的一些尝试" class="headerlink" title="近期的一些尝试"></a>近期的一些尝试</h2><ul><li><a href="https://github.com/tc39/proposal-javascript-standard-library" target="_blank" rel="noopener">proposal-javascript-standard-library</a> 这是一个非常早期的语言提议，定义了如何引用标准库(built-in modules)，但是没有定义标准库的内容</li><li><p><a href="https://developers.google.com/web/updates/2019/03/kv-storage" target="_blank" rel="noopener">KV Storage: the Web’s First Built-in Module</a> Chrome在年初推出的实验性功能，尝试实现proposal-javascript-standard-library提议. 它通过下面方式来引用‘标准库’模块:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;storage, StorageArea&#125; <span class="keyword">from</span> <span class="string">'std:kv-storage'</span>; <span class="comment">// std: 前缀，和普通模块区分开来</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从一个SegmentFault上的一个问题开始，对比其他语言，揭露Javascript没有标准库的窘境. 接着介绍现有Javascript的API结构，介绍什么是标准库，辩证考虑标准库的优缺点，以及推行上面可能会遇到的阻碍.</p><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://www.infoworld.com/article/3048833/brendan-eich-javascript-standard-library-will-stay-small.html" target="_blank" rel="noopener">Brendan Eich: JavaScript standard library will stay small</a></li><li><a href="https://medium.com/@thomasfuchs/what-if-we-had-a-great-standard-library-in-javascript-52692342ee3f" target="_blank" rel="noopener">What if we had a great standard library in JavaScript?</a></li><li><a href="https://www.i-programmer.info/news/167-javascript/12608-the-javascript-standard-library.html" target="_blank" rel="noopener">The JavaScript Standard Library</a></li><li><a href="https://www.w3.org/TR/" target="_blank" rel="noopener">W3C</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API" target="_blank" rel="noopener">Web API 索引</a></li><li><a href="https://dev.to/sloan/explain-like-im-five-whats-a-standard-library-4gi" target="_blank" rel="noopener">Explain Like I’m Five: What’s a standard library?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在SegmentFault热心解题，一个问题比较让我比较印象深刻：&lt;em&gt;一个初学者试图在浏览器中导入Node.js的net模块。结果在控制台打印后是一个空对象&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;对于有点Javascript经验的人来说，这是一个‘弱智’问题，怎么可以在浏览器端
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你需要知道的软件测试类型和常识</title>
    <link href="https://bobi.ink/2019/07/10/typeof-testing/"/>
    <id>https://bobi.ink/2019/07/10/typeof-testing/</id>
    <published>2019-07-09T16:00:00.000Z</published>
    <updated>2019-07-14T14:00:23.180Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接: <a href="https://www.softwaretestinghelp.com/types-of-software-testing/" target="_blank" rel="noopener">Types Of Software Testing: Different Testing Types With Details</a></p><blockquote><p>文章为意译，并且在原文的基础之上进行演绎和扩展</p></blockquote><blockquote><p>文章篇幅较长，阅读完大概20min，读完会有收获。欢迎点赞收藏关注</p></blockquote><p><br></p><p><img src="/images/typeof-testing/Types-of-Testing1.jpg" alt></p><p><br></p><p>有多少软件测试类型呢?</p><p>我们作为测试人员了解很多种不同的软件测试类型，例如功能测试(Functional Test)、非功能测试、自动测试、敏捷测试、以及它们的各种子类型. 尽管在我们的测试过程中会接触很多种测试类型, 或者听说过某些测试类型，但是很少人敢说精通所有的测试类型.</p><p>每个测试类型都有自己的特点、优势和劣势。所以我写这篇文章，科普一下我们今天最常用的测试类型.</p><p><br></p><h2 id="不同的软件测试类型"><a href="#不同的软件测试类型" class="headerlink" title="不同的软件测试类型"></a>不同的软件测试类型</h2><p><img src="/images/typeof-testing/Types-of-Software-Testing.jpg" alt></p><p>下面是软件测试的通用类型列表</p><ul><li><p>功能测试类型:</p><ul><li>单元测试(Unit testing)</li><li>集成测试(Integration testing)</li><li>系统测试(System testing)</li><li>健全性测试(Sanity testing)</li><li>冒烟测试(Smoke testing)</li><li>接口测试(Interface testing)</li><li>回归测试(Regression testing)</li><li>Beta/验收测试(Beta/Acceptance testing)</li></ul></li><li><p>非功能测试类型:</p><ul><li>性能测试(Performance Testing)</li><li>负载测试(Load testing)</li><li>压力测试(Stress testing)</li><li>容量测试(Volume testing)</li><li>安全测试(Security testing)</li><li>兼容性测试(Compatibility testing)</li><li>安装测试(Install testing)</li><li>恢复测试(Recovery testing)</li><li>可靠性测试(Reliability testing)</li><li>可用性测试(Usability testing)</li><li>一致性测试(Compliance testing)</li><li>本地化测试(Localization testing)</li></ul></li></ul><p>来看看这些测试类型的细节</p><p><br></p><h2 id="0-a-b测试-a-b-testing"><a href="#0-a-b测试-a-b-testing" class="headerlink" title="0) A/B测试(A/B Testing)"></a>0) A/B测试(A/B Testing)</h2><p><img src="/images/typeof-testing/ab.png" alt></p><p>顾名思义， <a href="https://maxket.com/ab-test-best-practice/" target="_blank" rel="noopener">A/B测试</a>就是准备两个(A/B)或两个以上的版本，让不同的用户来随机访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。如上图，谷歌使用A/B测试来决定导航应该是红色还是蓝色。</p><p><br></p><h2 id="1-alpha测试-alpha-testing"><a href="#1-alpha测试-alpha-testing" class="headerlink" title="1) Alpha测试(Alpha Testing)"></a>1) Alpha测试(Alpha Testing)</h2><p><strong><a href="https://www.softwaretestinghelp.com/what-is-alpha-testing-beta-testing/" target="_blank" rel="noopener">Alpha测试</a>这是软件工程中很常见的测试类型。它的目标就是尽可能地在发布到市场或交付给用户之前找出所有的问题和缺陷</strong>。</p><p>Alpha测试一般在开发的末段且在Beta测试之前进行。在这个测试过程中可能会驱动开发者进行一些小(minor)的设计变动. Alpha测试一般在开发者网站进行，即只对开发者或内部用户开放，一般可以为此类测试创建内部虚拟的用户环境。</p><p><br></p><p>一般大型的软件项目都有规范化的<strong>软件版本周期</strong>:</p><p><img src="/images/typeof-testing/alpha-testing.png" alt></p><ul><li><strong>Pre-alpha</strong>: 有时候软件会在Alpha或Beta版本前先发布Pre-alpha版本, 相比Alpha和Beta，这是一个功能不完整的版本</li><li><strong>Alpha</strong>: Alpha版本功能还没完善，需要进一步测试。Alpha版本通常会发送到开发软件的组织或某群体中的软件测试者进行内部测试。</li><li><strong>Beta</strong>: 一般Beta版本会包含所有功能，但可能又有一些Bug，需要调试反馈。 Beta版本是软件最早对外公开的软件版本，由公众（通常为公司外的第三方开发者和业余玩家）参与测试。</li><li><strong>Release Candidate(rc)</strong>: 发布候选版本，如果没有出现问题则可发布成为正式的版本。这个版本包含完整且比较稳定的功能</li></ul><p>举一个典型的例子, 最近把我<a href="https://juejin.im/pin/5d1ecb656fb9a00259a176a5" target="_blank" rel="noopener">坑得有点惨</a>的iOS13的发布计划:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">June 3: iOS 13 beta 1 and first look at WWDC 2019                 # -&gt; WWDC后就可以装的，相当于pre-alpha或Alpha阶段吧</span><br><span class="line">June 17: iOS 13 beta 2 launched for developers</span><br><span class="line">June 24: iOS 13 public beta release date for adventurous testers  # -&gt; 公开Beta版本，相当于上面说的Beta阶段</span><br><span class="line">July 3: iOS 13 developer beta 3 launch with some new features     </span><br><span class="line">July 8: iOS 13 public beta 2 release date</span><br><span class="line">Early September 2019: iOS 13 Golden Master (final dev beta)       # -&gt; 九月初，该发最终Beta版本了，相当于进入RC阶段了</span><br><span class="line">Mid-September 2019: iOS 13 likely to launch with new 2019 iPhones # -&gt; 正式版本</span><br></pre></td></tr></table></figure><p><br></p><p>现在很多开源项目，已经淡化了瀑布式的软件版本周期，变成一种持续(Continuous)的、常态化的行为, 例如Firefox:</p><p><img src="/images/typeof-testing/firefox.png" alt></p><p><br></p><h2 id="2-验收测试-acceptance-testing"><a href="#2-验收测试-acceptance-testing" class="headerlink" title="2) 验收测试(Acceptance Testing)"></a>2) 验收测试(Acceptance Testing)</h2><p><strong><a href="https://www.softwaretestinghelp.com/what-is-acceptance-testing/" target="_blank" rel="noopener">验收测试</a>通常是部署软件之前的最后一个测试操作, 也称为交付测试, 由最终客户执行，他们会验证端到端(end to end)的系统流程是否符合业务需求，以及功能是否是满足最终用户的需求</strong>。只有当所有的特性和功能按照期望的运行，客户才会接受软件</p><p>这是测试的最后阶段，在验收测试之后，软件将投入生产环境. 所以它也叫用户验收测试(UAT)</p><p><img src="/images/typeof-testing/accept.png" alt></p><p>举个例子，验收测试就相当于收快递, 包裹是软件、你就是客户，是验收方，如果货物不符合你的要求，是要退货的。</p><p><br></p><h2 id="3-临时测试-ad-hoc-testing"><a href="#3-临时测试-ad-hoc-testing" class="headerlink" title="3) 临时测试(Ad-hoc Testing)"></a>3) 临时测试(Ad-hoc Testing)</h2><p>Ad-hoc中文应该理解为临时的意思。顾名思义，这种测试是在临时基础上进行的, 有时候也称为随机测试。即没有参考测试用例、没有针对该测试的任何计划和文档。Ad-hoc测试的目的就是<strong>通过执行随意的流程或任意的功能来找出应用的缺陷和问题</strong></p><p>Ad-hoc测试一种非正式的方法，可以由项目中的任何人执行。尽管没有测试用例很难识别缺陷，但是有些时候在Ad-hoc测试期间发现的缺陷可能无法使用现有的测试用例来识别, <strong>也就是说它一般用来发现‘意外’的缺陷</strong>.</p><p><br></p><h2 id="4-可访问性测试-accessibility-testing"><a href="#4-可访问性测试-accessibility-testing" class="headerlink" title="4) 可访问性测试(Accessibility Testing)"></a>4) 可访问性测试(Accessibility Testing)</h2><p><strong>可访问性测试的目的是确定软件或应用程序是否可供残疾人使用</strong>。残疾是指聋人，色盲，智障人士，失明者，老年人和其他残疾人群体。这里会执行各种检查，例如针对视觉残疾的字体大小测试，针对色盲的颜色和对比度测试等等。</p><p>不同平台、不同应用类型对可访问性支持情况不太一样，比如iOS相比其他操作系统则更重视可访问, 而国外比国内更重视可访问性。</p><p><img src="/images/typeof-testing/acs.png" alt></p><p><br></p><h2 id="5-beta测试-beta-testing"><a href="#5-beta测试-beta-testing" class="headerlink" title="5) Beta测试(Beta Testing)"></a>5) Beta测试(Beta Testing)</h2><p>上文Alpha测试已经提及Beta测试, <strong>Beta测试是一种正式的软件测试类型，在将产品发布到市场或者实际最终用户之前，由客户在真实的应用环境中执行</strong>。</p><p>执行Beta测试目的是确保软件或产品中没有重大故障，并且满足最终用户的业务需求。当客户接受软件时，Beta测试才算通过。</p><p>通常，此类测试由最终用户或其他人完成。这是在将应用发布作为商业用途之前完成的最终测试。通常，发布的软件或产品的Beta版本仅限于特定区域中的特定数量的用户。<br>所以最终用户实际使用软件后会将一些问题反馈给公司。公司可以在全面发布之前采取必要的措施。</p><p>Beta测试在正式版本之前也可能会迭代进行多次.</p><p><br></p><h2 id="6-后端测试-back-end-testing"><a href="#6-后端测试-back-end-testing" class="headerlink" title="6) 后端测试(Back-end Testing)"></a>6) 后端测试(Back-end Testing)</h2><p>前端应用输入的数据，一般都会存储在数据库，所以针对数据库的这类测试称为<strong>数据库测试或者后端测试</strong>. 市面有不同的数据库，如SQL Server，MySQL和Oracle等。数据库测试会涉及表结构，模式，存储过程，数据结构等。</p><p>后端测试一般不会涉及GUI，测试人员通过某些手段直接连接到数据库，从而可以容易地运行一些数据库请求来验证数据。<strong>通过后端测试可以发现一些数据库问题，比如数据丢失、死锁、数据损坏。这些问题在系统投入生产环境之前进行修复至关重要</strong></p><p><br></p><h2 id="7-浏览器兼容测试-browser-compatibility-testing"><a href="#7-浏览器兼容测试-browser-compatibility-testing" class="headerlink" title="7) 浏览器兼容测试(Browser Compatibility Testing)"></a>7) 浏览器兼容测试(Browser Compatibility Testing)</h2><p><img src="/images/typeof-testing/brw.png" alt></p><p>这是兼容性测试的子类型，由测试团队执行. <strong><a href="http://frontend.turing.io/lessons/module-2/cross-browser-compat.html" target="_blank" rel="noopener">浏览器兼容测试</a>主要针对Web应用，用于确保软件可以在不同浏览器或操作系统中运行; 或者验证Web应用程序是否支持在浏览器的所有版本上运行, 以确定应用最终兼容的范围</strong>.</p><p>浏览器兼容测试是前端开发者绕不开的坑。</p><p>我们有很多<strong>策略</strong>来应对浏览器兼容性，比如渐进增强或者优雅降级, 还有制定浏览器兼容规范; </p><p>为了<strong>抚平浏览器之间的差异</strong>，我们会使用各种特性检测工具(Modernizr), 还有各种polyfill(CSS Normaliz, polyfill/shim, css-autoprefixer);</p><p>当然为了<strong>测试跨浏览器兼容性</strong>，还要一些辅助工具，例如<a href="https://www.browserstack.com/" target="_blank" rel="noopener">BrowserStack</a>, 对于我们这些小团队，只能下一堆Portable(<em>Portable浏览器运行时相互隔离的, 所以不会存在配置文件等冲突问题</em>) 浏览器，手工测试了。</p><p><br></p><h2 id="8-后向兼容测试-backward-compatibility-testing"><a href="#8-后向兼容测试-backward-compatibility-testing" class="headerlink" title="8) 后向兼容测试(Backward Compatibility Testing)"></a>8) 后向兼容测试(Backward Compatibility Testing)</h2><p><strong>向后兼容测试, 用于验证新开发或更新的软件是否能在旧版本的环境中运行</strong>。</p><p>比如向后兼容测试会检查新版软件是否可以正确地处理旧版本软件创建的文件格式。例如新版的Office 2016是否可以打开2012创建的文件。</p><p>同理也可以检查新版本是否可以兼容旧版本软件创建的数据表、数据文件、数据结构、配置文件。 </p><p>任何软件更新应该在先前版本的基础之上良好地运行</p><p><br></p><h2 id="9-黑盒测试-black-box-testing"><a href="#9-黑盒测试-black-box-testing" class="headerlink" title="9) 黑盒测试(Black Box Testing)"></a>9) 黑盒测试(Black Box Testing)</h2><p><img src="/images/typeof-testing/black-box.png" alt></p><p>黑盒测试不考虑软件的内部系统设计，它基于需求和功能进行测试, 只关心系统的输入/输出以及功能流程。 </p><p>换句话说<strong>黑盒测试从用户的角度出发针对软件界面、功能及外部结构进行测试，而不考虑程序内部逻辑结构</strong>.</p><p>黑盒测试下面有很多子类，例如集成测试、系统测试、大部分非功能性测试</p><p>关于黑盒测试的优缺点以及测试类型可以看<a href="https://www.softwaretestinghelp.com/black-box-testing/" target="_blank" rel="noopener">这里</a></p><p><br></p><h2 id="10-边界值测试-boundary-value-testing"><a href="#10-边界值测试-boundary-value-testing" class="headerlink" title="10) 边界值测试(Boundary Value Testing)"></a>10) 边界值测试(Boundary Value Testing)</h2><p><strong>边界值测试, 测试应用处于边界条件(boundary level)的行为</strong>。很多边界条件开发者是很难考虑周到的，所以才有一个专门的测试类型来验证这种情况</p><p>边界值测试检查应用处于边界值时是否存在缺陷。边界值测试通常用于测试不同范围的数字, 每个范围都有一个上下边界，边界测试则是针对这些边界值进行测试。</p><p>比如数字范围为1-500, 那么边界值测试会在这些值上进行验证: 0、1、2、499、500、501</p><p><br></p><h2 id="11-分支测试-branch-testing"><a href="#11-分支测试-branch-testing" class="headerlink" title="11) 分支测试(Branch Testing)"></a>11) 分支测试(Branch Testing)</h2><p>这是白盒测试的子类型，在单元测试中实施. 顾名思义，<strong>分支测试表示测试要覆盖程序代码的各种条件分支, 避免遗漏缺陷</strong>。分支覆盖是单元测试覆盖率的一个指标之一</p><p><br></p><h2 id="12-比较测试-comparison-testing"><a href="#12-比较测试-comparison-testing" class="headerlink" title="12) 比较测试(Comparison Testing)"></a>12) 比较测试(Comparison Testing)</h2><p><img src="/images/typeof-testing/wzr.png" alt></p><p><strong>比较测试，将产品的优点和弱点与旧版本或者同类(竞品)产品进行比较.</strong></p><p>比如类似王自如这种数码测评栏目，评测一个手机或者其他数码产品时，一般会横向和友商产品进行比较，有时候也会纵向和上一代产品比较.</p><p>还有一种比较典型的例子就是和行业的领导者比较，比如我们做IM的，会经常和微信比较: ‘你这个应用的启动速度怎么比微信慢这么多?’</p><p><br></p><h2 id="13-兼容性测试-compatibility-testing"><a href="#13-兼容性测试-compatibility-testing" class="headerlink" title="13) 兼容性测试(Compatibility Testing)"></a>13) 兼容性测试(Compatibility Testing)</h2><p>这是一个大类, <strong>兼容性测试用于验证应用在不同环境、web服务器、硬件、网络条件下的行为</strong>。兼容性测试确保软件可以在不同的配置、不同的数据库、不同的浏览器，以及它们不同的版本下运行。兼容性测试由测试团队实施</p><p><br></p><h2 id="14-组件测试-component-testing"><a href="#14-组件测试-component-testing" class="headerlink" title="14) 组件测试(Component Testing)"></a>14) 组件测试(Component Testing)</h2><p><a href="https://www.guru99.com/component-testing.html" target="_blank" rel="noopener">组件测试</a>(此组件非GUI组件, 取组合测试可能更好理解一点)，<strong>一般也称为模块测试(Module Testing), 一般由开发者在完成单元测试后执行。组件测试将多个功能组合起来作为单一的整体进行测试，目的是发现多个功能在相互连接起来之后的缺陷</strong>。</p><p>组件测试可大可小，小到函数级别或者类级别的组合，大可以大到几个单独的页面、模块、子系统的组合。 举一个前端例子，将多个页面路由组合起来，测试它们的流程跳转，就属于组件测试。</p><p><img src="/images/typeof-testing/comp.png" alt></p><p><br></p><h2 id="15-端到端测试-end-to-end-testing"><a href="#15-端到端测试-end-to-end-testing" class="headerlink" title="15) 端到端测试(End-to-End Testing)"></a>15) 端到端测试(End-to-End Testing)</h2><p>端到端测试也是一种黑盒测试类型，类似于系统测试. <strong>端到端测试在模拟的、完整的、真实应用环境下模拟真实用户对应用进行测试，比如应用会和数据库交互、会使用网络通信、或者在适当的情况下和其他硬件、应用、系统进行交互</strong>. 端到端是指从一个端点到另一个端点的意思，所以端到端测试重点用于测试模块和模块之间的协调性。</p><p>当应用是分布式系统或者需要和其他外部系统协同时，端到端测试扮演着非常重要的角色, 它可以全面检查以确保软件在不同平台和环境产品能准确地交互。端到端测试有以下目的:</p><ul><li>确保应用可以和外部系统之间良好的协调。对于前端来说，是确保页面和后端之间良好协调</li><li>检查从源系统到目标系统的所有系统流</li><li>从最终用户角度验证需求</li><li>识别异构环境中的问题</li></ul><p>前端也有很多自动化的端到端测试工具，比如nightwatch，通过它们可以模拟用户对页面进行操作，从而检验整个应用流程是否正常和符合需求:</p><p><img src="/images/typeof-testing/nightwatch.png" alt></p><p>因为和<strong>系统测试</strong>很相似，所以它们也被经常拿来<a href="https://www.softwaretestinghelp.com/system-vs-end-to-end-testing/" target="_blank" rel="noopener">比较</a></p><p><br></p><h2 id="16-等价划分-equivalence-partitioning"><a href="#16-等价划分-equivalence-partitioning" class="headerlink" title="16) 等价划分(Equivalence Partitioning)"></a>16) 等价划分(Equivalence Partitioning)</h2><p>等价划分, 这是一种黑盒测试的测试技术. <strong>通过等价划分，可以将所有的输入数据合理地划分为多个分组，我们只需在每个分组中取一个数据作为测试的输入条件, 这样可以实现用少量代表性的测试数据取得较好的测试结果</strong>.</p><p>所以说这个测试的目的: 是在不导致缺陷的前提下，移除指定分组中的重复的用例, 简化测试的工作</p><p><img src="/images/typeof-testing/part.png" alt></p><p>比如一个程序应用接受-10到+10之间的值，使用等价分区方法可以划分为三个分组: 0、负值、正值. 接下来的测试只需从这个三个分组中取一个成员进行测试, 而不需要-10到+10每个成员都测试一遍.</p><p><br></p><h2 id="17-实例测试-example-testing"><a href="#17-实例测试-example-testing" class="headerlink" title="17) 实例测试(Example Testing)"></a>17) 实例测试(Example Testing)</h2><p>It means real-time testing. Example testing includes the real-time scenario, it also involves the scenarios based on the experience of the testers.</p><p>实例测试意味着实时测试。实例测试包含了实时场景、另外还涉及基于测试人员经验的场景。</p><blockquote><p>🤔 这里不是特别能理解这个测试类型，所以贴上原文。知道的告诉我呀</p></blockquote><p><br></p><h2 id="18-探索测试-exploratory-testing"><a href="#18-探索测试-exploratory-testing" class="headerlink" title="18) 探索测试(Exploratory Testing)"></a>18) 探索测试(Exploratory Testing)</h2><p><img src="/images/typeof-testing/explorer.png" alt></p><p>探索性测试有点类似于Ad-Hoc测试. 探索性测试是由测试团队进行的非正式测试。此测试的目的是探索应用并查找应用中存在的缺陷。像探险一样，在测试期间是有一定几率发现的重大、甚至可能导致系统故障的缺陷.</p><p>在探索性测试期间，建议跟踪记录好测试的流程、以及开始该流程之前的活动记录, 方便复现bug.</p><p>探索测试不需要任何文档和测试用例.</p><p><br></p><h2 id="20-功能测试-functional-testing"><a href="#20-功能测试-functional-testing" class="headerlink" title="20) 功能测试(Functional Testing)"></a>20) 功能测试(Functional Testing)</h2><p>功能测试是一个大类, 又称为行为测试，  <strong>功能测试会忽略内部实现而关注组件的输出，目的是验证是否符合需求，这是一种面向功能需求的黑盒测试类型</strong>。关于功能测试的细节请看<a href="https://www.softwaretestinghelp.com/guide-to-functional-testing/" target="_blank" rel="noopener">这里</a></p><p>功能测试是相对非功能测试而言的, 功能测试需要关心功能或者业务，需要业务耦合程度高；而非功能测试则是通用的，比如压力测试、负载测试，这些测试都有通用的工具来支持，不需要或很少定制化操作.</p><p><br></p><h2 id="21-gui测试-graphical-user-interface-gui-testing"><a href="#21-gui测试-graphical-user-interface-gui-testing" class="headerlink" title="21) GUI测试(Graphical User Interface (GUI) Testing)"></a>21) GUI测试(Graphical User Interface (GUI) Testing)</h2><p>GUI测试的目的是根据业务需求验证GUI。在详细设计文档和GUI模型(UI设计文档)中一般会提到应用期望的GUI.</p><p>常见的GUI测试包括测试屏幕上显示的按钮和输入字段的大小、表格中所有文本、表格或内容的对齐规则等等. 如果团队有UI设计规范，还会验证是否符合设计规范</p><p><br></p><h2 id="22-大猩猩测试-gorilla-testing"><a href="#22-大猩猩测试-gorilla-testing" class="headerlink" title="22) 大猩猩测试(Gorilla Testing)"></a>22) 大猩猩测试(Gorilla Testing)</h2><p><img src="/images/typeof-testing/gr.jpg" alt></p><p>大猩猩测试是由测试人员执行的测试类型，有时也由开发人员执行。在大猩猩测试中，对模块中的一个模块或功能进行了彻底和严格的测试。原文没有说出大猩猩测试的精髓，大猩猩测试会对一个功能或模块进行重复‘上百次’的测试, 人类根本受不了这样子的测试方式，所以大猩猩测试的另一个别名是‘令人沮丧的测试(Frustrating Testing)’</p><p>这种测试的目的是检查应用程序的稳健性(robustness)</p><p><br></p><h2 id="23-乐观路线测试-happy-path-testing"><a href="#23-乐观路线测试-happy-path-testing" class="headerlink" title="23) 乐观路线测试(Happy Path Testing)"></a>23) 乐观路线测试(Happy Path Testing)</h2><p><strong>乐观路线测试</strong>的目标是在正常流程上成功测试应用。它不会考虑各种负面或异常情况。重点只关注于验证应用在有效和合法输入的条件下生成期望的输出. 比如银行付款，只考虑账户有钱的正常状态😂</p><p><br></p><h2 id="24-增量集成测试-incremental-integration-testing"><a href="#24-增量集成测试-incremental-integration-testing" class="headerlink" title="24) 增量集成测试(Incremental Integration Testing)"></a>24) 增量集成测试(Incremental Integration Testing)</h2><p>增量集成测试是一种自下而上的测试方法，即在添加新功能时立即集成应用程序进行连续测试。应用程序功能和模块应该足够独立，以便单独测试。这通常由程序员或测试人员完成。</p><p><br></p><h2 id="25-安装卸载测试-install-uninstall-testing"><a href="#25-安装卸载测试-install-uninstall-testing" class="headerlink" title="25) 安装卸载测试(Install/Uninstall Testing)"></a>25) 安装卸载测试(Install/Uninstall Testing)</h2><p><img src="/images/typeof-testing/blue-screen.jpg" alt></p><p>安装和卸载测试是在不同硬件或软件环境下的不同操作系统上的进行完整/部分的安装、升级、卸载、回滚等测试. 常用于桌面端应用</p><p><br></p><h2 id="26-集成测试-integration-testing"><a href="#26-集成测试-integration-testing" class="headerlink" title="26) 集成测试(Integration Testing)"></a>26) 集成测试(Integration Testing)</h2><p>集成测试是指将所有模块集成之后，验证合并后的功能. 模块通常是代码模块、单个应用、网络上的客户端和服务器应用等等。</p><p><img src="/images/typeof-testing/ingr.png" alt></p><p>集成测试一般在单元测试之后，所以单元测试是集成测试的基础，没有进行单元测试的集成测试是不靠谱的。所以最简单的形式是：’把两个已经测试过的单元组合成一个组件，测试它们之间的接口’。也就是说<strong>集成测试在单元测试的基础之上，将单元测试中独立的单元合并起来，验证它们的协调性, 合并后的组件又是一个新的‘单元’，这样逐步合并测试，最终形成完整的应用程序</strong>。</p><p>这种类型的测试常用于B/S软件和分布式系统。</p><p><br></p><h2 id="27-负载测试-load-testing"><a href="#27-负载测试-load-testing" class="headerlink" title="27) 负载测试(Load Testing)"></a>27) 负载测试(Load Testing)</h2><p>它是一种非功能性测试，负载测试的目的是检查系统可以承受多少负载而不会降低性能, 或者说确定最大工作负载是多少。</p><p>负载测试有助于查找特定负载下系统的最大容量以及导致软件性能下降的任何原因。可以使用JMeter，LoadRunner，WebLoad，Silk执行程序等工具执行负载测试。</p><p><img src="/images/typeof-testing/perf.png" alt></p><p>负载测试经常和性能测试、压力测试、稳定性测试等联系在一起。如上图(来源于淘宝性能白皮书). 其中TPS(Transation Per Second)指的是每秒钟系统可以处理的交易或事务的数量; Server Resource指的是系统资源占有.</p><ul><li><strong>性能测试</strong>. 主要位于a-b之间. 在系统设计初期就会规划一个预期目标, 比如给定资源Ax，a点就是性能期望值。也就是说在给定固定资源Ax的情况下，如果TPS可以达到a点甚至更高，就说明系统性能达到或者好于预期. <strong>通过性能测试可以验证系统的处理能力有没有达到预期</strong></li><li><strong>负载测试</strong>. 位于b-c之间。对系统不断增加并发请求，直到系统的某项或者多项指标达到安全的临界值，如上图中的c，这个c就是所谓的最大负载量。后面再增加请求压力，系统的处理能力不但不能提高，返回会下降. <strong>通过压力测试可以得出系统最大的安全负载值</strong></li><li><strong>压力测试</strong>. 位于c-d之间。在超过安全负载的情况下，继续对系统增加压力，直到达到崩溃点, 即上图的d. <strong>通过压力测试可以得出系统的最大承受能力</strong></li><li><strong>稳定性测试</strong>. 位于a-d之间。在a、b、c、d不同的点(代表特定的硬件、软件和网络环境)，让系统运行一段较长的时间，<strong>检测系统在不同条件下的系统运行的稳定性</strong>。</li></ul><p>另外也推荐阅读&lt;&lt;大型网站技术架构&gt;&gt;这本书</p><p><br></p><h2 id="28-猴子测试-monkey-testing"><a href="#28-猴子测试-monkey-testing" class="headerlink" title="28) 猴子测试(Monkey Testing)"></a>28) 猴子测试(Monkey Testing)</h2><p><img src="/images/typeof-testing/monkey-testing.jpg" alt></p><p>猴子测试是由测试人员进行的，即把自己当成猴子，在没有任何知识背景或者理解应用前提下，随意输入和操作。</p><p>猴子测试的目标是通过提供随机输入值/数据来检查应用程序或系统是否崩溃。 猴子是随机执行的，没有测试用例, 也没有必要了解系统的全部功能</p><p><br></p><h2 id="29-变异测试-mutation-testing"><a href="#29-变异测试-mutation-testing" class="headerlink" title="29) 变异测试(Mutation Testing)"></a>29) 变异测试(Mutation Testing)</h2><p>变异测试(或者说可变性测试)是一种白盒测试，这是一种和单元测试反着来的测试类型。</p><p><img src="/images/typeof-testing/mut.png" alt></p><p><strong>通常单元测试的思路是通过测试用例来验证代码是否有效可靠，而变异测试是反过来. 它首先更改其中一个程序的源代码，再跑单元测试，如果单元测试通过则可能说明测试用例没有效果，或者测试用例没有覆盖到这处代码变异</strong>. </p><p>所以说变异测试可以反过来验证你的测试用例是否有效, 还有可以帮助我们找出一些无法被当前测试所防止的潜在错误.</p><p><br></p><h2 id="30-悲观测试-negative-testing"><a href="#30-悲观测试-negative-testing" class="headerlink" title="30) 悲观测试(Negative Testing)"></a>30) 悲观测试(Negative Testing)</h2><p>悲观测试和乐观路线测试相反, 它要求测试者要具有“打破”常规的态度，考虑各种异常情况, 使用各种邪恶的👿、不怀好意、不合法的操作来测试系统。悲观测试会使用不正确的数据、无效数据或输入来进行验证。它验证系统是否可以识别异常情况，并按预期运行。</p><p><br></p><h2 id="31-非功能测试-non-functional-testing"><a href="#31-非功能测试-non-functional-testing" class="headerlink" title="31) 非功能测试(Non-Functional Testing)"></a>31) 非功能测试(Non-Functional Testing)</h2><p>每个大型的组织都有一个独立的团队，通常称为非功能测试（NFT）团队或性能团队。</p><p>非功能性测试涉及测试非功能性需求，如负载测试、压力测试、安全性、容量，恢复测试等等. NFT测试的目标是确保软件或应用程序的响应时间是否满足业务需求。</p><p>例如加载任何页面或系统都不应该花费太多时间，并且在负载峰值期间应该维持良好运行状态。</p><p><br></p><h2 id="32-性能测试-performance-testing"><a href="#32-性能测试-performance-testing" class="headerlink" title="32) 性能测试(Performance Testing)"></a>32) 性能测试(Performance Testing)</h2><p>这个术语通常与“压力”和“负载”测试互换使用。<a href="https://en.wikipedia.org/wiki/Software_performance_testing" target="_blank" rel="noopener">性能测试</a>用于检查系统是否满足性能要求。它会使用不同的性能和负载工具来执行此测试。</p><p><a href="https://www.softwaretestinghelp.com/introduction-to-performance-testing-loadrunner-training-tutorial-part-1/" target="_blank" rel="noopener">性能测试</a>这个范围比较大，<strong>广义上的性能测试包括了上文提到的负载测试、压力测试、稳定性测试、容量测试等等。狭义的性能测试则是指在特定资源条件下，测试系统能否达到期望值, 也就是基线测试(Baseline Test).</strong></p><p>总结一下性能测试的类型:</p><ul><li><strong>基线测试(Baseline Test)</strong>: 在给定的资源下，测试最佳的性能，用作后续测量的参考‘基线’。注意基线测试和基准测试是有区别的, 这么理解，基准是你想达到的，比如100短跑世界纪录，基线是你的成绩。</li><li><strong>负载测试(Load Test)</strong>: 在预期峰值的生产负载下测量系统的性能。上文负载测试已经大概介绍了</li><li><strong>稳定性测试(Endurance Test)</strong>: 在指定负载下，长时间测量系统的稳定性</li><li><strong>压力测试(Stress Test)</strong>: 测试极端条件下的系统性能</li></ul><p><br></p><h2 id="33-恢复测试-recovery-testing"><a href="#33-恢复测试-recovery-testing" class="headerlink" title="33) 恢复测试(Recovery Testing)"></a>33) 恢复测试(Recovery Testing)</h2><p>恢复测试用于验证应用或系统中崩溃或灾难中恢复的程度. 确定系统是否能够在灾难发生后继续运行。</p><p>比如应用通过网络电缆接收数据，突然断开了网络电缆的连接, 过一段时间，再插上网线, 系统应该开始恢复由于网络电缆拔出而丢失连接的数据</p><p><br></p><h2 id="34-回归测试-regression-testing"><a href="#34-回归测试-regression-testing" class="headerlink" title="34) 回归测试(Regression Testing)"></a>34) 回归测试(Regression Testing)</h2><p>在修改任意模块或者功能后，将应用作为一个整体进行测试，称为回归测试。<strong>回归测试的目的就是验证在软件原有的功能变动后是否保持完整性</strong>. </p><p><img src="/images/typeof-testing/bug-fix.gif" alt></p><p><strong>有观点认为回归测试就是回归测试是指重复执行以前的全部或部分相同的测试工作, 其实不是不无道理。而且因为局部修改而牵一发动全身的意外在平时开发中并不少见，这种意外性就是回归测试的存在的目的</strong>.</p><p>因为在回归测试中很难覆盖所有系统，通常最好使用自动化测试工具进行这些类测试。比如每次修改完代码，跑单元测试来确保不影响确保其他软件单元。</p><p>在前端中<a href="https://jestjs.io/docs/en/snapshot-testing" target="_blank" rel="noopener">组件快照测试(Snapshot Testing)</a>和一些<a href="https://github.com/HuddleEng/PhantomCSS" target="_blank" rel="noopener">CSS UI测试</a>，都是属于回归测试类型,它们的原理都是和上一次测试生成的结果进行比对，以确保没有意外的修改:</p><p><img src="/images/typeof-testing/phantomcss.png" alt></p><p><br></p><h2 id="35-基于风险的测试-risk-based-testing-rbt"><a href="#35-基于风险的测试-risk-based-testing-rbt" class="headerlink" title="35) 基于风险的测试(Risk-Based Testing (RBT))"></a>35) 基于风险的测试(Risk-Based Testing (RBT))</h2><p>在基于风险的测试中，功能或需求将根据其优先级进行测试。基于风险的测试会优先测试高度关键的功能，因为这些功能对业务影响最大或者故障概率非常高. 而优先级由业务需求决定，因此一旦为所有功能设置了优先级，则应该首先执行高优先级功能或测试用例，然后再执行低优先级功能。 低优先级功能可以在时间充裕时测试，或者不测试。</p><p><strong>基于风险的测试应该在‘不够时间来测试整个应用，但是又要按时交付软件’的情况下执行</strong>，通常还需要客户和高级管理层的讨论和批准之后才进行</p><p><br></p><h2 id="36-完整性测试-sanity-testing"><a href="#36-完整性测试-sanity-testing" class="headerlink" title="36) 完整性测试(Sanity Testing)"></a>36) 完整性测试(Sanity Testing)</h2><p>完整性测试用于确定一个新的软件版本是否可以开始进行正式的测试，如果一个应该在一开始使用时就崩溃，那么就说明系统还不够稳定，没有必要进行下一步测试。这种情况应该打回给开发，以免浪费时间</p><p>以我们公司为例:</p><p><img src="/images/typeof-testing/smoke.png" alt></p><ul><li>在软件设计阶段，测试团队就会为编写冒烟测试用例; </li><li>开发团队在提交版本给测试之前会自己跑一下冒烟用例, 确保没有重大故障；</li><li>将版本提交给测试团队后，测试团队就会先跑一下完整性测试，检查一下有没有重大的，影响测试进程的bug，如果有则退回开发</li><li>如果通过了完整性测试, 则进行冒烟测试，如果冒烟测试没有通过也会立即打回开发。</li><li>顺利通过完整性测试和冒烟测试之后才会进入正式测试阶段。</li></ul><p>这么做的目的之一就是为了降低测试团队的工作负担，因为他们要对接多个开发团队的测试任务。</p><p><br></p><h2 id="37-安全测试-security-testing"><a href="#37-安全测试-security-testing" class="headerlink" title="37) 安全测试(Security Testing)"></a>37) 安全测试(Security Testing)</h2><p><img src="/images/typeof-testing/sec.png" alt></p><p>安全也是一个庞大的学科，而且知识每天都在更新，所以安全测试一般由特殊的安全团队执行，他们以各种黑客手段对系统进行渗透测试。</p><p>安全测试旨在确保应用或网站免受内部和外部威胁的侵害。这个测试包括预防恶意程序、病毒； 检验授权和身份验证过程的安全性。</p><p>它还会检查软件对任何黑客攻击和恶意程序的反应方式，以及在遭到黑客攻击后如何维护软件以保护数据安全</p><p><br></p><h2 id="38-冒烟测试-smoke-testing"><a href="#38-冒烟测试-smoke-testing" class="headerlink" title="38) 冒烟测试(Smoke Testing)"></a>38) 冒烟测试(Smoke Testing)</h2><p><img src="/images/typeof-testing/note7.jpg" alt></p><p>冒烟测试，每当开发团队提交新的构建时，软件测试团队就会先验证构建, 并确保不存在重大问题, 如果存在重大问题会直接打回开发团队.</p><p>如何通俗地理解冒烟测试呢？这个属于来源于硬件行业，对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。举个例子，给三星Note7加电，如果没爆炸，就说明通过了‘冒烟测试’(感觉当手机测试者不容易，容易有生命危险😂)?</p><p>测试团队在确保构建稳定后才会进一步执行详细的测试。 冒烟检查会检查构建中是否存在中断缺陷(stopper defect, 即影响继续测试的缺陷)，这将阻止测试团队进一步详细测试。 即如果测试人员发现主要功能不能工作，他们会拒绝这次构建，并退回给开发团队。</p><p>冒烟测试一般在回归测试或其他详细测试之前进行</p><p><br></p><h2 id="39-静态测试-static-testing"><a href="#39-静态测试-static-testing" class="headerlink" title="39) 静态测试(Static Testing)"></a>39) 静态测试(Static Testing)</h2><p><img src="/images/typeof-testing/review.jpg" alt></p><p>静态测试有点类似于代码Review，在不执行任何代码的情况下执行(也就是不运行应用)，它涉及对可交付成果审查(inspection)、review和演练(walkthrough). 比如检查代码语法、命名约定、项目组织。</p><p>静态测试不仅适用于代码, 也适用于测试用例、测试计划和设计文档. 如果在静态测试阶段发现缺陷，可以将缺陷成本降到最低。比如在设计阶段就发现问题，相比到开发阶段甚至到生产环境出现问题要好解决</p><p>举前端的例子，静态测试可能包括:</p><ul><li>使用Lint工具对程序进行规范检查，相关的工具有ESLint、TSLint、Stylint等, 甚至Typescript这些类型检查器也可以归到这个范畴</li><li>代码Review。有一些问题是无法通过Lint工具覆盖的，比如代码逻辑、异常捕获、项目组织、内存泄露等等，这些需要人工进行走查Review</li><li>检查代码是否与设计一致，是否符合软件需求、概要和详细设计，这不仅可以看出代码问题，也可以反过来更早发现需求或设计是否正确。</li></ul><p><br></p><h2 id="40-压力测试-stress-testing"><a href="#40-压力测试-stress-testing" class="headerlink" title="40) 压力测试(Stress Testing)"></a>40) 压力测试(Stress Testing)</h2><p><img src="/images/typeof-testing/str.jpg" alt></p><p><strong>通过压力测试，模拟系统受到超出其规格的压力时失败的方式和时间, 找出系统的崩溃点</strong>. 这个测试在高负载情况下执行的，例如存取超过容量限制的数据、执行复杂的数据库查询、连续暴力输入到系统或加载到数据库。</p><p><br></p><h2 id="41-系统测试-system-testing"><a href="#41-系统测试-system-testing" class="headerlink" title="41) 系统测试(System Testing)"></a>41) 系统测试(System Testing)</h2><p>系统测试在完整的集成系统上进行测试，也就是说<strong>系统测试一般在集成测试之后进行，集成测试之后系统成为了一个整体，系统测试在这个基础上、在真实的运行环境中验证系统是否符合业务需求</strong>。 这是一种黑盒型测试，基于总体需求规范，涵盖系统的所有组合部分。</p><p>系统测试其实不是一个具体的测试技术，而是一个测试阶段。 这个阶段会进行很多种测试，一般公司的测试团队的工作就集中在这一块。 一般包含:</p><ul><li><strong>功能测试</strong>: 即上面讲的，从系统的整体上测试是否符合业务需求</li><li><strong>各种非功能测试</strong>：例如恢复测试、性能测试、压力测试、安全测试等等。</li></ul><p>归纳一下<strong>系统测试的目的</strong>:</p><ul><li>确保应用<strong>作为一个整体</strong>可以良好地运行.</li><li>确保应用符合业务需求</li><li>确保应用在真实的环境可以良好地运行。比如进行一些非功能测试，验证系统的健壮性</li></ul><p>其实系统测试和上文说的端到端测试很像，它们要求系统作为一个整体进行测试。可以简单展开对比一下</p><table><thead><tr><th></th><th>系统测试</th><th>端到端测试</th></tr></thead><tbody><tr><td>测试范围</td><td>一般针对被测应用本身</td><td>一般针对被测应用以及其依赖的其他系统。正如其名，端到端，即从一端点到另一端点。重点关注前端、后端以及中间件之间的处理流程</td></tr><tr><td>测试类型</td><td>包含功能测试和非功能测试</td><td>一般涵盖所有源系统和目标系统之间的接口级别的测试</td></tr><tr><td>测试时机</td><td>一般在集成测试之后</td><td>一般在系统测试之后</td></tr></tbody></table><p><br></p><h2 id="42-单元测试-unit-testing"><a href="#42-单元测试-unit-testing" class="headerlink" title="42) 单元测试(Unit Testing)"></a>42) 单元测试(Unit Testing)</h2><p><img src="/images/typeof-testing/unit-test.png" alt></p><p><strong>测试独立的软件单元或模块称为单元测试</strong>。它通常由开发者完成，而不是由测试人员完成，因为它需要详细了解内部程序设计和代码。</p><p>单元测试是和我们开发者最密切相关的测试类型。它的测试对象是软件单元。<strong>软件单元可以是一个函数/方法、一个类或者一个GUI组件等</strong>。</p><p>这是一种白盒测试，所以要求由开发者自己进行，因为只有开发者才知道单元的内部实现。<strong>单元测试一般会使用测试覆盖率来验证单元测试的完成度</strong>. </p><p>前端常见的单元测试工具有Jest、Mocha、Jasmine等等. 下面是典型的BDD风格的单元测试组织:</p><p><img src="/images/typeof-testing/bdd.png" alt></p><p><br></p><h2 id="43-可用性测试-usability-testing"><a href="#43-可用性测试-usability-testing" class="headerlink" title="43) 可用性测试(Usability Testing)"></a>43) 可用性测试(Usability Testing)</h2><p>可用性测试用于检测应用的用户友好程度(User-friendliness). 它会验证新用户受可以轻松理解应用流程，如果用户陷入麻烦，测试人员要记录好并提供帮助。可以认为可用性测试是在检查系统的导航性(navigation)</p><p><br></p><h2 id="44-漏洞测试-vulnerability-testing"><a href="#44-漏洞测试-vulnerability-testing" class="headerlink" title="44) 漏洞测试(Vulnerability Testing)"></a>44) 漏洞测试(Vulnerability Testing)</h2><p>漏洞测试，涉及识别软件、硬件和网络中的漏洞。如果漏洞容易受到攻击，或者容易受到病毒和蠕虫感染，黑客或恶意程序就可以控制系统。</p><p>因此有必要在投入生产环境之前检查这些系统是否存在漏洞。</p><p><br></p><h2 id="45-容量测试-volume-testing"><a href="#45-容量测试-volume-testing" class="headerlink" title="45) 容量测试(Volume Testing)"></a>45) 容量测试(Volume Testing)</h2><p>容量测试是由性能测试团队执行的一种非功能测试。容量测试会检查应用程序遇到大量的数据时的系统行为和响应时间。这种大量数据可能会影响系统的性能和处理时间的速度。</p><p><br></p><h2 id="46-白盒测试-white-box-testing"><a href="#46-白盒测试-white-box-testing" class="headerlink" title="46) 白盒测试(White Box Testing)"></a>46) 白盒测试(White Box Testing)</h2><p><img src="/images/typeof-testing/glassbox.jpg" alt></p><p>白盒测试, 它也被称为玻璃盒测试、结构测试、逻辑驱动测试或基于代码的测试, 基于应用程序代码的内部逻辑。即测试人员应该知道内部软件和代码是如何工作的, 对所有的逻辑路径进行覆盖测试。上面提到的单元测试和静态测试就是典型的白盒测试, 基本上白盒测试可以等价于单元测试</p><p><strong>逻辑路径包括语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖等等</strong>.</p><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/typeof-testing/all.png" alt></p><p>上面提到的软件测试类型只是测试中的一部分，实际有超过100种的测试类型，但是并非所有测试类型都会被所有项目使用，所以我这里只是列举一些比较常见的软件测试类型。</p><p>另外不同的组织中可能会有不同的定义或过程，但是基本概念在任何地方都是相同的。当项目、需求和范围发生变化时，这些测试类型、过程及其实现方法会不断演变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接: &lt;a href=&quot;https://www.softwaretestinghelp.com/types-of-software-testing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Types Of Software Testing: 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你可能不知道的浏览器实时通信方案</title>
    <link href="https://bobi.ink/2019/07/07/sockjs/"/>
    <id>https://bobi.ink/2019/07/07/sockjs/</id>
    <published>2019-07-06T16:00:00.000Z</published>
    <updated>2019-07-10T08:30:04.800Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。</p><p>这里以<a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="noopener"><code>sockjs</code></a>作为切入点，这是一个流行的浏览器实时通信库，提供了’类Websocket’、一致性、跨平台的API，旨在浏览器和服务器之间创建一个低延迟、全双工、支持跨域的实时通信信道. <strong>主要特点就是仿生Websocket，它会优先使用Websocket作为传输层，在不支持WebSocket的环境回退使用其他解决方案，例如XHR-Stream、轮询</strong>. </p><p>所以<code>sockjs</code>本身就是浏览器实时通信方案的编年史, 本文也是按照由新到老这样的顺序来介绍这些解决方案. </p><blockquote><p>类似sockjs的解决方案还有 <a href="https://socket.io/" target="_blank" rel="noopener">socket.io</a></p></blockquote><blockquote><p>如果你觉得文章不错，请不要吝惜你的点赞👍，鼓励笔者写出更精彩的文章</p></blockquote><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#websocket">WebSocket</a></li><li><a href="#xhr-streaming">XHR-streaming</a></li><li><a href="#eventsource">EventSource</a></li><li><a href="#htmlfile">HtmlFile</a></li><li><a href="#polling">Polling</a></li><li><a href="#long-polling">Long polling</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="websocket"><a href="#websocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket其实不是本文的主角，而且网上已经有很多教程，本文的目的是介绍WebSocket之外的一些回退方案，在浏览器不支持Websocket的情况下, 可以选择回退到这些方案.</p><p>在此介绍Websocket之前，先来了解一些HTTP的基础知识，毕竟WebSocket本身是借用HTTP协议实现的。</p><p>HTTP协议是基于TCP/IP之上的应用层协议，也就是说HTTP在TCP连接中进行请求和响应的，<strong>浏览器会为每个请求建立一个TCP连接，请求等待服务端响应，在服务端响应后关闭连接</strong>:</p><p><img src="/images/sockjs/base-http.png" alt></p><p>后来人们发现为每个HTTP请求都建立一个TCP连接，太浪费资源了，能不能不要着急关闭TCP连接，而是将它复用起来, 在一个TCP连接中进行多次请求。</p><p><strong>这就有了HTTP持久连接(HTTP persistent connection, 也称为HTTP keep-alive), 它利用同一个TCP连接来发送和接收多个HTTP请求/响应。持久连接的方式可以大大减少等待时间, 双方不需要重新运行TCP握手，这对前端静态资源的加载也有很大意义</strong>:</p><p><img src="/images/sockjs/http-keep-alive.png" alt></p><p>Ok, 现在回到WebSocket, <strong>浏览器端用户程序并不支持和服务端直接建立TCP连接，但是上面我们看到每个HTTP请求都会建立TCP连接, TCP是可靠的、全双工的数据通信通道，那我们何不直接利用它来进行实时通信？ 这就是Websocket的原理!</strong> </p><p>我们这里通过一张图，通俗地理解一下Websocket的原理:</p><p><img src="/images/sockjs/websocket.png" alt></p><p>通过上图可以看到，<strong>WebSocket除最初建立连接时需要借助于现有的HTTP协议，其他时候直接基于TCP完成通信</strong>。这是浏览器中最靠近套接字的API，可以实时和服务端进行全双工通信. WebSocket相比传统的浏览器的<a href="https://en.wikipedia.org/wiki/Comet_(programming" target="_blank" rel="noopener">Comet</a>)(下文介绍)技术, 有很多优势：</p><ul><li>更强的实时性。基于TCP协议的全双工通信</li><li>更高效。一方面是数据包相对较小，另一方面相比传统XHR-Streaming和轮询方式更加高效，不需要重复建立TCP连接</li><li>更好的二进制支持。 Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容</li><li>保持连接状态。 相比HTTP无状态的协议，WebSocket只需要在建立连接时携带认证信息，后续的通信都在这个会话内进行</li><li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等</li></ul><p><br></p><p>它的接口也非常简单：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/socket'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">ws.onerror = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123; ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接关闭</span></span><br><span class="line">ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接建立</span></span><br><span class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 向服务端发送消息</span></span><br><span class="line">  ws.send(<span class="string">"ping"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端发送的消息</span></span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span>(msg.data <span class="keyword">instanceof</span> Blob) &#123; </span><br><span class="line">  <span class="comment">// 处理二进制信息</span></span><br><span class="line">    processBlob(msg.data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文本信息</span></span><br><span class="line">    processText(msg.data); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文不会深入解析Websocket的协议细节，有兴趣的读者可以看下列文章:</p><ul><li><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a></li><li><a href="https://mp.weixin.qq.com/s/7aXMdnajINt0C5dcJy2USg?" target="_blank" rel="noopener">WebSocket 浅析</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">阮一峰：WebSocket 教程</a></li></ul><p><br></p><p>如果不考虑低版本IE，基本上WebSocket不会有什么兼容性上面的顾虑. 下面列举了Websocket一些常见的问题, 当无法正常使用Websocket时，可以利用sockjs或者socket.io这些方案回退到传统的Comet技术方案.</p><ol><li>浏览器兼容性。<ul><li>IE10以下不支持</li><li>Safari 下不允许使用非标准接口建立连接</li></ul></li><li>心跳. WebSocket本身不会维护心跳机制，一些Websocket实现在空闲一段时间会自动断开。所以sockjs这些库会帮你维护心跳</li><li>一些负载均衡或代理不支持Websocket。</li><li>会话和消息队列维护。这些不是Websocket协议的职责，而是应用的职责。sockjs会为每个Websocket连接维护一个会话，且这个会话里面会维护一个消息队列，当Websocket意外断开时，不至于丢失数据</li></ol><p><br></p><hr><p><br></p><h2 id="xhr-streaming"><a href="#xhr-streaming" class="headerlink" title="XHR-streaming"></a>XHR-streaming</h2><p>XHR-Streming, 中文名称‘XHR流’, 这是WebSocket的最佳替补方案. XHR-streaming的原理也比较简单：<strong>服务端使用分块传输编码(Chunked transfer encoding)的HTTP传输机制进行响应，并且服务器端不终止HTTP响应流，让HTTP始终处于持久连接状态，当有数据需要发送给客户端时再进行写入数据</strong>。</p><p>没理解？没关系，我们一步一步来, 先来看一下正常的HTTP请求处理是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node.js代码</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>, <span class="comment">// 设置内容格式</span></span><br><span class="line">    <span class="string">'Content-Length'</span>: <span class="number">11</span>, <span class="comment">// 设置内容长度</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.end(<span class="string">'hello world'</span>) <span class="comment">// 响应 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端会立即接收到响应:</p><p><img src="/images/sockjs/http-req.png" alt></p><p><br></p><p>那么什么是<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener"><strong>分块传输编码</strong></a>呢?</p><p><strong>在HTTP/1.0之前, 响应是必须作为一整块数据返回客户端的(如上例)，这要求服务端在发送响应之前必须设置<code>Content-Length</code>, 浏览器知道数据的大小后才能确定响应的结束时间</strong>。这让服务器响应动态的内容变得非常低效，它必须等待所有动态内容生成完，再计算Content-Length, 才可以发送给客户端。如果响应的内容体积很大，需要占用很多内存空间.</p><p><strong>HTTP/1.1引入了<code>Transfer-Encoding: chunked;</code>报头。 它允许服务器发送给客户端应用的数据可以分为多个部分, 并以一个或多个块发送，这样服务器可以发送数据而不需要提前计算发送内容的总大小</strong>。</p><p><strong>有了分块传输机制后，动态生成内容的服务器就可以维持HTTP长连接, 也就是说服务器响应流不结束，TCP连接就不会断开</strong>. </p><p><br></p><p>现在我们切换为分块传输编码模式， 且我们不终止响应流，看会有什么情况:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    <span class="comment">// 'Content-Length': 11, // 🔴将Content-Length报头去掉，Node.js默认就是使用分块编码传输的</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.write(<span class="string">'hello world'</span>)</span><br><span class="line">  <span class="comment">// res.end() // 🔴不终止输出流</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们会发现请求会一直处于Pending状态(绿色下载图标)，<strong>除非出现异常、服务器关闭或显式关闭连接(比如设置超时机制)，请求是永远不会终止的。但是即使处于Pending状态客户端还是可以接收数据，不必等待请求结束</strong>:</p><p><img src="/images/sockjs/http-pending-req.png" alt></p><p><br></p><p>基于这个原理我们再来创建一个简单的ping-pong服务器:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/ping'</span>) &#123;</span><br><span class="line">    <span class="comment">// ping请求</span></span><br><span class="line">    <span class="keyword">if</span> (pendingResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">500</span>);</span><br><span class="line">      res.write(<span class="string">'session not found'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.writeHead(<span class="number">200</span>)</span><br><span class="line">    res.end()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给客户端推流</span></span><br><span class="line">    pendingResponse.write(<span class="string">'pong\n'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存句柄</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="string">'welcome to ping\n'</span>);</span><br><span class="line">    pendingResponse = res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>测试一下，在另一个窗口访问<code>/ping</code>路径：</p><p><img src="/images/sockjs/http-stream-ping.png" alt></p><p>Ok! 这就是XHR-Streaming!</p><p><br></p><p>那么Ajax怎么接收这些数据呢？ ①一种做法是在<code>XMLHttpRequest</code>的<code>onreadystatechange</code>事件处理器中判断<code>readyState</code>是否等于<code>XMLHttpRequest.LOADING</code>；②另外一种做法是在<code>xhr.onprogress</code>事件处理器中处理。下面是ping客户端实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.onprogress = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意responseText是获取服务端发送的所有数据，如果要获取未读数据，则需要进行划分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'progress'</span>, xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(<span class="string">'POST'</span>, HOST);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ping</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'POST'</span>, HOST + <span class="string">'/ping'</span>);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen();</span><br><span class="line">setInterval(ping, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p><br></p><p>慢着，不要高兴得太早😰. 如果运行上面的代码会发现<code>onprogress</code>并没有被正常的触发, 具体原因笔者也没有深入研究，我发现sockjs的服务器源码里面会预先写入2049个字节，这样就可以正常触发onprogress事件了:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/ping'</span>) &#123;</span><br><span class="line">    <span class="comment">// ping请求</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存句柄</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">Array</span>(<span class="number">2049</span>).join(<span class="string">'h'</span>) + <span class="string">'\n'</span>);</span><br><span class="line">    pendingResponse = res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>最后再图解一下XHR-streaming的原理:</p><p><img src="/images/sockjs/xhr-stream.png" alt></p><p>总结一下XHR-Streaming的特点:</p><ul><li>利用分块传输编码机制实现持久化连接(persistent connection): 服务器不关闭响应流，连接就不会关闭</li><li>单工(unidirectional): 只允许服务器向浏览器单向的推送数据</li></ul><p><strong>通过XHR-Streaming，可以允许服务端连续地发送消息，无需每次响应后再去建立一个连接, 所以它是除了Websocket之外最为高效的实时通信方案. 但它也并不是完美无缺</strong>。</p><p>比如XHR-streaming连接的时间越长，浏览器会占用过多内存，而且在每一次新的数据到来时，需要对消息进行划分，剔除掉已经接收的数据. 因此sockjs对它进行了一点优化, 例如sockjs默认只允许每个xhr-streaming连接输出128kb数据，超过这个大小时会关闭输出流，让浏览器重新发起请求.</p><p><br></p><hr><p><br></p><h2 id="eventsource"><a href="#eventsource" class="headerlink" title="EventSource"></a>EventSource</h2><p>了解了XHR-Streaming, 就会觉得<a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/EventSource" target="_blank" rel="noopener"><code>EventSource</code></a>并不是什么新鲜玩意: 它就是上面讲的<code>XHR-streaming</code>, 只不过浏览器给它提供了标准的API封装和协议, 你抓包一看和XHR-streaming没有太大的区别:</p><p><img src="/images/sockjs/eventsource.png" alt></p><p><br></p><p>上面可以看到请求的<code>Accept</code>为<code>text/event-stream</code>, 且服务端写入的数据都有标准的约定, 即载荷需要这样组织:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="string">`data: <span class="subst">$&#123;payload&#125;</span>\r\n\r\n`</span></span><br></pre></td></tr></table></figure><p><br></p><p>EventSource的API和Websocket类似, 实例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">'sse.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接打开</span></span><br><span class="line">evtSource.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受消息</span></span><br><span class="line">evtSource.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"message: "</span> + e.data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭流</span></span><br><span class="line">  evtSource.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常</span></span><br><span class="line">evtSource.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>因为是标准的，浏览器调试也比较方便，不需要借助第三方抓包工具:</p><p><img src="/images/sockjs/eventsource-inspect.png" alt></p><p><br></p><hr><p><br></p><h2 id="htmlfile"><a href="#htmlfile" class="headerlink" title="HtmlFile"></a>HtmlFile</h2><p>这是一种古老的‘秘术’😂，虽然我们可能永远都不会再用到它，但是它的实现方式比较有意思(类似于JSONP这种黑科技), 所以还是值得讲一下。</p><p>HtmlFile的另一个名字叫做<code>永久帧(forever-frame)</code>, 顾名思义, 浏览器会打开一个隐藏的iframe，这个iframe会请求一个分块传输编码的html文件(Transfer-Encoding: chunked), 和XHR-Streaming一样，这个请求永远都不会结束，服务器会不断在这个文档上输出内容。<strong>这里面的要点是现代浏览器都会增量渲染html文件，所以服务器可以通过添加script标签在客户端执行某些代码</strong>，先来看个抓包的实例:</p><p><img src="/images/sockjs/htmlfile.png" alt></p><p><br></p><p>从上图可以看出:</p><ul><li>① 这里会给服务器传递一个callback，通过这个callback将数据传递给父文档</li><li>② 服务器每当有新的数据，就向文档追加一个<code>&lt;script&gt;</code>标签，script的代码就是将数据传递给callback。利用浏览器会被下载边解析HTML文档的特性，新增的script会马上被执行</li></ul><p><br></p><p>最后还是用流程图描述一下：</p><p><img src="/images/sockjs/htmlfile-progress.png" alt></p><p>除了IE6、7以下不支持，大部分浏览器都支持这个方案，当浏览器不支持<code>XHR-streaming</code>时，可以作为最佳备胎。</p><p><br></p><hr><p><br></p><h2 id="polling"><a href="#polling" class="headerlink" title="Polling"></a>Polling</h2><p>轮询是最粗暴(或者说最简单)，也是效率最低下的‘实时’通信方案，这种方式的原理就是定期向服务器发起请求, 拉取最新的消息队列:</p><p><img src="/images/sockjs/polling2.png" alt></p><p>这种轮询方式比较合适<strong>服务器的信息定期更新</strong>的场景，如天气和股票行情信息。举个例子股票信息每隔5分钟更新一次，这时候客户端定期轮询, 且轮询间隔和服务端更新频率保持一致是一种理想的方式。</p><p>但是如果追求实时性，轮询会导致一些严重的问题:</p><ul><li>资源浪费。比如轮询的间隔小于服务器信息更新的频率，这会浪费很多HTTP请求, 消耗宝贵的CPU时间和带宽</li><li>容易导致请求轰炸。比如当服务器负载比较高时，第一个请求还没处理完成，这时候第二、第三个请求接踵而来，无用的额外请求对服务端进行了轰炸。</li></ul><p><br></p><hr><p><br></p><h2 id="long-polling"><a href="#long-polling" class="headerlink" title="Long polling"></a>Long polling</h2><p>还有一种优化的轮询方法，称为长轮询(Long Polling)，sockjs就是使用这种轮询方式, <strong>长轮询指的是浏览器发送一个请求到服务器，服务器只有在有可用的新数据时才响应</strong>：</p><p><img src="/images/sockjs/polling.png" alt></p><p>客户端向服务端发起一个消息获取请求，服务端会将当前的消息队列返回给客户端，然后关闭连接。<strong>当消息队列为空时，服务端不会立即关闭连接，而是等待指定的时间间隔，如果在这个时间间隔内没有新的消息，则由客户端主动超时关闭连接</strong>。</p><p>另外一个要点是，<strong>客户端的轮询请求只有在上一个请求连接关闭后才会重新发起</strong>。这就解决了上文的请求轰炸问题。服务端可以控制客户端的请求时序，因为在服务端未响应之前，客户端不会发送额外的请求(在超时期间内)。</p><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="noopener">WebRTC</a> 这是浏览器的实时通信技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。</li><li><a href="https://github.com/meteor/meteor/tree/devel/packages/ddp" target="_blank" rel="noopener">metetor DDP</a> DDP(Distributed Data Protocol), 这是一个’有状态的’实时通信协议，这个是<a href="https://github.com/meteor/meteor" target="_blank" rel="noopener">Meteor</a>框架的基础, 它就是使用这个协议来进行客户端和服务端通信. 他只是一个协议，而不是通信技术，比如它的底层可以基于Websocket、XHR-Streaming、长轮询甚至是WebRTC</li><li><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">Server-Sent Events 教程</a></li><li><a href="https://medium.com/@chijianqiang/程序员怎么会不知道-c10k-问题呢-d024cb7880f3" target="_blank" rel="noopener">程序员怎么会不知道C10K 问题呢？ - 池建强- Medium</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。&lt;/p&gt;
&lt;p&gt;这里以&lt;a href=&quot;https://github.com/sockjs/sockjs-client&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;sockjs
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
