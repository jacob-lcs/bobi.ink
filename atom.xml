<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2019-06-16T22:10:00.337Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React性能测量和分析</title>
    <link href="https://bobi.ink/2019/06/16/react-performance-analyze/"/>
    <id>https://bobi.ink/2019/06/16/react-performance-analyze/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T22:10:00.337Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">文章</a>讲了 React 性能优化的一些方向和手段，这篇文章再补充说一下如何进行性能测量和分析, 介绍 React 性能分析的一些工具和方法.</p><p>进行任何性能优化的前提是你要找出’性能问题‘，这样才能针对性地进行优化。我觉得对于 React 的性能优化可以分两个阶段:</p><ul><li><p><strong>1. 分析阶段</strong></p><ul><li>通过分析器(Profiler)找出重新渲染的组件、重新渲染的次数、以及重新渲染耗费的资源与时间</li><li>变动检测. 通过分析器我们可以知道’什么被重新渲染, 重新渲染的代价’，那么变动检测回答的问题就是： ’为什么这些进行了重新渲染?’</li></ul></li><li><p><strong>2. 优化阶段</strong>. 优化阶段我们针对分析阶段抛出的问题进行解决，解决的方法有很多，可以参考本文的姊妹篇&lt;<a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">浅谈React性能优化的方向</a>&gt;</p></li></ul><p><br></p><p><strong>本文大纲</strong></p><!-- TOC --><ul><li><a href="#分析器">分析器</a><ul><li><a href="#react-devtool">React Devtool</a><ul><li><a href="#高亮更新">高亮更新</a></li><li><a href="#分析器-1">分析器</a></li></ul></li><li><a href="#chrome-performance-工具">Chrome Performance 工具</a></li><li><a href="#其他工具">其他工具</a></li></ul></li><li><a href="#变动检测">变动检测</a><ul><li><a href="#props-变动检测">props 变动检测</a></li><li><a href="#mobx-变动检测">mobx 变动检测</a></li><li><a href="#context-变更检测">Context 变更检测</a></li></ul></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><p>下面本文测试的样板代码.</p><blockquote><p>推荐点击 Preview 面板的<code>Open In New Window</code>, 或者直接点击该<a href="https://igz9h.codesandbox.io/" target="_blank" rel="noopener">链接</a>，在线动手实践</p></blockquote><iframe src="https://codesandbox.io/embed/react-performance-analyze-demo-igz9h?autoresize=1&fontsize=14" title="React-Performance-Analyze-Demo" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p><br><br><br></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>分析哪些组件进行了渲染，以及渲染消耗的时间以及资源。主要工具有 React 官方的开发者工具以及 Chrome 的 Performance 工具。</p><h3 id="react-devtool"><a href="#react-devtool" class="headerlink" title="React Devtool"></a>React Devtool</h3><p>最先应该使用的肯定是官方提供的开发者工具，React v16.5 引入了新的 Profiler 功能，让分析组件渲染过程变得更加简单，而且可以很直观地查看哪些组件被渲染.</p><h4 id="高亮更新"><a href="#高亮更新" class="headerlink" title="高亮更新"></a>高亮更新</h4><p><strong>首先最简单也是最方便的判断组件是否被重新渲染的方式是’高亮更新(Hightlight Updates)’</strong>.</p><p>① 开启高亮更新:</p><center><br> <img src="/images/10/hightlight-update.png"><br></center><p>② 运行效果如下:</p><center><br>  <img src="/images/10/hightlight-update.gif"><br></center><p>③ 通过高亮更新，基本上可以确定哪些组件被重新渲染. 所以现在我们给 ListItem 加上 React.memo(查看 PureList 示例), 看一下效果:</p><center><br> <img src="/images/10/hightlight-update-pure.gif"><br></center><p>效果非常明显，现在只有递增的 ListItem 会被更新，而且当数组排序时只有 List 组件会被刷新. 所以说‘纯组件’是 React 优化的第一张牌, 也是最有效的一张牌.</p><p><br><br><br></p><h4 id="分析器-1"><a href="#分析器-1" class="headerlink" title="分析器"></a>分析器</h4><p>如果<code>高亮更新</code>无法满足你的需求，比如<strong>你需要知道具体哪些组件被渲染、渲染消耗多少时间、进行了多少次的提交(渲染)等等</strong>, 这时候就需要用到分析器了.</p><p>① 首先选择需要收集测量信息的节点(一般默认选中根节点，有一些应用可能存在多个组件树，这时候需要手动选择):</p><center><br> <img src="/images/10/select-profile.png"><br></center><p>② Ok，点击 Record 开始测量</p><center><br> <img src="/images/10/start-record.gif"><br></center><p><br></p><p>③ 看看测量的结果，先来了解一下 Profiler 面板的基本结构:</p><center><br> <img src="/images/10/profile-outline.png"><br></center><ul><li><p><strong>1️⃣ 这是一个 commit 列表</strong>。commit 列表表示录制期间发生的 commit(可以认为是渲染) 操作，要理解 commit 的意思还需要了解 React 渲染的基本原理.</p><p>在 v16 后 React 组件渲染会分为两个阶段，即 render 和 commit 阶段。</p><ul><li><strong>render 阶段决定需要进行哪些变更，比如 DOM</strong>。顾名思义, 这个阶段 React 会调用 render 函数，并将结果和上一次 render 的结果进行 diff, 计算出需要进行变更的操作队列</li><li><strong>commit 阶段</strong>。或者称为提交阶段, 在这个阶段会执行 render 阶段 diff 出来的变更请求。比如 DOM 插入、更新、删除、排序等等。在这个阶段 React 还会调用 componentDidMount 和 componentDidUpdate 生命周期函数.</li></ul><p>在 v16 之前，或者在 Preact 这些’类 React’ 框架中，并不区分 render 阶段和 commit 阶段，也就说这两个阶段糅合在一起，一边 diff 一边 commit。有兴趣的读者可以看笔者之前写的<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">从 Preact 中了解组件和 hooks 基本原理</a><br><br></p><p>切换 commit:</p><p><img src="/images/10/profile-commit.gif" alt><br><br></p></li><li><p><strong>2️⃣ 选择其他图形展示形式</strong>，例如 <code>Ranked 视图</code>，这个视图按照渲染消耗时间对组件进行排序：</p><p><img src="/images/10/ranked.png" alt></p><p><br></p></li><li><p><strong>3️⃣ 火焰图</strong> 这个图其实就是<strong>组件树</strong>，Profiler 使用颜色来标记哪些组件被重新渲染。<strong>和 commit 列表以及 Ranked 图一样，颜色在这里是有意义的，比如灰色表示没有重新渲染；从渲染消耗的时间上看的话: <code>黑色 &gt; 黄色 &gt; 蓝色</code>, 通过 👆Ranked 图可以直观感受到不同颜色之间的意义</strong></p><p><img src="/images/10/profile-framegraph.gif" alt></p><p><br></p></li><li><p><strong>4️⃣ 当前选中组件或者 Commit 的详情</strong>, 可以查看该组件渲染时的 props 和 state</p><p><img src="/images/10/profile-props.gif" alt></p><p>双击具体组件可以详细比对每一次 commit 消耗的时间:</p><p><img src="/images/10/profile-component-detail.png" alt></p><p><br></p></li><li><p><strong>5️⃣ 设置</strong></p><p>另外可以通过设置，筛选 Commit，以及是否显示原生元素:</p><p><img src="/images/10/profile-settings.png" alt></p></li></ul><p><br></p><p>④现在使用 Profiler 来分析一下 PureList 的渲染过程:</p><p><img src="/images/10/profile-demo.png" alt></p><p><br></p><blockquote><p>关于 Profiler 的详细介绍可以看这篇官方博客&lt;<a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">Introducing the React Profiler</a>&gt;</p></blockquote><p><br><br><br></p><h3 id="chrome-performance-工具"><a href="#chrome-performance-工具" class="headerlink" title="Chrome Performance 工具"></a>Chrome Performance 工具</h3><p>在 v16.5 之前，我们一般都是利用 Chrome 自带的 Performance 来进行 React 性能测量:</p><p><img src="/images/10/chrome-performance.png" alt></p><p><br></p><p>React 使用标准的<code>User Timing API</code>(所有支持该标准的浏览器都可以用来分析 React)来记录操作，所以我们在 Timings 标签中查看 React 的渲染过程。React 还特意使用 emoji 标记.</p><p>相对 React Devtool 而言 Performance 工具可能还不够直观，但是它非常强大，举个例子，<strong>如果说 React-Devtool 是<a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a>, 那么 Performance 就是<a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a>. 使用 Performance 可以用来定位一些比较深层次的问题，这可能需要你对 React 的实现原理有一定了解, 就像使用 Wireshark 你需要懂点网络协议一样</strong></p><p>所以说使用 Performance 工具有以下优势:</p><ul><li>可以测量分析整个渲染的过程细节. 它可以定位某些具体方法的调用过程和消耗, 方便定位一些深层次问题.</li><li>可以测量分析底层 DOM 的绘制、布局、合成等细节。方便定位浏览器性能问题</li></ul><p>其实 Performance 是一个通用的性能检测工具，所以其细节不在本文讨论访问。 详细参考</p><ul><li><a href="https://calibreapp.com/blog/react-performance-profiling-optimization/" target="_blank" rel="noopener">Profiling React performance with React 16 and Chrome Devtools</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Chrome官方的Performance使用文档</a></li></ul><p><br></p><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><p>上面介绍的这些工具基本上已经够用了。社区上还有一些比较流行的工具，不过这些工具迟早/已经要被官方取代(招安)，而且它们也跟不上 React 的更新。</p><ul><li><a href="https://reactjs.org/docs/perf.html" target="_blank" rel="noopener">react-addons-perf</a> React v16 不支持了，不说了。老版本可用</li><li><a href="https://github.com/nitin42/react-perf-devtool" target="_blank" rel="noopener">react-perf-devtool</a> 也不活跃了，不推荐使用</li></ul><p><br></p><hr><p><br></p><h2 id="变动检测"><a href="#变动检测" class="headerlink" title="变动检测"></a>变动检测</h2><p>OK, 我们通过分析工具已经知道我们的应用存在哪些问题了，诊断出了哪些组件被无意义的渲染。下一步操作就是找出组件重新渲染的元凶, 检测为什么组件进行了更新.</p><p><strong>我们先假设我们的组件是一个’纯组件‘，也就是说我们认为只有组件依赖的状态变更时，组件才会重新渲染</strong>. 非纯组件没有讨论的意义，因为只要状态变更或父级变更他都会重新渲染。</p><p><strong>那么对于一个’纯组件‘来说，一般会有下面这些因素都可能导致组件重新渲染</strong>:</p><ul><li><strong>props + state</strong> 毫无疑问. 这里我们只需要关注<strong>来源于外部的 props</strong>. 内部state变动一般是人为触发的，比较容易发现</li><li><strong>Mobx observable value</strong>. 如果访问了 mobx 传进来的响应式数据，就会建立一个状态依赖关系，这个相对于 props 和 context 来说是隐式的，检测它的变动我们可能需要利用 mobx 提供的一些工具</li><li><strong>Context</strong>。 Context 的 value 的变更会强制重新渲染组件</li></ul><p><br></p><h3 id="props-变动检测"><a href="#props-变动检测" class="headerlink" title="props 变动检测"></a>props 变动检测</h3><p>在上一篇文章中我就建议简化 props，简单组件的 props 的变更很容易预测, 甚至你肉眼都可以察觉出来。另外如果你使用 Redux，如果严格按照 Redux 的最佳实践，配合 Redux 的开发者工具，也可以很直观地判断哪些状态发生了变更。</p><p>如果你没办法满足以上条件，可能就得依赖工具了。之前有一个<a href="https://github.com/maicki/why-did-you-update" target="_blank" rel="noopener">why-did-you-update</a>的库，<strong>很可惜现在已经没怎么维护了(旧版本可以使用它)</strong>。这个库使用猴补丁(monkey patches)来扩展 React，比对检测哪些 props 和 state 发生了变化：</p><p><img src="/images/10/wdyu.png" alt></p><p>后面也有人借鉴 why-did-you-update 写了个<a href="https://github.com/welldone-software/why-did-you-render" target="_blank" rel="noopener">why-did-you-render</a>. 不过笔者还是不看好这些通过猴补丁扩展 React 的实现，依赖于React的内部实现细节，维护成本太高了，跟不上 React 更新基本就废了.</p><p>如果你现在使用 hook 的话，自己手写一个也很简单, 这个 idea 来源于<a href="https://github.com/devhubapp/devhub/blob/master/packages/components/src/hooks/use-why-did-you-update.ts" target="_blank" rel="noopener">use-why-did-you-update</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useWhyDidYouUpdate</span>(<span class="params">name: <span class="built_in">string</span>, props: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️保存上一个props</span></span><br><span class="line">  <span class="keyword">const</span> latestProps = useRef(props);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> allKeys = <span class="built_in">Object</span>.keys(&#123; ...latestProps.current, ...props &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changesObj: Record&lt;<span class="built_in">string</span>, &#123; <span class="keyword">from</span>: <span class="built_in">any</span>; to: <span class="built_in">any</span> &#125;&gt; = &#123;&#125;;</span><br><span class="line">    allKeys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (latestProps.current[key] !== props[key]) &#123;</span><br><span class="line">        changesObj[key] = &#123; <span class="keyword">from</span>: latestProps.current[key], to: props[key] &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(changesObj).length) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[why-did-you-update]'</span>, name, changesObj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他原因导致组件渲染</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latestProps.current = props;</span><br><span class="line">  &#125;, <span class="built_in">Object</span>.values(props));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter = React.memo(props =&gt; &#123;</span><br><span class="line">  useWhyDidYouUpdate(&apos;Counter&apos;, props);</span><br><span class="line">  return &lt;div style=&#123;props.style&#125;&gt;&#123;props.count&#125;&lt;/div&gt;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果是类组件，可以在<code>componentDidUpdate</code>使用类似上面的方式来比较props</p><p><br></p><h3 id="mobx-变动检测"><a href="#mobx-变动检测" class="headerlink" title="mobx 变动检测"></a>mobx 变动检测</h3><p>排除了 props 变更导致的重新渲染，现在来看看是否是 mobx 响应式数据导致的变更. 如果你们团队不使用 mobx，可以跳过这一节。</p><p><strong>首先不管是 Redux 和 Mobx，我们都应该让状态的变动变得可预测</strong>. 因为 Mobx 没有 Redux 那样固化的数据变更模式，Mobx 并不容易自动化地监测数据是如何被变更的。在 mobx 中我们使用<code>@action</code> 来标志状态的变更操作，但是它拿异步操作没办法。好在后面 mobx 推出了 <code>flow</code> API👏。</p><p>对于 Mobx 首先建议开启严格模式, 要求所有数据变更都放在@action 或 flow 中:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line">configure(&#123; <span class="attr">enforceActions</span>: <span class="string">'always'</span> &#125;);</span><br></pre></td></tr></table></figure><p>定义状态变更操作</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, action, flow &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterStore</span> </span>&#123;</span><br><span class="line">  @observable count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步操作</span></span><br><span class="line">  @action(<span class="string">'increment count'</span>)</span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">  <span class="comment">// 这是一个生成器，类似于saga的机制</span></span><br><span class="line">  fetchCount = flow(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="keyword">yield</span> getCount();</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok 有了上面的约定，现在可以在控制台(通过mobx-logger)或者 <a href="https://github.com/mobxjs/mobx-devtools" target="_blank" rel="noopener">Mobx开发者工具</a>中跟踪 Mobx 响应式数据的变动了。</p><p><img src="/images/10/mobx-devtool.png" alt></p><p><br></p><p>如果不按照规范来，出现问题会比较浪费时间, 但也不是没办法解决。Mobx 还提供了一个<a href="https://mobx.js.org/best/trace.html" target="_blank" rel="noopener">trace</a>函数, 用来检测为什么会执行 SideEffect:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ListItem = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; item, onShiftDown &#125; = props;</span><br><span class="line">  trace();</span><br><span class="line">  <span class="keyword">return</span> &lt;div className="list-item"&gt;&#123;/*...*/&#125;&lt;/div&gt;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行效果(递增了 value 值):</p><p><img src="/images/10/mobx-trace.png" alt="mobx-trace"></p><p><br></p><h3 id="context-变更检测"><a href="#context-变更检测" class="headerlink" title="Context 变更检测"></a>Context 变更检测</h3><p>Ok, 如果排除了 props 和 mobx 数据变更还会重新渲染，那么 100%是 Context 导致的，因为一旦 Context 数据变动，组件就会被强制渲染。笔者在<a href="https://juejin.im/post/5d045350f265da1b695d5bf2#heading-14" target="_blank" rel="noopener">浅谈 React 性能优化的方向</a>提到了 ContextAPI 的一些陷阱。先排除一下是否是这些原因导致的.</p><p>现在并没有合适的跟踪 context 变动的机制，我们可以采取像上文的<code>useWhyDidYouUpdate</code>一样的方式来比对Context的值：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useIsContextUpdate</span>(<span class="params">contexts: object = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> latestContexts = useRef(contexts);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> changedContexts: string[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> contexts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (contexts[key] !== latestContexts.current[key]) &#123;</span><br><span class="line">        changedContexts.push(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changedContexts.length) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`[is-context-update]: <span class="subst">$&#123;changedContexts.join(<span class="string">', '</span>)&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latestContexts.current = contexts;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = useRouter();</span><br><span class="line"><span class="keyword">const</span> myContext = useContext(MyContext);</span><br><span class="line"></span><br><span class="line">useIsContextUpdate(&#123;</span><br><span class="line">  router,</span><br><span class="line">  myContext,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好了行文结束，如果觉得可以就点个👍吧</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">Introducing the React Profiler</a></li><li><a href="https://calibreapp.com/blog/react-performance-profiling-optimization/" target="_blank" rel="noopener">Profiling React performance with React 16 and Chrome Devtools.</a></li><li><a href="https://www.youtube.com/watch?v=nl8VVig_9aM" target="_blank" rel="noopener">Tools For Measuring React Performance - Brenda Jimenez @ ReactNYC</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇&lt;a href=&quot;https://juejin.im/post/5d045350f265da1b695d5bf2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;讲了 React 性能优化的一些方向和手段，这篇文章再补充说一下如何进行性能测
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈React性能优化的方向</title>
    <link href="https://bobi.ink/2019/06/14/react-performance/"/>
    <id>https://bobi.ink/2019/06/14/react-performance/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-06-16T01:03:44.939Z</updated>
    
    <content type="html"><![CDATA[<p>本文来源于公司内部的一次闪电分享，稍作润色分享出来。主要讨论 React 性能优化的主要方向和一些小技巧。<strong>如果你觉得可以，请多点赞，鼓励我写出更精彩的文章</strong>🙏。</p><p><br></p><p>React 渲染性能优化的三个方向，其实也适用于其他软件开发领域，这三个方向分别是:</p><ul><li><strong>减少计算的量</strong>。 -&gt; 对应到 React 中就是<strong>减少渲染的节点 或者 降低组件渲染的复杂度</strong></li><li><strong>利用缓存</strong>。-&gt; 对应到 React 中就是<strong>如何避免重新渲染，利用函数式编程的 memo 方式来避免组件重新渲染</strong></li><li><strong>精确重新计算的范围</strong>。 对应到 React 中就是<strong>绑定组件和状态关系, 精确判断更新的’时机’和’范围’. 只重新渲染’脏’的组件，或者说降低渲染范围</strong></li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#减少渲染的节点降低渲染计算量复杂度">减少渲染的节点/降低渲染计算量(复杂度)</a><ul><li><a href="#0️⃣-不要在渲染函数都进行不必要的计算">0️⃣ 不要在渲染函数都进行不必要的计算</a></li><li><a href="#1️⃣-减少不必要的嵌套">1️⃣ 减少不必要的嵌套</a></li><li><a href="#2️⃣-虚拟列表">2️⃣ 虚拟列表</a></li><li><a href="#3️⃣-惰性渲染">3️⃣ 惰性渲染</a></li><li><a href="#4️⃣-选择合适的样式方案">4️⃣ 选择合适的样式方案</a></li></ul></li><li><a href="#避免重新渲染">避免重新渲染</a><ul><li><a href="#0️⃣-简化-props">0️⃣ 简化 props</a></li><li><a href="#1️⃣-不变的事件处理器">1️⃣ 不变的事件处理器</a></li><li><a href="#2️⃣-不可变数据">2️⃣ 不可变数据</a></li><li><a href="#3️⃣-简化-state">3️⃣ 简化 state</a></li><li><a href="#4️⃣-使用-recompose-精细化比对">4️⃣ 使用 recompose 精细化比对</a></li></ul></li><li><a href="#精细化渲染">精细化渲染</a><ul><li><a href="#0️⃣-响应式数据的精细化渲染">0️⃣ 响应式数据的精细化渲染</a></li><li><a href="#1️⃣-不要滥用-context">1️⃣ 不要滥用 Context</a></li></ul></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="减少渲染的节点-降低渲染计算量-复杂度"><a href="#减少渲染的节点-降低渲染计算量-复杂度" class="headerlink" title="减少渲染的节点/降低渲染计算量(复杂度)"></a>减少渲染的节点/降低渲染计算量(复杂度)</h2><p>首先从计算的量上下功夫，减少节点渲染的数量或者降低渲染的计算量可以显著的提高组件渲染性能。</p><p><br></p><h3 id="0️⃣-不要在渲染函数都进行不必要的计算"><a href="#0️⃣-不要在渲染函数都进行不必要的计算" class="headerlink" title="0️⃣ 不要在渲染函数都进行不必要的计算"></a>0️⃣ 不要在渲染函数都进行不必要的计算</h3><p>比如不要在渲染函数(render)中进行数组排序、数据转换、订阅事件、创建事件处理器等等. <strong>渲染函数中不应该放置太多副作用</strong></p><p><br></p><h3 id="1️⃣-减少不必要的嵌套"><a href="#1️⃣-减少不必要的嵌套" class="headerlink" title="1️⃣ 减少不必要的嵌套"></a>1️⃣ 减少不必要的嵌套</h3><center><br> <img src="/images/09/styled-components.png"><br></center><p>我们团队是重度的 <code>styled-components</code> 用户，<strong>其实大部分情况下我们都不需要这个玩意</strong>，比如纯静态的样式规则，以及需要重度性能优化的场景。除了性能问题，另外一个困扰我们的是它带来的节点嵌套地狱(如上图)。</p><p>所以我们需要理性地选择一些工具，比如使用原生的 CSS，减少 React 运行时的负担.</p><p><strong>一般不必要的节点嵌套都是滥用高阶组件/RenderProps 导致的。所以还是那句话‘只有在必要时才使用 xxx’</strong>。 有很多种方式来代替高阶组件/RenderProps，例如优先使用 props、React Hooks</p><p><br></p><h3 id="2️⃣-虚拟列表"><a href="#2️⃣-虚拟列表" class="headerlink" title="2️⃣ 虚拟列表"></a>2️⃣ 虚拟列表</h3><p>虚拟列表是常见的‘长列表’和’复杂组件树’优化方式，它优化的本质就是减少渲染的节点。</p><p>虚拟列表只渲染当前视口可见元素:</p><center><br> <img src="/images/09/vl.png" width="500"><br></center><p>虚拟列表渲染性能对比:</p><center><br> <img src="/images/09/vl-compare.png" width="500"><br></center><p>虚拟列表常用于以下组件场景:</p><ul><li>无限滚动列表，grid, 表格，下拉列表，spreadsheets</li><li>无限切换的日历或轮播图</li><li>大数据量或无限嵌套的树</li><li>聊天窗，数据流(feed), 时间轴</li><li>等等</li></ul><p>相关组件方案:</p><ul><li><a href="https://github.com/bvaughn/react-virtualized" target="_blank" rel="noopener">react-virtualized</a></li><li><a href="https://github.com/bvaughn/react-window" target="_blank" rel="noopener">react-window</a> 更轻量的 react-virtualized, 同出一个作者</li><li><a href="https://github.com/bvaughn/react-virtualized#friends" target="_blank" rel="noopener">更多</a></li></ul><p>扩展：</p><ul><li><a href="https://bvaughn.github.io/forward-js-2017/#/0/0" target="_blank" rel="noopener">Creating more efficient React views with windowing</a></li><li><a href="https://addyosmani.com/blog/react-window/" target="_blank" rel="noopener">Rendering large lists with react-window</a></li></ul><p><br><br><br></p><h3 id="3️⃣-惰性渲染"><a href="#3️⃣-惰性渲染" class="headerlink" title="3️⃣ 惰性渲染"></a>3️⃣ 惰性渲染</h3><p><strong>惰性渲染的初衷本质上和虚表一样，也就是说我们只在必要时才去渲染对应的节点</strong>。</p><p>举个典型的例子，我们常用 Tab 组件，我们没有必要一开始就将所有 Tab 的 panel 都渲染出来，而是等到该 Tab 被激活时才去惰性渲染。</p><p>还有很多场景会用到惰性渲染，例如树形选择器，模态弹窗，下拉列表，折叠组件等等。</p><p>这里就不举具体的代码例子了，留给读者去思考.</p><p><br></p><h3 id="4️⃣-选择合适的样式方案"><a href="#4️⃣-选择合适的样式方案" class="headerlink" title="4️⃣ 选择合适的样式方案"></a>4️⃣ 选择合适的样式方案</h3><center><br>  <img src="/images/09/style-compare.png" width="500"><br></center><p>如图(图片来源于<a href="https://blog.primehammer.com/the-performance-of-styled-react-components/" target="_blank" rel="noopener">THE PERFORMANCE OF STYLED REACT COMPONENTS</a>), 这个图片是17年的了，但是大抵的趋势还是这样。</p><p>所以在样式运行时性能方面大概可以总结为：<code>CSS &gt; 大部分CSS-in-js &gt; inline style</code></p><p><br></p><hr><p><br></p><h2 id="避免重新渲染"><a href="#避免重新渲染" class="headerlink" title="避免重新渲染"></a>避免重新渲染</h2><p>减少不必要的重新渲染也是 React 组件性能优化的重要方向. 为了避免不必要的组件重新渲染需要在做到两点:</p><ol><li>保证组件纯粹性。即控制组件的副作用，如果组件有副作用则无法安全地缓存渲染结果</li><li>通过<code>shouldComponentUpdate</code>生命周期函数来比对 state 和 props, 确定是否要重新渲染。对于函数组件可以使用<code>React.memo</code>包装</li></ol><p>另外这些措施也可以帮助你更容易地优化组件重新渲染:</p><p><br></p><h3 id="0️⃣-简化-props"><a href="#0️⃣-简化-props" class="headerlink" title="0️⃣ 简化 props"></a>0️⃣ 简化 props</h3><p><strong>① 如果一个组件的 props 太复杂一般意味着这个组件已经违背了‘单一职责’，首先应该尝试对组件进行拆解</strong>.<br><strong>② 另外复杂的 props 也会变得难以维护, 比如会影响<code>shallowCompare</code>效率, 还会让组件的变动变得难以预测和调试</strong>.</p><p>下面是一个典型的例子, 为了判断列表项是否处于激活状态，这里传入了一个当前激活的 id:</p>  <center><br>    <img src="/images/09/list.png" width="500"><br>  </center><p>这是一个非常糟糕的设计，一旦激活 id 变动，所有列表项都会重新刷新. 更好的解决办法是使用类似<code>actived</code>这样的布尔值 prop. actived 现在只有两种变动情况，也就是说激活 id 的变动，最多只有两个组件需要重新渲染.</p><p><strong>简化的 props 更容易理解, 且可以提高组件缓存的命中率</strong></p><p><br></p><h3 id="1️⃣-不变的事件处理器"><a href="#1️⃣-不变的事件处理器" class="headerlink" title="1️⃣ 不变的事件处理器"></a>1️⃣ 不变的事件处理器</h3><p>①<strong>避免使用箭头函数形式的事件处理器</strong>, 例如:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ComplexComponent onClick=&#123;evt =&gt; onClick(evt.id)&#125; otherProps=&#123;values&#125; /&gt;</span><br></pre></td></tr></table></figure><p>假设 ComplexComponent 是一个复杂的 PureComponent, 这里使用箭头函数，其实每次渲染时都会创建一个新的事件处理器，这会导致 ComplexComponent 始终会被重新渲染.</p><p>更好的方式是使用实例方法:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;ComplexComponent onClick=&#123;<span class="keyword">this</span>.handleClick&#125; otherProps=&#123;values&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <br></p><p>② 即使现在使用<code>hooks</code>，我依然会<strong>使用<code>useCallback</code>来包装事件处理器</strong>，尽量给下级组件暴露一个静态的函数:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &lt;ComplexComponent onClick=&#123;handleClick&#125; otherProps=&#123;values&#125; /&gt;;</span><br></pre></td></tr></table></figure><p>但是如果<code>useCallback</code>依赖于很多状态，你的<code>useCallback</code>可能会变成这样:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="comment">// 🤭</span></span><br><span class="line">&#125;, [foo, bar, baz, bazz, bazzzz]);</span><br></pre></td></tr></table></figure><p>这种写法实在让人难以接受，这时候谁还管什么函数式非函数式的。我是这样处理的:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRefProps</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef &lt; T &gt; props;</span><br><span class="line">  <span class="comment">// 每次渲染更新props</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = props;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsRef = useRefProps(props);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在handleClick是始终不变的</span></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; foo, bar, baz, bazz, bazzzz &#125; = propsRef.current;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>③<strong>设计更方便处理的 Event Props</strong>. 有时候我们会被逼的不得不使用箭头函数来作为事件处理器：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;List&gt;</span><br><span class="line">  &#123;list.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">    &lt;Item key=&#123;i.id&#125; onClick=&#123;() =&gt; handleDelete(i.id)&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;<span class="regexp">/List&gt;</span></span><br></pre></td></tr></table></figure><p>上面的 onClick 是一个糟糕的实现，它没有携带任何信息来标识事件来源，所以这里只能使用闭包形式，更好的设计可能是这样的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onClick传递事件来源信息</span></span><br><span class="line"><span class="keyword">const</span> handleDelete = useCallback(<span class="function">(<span class="params">id: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*删除操作*/</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;List&gt;</span><br><span class="line">    &#123;list.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">      &lt;Item key=&#123;i.id&#125; id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/List&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>如果是第三方组件或者 DOM 组件呢? 实在不行，看能不能传递<code>data-*</code>属性:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleDelete = useCallback(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = event.dataset.id;</span><br><span class="line">  <span class="comment">/*删除操作*/</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;list.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">      &lt;li key=&#123;i.id&#125; data-id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="2️⃣-不可变数据"><a href="#2️⃣-不可变数据" class="headerlink" title="2️⃣ 不可变数据"></a>2️⃣ 不可变数据</h3><p>不可变数据可以让状态变得可预测，也让 shouldComponentUpdate ‘浅比较’变得更可靠和高效. 笔者在<a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-8" target="_blank" rel="noopener">React 组件设计实践总结 04 - 组件的思维</a>介绍过不可变数据，有兴趣读者可以看看.</p><p>相关的工具有<a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">Immutable.js</a>、<a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">Immer</a>、immutability-helper 以及 seamless-immutable。</p><p><br></p><h3 id="3️⃣-简化-state"><a href="#3️⃣-简化-state" class="headerlink" title="3️⃣ 简化 state"></a>3️⃣ 简化 state</h3><p><strong>不是所有状态都应该放在组件的 state 中</strong>. 例如缓存数据。按照我的原则是：<strong>如果需要组件响应它的变动, 或者需要渲染到视图中的数据才应该放到 state 中。这样可以避免不必要的数据变动导致组件重新渲染.</strong></p><p><br></p><h3 id="4️⃣-使用-recompose-精细化比对"><a href="#4️⃣-使用-recompose-精细化比对" class="headerlink" title="4️⃣ 使用 recompose 精细化比对"></a>4️⃣ 使用 recompose 精细化比对</h3><p>尽管 hooks 出来后，recompose 宣称不再更新了，但还是不影响我们使用 recompose 来控制<code>shouldComponentUpdate</code>方法, 比如它提供了以下方法来精细控制应该比较哪些 props:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 相当于React.memo */</span></span><br><span class="line">pure()</span><br><span class="line"><span class="comment">/* 自定义比较 */</span></span><br><span class="line">shouldUpdate(test: <span class="function">(<span class="params">props: <span class="built_in">Object</span>, nextProps: <span class="built_in">Object</span></span>) =&gt;</span> <span class="built_in">boolean</span>): HigherOrderComponent</span><br><span class="line"><span class="comment">/* 只比较指定key */</span></span><br><span class="line">onlyUpdateForKeys( propKeys: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;): HigherOrderComponent</span><br></pre></td></tr></table></figure><p>其实还可以再扩展一下，比如<code>omitUpdateForKeys</code>忽略比对某些 key.</p><p><br><br><br></p><h2 id="精细化渲染"><a href="#精细化渲染" class="headerlink" title="精细化渲染"></a>精细化渲染</h2><p>所谓精细化渲染指的是<strong>只有一个数据来源导致组件重新渲染</strong>, 比如说 A 只依赖于 a 数据，那么只有在 a 数据变动时才渲染 A, 其他状态变化不应该影响组件 A。</p><p>Vue 和 Mobx 宣称自己性能好的一部分原因是它们的’响应式系统’, <strong>它允许我们定义一些‘响应式数据’，当这些响应数据变动时，依赖这些响应式数据视图就会重新渲染</strong>. 来看看 Vue 官方是如何描述的:</p><center><br>  <img src="/images/09/vue-compare.png" width="500"><br></center><p><br></p><h3 id="0️⃣-响应式数据的精细化渲染"><a href="#0️⃣-响应式数据的精细化渲染" class="headerlink" title="0️⃣ 响应式数据的精细化渲染"></a>0️⃣ 响应式数据的精细化渲染</h3><p><strong>大部分情况下，响应式数据可以实现视图精细化的渲染, 但它还是不能避免开发者写出低效的程序</strong>. <strong>本质上还是因为组件违背‘单一职责’</strong>.</p><p>举个例子，现在有一个 MyComponent 组件，依赖于 A、B、C 三个数据源，来构建一个 vdom 树。现在的问题是什么呢？现在只要 A、B、C 任意一个变动，那么 MyComponent 整个就会重新渲染:</p><center><br>  <img src="/images/09/my-component1.png" width="300"><br></center><p>更好的做法是让组件的职责更单一，精细化地依赖响应式数据，或者说对响应式数据进行‘隔离’. 如下图, A、B、C 都抽取各自的组件中了，现在 A 变动只会渲染 A 组件本身，而不会影响父组件和 B、C 组件:</p><center><br>  <img src="/images/09/my-component2.png" width="480"><br></center><p><br></p><p>举一个典型的例子，列表渲染:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react-lite'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialList = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  initialList.push(&#123; <span class="attr">id</span>: i, <span class="attr">name</span>: <span class="string">`name-<span class="subst">$&#123;i&#125;</span>`</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = observable(&#123;</span><br><span class="line">  list: initialList,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> List = observer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> list = store.list;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'List渲染'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"list-container"</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map(<span class="function">(<span class="params">i, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;div className=<span class="string">"list-item"</span> key=&#123;i.id&#125;&gt;</span><br><span class="line">            &#123;<span class="comment">/* 假设这是一个复杂的组件 */</span>&#125;</span><br><span class="line">            &#123;<span class="built_in">console</span>.log(<span class="string">'render'</span>, i.id)&#125;</span><br><span class="line">            &lt;span className=<span class="string">"list-item-name"</span>&gt;&#123;i.name&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span className="list-item-value"&gt;&#123;i.value&#125; &lt;/</span>span&gt;</span><br><span class="line">            &lt;button</span><br><span class="line">              className=<span class="string">"list-item-increment"</span></span><br><span class="line">              onClick=&#123;() =&gt; &#123;</span><br><span class="line">                i.value++;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'递增'</span>);</span><br><span class="line">              &#125;&#125;</span><br><span class="line">            &gt;</span><br><span class="line">              递增</span><br><span class="line">            &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button</span></span><br><span class="line"><span class="regexp">              className="list-item-increment"</span></span><br><span class="line"><span class="regexp">              onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                if (idx &lt; list.length - 1) &#123;</span></span><br><span class="line"><span class="regexp">                  console.log('移位');</span></span><br><span class="line"><span class="regexp">                  let t = list[idx];</span></span><br><span class="line"><span class="regexp">                  list[idx] = list[idx + 1];</span></span><br><span class="line"><span class="regexp">                  list[idx + 1] = t;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">              &#125;&#125;</span></span><br><span class="line"><span class="regexp">            &gt;</span></span><br><span class="line"><span class="regexp">              下移</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><p><br></p><p>上述的例子是存在性能问题的，单个 list-item 的递增和移位都会导致整个列表的重新渲染:</p><center><br>  <img src="/images/09/list-demo.png" width="380"><br></center><p>原因大概能猜出来吧? 对于 Vue 或者 Mobx 来说，<strong>一个组件的渲染函数就是一个依赖收集的上下文</strong>。上面 List 组件渲染函数内’访问’了所有的列表项数据，那么 Vue 或 Mobx 就会认为你这个组件依赖于所有的列表项，这样就导致，只要任意一个列表项的属性值变动就会重新渲染整个 List 组件。</p><p>解决办法也很简单，就是将数据隔离抽取到单一职责的组件中。<strong>对于 Vue 或 Mobx 来说，越细粒度的组件，可以收获更高的性能优化效果</strong>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ListItem = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; item, onShiftDown &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"list-item"</span>&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'render'</span>, item.id)&#125;</span><br><span class="line">      &#123;<span class="comment">/* 假设这是一个复杂的组件 */</span>&#125;</span><br><span class="line">      &lt;span className=<span class="string">"list-item-name"</span>&gt;&#123;item.name&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span className="list-item-value"&gt;&#123;item.value&#125; &lt;/</span>span&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        className=<span class="string">"list-item-increment"</span></span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          item.value++;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'递增'</span>);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        递增</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button className="list-item-increment" onClick=&#123;() =&gt; onShiftDown(item)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        下移</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export const List = observer(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const list = store.list;</span></span><br><span class="line"><span class="regexp">  const handleShiftDown = useCallback(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const idx = list.findIndex(i =&gt; i.id === item.id);</span></span><br><span class="line"><span class="regexp">    if (idx !== -1 &amp;&amp; idx &lt; list.length - 1) &#123;</span></span><br><span class="line"><span class="regexp">      console.log('移位');</span></span><br><span class="line"><span class="regexp">      let t = list[idx];</span></span><br><span class="line"><span class="regexp">      list[idx] = list[idx + 1];</span></span><br><span class="line"><span class="regexp">      list[idx + 1] = t;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ eslint-disable-next-line react-hooks/</span>exhaustive-deps</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'List 渲染'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"list-container"</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map(<span class="function">(<span class="params">i, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;ListItem key=&#123;i.id&#125; item=&#123;i&#125; onShiftDown=&#123;handleShiftDown&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果很明显, list-item 递增只会重新渲染本身; 而移位只会重新渲染 List， 因为列表项没有变动, 所以下级 list-item 也不需要重新渲染:</p><center><br>  <img src="/images/09/list-demo2.png" width="380"><br></center><p><br><br><br></p><h3 id="1️⃣-不要滥用-context"><a href="#1️⃣-不要滥用-context" class="headerlink" title="1️⃣ 不要滥用 Context"></a>1️⃣ 不要滥用 Context</h3><p><strong>其实 Context 的用法和响应式数据正好相反</strong>。笔者也看过不少滥用 Context API 的例子, 说到底还是没有处理好‘状态的作用域问题’.</p><p>首先要理解 Context API 的更新特点，<strong>它是可以穿透<code>React.memo</code>或者<code>shouldComponentUpdate</code>的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate</strong>.</p><p><strong>这个和 Mobx 和 Vue 的响应式系统不同，Context API 并不能细粒度地检测哪些组件依赖哪些状态，所以说上节提到的‘精细化渲染’组件模式，在 Context 这里就成为了‘反模式’</strong>.</p><p>总结一下使用 Context API 要遵循一下原则:</p><p><br></p><ul><li><p><strong>明确状态作用域, Context 只放置必要的，关键的，被大多数组件所共享的状态</strong>。比较典型的是鉴权状态</p><p>举一个简单的例子:</p><center><br>  <img src="/images/09/use-context1.png" width="400"><br></center><center><br>  <img src="/images/09/use-context2.png" width="650"><br></center><p>扩展：Context其实有个实验性或者说非公开的选项<code>observedBits</code>, 可以用于控制ContextConsumer是否需要更新. 详细可以看这篇文章&lt;<a href="https://zhuanlan.zhihu.com/p/51073183" target="_blank" rel="noopener">ObservedBits: React Context的秘密功能</a>&gt;. 不过不推荐在实际项目中使用，而且这个API也比较难用，不如直接上mobx。</p></li><li><p><strong>粗粒度地订阅 Context</strong></p><p>如下图. 细粒度的 Context 订阅会导致不必要的重新渲染, 所以这里推荐粗粒度的订阅. 比如在父级订阅 Context，然后再通过 props 传递给下级。</p><center><br>  <img src="/images/09/context-vs-props.png" width="600"><br></center></li></ul><p><br></p><p>另外程墨 Morgan 在<a href="https://zhuanlan.zhihu.com/p/50336226" target="_blank" rel="noopener">避免 React Context 导致的重复渲染</a>一文中也提到 ContextAPI 的一个陷阱:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Context.Provider</span><br><span class="line">  value=&#123;&#123; <span class="attr">theme</span>: <span class="keyword">this</span>.state.theme, <span class="attr">switchTheme</span>: <span class="keyword">this</span>.switchTheme &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &lt;Content /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Context.Provider&gt;</span><br></pre></td></tr></table></figure><p>上面的组件会在 state 变化时重新渲染整个组件树，至于为什么留给读者去思考。</p><p>所以我们一般都不会裸露地使用 Context.Provider, 而是封装为独立的 Provider 组件:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 顺便暴露useTheme, 让外部必须直接使用Context</span></span><br><span class="line"><span class="regexp">export function useTheme() &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(Context);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>现在 theme 变动就不会重新渲染整个组件树，因为 props.children 由外部传递进来，并没有发生变动。</p><p><strong>其实上面的代码还有另外一个比较难发现的陷阱(官方文档也有<a href="https://zh-hans.reactjs.org/docs/context.html#caveats" target="_blank" rel="noopener">提到</a>)</strong>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;<span class="comment">/* 👇 💣这里每一次渲染ThemeProvider, 都会创建一个新的value(即使theme和switchTheme没有变动),</span></span><br><span class="line"><span class="comment">        从而导致强制渲染所有依赖该Context的组件 */</span>&#125;</span><br><span class="line">    &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>所以<strong>传递给 Context 的 value 最好做一下缓存</strong>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  <span class="keyword">const</span> value = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; theme, switchTheme &#125;), [theme]);</span><br><span class="line">  <span class="keyword">return</span> &lt;Context.Provider value=&#123;value&#125;&gt;&#123;props.children&#125;&lt;/Context.Provider&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://react.docschina.org/docs/optimizing-performance.html" target="_blank" rel="noopener">Optimizing Performance</a> React 官方文档，最好的教程, 利用好 React 的性能分析工具。</li><li><a href="https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3" target="_blank" rel="noopener">Twitter Lite and High Performance React Progressive Web Apps at Scale</a> 看看 Twitter 如何优化的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文来源于公司内部的一次闪电分享，稍作润色分享出来。主要讨论 React 性能优化的主要方向和一些小技巧。&lt;strong&gt;如果你觉得可以，请多点赞，鼓励我写出更精彩的文章&lt;/strong&gt;🙏。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;React 渲染性能优化的三个方向，其实
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] Preact</title>
    <link href="https://bobi.ink/2019/06/02/preact-map/"/>
    <id>https://bobi.ink/2019/06/02/preact-map/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-06-07T23:04:38.874Z</updated>
    
    <content type="html"><![CDATA[<p>React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路).</p><p>Preact 是 React 的缩略版, 体积非常小, 但五脏俱全. 如果你想了解 React 的基本原理, 可以去学习学习 Preact 的源码, 这也正是本文的目的。</p><p>关于 React 原理的优秀的文章已经非常多, 本文就是老酒装新瓶, 算是自己的一点总结，也为后面的文章作一下铺垫吧.</p><p>文章篇幅较长，阅读时间约 20min，主要被代码占据，另外也画了流程图配合理解代码。</p><blockquote><p>注意：代码有所简化，忽略掉 svg、replaceNode、context 等特性<br>本文代码基于 Preact v10 版本</p></blockquote><p><br></p><!-- TOC --><ul><li><a href="#virtual-dom">Virtual-DOM</a></li><li><a href="#从-createelement-开始">从 createElement 开始</a></li><li><a href="#component-的实现">Component 的实现</a></li><li><a href="#diff-算法">diff 算法</a><ul><li><a href="#diffchildren">diffChildren</a></li><li><a href="#diff">diff</a></li><li><a href="#diffelementnodes">diffElementNodes</a></li><li><a href="#diffprops">diffProps</a></li></ul></li><li><a href="#hooks-的实现">Hooks 的实现</a><ul><li><a href="#usestate">useState</a></li><li><a href="#useeffect">useEffect</a></li></ul></li><li><a href="#技术地图">技术地图</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="Virtual-DOM"></a>Virtual-DOM</h2><center><br> <img src="/images/07/vd.png" width="500"><br></center><p>Virtual-DOM 其实就是一颗对象树，没有什么特别的，这个对象树最终要映射到图形对象. Virtual-DOM 比较核心的是它的<code>diff算法</code>.</p><p>你可以想象这里有一个<code>DOM映射器</code>，见名知义，<strong>这个’DOM 映射器‘的工作就是将 Virtual-DOM 对象树映射浏览器页面的 DOM，只不过为了提高 DOM 的’操作性能’. 它不是每一次都全量渲染整个 Virtual-DOM 树，而是支持接收两颗 Virtual-DOM 对象树(一个更新前，一个更新后), 通过 diff 算法计算出两颗 Virtual-DOM 树差异的地方，然后只应用这些差异的地方到实际的 DOM 树, 从而减少 DOM 变更的成本.</strong></p><p>Virtual-DOM 是比较有争议性，推荐阅读<a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noopener">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a> 。切记永远都不要离开场景去评判一个技术的好坏。当初网上把 React 吹得多么牛逼, 一些小白就会觉得 Virtual-DOM 很吊，JQuery 弱爆了。</p><p>我觉得两个可比性不大，从性能上看, <strong>框架再怎么牛逼它也是需要操作原生 DOM 的，而且它未必有你使用 JQuery 手动操作 DOM 来得’精细’</strong>. 框架不合理使用也可能出现修改一个小状态，导致渲染雪崩(大范围重新渲染)的情况; 同理 JQuery 虽然可以精细化操作 DOM, 但是不合理的 DOM 更新策略可能也会成为应用的性能瓶颈. 所以关键还得看你怎么用.</p><p>那为什么需要 Virtual-DOM？</p><p><strong>我个人的理解就是为了解放生产力。现如今硬件的性能越来越好，web 应用也越来越复杂，生产力也是要跟上的</strong>. 尽管手动操作 DOM 可能可以达到更高的性能和灵活性，但是这样对大部分开发者来说太低效了，我们是可以接受牺牲一点性能换取更高的开发效率的.</p><p>所以说 Virtual-DOM 更大的意义在于开发方式的改变: 声明式、 数据驱动, 让开发者不需要关心 DOM 的操作细节(属性操作、事件绑定、DOM 节点变更)，也就是说应用的开发方式变成了<code>view=f(state)</code>, 这对生产力的解放是有很大推动作用的.</p><p>当然 Virtual-DOM 不是唯一，也不是第一个的这样解决方案. 比如 AngularJS, Vue1.x 这些基于模板的实现方式, 也可以说实现这种开发方式转变的. 那相对于他们 Virtual-DOM 的买点可能就是更高的性能了, 另外 Virtual-DOM 在渲染层上面的抽象更加彻底, 不再耦合于 DOM 本身，比如可以渲染为 ReactNative，PDF，终端 UI 等等。</p><p><br></p><hr><p><br></p><h2 id="从-createelement-开始"><a href="#从-createelement-开始" class="headerlink" title="从 createElement 开始"></a>从 createElement 开始</h2><p>很多小白将 <code>JSX</code> 等价为 Virtual-DOM，其实这两者并没有直接的关系, 我们知道 <strong>JSX 不过是一个语法糖</strong>.</p><p>例如<code>&lt;a href=&quot;/&quot;&gt;&lt;span&gt;Home&lt;/span&gt;&lt;/a&gt;</code>最终会转换为<code>h(&#39;a&#39;, { href:&#39;/&#39; }, h(&#39;span&#39;, null, &#39;Home&#39;))</code>这种形式, <code>h</code>是 JSX Element 工厂方法.</p><p><code>h</code> 在 React 下约定是<code>React.createElement</code>, 而大部分 Virtual-DOM 框架则使用<code>h</code>. <code>h</code> 是 <code>createElement</code> 的别名, Vue 生态系统也是使用这个惯例, 具体为什么没作考究(比较简短？)。</p><p>可以使用<code>@jsx</code>注解或 babel 配置项来配置 JSX 工厂：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @jsx h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">render(&lt;div&gt;hello jsx&lt;/div&gt;, el);</span><br></pre></td></tr></table></figure><p>本文不是 React 或 Preact 的入门文章，所以点到为止，更多内容可以查看<a href="https://preactjs.com/guide/getting-started" target="_blank" rel="noopener">官方教程</a>.</p><p>现在来看看<code>createElement</code>, <strong>createElement 不过就是构造一个对象(VNode)</strong>:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️type 节点的类型，有DOM元素(string)和自定义组件，以及Fragment, 为null时表示文本节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  props.children = children;</span><br><span class="line">  <span class="comment">// ⚛️应用defaultProps</span></span><br><span class="line">  <span class="keyword">if</span> (type != <span class="literal">null</span> &amp;&amp; type.defaultProps != <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> type.defaultProps)</span><br><span class="line">      <span class="keyword">if</span> (props[i] === <span class="literal">undefined</span>) props[i] = type.defaultProps[i];</span><br><span class="line">  <span class="keyword">let</span> ref = props.ref;</span><br><span class="line">  <span class="keyword">let</span> key = props.key;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️构建VNode对象</span></span><br><span class="line">  <span class="keyword">return</span> createVNode(type, props, key, ref);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createVNode</span>(<span class="params">type, props, key, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; type, props, key, ref, <span class="comment">/* ... 忽略部分内置字段 */</span> <span class="keyword">constructor</span>: undefined &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>通过 JSX 和组件, 可以构造复杂的对象树:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;SideBar /&gt;</span><br><span class="line">    &lt;Body /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  root,</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="component-的实现"><a href="#component-的实现" class="headerlink" title="Component 的实现"></a>Component 的实现</h2><p>对于一个视图框架来说，组件就是它的灵魂, 就像函数之于函数式语言，类之于面向对象语言, 没有组件则无法组成复杂的应用.</p><p>组件化的思维推荐将一个应用分而治之, 拆分和组合不同级别的组件，这样可以简化应用的开发和维护，让程序更好理解. 从技术上看<strong>组件是一个自定义的元素类型，可以声明组件的输入(props)、有自己的生命周期和状态以及方法、最终输出 Virtual-DOM 对象树, 作为应用 Virtual-DOM 树的一个分支存在</strong>.</p><p>Preact 的自定义组件是基于 Component 类实现的. 对组件来说最基本的就是状态的维护, 这个通过 setState 来实现:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️setState实现</span></span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">update, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 克隆下一次渲染的State, _nextState会在一些生命周期方式中用到(例如shouldComponentUpdate)</span></span><br><span class="line">  <span class="keyword">let</span> s = (<span class="keyword">this</span>._nextState !== <span class="keyword">this</span>.state &amp;&amp; <span class="keyword">this</span>._nextState) ||</span><br><span class="line">    (<span class="keyword">this</span>._nextState = assign(&#123;&#125;, <span class="keyword">this</span>.state));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// state更新</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> update !== <span class="string">'function'</span> || (update = update(s, <span class="keyword">this</span>.props)))</span><br><span class="line">    assign(s, update);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._vnode) &#123; <span class="comment">// 已挂载</span></span><br><span class="line">    <span class="comment">// 推入渲染回调队列, 在渲染完成后批量调用</span></span><br><span class="line">    <span class="keyword">if</span> (callback) <span class="keyword">this</span>._renderCallbacks.push(callback);</span><br><span class="line">    <span class="comment">// 放入异步调度队列</span></span><br><span class="line">    enqueueRender(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p><code>enqueueRender</code> 将组件放进一个异步的批执行队列中，这样可以归并频繁的 setState 调用，实现也非常简单:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> q = [];</span><br><span class="line"><span class="comment">// 异步调度器，用于异步执行一个回调</span></span><br><span class="line"><span class="keyword">const</span> defer = <span class="keyword">typeof</span> <span class="built_in">Promise</span> == <span class="string">'function'</span></span><br><span class="line">    ? <span class="built_in">Promise</span>.prototype.then.bind(<span class="built_in">Promise</span>.resolve()) <span class="comment">// micro task</span></span><br><span class="line">    : setTimeout; <span class="comment">// 回调到setTimeout</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueRender</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不需要重复推入已经在队列的Component</span></span><br><span class="line">  <span class="keyword">if</span> (!c._dirty &amp;&amp; (c._dirty = <span class="literal">true</span>) &amp;&amp; q.push(c) === <span class="number">1</span>)</span><br><span class="line">    defer(process); <span class="comment">// 当队列从空变为非空时，开始调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量清空队列, 调用Component的forceUpdate</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p;</span><br><span class="line">  <span class="comment">// 排序队列，从低层的组件优先更新?</span></span><br><span class="line">  q.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b._depth - a._depth);</span><br><span class="line">  <span class="keyword">while</span> ((p = q.pop()))</span><br><span class="line">    <span class="keyword">if</span> (p._dirty) p.forceUpdate(<span class="literal">false</span>); <span class="comment">// false表示不要强制更新，即不要忽略shouldComponentUpdate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>Ok, 上面的代码可以看出 <code>setState</code> 本质上是调用 <code>forceUpdate</code> 进行组件重新渲染的，来往下挖一挖 forceUpdate 的实现.</p><blockquote><p>这里暂且忽略 diff, <strong>将 diff 视作一个黑盒，他就是一个 DOM 映射器, 像上面说的 diff 接收两棵 VNode 树, 以及一个 DOM 挂载点, 在比对的过程中它可以会创建、移除或更新组件和 DOM 元素，触发对应的生命周期方法</strong>.</p></blockquote><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; <span class="comment">// callback放置渲染完成后的回调</span></span><br><span class="line">  <span class="keyword">let</span> vnode = <span class="keyword">this</span>._vnode, dom = <span class="keyword">this</span>._vnode._dom, parentDom = <span class="keyword">this</span>._parentDom;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentDom) &#123; <span class="comment">// 已挂载过</span></span><br><span class="line">    <span class="keyword">const</span> force = callback !== <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> mounts = [];</span><br><span class="line">    <span class="comment">// 调用diff对当前组件进行重新渲染和Virtual-DOM比对</span></span><br><span class="line">    <span class="comment">// ⚛️暂且忽略这些参数, 将diff视作一个黑盒，他就是一个DOM映射器，</span></span><br><span class="line">    dom = diff(parentDom, vnode, vnode, mounts, <span class="keyword">this</span>._ancestorComponent, force, dom);</span><br><span class="line">    <span class="keyword">if</span> (dom != <span class="literal">null</span> &amp;&amp; dom.parentNode !== parentDom)</span><br><span class="line">      parentDom.appendChild(dom);</span><br><span class="line">    commitRoot(mounts, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (callback) callback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>在看看 <code>render</code> 方法, 实现跟 forceUpdate 差不多, 都是调用 diff 算法来执行 DOM 更新，只不过由外部指定一个 DOM 容器:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, parentDom</span>) </span>&#123;</span><br><span class="line">  vnode = createElement(Fragment, <span class="literal">null</span>, [vnode]);</span><br><span class="line">  parentDom.childNodes.forEach(<span class="function"><span class="params">i</span> =&gt;</span> i.remove())</span><br><span class="line">  <span class="keyword">let</span> mounts = [];</span><br><span class="line">  diffChildren(parentDom, <span class="literal">null</span> oldVNode, mounts, vnode, EMPTY_OBJ);</span><br><span class="line">  commitRoot(mounts, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>梳理一下上面的流程:</p><center><br>  <img src="/images/07/setState.png" width="800"><br></center><p>到目前为止没有看到组件的其他功能，如初始化、生命周期函数。这些特性在 diff 函数中定义，也就是说在组件挂载或更新的过程中被调用。下一节就会介绍 diff</p><p><br></p><hr><p><br></p><h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p>千呼万唤始出来，通过上文可以看出，<code>createElement</code> 和 <code>Component</code> 逻辑都很薄， 主要的逻辑还是集中在 diff 函数中. React 将这个过程称为 <code>Reconciliation</code>, 在 Preact 中称为 <code>Differantiate</code>.</p><p>为了简化程序 Preact 的实现将 diff 和 DOM 杂糅在一起, 但逻辑还是很清晰，看下目录结构就知道了:</p><p><br></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/diff</span><br><span class="line">├── children.js # 比对children数组</span><br><span class="line">├── index.js    # 比对两个节点</span><br><span class="line">└── props.js    # 比对两个DOM节点的props</span><br></pre></td></tr></table></figure><center><br>  <img src="/images/07/diff.png" width="600"><br></center><p><br></p><p>在深入 diff 程序之前，先看一下基本的对象结构, 方便后面理解程序流程. 先来看下 VNode 的外形:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type ComponentFactory&lt;P&gt; = preact.ComponentClass&lt;P&gt; | FunctionalComponent&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">interface VNode&lt;P = &#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="comment">// 节点类型, 内置DOM元素为string类型，而自定义组件则是Component类型，Preact中函数组件只是特殊的Component类型</span></span><br><span class="line">  type: string | ComponentFactory&lt;P&gt; | <span class="literal">null</span>;</span><br><span class="line">  props: P &amp; &#123; <span class="attr">children</span>: ComponentChildren &#125; | string | number | <span class="literal">null</span>;</span><br><span class="line">  key: Key</span><br><span class="line">  ref: Ref&lt;any&gt; | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 内部缓存信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// VNode子节点</span></span><br><span class="line">  _children: <span class="built_in">Array</span>&lt;VNode&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 关联的DOM节点, 对于Fragment来说第一个子节点</span></span><br><span class="line">  _dom: PreactElement | Text | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// Fragment, 或者组件返回Fragment的最后一个DOM子节点，</span></span><br><span class="line">  _lastDomChild: PreactElement | Text | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// Component实例</span></span><br><span class="line">  _component: Component | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="diffchildren"><a href="#diffchildren" class="headerlink" title="diffChildren"></a>diffChildren</h3><p>先从最简单的开始, 上面已经猜出 diffChildren 用于比对两个 VNode 列表.</p><center><br>  <img src="/images/07/diffChildren-base.png" width="600"><br></center><p>如上图, 首先这里需要维护一个表示当前插入位置的变量 oldDOM, 它一开始指向 DOM childrenNode 的第一个元素, 后面每次插入更新或插入 newDOM，都会指向 newDOM 的下一个兄弟元素.</p><p>在遍历 newChildren 列表过程中, 会尝试找出相同 key 的旧 VNode，和它进行 diff. 如果新 VNode 和旧 VNode 位置不一样，这就需要移动它们;对于新增的 DOM，如果插入位置(oldDOM)已经到了结尾，则直接追加到父节点, 否则插入到 oldDOM 之前。</p><p>最后卸载旧 VNode 列表中未使用的 VNode.</p><p>来详细看看源码:</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentDom,         <span class="regexp">//</span> children的父DOM元素</span></span></span><br><span class="line"><span class="function"><span class="params">  newParentVNode,    <span class="regexp">//</span> children的新父VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  oldParentVNode,    <span class="regexp">//</span> children的旧父VNode，diffChildren主要比对这两个Vnode的children</span></span></span><br><span class="line"><span class="function"><span class="params">  mounts,            <span class="regexp">//</span> 保存在这次比对过程中被挂载的组件实例，在比对后，会触发这些组件的componentDidMount生命周期函数</span></span></span><br><span class="line"><span class="function"><span class="params">  ancestorComponent, <span class="regexp">//</span> children的直接父<span class="string">'组件'</span>, 即渲染(render</span>)<span class="title">VNode</span>的组件实例</span></span><br><span class="line"><span class="function">  <span class="title">oldDom</span>,            // 当前挂载的<span class="title">DOM</span>，对于<span class="title">diffChildren</span>来说，<span class="title">oldDom</span>一开始指向第一个子节点</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newChildren = newParentVNode._children || toChildArray(newParentVNode.props.children, (newParentVNode._children = []), coerceToVNode, <span class="literal">true</span>,);</span><br><span class="line">  <span class="keyword">let</span> oldChildren = (oldParentVNode &amp;&amp; oldParentVNode._children) || EMPTY_ARR;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️遍历新children</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">    childVNode = newChildren[i] = coerceToVNode(newChildren[i]); <span class="comment">// 规范化VNode</span></span><br><span class="line">    <span class="keyword">if</span> (childVNode == <span class="literal">null</span>) <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">// ⚛️查找oldChildren中是否有对应的元素，如果找到则通过设置为undefined，从oldChildren中移除</span></span><br><span class="line">    <span class="comment">// 如果没有找到则保持为null</span></span><br><span class="line">    oldVNode = oldChildren[i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; oldChildrenLength; j++) &#123;</span><br><span class="line">      oldVNode = oldChildren[j];</span><br><span class="line">      <span class="keyword">if</span> (oldVNode &amp;&amp; childVNode.key == oldVNode.key &amp;&amp; childVNode.type === oldVNode.type) &#123;</span><br><span class="line">        oldChildren[j] = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      oldVNode = <span class="literal">null</span>; <span class="comment">// 没有找到任何旧node，表示是一个新的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⚛️ 递归比对VNode</span></span><br><span class="line">    newDom = diff(parentDom, childVNode, oldVNode, mounts, ancestorComponent, <span class="literal">null</span>, oldDom);</span><br><span class="line">    <span class="comment">// vnode没有被diff卸载掉</span></span><br><span class="line">    <span class="keyword">if</span> (newDom != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (childVNode._lastDomChild != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ⚛️当前VNode是Fragment类型</span></span><br><span class="line">        <span class="comment">// 只有Fragment或组件返回Fragment的Vnode会有非null的_lastDomChild, 从Fragment的结尾的DOM树开始比对:</span></span><br><span class="line">        <span class="comment">// &lt;A&gt;                               &lt;A&gt;</span></span><br><span class="line">        <span class="comment">//  &lt;&gt;                                 &lt;&gt;   👈 Fragment类型，diff会递归比对它的children，所以最后我们只需要将newDom指向比对后的最后一个子节点即可</span></span><br><span class="line">        <span class="comment">//    &lt;a&gt;a&lt;/a&gt;           &lt;- diff -&gt;      &lt;b&gt;b&lt;/b&gt;</span></span><br><span class="line">        <span class="comment">//    &lt;b&gt;b&lt;/b&gt;                           &lt;a&gt;a&lt;/a&gt; ----+</span></span><br><span class="line">        <span class="comment">//  &lt;/&gt;                                &lt;/&gt;             \</span></span><br><span class="line">        <span class="comment">//                                     &lt;div&gt;x&lt;/div&gt;     👈oldDom会指向这里</span></span><br><span class="line">        <span class="comment">// &lt;/A&gt;                              &lt;/A&gt;</span></span><br><span class="line">        newDom = childVNode._lastDomChild;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVNode == <span class="literal">null</span> || newDom != oldDom || newDom.parentNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ newDom和当前oldDom不匹配，尝试新增或修改位置</span></span><br><span class="line">        outer: <span class="keyword">if</span> (oldDom == <span class="literal">null</span> || oldDom.parentNode !== parentDom) &#123;</span><br><span class="line">          <span class="comment">// ⚛️oldDom指向了结尾, 即后面没有更多元素了，直接插入即可; 首次渲染一般会调用到这里</span></span><br><span class="line">          parentDom.appendChild(newDom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 这里是一个优化措施，去掉也不会影响正常程序. 为了便于理解可以忽略这段代码</span></span><br><span class="line">          <span class="comment">// 尝试向后查找oldChildLength/2个元素，如果找到则不需要调用insertBefore. 这段代码可以减少insertBefore的调用频率</span></span><br><span class="line">          <span class="keyword">for</span> (sibDom = oldDom, j = <span class="number">0</span>; (sibDom = sibDom.nextSibling) &amp;&amp; j &lt; oldChildrenLength; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sibDom == newDom)</span><br><span class="line">              <span class="keyword">break</span> outer;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ⚛️insertBefore() 将newDom移动到oldDom之前 </span></span><br><span class="line">          parentDom.insertBefore(newDom, oldDom);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ⚛️其他情况，newDom === oldDOM不需要处理</span></span><br><span class="line">      <span class="comment">// ⚛️ oldDom指向下一个DOM节点</span></span><br><span class="line">      oldDom = newDom.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 卸载掉没有被置为undefined的元素</span></span><br><span class="line">  <span class="keyword">for</span> (i = oldChildrenLength; i--; )</span><br><span class="line">    <span class="keyword">if</span> (oldChildren[i] != <span class="literal">null</span>) unmount(oldChildren[i], ancestorComponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>配图理解一下 diffChilrend 的调用过程:</p><center><br>  <img src="/images/07/diffChildren.png" width="600"><br></center><p><br></p><p>总结一下流程图</p><center><br>  <img src="/images/07/diffChildren-process.png" width="800"><br></center><p><br></p><hr><p><br></p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>diff 用于比对两个 VNode 节点. diff 函数比较冗长, 但是这里面并没有特别复杂逻辑，主要是一些自定义组件生命周期的处理。所以先上流程图，代码不感兴趣可以跳过.</p><center><br>  <img src="/images/07/diff-process.png" width="800"><br></center><p><br></p><p>源代码解析：</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentDom,         <span class="regexp">//</span> 父DOM节点</span></span></span><br><span class="line"><span class="function"><span class="params">  newVNode,          <span class="regexp">//</span> 新VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  oldVNode,          <span class="regexp">//</span> 旧VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  mounts,            <span class="regexp">//</span> 存放已挂载的组件, 将在diff结束后批量处理</span></span></span><br><span class="line"><span class="function"><span class="params">  ancestorComponent, <span class="regexp">//</span> 直接父组件</span></span></span><br><span class="line"><span class="function"><span class="params">  force,             <span class="regexp">//</span> 是否强制更新, 为true将忽略掉shouldComponentUpdate</span></span></span><br><span class="line"><span class="function"><span class="params">  oldDom,            <span class="regexp">//</span> 当前挂载的DOM节点</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    outer: <span class="keyword">if</span> (oldVNode.type === Fragment || newType === Fragment) &#123;</span><br><span class="line">      <span class="comment">// ⚛️ Fragment类型，使用diffChildren进行比对</span></span><br><span class="line">      diffChildren(parentDom, newVNode, oldVNode, mounts, ancestorComponent, oldDom);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️记录Fragment的起始DOM和结束DOM</span></span><br><span class="line">      <span class="keyword">let</span> i = newVNode._children.length;</span><br><span class="line">      <span class="keyword">if</span> (i &amp;&amp; (tmp = newVNode._children[<span class="number">0</span>]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        newVNode._dom = tmp._dom;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">          tmp = newVNode._children[i];</span><br><span class="line">          <span class="keyword">if</span> (newVNode._lastDomChild = tmp &amp;&amp; (tmp._lastDomChild || tmp._dom))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newType === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️自定义组件类型</span></span><br><span class="line">      <span class="keyword">if</span> (oldVNode._component) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ ️已经存在组件实例</span></span><br><span class="line">        c = newVNode._component = oldVNode._component;</span><br><span class="line">        newVNode._dom = oldVNode._dom;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️初始化组件实例</span></span><br><span class="line">        <span class="keyword">if</span> (newType.prototype &amp;&amp; newType.prototype.render) &#123;</span><br><span class="line">          <span class="comment">// ⚛️类组件</span></span><br><span class="line">          newVNode._component = c = <span class="keyword">new</span> newType(newVNode.props, cctx); <span class="comment">// eslint-disable-line new-cap</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️函数组件</span></span><br><span class="line">          newVNode._component = c = <span class="keyword">new</span> Component(newVNode.props, cctx);</span><br><span class="line">          c.constructor = newType;</span><br><span class="line">          c.render = doRender;</span><br><span class="line">        &#125;</span><br><span class="line">        c._ancestorComponent = ancestorComponent;</span><br><span class="line">        c.props = newVNode.props;</span><br><span class="line">        <span class="keyword">if</span> (!c.state) c.state = &#123;&#125;;</span><br><span class="line">        isNew = c._dirty = <span class="literal">true</span>;</span><br><span class="line">        c._renderCallbacks = [];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      c._vnode = newVNode;</span><br><span class="line">      <span class="keyword">if</span> (c._nextState == <span class="literal">null</span>) c._nextState = c.state;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️getDerivedStateFromProps 生命周期方法</span></span><br><span class="line">      <span class="keyword">if</span> (newType.getDerivedStateFromProps != <span class="literal">null</span>)</span><br><span class="line">        assign(c._nextState == c.state</span><br><span class="line">            ? (c._nextState = assign(&#123;&#125;, c._nextState)) <span class="comment">// 惰性拷贝</span></span><br><span class="line">            : c._nextState,</span><br><span class="line">          newType.getDerivedStateFromProps(newVNode.props, c._nextState),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isNew) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 调用挂载前的一些生命周期方法</span></span><br><span class="line">        <span class="comment">// ⚛️ componentWillMount</span></span><br><span class="line">        <span class="keyword">if</span> (newType.getDerivedStateFromProps == <span class="literal">null</span> &amp;&amp; c.componentWillMount != <span class="literal">null</span>) c.componentWillMount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ componentDidMount</span></span><br><span class="line">        <span class="comment">// 将组件推入mounts数组，在整个组件树diff完成后批量调用, 他们在commitRoot方法中被调用</span></span><br><span class="line">        <span class="comment">// 按照先进后出(栈)的顺序调用, 即子组件的componentDidMount会先调用</span></span><br><span class="line">        <span class="keyword">if</span> (c.componentDidMount != <span class="literal">null</span>) mounts.push(c);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 调用重新渲染相关的一些生命周期方法</span></span><br><span class="line">        <span class="comment">// ⚛️ componentWillReceiveProps</span></span><br><span class="line">        <span class="keyword">if</span> (newType.getDerivedStateFromProps == <span class="literal">null</span> &amp;&amp; force == <span class="literal">null</span> &amp;&amp; c.componentWillReceiveProps != <span class="literal">null</span>)</span><br><span class="line">          c.componentWillReceiveProps(newVNode.props, cctx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ shouldComponentUpdate</span></span><br><span class="line">        <span class="keyword">if</span> (!force &amp;&amp; c.shouldComponentUpdate != <span class="literal">null</span> &amp;&amp; c.shouldComponentUpdate(newVNode.props, c._nextState, cctx) === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="comment">// shouldComponentUpdate返回false，取消渲染更新</span></span><br><span class="line">          c.props = newVNode.props;</span><br><span class="line">          c.state = c._nextState;</span><br><span class="line">          c._dirty = <span class="literal">false</span>;</span><br><span class="line">          newVNode._lastDomChild = oldVNode._lastDomChild;</span><br><span class="line">          <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ componentWillUpdate</span></span><br><span class="line">        <span class="keyword">if</span> (c.componentWillUpdate != <span class="literal">null</span>) c.componentWillUpdate(newVNode.props, c._nextState, cctx);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️至此props和state已经确定下来，缓存和更新props和state准备渲染</span></span><br><span class="line">      oldProps = c.props;</span><br><span class="line">      oldState = c.state;</span><br><span class="line">      c.props = newVNode.props;</span><br><span class="line">      c.state = c._nextState;</span><br><span class="line">      <span class="keyword">let</span> prev = c._prevVNode || <span class="literal">null</span>;</span><br><span class="line">      c._dirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️渲染</span></span><br><span class="line">      <span class="keyword">let</span> vnode = (c._prevVNode = coerceToVNode(c.render(c.props, c.state)));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️getSnapshotBeforeUpdate</span></span><br><span class="line">      <span class="keyword">if</span> (!isNew &amp;&amp; c.getSnapshotBeforeUpdate != <span class="literal">null</span>) snapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️组件层级，会影响更新的优先级</span></span><br><span class="line">      c._depth = ancestorComponent ? (ancestorComponent._depth || <span class="number">0</span>) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// ⚛️递归diff渲染结果</span></span><br><span class="line">      c.base = newVNode._dom = diff(parentDom, vnode, prev, mounts, c, <span class="literal">null</span>, oldDom);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (vnode != <span class="literal">null</span>) &#123;</span><br><span class="line">        newVNode._lastDomChild = vnode._lastDomChild;</span><br><span class="line">      &#125;</span><br><span class="line">      c._parentDom = parentDom;</span><br><span class="line">      <span class="comment">// ⚛️应用ref</span></span><br><span class="line">      <span class="keyword">if</span> ((tmp = newVNode.ref)) applyRef(tmp, c, ancestorComponent);</span><br><span class="line">      <span class="comment">// ⚛️调用renderCallbacks，即setState的回调</span></span><br><span class="line">      <span class="keyword">while</span> ((tmp = c._renderCallbacks.pop())) tmp.call(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️componentDidUpdate</span></span><br><span class="line">      <span class="keyword">if</span> (!isNew &amp;&amp; oldProps != <span class="literal">null</span> &amp;&amp; c.componentDidUpdate != <span class="literal">null</span>) c.componentDidUpdate(oldProps, oldState, snapshot);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️比对两个DOM元素</span></span><br><span class="line">      newVNode._dom = diffElementNodes(oldVNode._dom, newVNode, oldVNode, mounts, ancestorComponent);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((tmp = newVNode.ref) &amp;&amp; oldVNode.ref !== tmp) applyRef(tmp, newVNode._dom, ancestorComponent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ⚛️捕获渲染错误，传递给上级组件的didCatch生命周期方法</span></span><br><span class="line">    catchErrorInComponent(e, ancestorComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newVNode._dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><hr><p><br></p><h3 id="diffelementnodes"><a href="#diffelementnodes" class="headerlink" title="diffElementNodes"></a>diffElementNodes</h3><p>比对两个 DOM 元素, 流程非常简单:</p><center><br>  <img src="/images/07/diffElementNodes-process.png" width="600"><br></center><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffElementNodes</span>(<span class="params">dom, newVNode, oldVNode, mounts, ancestorComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️创建DOM节点</span></span><br><span class="line">  <span class="keyword">if</span> (dom == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVNode.type === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️文本节点, 没有属性和子级，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(newProps);</span><br><span class="line">    &#125;</span><br><span class="line">    dom = <span class="built_in">document</span>.createElement(newVNode.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newVNode.type === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ⚛️文本节点更新</span></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps) dom.data = newProps;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVNode !== oldVNode) &#123;</span><br><span class="line">      <span class="comment">// newVNode !== oldVNode 这说明是一个静态节点</span></span><br><span class="line">      <span class="keyword">let</span> oldProps = oldVNode.props || EMPTY_OBJ;</span><br><span class="line">      <span class="keyword">let</span> newProps = newVNode.props;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ dangerouslySetInnerHTML处理</span></span><br><span class="line">      <span class="keyword">let</span> oldHtml = oldProps.dangerouslySetInnerHTML;</span><br><span class="line">      <span class="keyword">let</span> newHtml = newProps.dangerouslySetInnerHTML;</span><br><span class="line">      <span class="keyword">if</span> (newHtml || oldHtml)</span><br><span class="line">        <span class="keyword">if</span> (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html)</span><br><span class="line">          dom.innerHTML = (newHtml &amp;&amp; newHtml.__html) || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️递归比对子元素</span></span><br><span class="line">      diffChildren(dom, newVNode, oldVNode, context, mounts, ancestorComponent, EMPTY_OBJ);</span><br><span class="line">      <span class="comment">// ⚛️递归比对DOM属性</span></span><br><span class="line">      diffProps(dom, newProps, oldProps, isSvg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><hr><p><br></p><h3 id="diffprops"><a href="#diffprops" class="headerlink" title="diffProps"></a>diffProps</h3><p>diffProps 用于更新 DOM 元素的属性</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">dom, newProps, oldProps, isSvg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(newProps).sort();</span><br><span class="line">  <span class="comment">// ⚛️比较并设置属性</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> k = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (k !== <span class="string">'children'</span> &amp;&amp; k !== <span class="string">'key'</span> &amp;&amp;</span><br><span class="line">      (!oldProps || (k === <span class="string">'value'</span> || k === <span class="string">'checked'</span> ? dom : oldProps)[k] !== newProps[k])) </span><br><span class="line">      setProperty(dom, k, newProps[k], oldProps[k], isSvg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️清空属性</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> oldProps)</span><br><span class="line">    <span class="keyword">if</span> (i !== <span class="string">'children'</span> &amp;&amp; i !== <span class="string">'key'</span> &amp;&amp; !(i <span class="keyword">in</span> newProps))</span><br><span class="line">      setProperty(dom, i, <span class="literal">null</span>, oldProps[i], isSvg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>diffProps 实现比较简单，就是遍历一下属性有没有变动，有变动则通过 setProperty 设置属性。对于失效的 props 也会通过 setProperty 置空。这里面稍微有点复杂的是 setProperty. 这里涉及到事件的处理, 命名的转换等等:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>(<span class="params">dom, name, value, oldValue, isSvg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'style'</span>) &#123;</span><br><span class="line">    <span class="comment">// ⚛️样式设置</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = assign(assign(&#123;&#125;, oldValue), value);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">      <span class="comment">// 样式属性没有变动</span></span><br><span class="line">      <span class="keyword">if</span> ((value || EMPTY_OBJ)[i] === (oldValue || EMPTY_OBJ)[i]) <span class="keyword">continue</span>;</span><br><span class="line">      dom.style.setProperty(</span><br><span class="line">        i[<span class="number">0</span>] === <span class="string">'-'</span> &amp;&amp; i[<span class="number">1</span>] === <span class="string">'-'</span> ? i : i.replace(CAMEL_REG, <span class="string">'-$&amp;'</span>),</span><br><span class="line">        value &amp;&amp; i <span class="keyword">in</span> value</span><br><span class="line">          ? <span class="keyword">typeof</span> <span class="keyword">set</span>[i] === 'number' &amp;&amp; IS_NON_DIMENSIONAL.test(i) === false</span><br><span class="line">            ? <span class="keyword">set</span>[i] + 'px'</span><br><span class="line">            : <span class="keyword">set</span>[i]</span><br><span class="line">          : '', // 清空</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (name[0] === 'o' &amp;&amp; name[1] === 'n') &#123;</span><br><span class="line">    <span class="comment">// ⚛️事件绑定</span></span><br><span class="line">    <span class="keyword">let</span> useCapture = name !== (name = name.replace(<span class="regexp">/Capture$/</span>, <span class="string">''</span>));</span><br><span class="line">    <span class="keyword">let</span> nameLower = name.toLowerCase();</span><br><span class="line">    name = (nameLower <span class="keyword">in</span> dom ? nameLower : name).slice(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      <span class="comment">// ⚛️首次添加事件, 注意这里是eventProxy为事件处理器</span></span><br><span class="line">      <span class="comment">// preact统一将所有事件处理器收集在dom._listeners对象中，统一进行分发</span></span><br><span class="line">      <span class="comment">// function eventProxy(e) &#123;</span></span><br><span class="line">      <span class="comment">//   return this._listeners[e.type](options.event ? options.event(e) : e);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">if</span> (!oldValue) dom.addEventListener(name, eventProxy, useCapture);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      dom.removeEventListener(name, eventProxy, useCapture);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存事件队列</span></span><br><span class="line">    (dom._listeners || (dom._listeners = &#123;&#125;))[name] = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name !== <span class="string">'list'</span> &amp;&amp; name !== <span class="string">'tagName'</span> &amp;&amp; name <span class="keyword">in</span> dom) &#123;</span><br><span class="line">    <span class="comment">// ⚛️DOM对象属性</span></span><br><span class="line">    dom[name] = value == <span class="literal">null</span> ? <span class="string">''</span> : value;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> value !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    name !== <span class="string">'dangerouslySetInnerHTML'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ⚛️DOM元素属性</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">      dom.removeAttribute(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dom.setAttribute(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>OK 至此 Diff 算法介绍完毕，其实这里面的逻辑并不是特别复杂, 当然 Preact 只是一个极度精简的框架，React 复杂度要高得多，尤其 React Fiber 重构之后。你也可以把 Preact 当做 React 的历史回顾，有兴趣再深入了解 React 的最新架构。</p><p><br></p><hr><p><br></p><h2 id="hooks-的实现"><a href="#hooks-的实现" class="headerlink" title="Hooks 的实现"></a>Hooks 的实现</h2><p>React16.8 正式引入的 hooks，这玩意带来了全新的 React 组件开发方式，让代码变得更加简洁。 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a>这篇文章已经揭示了 hooks 的基本实现原理, 它不过是基于数组实现的。preact 也实现了 hooks 机制，实现代码也就百来行，让我们来体会体会.</p><p>hooks 功能本身是没有集成在 Preact 代码库内部的，而是通过<code>preact/hooks</code>导入</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'preact'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'preact/hooks'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mounted'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello hooks&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>那 Preact 是如何扩展 diff 算法来实现 hooks 的呢？ 实际上 Preact 提供了<code>options</code>对象来对 Preact diff 进行扩展，options 类似于 Preact 生命周期钩子，在 diff 过程中被调用(为了行文简洁，上面的代码我忽略掉了)。例如:</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"><span class="regexp">/*...*/</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️开始diff</span></span><br><span class="line">  <span class="keyword">if</span> ((tmp = options.diff)) tmp(newVNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    outer: <span class="keyword">if</span> (oldVNode.type === Fragment || newType === Fragment) &#123;</span><br><span class="line">      <span class="comment">// Fragment diff</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newType === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 自定义组件diff</span></span><br><span class="line">      <span class="comment">// ⚛️开始渲染</span></span><br><span class="line">      <span class="keyword">if</span> ((tmp = options.render)) tmp(newVNode);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        c.render(c.props, c.state, c.context),</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// ⚛️捕获异常</span></span><br><span class="line">        <span class="keyword">if</span> ((tmp = options.catchRender) &amp;&amp; tmp(e, c)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// DOM element diff</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⚛️diff结束</span></span><br><span class="line">    <span class="keyword">if</span> ((tmp = options.diffed)) tmp(newVNode);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    catchErrorInComponent(e, ancestorComponent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newVNode._dom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><h3 id="usestate"><a href="#usestate" class="headerlink" title="useState"></a>useState</h3><p>先从最常用的 useState 开始:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️OK只是数组，没有Magic，每个hooks调用都会递增currenIndex, 从当前组件中取出状态</span></span><br><span class="line">  <span class="keyword">const</span> hookState = getHookState(currentIndex++);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!hookState._component) &#123;</span><br><span class="line">    hookState._component = currentComponent; <span class="comment">// 当前组件实例</span></span><br><span class="line">    hookState._value = [</span><br><span class="line">      <span class="comment">// ⚛️state, 初始化state</span></span><br><span class="line">      <span class="keyword">typeof</span> initialState === <span class="string">'function'</span> ? initialState() : initialState,</span><br><span class="line">      <span class="comment">// ⚛️dispatch</span></span><br><span class="line">      value =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> nextValue = <span class="keyword">typeof</span> value === <span class="string">'function'</span> ? value(hookState._value[<span class="number">0</span>]) : value;</span><br><span class="line">        <span class="keyword">if</span> (hookState._value[<span class="number">0</span>] !== nextValue) &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 保存状态并调用setState强制更新</span></span><br><span class="line">          hookState._value[<span class="number">0</span>] = nextValue;</span><br><span class="line">          hookState._component.setState(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hookState._value; <span class="comment">// [state, dispatch]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>从代码可以看到，关键在于<code>getHookState</code>的实现</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; options &#125; <span class="keyword">from</span> <span class="string">'preact'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentIndex; <span class="comment">// 保存当前hook的索引</span></span><br><span class="line"><span class="keyword">let</span> currentComponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️render 钩子, 在组件开始渲染之前调用</span></span><br><span class="line"><span class="comment">// 因为Preact是同步递归向下渲染的，而且Javascript是单线程的，所以可以安全地引用当前正在渲染的组件实例</span></span><br><span class="line">options.render = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  currentComponent = vnode._component; <span class="comment">// 保存当前正在渲染的组件</span></span><br><span class="line">  currentIndex = <span class="number">0</span>;                    <span class="comment">// 开始渲染时index重置为0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暂时忽略，下面讲到useEffect就能理解</span></span><br><span class="line">  <span class="comment">// 清空上次渲染未处理的Effect(useEffect)，只有在快速重新渲染时才会出现这种情况，一般在异步队列中被处理</span></span><br><span class="line">  <span class="keyword">if</span> (currentComponent.__hooks) &#123;</span><br><span class="line">    currentComponent.__hooks._pendingEffects = handleEffects(</span><br><span class="line">      currentComponent.__hooks._pendingEffects,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️no magic!, 只是一个数组, 状态保存在组件实例的_list数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHookState</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取或初始化列表</span></span><br><span class="line">  <span class="keyword">const</span> hooks = currentComponent.__hooks ||</span><br><span class="line">    (currentComponent.__hooks = &#123;</span><br><span class="line">      _list: [],                  <span class="comment">// 放置状态</span></span><br><span class="line">      _pendingEffects: [],        <span class="comment">// 放置待处理的effect，由useEffect保存</span></span><br><span class="line">      _pendingLayoutEffects: [],  <span class="comment">// 放置待处理的layoutEffect，有useLayoutEffect保存</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建状态</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= hooks._list.length) &#123;</span><br><span class="line">    hooks._list.push(&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hooks._list[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>大概的流程如下:</p><center><br>  <img src="/images/07/useState.png" width="800"><br></center><p><br></p><h3 id="useeffect"><a href="#useeffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>再看看 useEffect 和 useLayoutEffect. useEffect 和 useLayouteEffect 差不多, 只是触发 effect 的时机不一样，useEffect 在完成渲染后绘制触发，而 useLayoutEffect 在 diff 完成后触发:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123;</span><br><span class="line">    <span class="comment">// ⚛️状态变化</span></span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    currentComponent.__hooks._pendingEffects.push(state); <span class="comment">// ⚛️推进_pendingEffects队列</span></span><br><span class="line">    afterPaint(currentComponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLayoutEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123;</span><br><span class="line">    <span class="comment">// ⚛️状态变化</span></span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    currentComponent.__hooks._pendingLayoutEffects.push(state); <span class="comment">// ⚛️推进_pendingLayoutEffects队列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>看看如何触发 effect. useEffect 和上面看到的<code>enqueueRender</code>差不多，放进一个异步队列中，由<code>requestAnimationFrame</code>进行调度，批量处理:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个类似于上面提到的异步队列</span></span><br><span class="line">afterPaint = <span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!component._afterPaintQueued &amp;&amp; <span class="comment">// 避免组件重复推入</span></span><br><span class="line">    (component._afterPaintQueued = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">    afterPaintEffects.push(component) === <span class="number">1</span> <span class="comment">// 开始调度</span></span><br><span class="line">  )</span><br><span class="line">    requestAnimationFrame(scheduleFlushAfterPaint);  <span class="comment">// 由requestAnimationFrame调度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleFlushAfterPaint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(flushAfterPaintEffects);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushAfterPaintEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  afterPaintEffects.some(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    component._afterPaintQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (component._parentDom)</span><br><span class="line">      <span class="comment">// 清空_pendingEffects队列</span></span><br><span class="line">      component.__hooks._pendingEffects = handleEffects(component.__hooks._pendingEffects);</span><br><span class="line">  &#125;);</span><br><span class="line">  afterPaintEffects = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEffects</span>(<span class="params">effects</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先清除后调用effect</span></span><br><span class="line">  effects.forEach(invokeCleanup); <span class="comment">// 请调用清理</span></span><br><span class="line">  effects.forEach(invokeEffect);  <span class="comment">// 再调用effect</span></span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCleanup</span>(<span class="params">hook</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hook._cleanup) hook._cleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeEffect</span>(<span class="params">hook</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = hook._value();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">'function'</span>) hook._cleanup = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>再看看如何触发 LayoutEffect, 很简单，在 diff 完成后触发, 这个过程是同步的.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options.diffed = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c = vnode._component;</span><br><span class="line">  <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> hooks = c.__hooks;</span><br><span class="line">  <span class="keyword">if</span> (hooks) &#123;</span><br><span class="line">    hooks._pendingLayoutEffects = handleEffects(hooks._pendingLayoutEffects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>👌，hooks 基本原理基本了解完毕, 最后还是用一张图来总结一下吧。</p><center><br>  <img src="/images/07/hooks.png" width="800"><br></center><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><p>文章篇幅很长，主要是太多代码了, 我自己也不喜欢看这种文章，所以没期望读者会看到这里. 后面文章再想办法改善改善. 谢谢你阅读到这里。</p><p>本期的主角本身是一个小而美的视图框架，没有其他技术栈. 这里就安利一下 Preact 作者<a href="https://github.com/developit" target="_blank" rel="noopener">developit</a>的另外一些小而美的库吧.</p><ul><li><a href="https://github.com/developit/workerize" target="_blank" rel="noopener">Workerize</a> 优雅地在 webWorker 中执行和调用程序</li><li><a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> 零配置的库打包工具</li><li><a href="https://github.com/developit/greenlet" target="_blank" rel="noopener">greenlet</a> 和 workerize 差不多，这个将单个异步函数放到 webworker 中执行，而 workerize 是将一个模块</li><li><a href="https://github.com/developit/mitt" target="_blank" rel="noopener">mitt</a> 200byte 的 EventEmitter</li><li><a href="https://github.com/developit/dlv" target="_blank" rel="noopener">dlv</a> 安全地访问深嵌套的对象属性，类似于 lodash 的 get 方法</li><li><a href="https://github.com/developit/snarkdown" target="_blank" rel="noopener">snarkdown</a> 1kb 的 markdown parser</li><li><a href="https://github.com/developit/unistore" target="_blank" rel="noopener">unistore</a> 简洁类 Redux 状态容器，支持 React 和 Preact</li><li><a href="https://github.com/developit/stockroom" target="_blank" rel="noopener">stockroom</a> 在 webWorker 支持状态管理器</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://juejin.im/entry/59b9284a5188257e6571b9b4" target="_blank" rel="noopener">Preact：Into the void 0（译）</a></li><li><a href="https://auth0.com/blog/face-off-virtual-dom-vs-incremental-dom-vs-glimmer/" target="_blank" rel="noopener">React Virtual DOM vs Incremental DOM vs Ember’s Glimmer: Fight</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路).&lt;/p&gt;
&lt;p&gt;Preact 是 R
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] 💅styled-components 💅</title>
    <link href="https://bobi.ink/2019/05/29/styled-components-map/"/>
    <id>https://bobi.ink/2019/05/29/styled-components-map/</id>
    <published>2019-05-28T16:00:00.000Z</published>
    <updated>2019-06-01T09:18:28.099Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://juejin.im/post/5cdad9c7f265da039b08915d" target="_blank" rel="noopener">React 组件设计实践总结 03 - 样式的管理</a>一文中吹了一波 <a href="https://www.styled-components.com" target="_blank" rel="noopener">styled-components</a> 后，本文想深入来了解一下 styled-components 的原理. 如果你对 styled-components 还不了解，建议先阅读一下官方<a href="http://styled-components.com" target="_blank" rel="noopener">文档</a>或前面的文章.</p><blockquote><p>本文基于 styled-components v4.13 版本</p></blockquote><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#从-tagged-template-literals-说起">从 Tagged Template Literals 说起</a></li><li><a href="#源码导读">源码导读</a><ul><li><a href="#1-处理标签模板字面量">1. 处理标签模板字面量</a></li><li><a href="#2-react-组件的封装">2. React 组件的封装</a></li><li><a href="#3-样式和类名的生成">3. 样式和类名的生成</a></li><li><a href="#4-dom-层操作">4. DOM 层操作</a></li><li><a href="#5-总结">5. 总结</a></li></ul></li><li><a href="#技术地图">技术地图</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="从-tagged-template-literals-说起"><a href="#从-tagged-template-literals-说起" class="headerlink" title="从 Tagged Template Literals 说起"></a>从 Tagged Template Literals 说起</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener"><strong>标签模板字面量(Tagged Template Literals)</strong></a>是 ES6 新增的特性，它允许你<strong>自定义字符串的内插(interpolation)规则</strong>, styled-components 正是基于这个特性构建:</p><center><br>  <img src="/images/06/styled-sample.png" width="400"><br></center><p>它的原理非常简单，所有静态字符串会被拆分出来合并成为数组, 作为第一个参数传入到目标函数，而内插(interpolation)表达式的值则会作为 rest 参数传入:</p><center><br>  <img src="/images/06/tag-template.png" width="400"><br></center><p><strong>标签模板字面量相比普通的模板字面量更加灵活. 普通模板字符串会将所有内插值转换为字符串，而<code>标签模板字面量</code>则由你自己来控制</strong>:</p><center><br>  <img src="/images/06/tag-template-pros.png" width="600"><br></center><p>因为标签模板字符串简洁的语法和灵活性，它比较适用于作为<code>DSL</code>, 不需要在语言层面进行支持，比如前阵子<a href="https://github.com/preactjs/preact" target="_blank" rel="noopener">preact</a>作者开发的<a href="https://github.com/developit/htm" target="_blank" rel="noopener">htm</a>, 口号就是”取代 JSX，而且不需要编译器支持”, 通过这种方式是可以优雅地实现<a href="https://juejin.im/post/5ceacf09e51d454f73356cc4" target="_blank" rel="noopener">‘你的网站或许不需要前端构建’</a>.</p><center><br>  <img src="/images/06/htm.png" width="700"><br></center><p>另一个典型的例子就是 <code>jest</code> 的<a href="https://jestjs.io/docs/en/api#testeachtable-name-fn-timeout" target="_blank" rel="noopener"><code>表格测试</code></a>, 这样形式可读性更高:</p><center><br>  <img src="/images/06/jest.png" width="700"><br></center><p>标签模板字面量的脑洞还在继续，比如可以用来写 markdown，再生成 react 组件。限于篇幅就不啰嗦了</p><p>扩展:</p><ul><li><a href="https://mxstbr.blog/2016/11/styled-components-magic-explained/" target="_blank" rel="noopener">The magic behind 💅 styled-components</a></li></ul><p><br></p><hr><p><br></p><h2 id="源码导读"><a href="#源码导读" class="headerlink" title="源码导读"></a>源码导读</h2><p>现在来看一下 styled-components 的实现。为了行文简洁，我们只关心 styled-components 的核心逻辑，所以我对源代码进行了大量的简化，比如忽略掉服务端渲染、ReactNative 实现、babel 插件等等.</p><h3 id="1-处理标签模板字面量"><a href="#1-处理标签模板字面量" class="headerlink" title="1. 处理标签模板字面量"></a>1. 处理标签模板字面量</h3><p>先从 <code>styled</code> 构造函数看起:</p><center><br>  <img src="/images/06/styled-code.png" width="500"><br></center><p>styled 构造函数接收一个包装组件 target，而标签模板字面量则由<a href="https://www.styled-components.com/docs/api#css" target="_blank" rel="noopener"><code>css</code></a>函数进行处理的. 这个函数在 styled-components 中非常常用，类似于 <code>SCSS</code> 的 <code>mixin</code> 角色. <code>css</code> 函数会标签模板字面量规范化, 例如:</p><center><br>  <img src="/images/06/css.png" width="750"><br></center><p> css 实现也非常简单:</p><center><br>  <img src="/images/06/css-code.png" width="700"><br></center><p><code>interleave</code>函数将将静态字符串数组和内插值’拉链式‘交叉合并为单个数组, 比如[1, 2] + [a, b]会合并为[1, a, 2, b]</p><p>关键在于如何将数组进行扁平化, 这个由 <code>flatten</code> 函数实现. flatten 函数会将嵌套的 css(数组形式)递归 concat 在一起，将 StyledComponent 组件转换为类名引用、还有处理 keyframe 等等. 最终剩下静态字符串和函数, 输出结果如上所示。</p><p><strong>实际上 styled-components 会进行两次 flatten，第一次 flatten 将能够静态化的都转换成字符串，将嵌套的 css 结构打平, 只剩下一些函数，这些函数只能在运行时(比如在组件渲染时)执行；第二次是在运行时，拿到函数的运行上下文(props、theme 等等)后, 执行所有函数，将函数的执行结果进行递归合并，最终生成的是一个纯字符串数组</strong>. 对于标签模板字面量的处理大概都是这个过程. 看看 flatten 的实现:</p><center><br>  <img src="/images/06/flatten-code.png" width="700"><br></center><p>总结一下标签模板字面量的处理流程大概是这样子:</p><center><br><img src="/images/06/flatten.png" width="700"><br></center><p><br></p><hr><p><br></p><h3 id="2-react-组件的封装"><a href="#2-react-组件的封装" class="headerlink" title="2. React 组件的封装"></a>2. React 组件的封装</h3><p>现在看看如何构造出 React 组件。styled-components 通过 createStyledComponent 高阶组件将组件封装为 StyledComponent 组件:</p><center><br><img src="/images/06/create-component.png" width="800"><br></center><p>createStyledComponent 是一个典型的高阶组件，它在执行期间会生成一个唯一的组件 id 和创建<code>ComponentStyle</code>对象. ComponentStyle 对象用于维护 css 函数生成的 cssRules, 在运行时(组件渲染时)得到执行的上下文后生成最终的样式和类名。</p><p>再来看看 StyledComponent 的实现, StyledComponent 在组件渲染时，将当前的 props+theme 作为 context 传递给 ComponentStyle，生成类名.</p><center><br><img src="/images/06/StyledComponent.png" width="800"><br></center><p><br></p><hr><p><br></p><h3 id="3-样式和类名的生成"><a href="#3-样式和类名的生成" class="headerlink" title="3. 样式和类名的生成"></a>3. 样式和类名的生成</h3><p>上面看到 StyleComponent 通过 ComponentStyle 类来构造样式表并生成类名, ComponentStyle 拿到 context 后，再次调用 flatten 将 css rule 扁平化，得到一个纯字符串数组。通过使用 hash 算法生成类名, 并使用stylis 对样式进行预处理. 最后通过 StyleSheet 对象将样式规则插入到 DOM 中</p><center><br><img src="/images/06/ComponentStyle.png" width="800"><br></center><p><a href="https://github.com/thysultan/stylis.js/blob/master/README.md" target="_blank" rel="noopener">stylis</a>是一个 3kb 的轻量的 CSS 预处理器, styled-components 所有的 CSS 特性都依赖于它， 例如嵌套规则(<code>a {&amp;:hover{}}</code>)、厂商前缀、压缩等等.</p><p><br></p><hr><p><br></p><h3 id="4-dom-层操作"><a href="#4-dom-层操作" class="headerlink" title="4. DOM 层操作"></a>4. DOM 层操作</h3><p>现在来看一下 StyleSheet, StyleSheet 负责收集所有组件的样式规则，并插入到 DOM 中</p><center><br><img src="/images/06/StyleSheet.png" width="800"><br></center><p>看看简化版的 makeTag</p><center><br><img src="/images/06/makeTag.png" width="800"><br></center><p><br></p><hr><p><br></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>代码可能看晕了，通过流程图来梳理一下过程.</p><blockquote><p>上一篇文章<a href="https://juejin.im/post/5cedb26451882566477b7235" target="_blank" rel="noopener">技术地图 - vue-cli</a>一点代码也没有罗列，只有一个流程图, 读者可能一下子就傻眼了, 不知道在说些什么; 而且这个流程图太大，在移动端不好阅读. 这期稍微改进一下，新增’源码导读‘一节，代码表达能力毫无疑问是胜于流程图的，但是代码相对比较细节琐碎，所以第一是将代码进行简化，留下核心的逻辑，第二是使用流程图表示大概的程序流程，以及流程主体之间的关系.</p></blockquote><p><img src="/images/06/process.png" alt></p><p><br></p><p>如上图 styled-components 主要有四个核心对象:</p><ul><li><strong>WrappedComponent</strong>: 这是 createStyledComponent 创建的包装组件，这个组件保存的被包装的 target、并生成组件 id 和 ComponentStyle 对象</li><li><strong>StyledComponent</strong>: 这是样式组件，在它 render 时会将 props 作为 context 传递给 ComponentStyle，并生成类名</li><li><strong>ComponentStyle</strong>: 负责生成最终的样式表和唯一的类名，并调用 StyleSheet 将生成的样表注入到文档中</li><li><strong>StyleSheet</strong>: 负责管理已生成的样式表, 并注入到文档中</li></ul><p><br></p><p><strong>styled-components 性能优化建议</strong></p><p>styled-components 每次渲染都会重新计算 cssRule，并进行 hash 计算出 className，如果已经对应的 className 还没插入到样式表中，则使用 stylis 进行预处理，并插入到样式表中; </p><p>另外 styled-components 对静态 cssRule(没有任何内插函数)进行了优化，它们不会监听 ThemeContext 变化, 且在渲染时不会重新计算。</p><p>通过这些规则可以得出以下性能优化的建议:</p><ul><li><strong>静态化的 cssRule 性能是最好的</strong></li><li><p><strong>降低 StyledComponent 状态复杂度</strong>. styled-components 并不会对已有的不变的样式规则进行复用，一旦状态变化 styled-component 会生成一个全新的样式规则和类名. 这是最简单的一种实现, 避免了样式复用的复杂性，同时保持样式的隔离性, 问题就是会产生样式冗余。 例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo = styled.div&lt;&#123; active: boolean &#125;&gt;`</span><br><span class="line">  color: red;</span><br><span class="line">  background: $&#123;props =&gt; (props.active ? &apos;blue&apos; : &apos;red&apos;)&#125;;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>active 切换之间会生成两个类名:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cQAOKL</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.kklCtT</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把 StyledComponent 看做是一个状态机，那么 styled-components 可能会为每一个可能的状态生成独立的样式. 如果 StyledComponent 样式很多, 而且状态比较复杂，那么会生成很多冗余的样式.</p></li><li><p>❌ <strong>不要用于动画</strong>。上面了解到 styled-component 会为每个状态生成一个样式表. 动画一般会有很多中间值，在短时间内进行变化，如果动画值通过props传入该StyledComponent来应用样式，这样会生成很多样式，性能非常差:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Bar = styled.div&lt;&#123; width: boolean &#125;&gt;`</span><br><span class="line">  color: red;</span><br><span class="line">  // 千万别这么干</span><br><span class="line">  width: $&#123;props =&gt; props.width&#125;;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>这种动画场景最好使用 style 内联样式来做</p></li></ul><p><br></p><p>OK, 行文结束。styled-components 不过如此是吧？</p><p><br></p><hr><p><br></p><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><ul><li><strong>CSS 相关</strong><ul><li>@emotion/unitless 判断属性值是否需要单位</li><li>css-to-react-native 将 css 转换为 ReactNative style 属性</li><li>✨<a href="https://www.npmjs.com/package/bundlesize" target="_blank" rel="noopener">stylis</a> 轻量的 CSS 预处理器</li></ul></li><li><strong>React 相关</strong><ul><li>@emotion/is-prop-valid 判断是否是合法的 DOM 属性</li><li><a href="https://www.npmjs.com/package/hoist-non-react-statics" target="_blank" rel="noopener">hoist-non-react-statics</a> 提升React组件的静态属性，用于高阶组件场景</li><li>✨<a href="https://www.npmjs.com/package/react-is" target="_blank" rel="noopener">react-is</a>: 判断各种 React 组件类型</li><li><a href="https://github.com/lelandrichardson/react-primitives#readme" target="_blank" rel="noopener">react-primitives</a> 这是一个有意思的库，这个库试图围绕着构建 React 应用提出一套理想的原语，通俗的说就是通过它可以导入不同平台的组件。</li><li><a href="https://github.com/ryanseddon/react-frame-component" target="_blank" rel="noopener">react-frame-component</a> 将react渲染到iframe中。也是一个比较有意思的库</li><li><a href="https://www.npmjs.com/package/react-live" target="_blank" rel="noopener">react-live</a> react实时编辑器和展示，主要用于文档</li></ul></li><li><strong>构建相关</strong><ul><li><a href="https://github.com/siddharthkp/bundlesize#readme" target="_blank" rel="noopener">bundlesize</a> 检查包大小</li><li><a href="https://github.com/codemod-js/codemod/blob/master/packages/cli/README.md" target="_blank" rel="noopener">codemod</a> 使用babel-plugin来重写Javascript或Typescript代码， 一般用于制作升级脚本</li><li>✨<a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> 一个零配置的打包器，基于Rollup，可以用于库的打包和开发, preact作者开发必属精品</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://juejin.im/post/5cdad9c7f265da039b08915d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React 组件设计实践总结 03 - 样式的管理&lt;/a&gt;一文中吹了一波 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] vue-cli</title>
    <link href="https://bobi.ink/2019/05/26/vue-cli-map/"/>
    <id>https://bobi.ink/2019/05/26/vue-cli-map/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2019-06-01T08:15:46.354Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个新开的’实验性’文章系列，如其名‘技术地图’，这个系列计划剖析一些前端开源项目，可能会探讨这些项目的<strong>设计和组织</strong>、整理他们使用到<strong>技术栈</strong>。 首先拿<code>vue-cli</code>小试牛刀，再决定后续要不要继续这个系列.</p><p><br></p><p>我一直在思考我们编程主要在做什么？我们有一大部分工作就是选择各种工具/库/框架，来黏合业务. 工具和场景越匹配、原理了解越多，运用越娴熟，我们效率可能就越高. 这种说法很有争议，就像<code>程序=算法+数据结构</code>不能完全表达现今的软件工程一样, 说我们的工作就是堆砌工具，黏合业务, 一定程度上有自贬的意思。 但这确实是大部分程序员的真实写照。</p><p>这系列文章其实有点类似于 github 上面的<code>Awesome</code>项目. 这些 Awesome 项目就是一个<strong>生态展览馆</strong>, 里面项目琳琅满目. 因为数量太多了，而且缺少评分机制，大部分情况我们不可能一个个去查看，很难从中选择符合需求的项目(当然你带着明确的目的，且目标范围非常小，可能比较有用)。</p><center><br><img src="/images/05/awesome.png" width="400"><br></center><p>是否可以尝试换个角度，<strong>选取一些有趣的开源项目，看看它是怎么应用这些工具的, 有序的罗列出来? 对于有相同场景的项目, 参考或者模仿价值可能会更大一些</strong>. 这些开源项目就是巨人，站在巨人肩膀上显然省事多了</p><p>只是技术栈罗列未免过于简单，笔者还希望从这些项目中学点东西，比如他的设计和项目组织. 我会尝试简化和通俗解释里面的关键知识或亮点, 但是不求甚解。为了避免陷入细节泥潭，我会尽量使用图形化方式展示他们程序流程，避免拘泥于细节。你也可以把这些文章作为深入阅读这些项目源码的引导</p><p>我也希望读者同我交流反馈，共同学习和进步。</p><p><br></p><hr><p><br></p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>说到 CLI, 不得不提<a href="https://ruby-china.github.io/rails-guides/getting_started.html" target="_blank" rel="noopener">Rails</a>框架，它可能是<em>框架提供 CLI 的先祖</em>(具体历史没有深入考究). Rails 有一个重要的指导思想，即<strong>约定大于配置</strong>, <strong>它为 Web 应用的大多数需求都提供了最好的解决方法，并且默认使用这些约定，而不是在长长的配置文件中设置每个细节</strong>。</p><p><strong>CLI 也是这个指导思想下的产物</strong>, 例如通过它提供的 CLI，可以在<a href="https://ruby-china.github.io/rails-guides/getting_started.html" target="_blank" rel="noopener">15 分钟内构建一个简易的博客</a>, 可以通过 CLI 启动服务器和 REPL、生成项目脚手架、生成代码文件、路由、数据库迁移等等:</p><center><br>  <img src="/images/05/rails-cli.png" width="500"><br></center><p>Rails 的很多设计在那个年代就是就是一个明星(闪瞎 PHP、JSP、 ASP…, 想想要配置各种服务器，各种 xml 文件)，它的很多设计模式深刻影响了后面的 web 框架，比如 Django、Laravel, 甚至很多模仿 Rails 命名的，如 Sails、Grails.</p><p>Rails 对于前端开发影响也很深远，比如在 Nodejs 出来之前，Rails 社区就开始使用 <code>coffeescript + sass</code>预编译语言进行前端开发了, <a href="https://ruby-china.github.io/rails-guides/asset_pipeline.html" target="_blank" rel="noopener">Asset Pipeline</a>可以说是最早的’前端工程化’, 配合<a href="https://github.com/turbolinks/turbolinks" target="_blank" rel="noopener">Turbolink</a>可以让传统后端渲染页面拥有不亚于单页应用的用户体验…</p><p>当初 Rails 给我带来的各种震撼还历历在目, <a href="https://ruby-china.org" target="_blank" rel="noopener">Ruby China 社区</a>也是国内最好社区之一. 但是目前 Rails 的关注度不如从前, 在前端社区像 Rails 这种集大成的框架也早已不吃香(参考 Ember, 某种程度上 Angular 也算吧?).</p><p>说实在话如果一生只学一门语言，我会选 Ruby，如果选一个 web 框架，那就是 Rails。</p><p>推荐大家阅读<a href="https://ruby-china.org/wiki/the-rails-doctrine" target="_blank" rel="noopener">The Rails Doctrine - Rails 信条</a> 这篇文章里面有一句话笔者非常喜欢: <strong>“只要放下了自负的个人喜好，便可以跳过无谓的世俗决定，专注在最重要的地方下更快的决定。”</strong>。为人写程序，而不是为了机器写程序.</p><p><strong>约定大于配置</strong>可以减少我们做决定的数量，减少无谓的争论和考虑，让我们可以专注于更重要的事情. 这个原则可以提高开发和团队协作效率, 甚至可以凝聚一个社区.</p><p>以 Webpack 为例，恶心复杂的配置被人诟病，所以才需要 vue-cli 或者 create-react-app 这些工具.</p><blockquote><p>没有用 Ruby/Rails 工作过, 默默写了个 Ruby China 小程序(微信搜<code>Ruby CN</code>)，算是感恩回馈社区吧</p></blockquote><p><br></p><p>Ok, 忍不住吹了一波 Rails, 回到正题.</p><p>笔者是使用 React 作为主力开发的，Vue 也是我非常喜欢的一个开源项目，不说别的，在开发者的’用户体验’方面 Vue 是我见过最好之一，主要体现在 API 的简洁性和易用性、文档还有项目构建工具(今天的主角).</p><p>vue-cli-ui 是我想写这系列文章的动机之一. 前阵子用了一下<code>vue-cli-ui</code>, 感觉很不错, 支持可视化配置和任务运行，比我在终端下一个项目一个项目跑 task 清爽多了. 很想在我们自家的构建工具上也搞一套，怎搞？ 学习它的源码, 我觉得可以作为博客记录下来.</p><p>现在前端工程师也有‘webpack 配置工程师’的戏称，这能说明 webpack 配置是费时费力的苦事(Angular 例外). 这不后来就有了<code>parcel</code>宣称零配置的轮子, 还有 React 社区的<code>create-react-app</code>, vue-cli 前期是基于模板的创建项目, 不算此列。</p><p>后来 vue-cli 汲取着前者的很多优点，把这块做大做优了(看来 vue 很擅长做这些事情). 我们可以来对比一下这些工具:</p><p><br></p><table><thead><tr><th></th><th>Vue CLI</th><th>create-react-app</th><th>parcel</th></tr></thead><tbody><tr><td>快速原型开发</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>全局模式</td><td>零配置原型开发就是全局的</td><td>-</td><td>支持</td></tr><tr><td>插件</td><td>支持</td><td>-</td><td>支持，扩展文件类型和文件输出</td></tr><tr><td>扩展性</td><td>强，通过插件扩展 wepack 配置</td><td>弱, 强约定, 无法配置 webpack，可以 eject, 然后手工配置；支持 babel-macro;(严格说可以通过<a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">react-app-rewired</a>进行扩展)</td><td>中(可以配置 babel，postcss，Typescript); 提供了 Node API; 支持插件扩展文件类型</td></tr><tr><td>多页面</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>适用范围</td><td>Vue 组件的第一公民。通过扩展可以支持任意前端框架</td><td>针对 React 开发，不支持其他框架</td><td>parcel 是一个通用的打包工具，它的竞争对手是 webpack</td></tr><tr><td>编译速度</td><td>cache-loader,thread-loader 来加速 JS 和 TS 编译</td><td>babel-loader 开启了 cache</td><td>编译速度号称是 webpack 的两倍</td></tr><tr><td>可升级性</td><td>支持升级 cli-service, 插件需要单独升级, 插件需要遵循语义化版本. 太多插件存在升级风险</td><td>支持升级 react-script, 官方维护，且强约定基本可以保障向下兼容</td><td>支持升级 parcel-bundler</td></tr><tr><td>UI</td><td>图形化管理是 CLI 的特色之一</td><td>-</td><td>-</td></tr></tbody></table><p><br></p><p>通过上面的对比，可以看出 <strong>vue-cli 是一个扩展性非常强的构建工具，以致于它不仅限于 Vue，也可以用来构建 React 甚至其他前端框架</strong>。</p><p>相比而言 <code>create-react-app</code> 就是一个非常 Opinionated(坚持己见) 的工具，强约定. 一个典型的例子就是它不内置开启 babel 装饰器转译，CRA 团队认为已经废弃(或者不成熟)的语言特性不应该带到 CRA 中; 后面为了给‘优雅’地给 babel 扩展插件，就捣鼓出来了<code>babel-macro</code>, 这是一种’免配置’的 babel 插件规范.</p><p>这种强约定也是有好处的，比如不需要管理配置; 而且 CRA 团队谨慎可靠地维护着 CRA，这使得开发者可以一般无痛地升级 CRA. 如果要扩展 webpack，一般只有 eject，这就走回了手动配置 webpack 的老路, 不可取.</p><p>vue-cli 也是一个’渐进式’的 cli，vue-cli 提供了默认的 preset，但不阻止你对其进行扩展. vue-cli 的扩展接口也非常简洁(合理, 不多不少), 还有 UI 管理界面，可视化管理项目的配置和插件，用户体验很棒，计划在下一篇文章介绍 vue ui. 唯一比较不舒服的是如果滥用这种扩展性，装 N 多插件，而且插件之间还存在依赖关系时，也会成为升级维护的负担.</p><p><br></p><hr><p><br></p><h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>注意，本文不是 vue-cli 的教程，最好的教程是<a href="https://cli.vuejs.org/zh/dev-guide/plugin-dev.html#prompts" target="_blank" rel="noopener">官方文档</a>.</p><p><br></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>下面是 vue-cli 的基本目录结构. 大部分大型的前端项目都使用 lerna 实现 mono-repo 模式, 然后统一分发到 npm. 这种模式有利于项目模块组织</p><center><br>  <img src="/images/05/vue-cli-struct.png" width="700"><br></center><p><br></p><h3 id="分离-cli-层和-service-层"><a href="#分离-cli-层和-service-层" class="headerlink" title="分离 CLI 层和 Service 层"></a><strong>分离 CLI 层和 Service 层</strong></h3><p>这个设计是借鉴<code>create-react-app</code>的, CLI 层只是一些基础的命令一般不需要频繁升级，而且是全局安装; 而 Service 层是多变的, 作为项目的局部依赖，不应该硬编码在 CLI 里面. CLI 和 Service 的职责划分如下:</p><p><br></p><ul><li><p>CLI: 用于项目创建和管理</p><ul><li>全局安装</li><li><code>vue create</code> 创建项目脚手架. 拉取最新的 Service，并选择配置需要的插件</li><li><code>vue ui</code>. 启动 UI 管理界面</li><li>快速原型开发: <code>vue serve</code> | <code>vue build</code>, 直接伺服和编译一个 Vue 文件</li><li>插件管理: <code>vue add</code> | <code>vue invoke</code> 安装插件和调用插件生成器</li></ul></li><li><p>Service: 负责项目的实际构建</p><ul><li>局部安装</li><li>集成 webpack 构建环境，<strong>Service 本身只有一个插件机制, 所有构建相关逻辑都由内置插件和外部插件提供</strong></li><li>内置插件(命令): serve, build, inspect</li></ul></li></ul><p><br><br><br></p><h3 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a><strong>插件系统</strong></h3><p>vue-cli 提供了类似 babel、eslint 的插件机制。</p><center><br>  <img src="/images/05/plugins.png" width="400"><br></center><p><br></p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a><strong>插件</strong></h4><p>插件机制是 vue-cli 的核心, 用于扩展 Service. Service 的<code>命令</code>和 webpack 配置都由插件提供.</p><p>其实插件机制本身并没有什么技术难度, 换句话说<strong>插件其实就是一个协议的设计</strong>. vue-cli 插件的协议如下:</p><ul><li><strong>命名</strong>: <code>@vue/cli-plugin-*</code>或<code>vue-cli-plugin-*</code>. package.json 中按着这个命名约定的依赖会被识别为 vue-cli 插件，另外命名约定也有利于在 github 或 npm 上筛选</li><li><strong>生命周期</strong>:<br>一个插件的生命周期可以分为<code>安装阶段</code>和<code>运行阶段</code>. <code>vue create</code>命令创建项目脚手架、<code>vue add</code>以及<code>vue invoke</code>插件安装命令都属于安装阶段; 而 cli-service 命令执行时属于运行阶段.</li><li><p><strong>基本结构</strong>: 区分了生命周期后，插件的结构就比较清晰了:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── generator.js  # generator (可选)</span><br><span class="line">├── prompts.js    # prompt 文件 (可选)</span><br><span class="line">├── index.js      # service 插件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><ul><li>安装阶段:<ul><li>prompts: 收集用户意见和配置</li><li>gernerator: 在安装阶段生成模板文件</li></ul></li><li>运行时: index.js<ul><li>注入 service 命令</li><li>扩展和修改 webpack 配置. vue-cli 通过<code>webpack-chain</code>和<code>webpack-merge</code>来实现 webpack 可配置化</li></ul></li></ul></li></ul><p><br></p><p>一个简单的插件结构是这样子的:</p><center><br>  <img src="/codes/vue-plugin.png" width="600"><br></center><p><br></p><h4 id="preset"><a href="#preset" class="headerlink" title="preset"></a><strong>preset</strong></h4><p>这个 preset 和 babel 的 preset 概念实际上是不一样的:</p><p><strong>vue-cli 的 preset 一个脚手架创建方案</strong>, 也就是说它只作用于<code>vue create</code>阶段。比如<code>vue create</code>时默认使用的就是 babel+eslint preset. preset 可以简化项目脚手架的创建。<strong>团队可以共享一个 preset 来创建脚手架</strong>。</p><p><strong>而 babel 中的 preset 是一个插件集合，他可以统一收纳和管理一组插件方案</strong>. 例如<code>babel-preset-react</code>、 <code>babel-preset-env</code>. 上文说到如果扩展性被滥用，装 N 多插件，而且插件之间还存在依赖关系时，也会成为升级维护的负担. 而 ‘babel 式’的 preset 可以让插件更方便维护和和<strong>一键式升级</strong>。</p><p>尽管目前 vue 也提供了<code>vue upgrade</code>对插件进行升级，这个是基于语义化版本约定的, 且当插件之间存在依赖关系时, 不排除升级存在风险. 尤其对于团队项目还是推荐有统一地管理这些插件, 实现傻瓜化的升级。 实际上这种 ‘babel 式’的 preset 是可以通过 vue-plugin 实现和转发的。</p><p><br></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h4><p>vue 支持在 package.json 的 <code>vue</code> 字段或<code>vue.config.js</code>中进行配置。这里可以对 Service 核心功能和插件进行配置, 也可以直接修改 webpack 配置. 另外部分构建行为是通过环境变量进行影响的，这些可以通过<code>.env.*</code>文件进行配置</p><p><br></p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a><strong>基本流程</strong></h3><p>现在来看看一个 vue-cli 内部的基本流程, Service 的插件实现是 vue-cli 比较有意思的点. 以<code>vue serve</code>为例:</p><center><br>  <img src="/images/05/vue-cli.png"><br></center><p>Service 对象是 vue-cli 的核心对象，负责管理和应用插件，所有命令和 webpack 配置都是以插件的形式存在:</p><center><br>  <img src="/images/05/vue-service-struct.png" width="700"><br></center><p><strong>首先划分为配置阶段和运行阶段</strong>。 配置阶段 vue-cli 会加载配置文件，并查找和应用所有插件。将 PluginAPI 实例和项目配置传递给插件运行时, 插件运行时通过 PluginAPI 注入命令(registerCommand)和 扩展 webpack 配置(chainWebpack, configureWebpack).</p><p>运行阶段则根据用户传入的命令名调用插件注入命令。在命令实现函数中，可以调用 resolveWebpackConfig()来生成最终的 webpack 配置。以 serve 命令为例，获取到 webpackConfig 后会创建一个 webpack 编译器，并开启 webpack-dev-server 开发服务器.</p><p><br></p><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><ul><li><strong>组织</strong><ul><li><a href="http://lernajs.io" target="_blank" rel="noopener">lerna</a></li></ul></li><li><strong>cli 命令行相关工具</strong><ul><li><a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a>: 命令行字体颜色样式</li><li><a href="https://www.npmjs.com/package/cli-highlight" target="_blank" rel="noopener">cli-highlight</a>: 终端语法高亮输出, 类似于 Highlight.js</li><li><a href="https://www.npmjs.com/package/cliui" target="_blank" rel="noopener">cliui</a>: 在终端中进行多列输出</li><li><a href="https://github.com/dcporter/didyoumean.js" target="_blank" rel="noopener">didyoumean</a>: 根据单词相似度，来对用户输入纠正提示</li><li><a href="https://www.npmjs.com/package/semver" target="_blank" rel="noopener">semver</a>: 提供语义化版本号相关的工具函数。 例如比较，规范化</li><li><a href="https://github.com/tj/commander.js#readme" target="_blank" rel="noopener">commander</a> TJ 写的命令行选项和参数解析器，支持子命令，选项校验和类型转换，帮组信息生成等等. API 简单优雅</li><li><a href="https://www.npmjs.com/package/minimist" target="_blank" rel="noopener">minimist</a>: 一个极简的命令行参数解析器。如果只是简单的选项解析，可以用这个库</li><li><a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noopener">inquirer</a> 命令行询问</li><li><a href="https://github.com/sindresorhus/ora" target="_blank" rel="noopener">ora</a> 命令行 spinner</li><li><a href="https://github.com/yyx990803/launch-editor" target="_blank" rel="noopener">launch-editor</a> 打开编辑器. 通过 node 打开编辑器，前端可以 express 暴露接口调用打开</li><li><a href="https://www.npmjs.com/package/open" target="_blank" rel="noopener">open</a> 打开 URL、文件、可执行文件</li><li><a href="https://www.npmjs.com/package/execa" target="_blank" rel="noopener">execa</a> 更好的 child_process，修复了原生 exec 的一些问题</li><li>validate-npm-package-name: 验证 npm 包名称，比如创建的项目名是否合法</li><li><a href="https://www.npmjs.com/package/dotenv" target="_blank" rel="noopener">dotenv</a> &amp; <a href="https://www.npmjs.com/package/dotenv-expand" target="_blank" rel="noopener">dotenv-expand</a>: 从.env 文件中加载配置，环境变量</li></ul></li><li><strong>网络相关</strong><ul><li><a href="https://www.npmjs.com/package/portfinder" target="_blank" rel="noopener">portfinder</a>: 获取可用的端口</li><li><a href="https://www.npmjs.com/package/address" target="_blank" rel="noopener">address</a>: 获取当前主机的 ip，MAC 和 DNS 服务器</li></ul></li><li><strong>文件处理相关</strong><ul><li><a href="https://www.npmjs.com/package/slash" target="_blank" rel="noopener">slash</a> 一致化处理路径中的分隔符</li><li><a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="noopener">fs-extra</a> node fs 模块扩展</li><li>globby: glob 模式匹配</li><li>rimraf 跨平台文件删除命令</li><li><a href="https://www.npmjs.com/package/memfs" target="_blank" rel="noopener">memfs</a> 兼容 Node fs API 的内存文件系统</li></ul></li><li><strong>数据检验</strong><ul><li><a href="https://www.npmjs.com/package/@hapi/joi" target="_blank" rel="noopener">@hapi/joi</a> JSON schema 校验</li></ul></li><li><strong>调试</strong><ul><li><a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">debug</a>: 这是一个 debug 日志利器, 支持通过环境变量或动态设置来确定是否需要输出; 支持 printf 风格格式化</li></ul></li><li><strong>算法</strong><ul><li>hash-sum: 散列值计算</li><li>deepmerge 深合并</li></ul></li><li><strong>其他</strong><ul><li><a href="https://github.com/benjamn/recast" target="_blank" rel="noopener">recast</a> Javascript 语法树转换器，支持非破坏性的格式化输出. 常用于扩展 js 代码</li><li><a href="https://www.npmjs.com/package/javascript-stringify" target="_blank" rel="noopener">javascript-stringify</a>: 类似于 JSON.stringify, 将对象字符串化。</li></ul></li><li><strong>webpack</strong><ul><li>配置定义<ul><li>webpack-merge: 合并 webpack 配置对象</li><li>webpack-chain: 链式配置 webpack. 这两个库是 vue-cli 插件的重要成员</li></ul></li><li>webpack-dev-server: webpack 开发服务器，支持代码热重载，错误信息展示，接口代理等等</li><li>webpack-bundle-analyzer: webpack 包分析器</li></ul></li><li><strong>扩展(一些相关的技术栈)</strong><ul><li>http-server 快速伺服静态文件</li><li>plop 模板生成器</li><li>yeoman 项目脚手架工具</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个新开的’实验性’文章系列，如其名‘技术地图’，这个系列计划剖析一些前端开源项目，可能会探讨这些项目的&lt;strong&gt;设计和组织&lt;/strong&gt;、整理他们使用到&lt;strong&gt;技术栈&lt;/strong&gt;。 首先拿&lt;code&gt;vue-cli&lt;/code&gt;小试牛刀，再决定
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结05 - 状态管理</title>
    <link href="https://bobi.ink/2019/05/20/react-component-design-05/"/>
    <id>https://bobi.ink/2019/05/20/react-component-design-05/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-22T06:44:27.830Z</updated>
    
    <content type="html"><![CDATA[<p>今天是 520，这是本系列最后一篇文章，主要涵盖 React 状态管理的相关方案。</p><p>前几篇文章在<a href="https://juejin.im" target="_blank" rel="noopener">掘金</a>首发基本石沉大海, 没什么阅读量. 可能是文章篇幅太长了？掘金值太低了？ 还是错别字太多了? 后面静下心来想想，写作对我来说是一种学习和积累的过程, 让我学习更全面更系统性去描述一个事物. 但是写作确实是一件非常耗时的事情, 文章的每句话都要细细推敲, 还要避免主观性太强避免误导了别人.</p><p>所以模仿<a href="https://kernelpanic.fm" target="_blank" rel="noopener">&lt;&lt;内核恐慌&gt;&gt;</a>的口号: “想看的人看，不想看的人就别看”</p><p><br></p><p><strong>系列目录</strong></p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li><a href="/2019/05/20/react-component-design-05/">05 状态管理</a></li></ul><p><br></p><p><strong>文章目录</strong></p><!-- TOC --><ul><li><a href="#状态管理">状态管理</a></li><li><a href="#你不需要状态管理">你不需要状态管理</a></li><li><a href="#你不需要复杂的状态管理">你不需要复杂的状态管理</a></li><li><a href="#redux">Redux</a></li><li><a href="#mobx">Mobx</a></li><li><a href="#rxjs">RxJS</a></li><li><a href="#其他状态管理方案">其他状态管理方案</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>现在的前端框架，包括 React 的一个核心思想就是<strong>数据驱动视图</strong>, 即<code>UI = f(state)</code>. 这种开发方式的变化其实得益于 Virtual-DOM, 它使得我们不需要关心浏览器底层 DOM 的操作细节，只需关心‘状态(state)’和‘状态到 UI 的映射关系(f)’. <strong>所以如果你是初学者，不能理解什么是‘数据驱动’, 还是不推荐继续阅读文章下面的内容</strong>。</p><p>但是随着 <code>state</code> 的复杂化, 框架现有的组件化方式很难驾驭 <code>f</code>(视图的映射关系变得复杂, 难以被表达和维护); 或者相关类型的应用数据流本来就比较复杂, 组件之间的交互关系多样，本来难以使用<code>UI = f(state)</code>这种关系来表达; 或者应用的组件状态过于离散，需要统一的治理等等. 我们就有了状态管理的需求.</p><p>状态管理最基础的解决方式就是分层，也就是说和传统的 <code>MV*</code> 模式没有本质区别, 主流状态管理的主要结构基本都是这样的:</p><center><br> <img src="/images/04/mvc.png" width="500"><br></center><p>他们基本都包含这些特点:</p><ul><li><strong>分离视图和状态</strong>. 状态管理器擅长状态管理，所以他们一般会将应用状态聚合在一起管理，而视图退化为贫血视图(只关注展示)，这样就可以简化<code>f</code>映射关系, 让<code>UI = f(state)</code>这个表达式更彻底</li><li><strong>约束状态的变更</strong>。Redux 要求通过<code>dispatch+reducer</code>, mobx 要求数据变更函数使用<code>action</code>装饰或放在<a href="https://mobx.js.org/best/actions.html" target="_blank" rel="noopener"><code>flow</code></a>函数中，目的就是让状态的变更根据可预测性</li><li><strong>单向数据流</strong>。数据流总是按照 Store -&gt; View -&gt; Store 这样的方式流动, 简化数据流</li></ul><p><br></p><p>但是, React 的状态管理方案太多了，选择这些方案可能会让人抓狂，你需要权衡很多东西:</p><ul><li>面向对象还是函数式还是函数响应式?</li><li>单 Store 还是多 Store？</li><li>不可变数据还是可变数据？</li><li>写代码爽还是后期维护爽?</li><li>自由还是约束？</li><li>强类型还是弱类型？</li><li>范式化数据还是非范式化？</li><li>React 原生还是第三方?</li><li>…</li></ul><p><br></p><hr><p><br></p><h2 id="你不需要状态管理"><a href="#你不需要状态管理" class="headerlink" title="你不需要状态管理"></a>你不需要状态管理</h2><p>对于大部分简单的应用和中后台项目来说是不需要状态管理的。说实话这些应用和传统 web 页面没什么区别, 每个页面都各自独立，每次打开一个新页面时拉取最新数据，增删改查仅此而已. 对于这些场景 React 的组件状态就可以满足, 没有必要为了状态管理而状态管理. 这种各自独立的‘静态’页面，引入状态管理就是过度设计了。</p><p>在考虑引入状态管理之前考虑一下这些手段是否可以解决你的问题:</p><ul><li>是否可以通过抬升 State 来实现组件间通信?</li><li>如果跨越的层级太多，数据是否可以通过 Context API 来实现共享?</li><li>一些全局状态是否可以放在 localStorage 或 sessionStorage 中？</li><li>数据是否可以通过外置的事件订阅器进行共享?</li><li>…</li></ul><p><br></p><hr><p><br></p><h2 id="你不需要复杂的状态管理"><a href="#你不需要复杂的状态管理" class="headerlink" title="你不需要复杂的状态管理"></a>你不需要复杂的状态管理</h2><p>当你的应用有以下场景时，就要开始考虑状态管理:</p><ul><li>组件之间需要状态共享。同一份数据需要响应到多个视图，且被多个视图进行变更</li><li>需要维护全局状态，并在他们变动时响应到视图</li><li>数据流变得复杂，React 组件本身已经无法驾驭。例如跨页面的用户协作</li><li>需要统一管理应用的状态。比如实现持久化，可恢复，可撤销/重做</li><li>…</li></ul><p>首先确定是否需要 Redux、Mobx 这些复杂的状态管理工具? 在 2019 他们很多功能都可以被 React 本身提供的特性取代. 随着 React 16.3 发布了新的 Context API，我们可以方便地在它之上做简单的状态管理, 我们应该<strong>优先选择这些原生态的状态管理方式</strong>。</p><p>例如: 简单的使用 Context API 来做状态管理:</p><center><br>  <img src="/codes/context-api-vuex.png" width="600"><br></center><p>最近 hooks 用得比较爽(参考上一篇文章: <a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d" target="_blank" rel="noopener">组件的思维</a>)，我就想配合 Context API 做一个状态管理器, 后来发现早就有人这么干了： <a href="https://github.com/jamiebuilds/unstated-next" target="_blank" rel="noopener">unstated-next</a>, 代码只有 38 行(Hooks+Context)，接口非常简单:</p><center><br> <img src="/images/04/unstated.png" width="750"><br></center><p>依赖于 hooks 本身灵活的特性，我们可以用它来做很多东西, 仅限于想象力. 例如异步数据获取:</p><center><br> <img src="/codes/useTodoList.png" width="750"><br></center><p>抑或者实现 Redux 的核心功能:</p><iframe src="https://codesandbox.io/embed/w1plr?fontsize=14" title="redux hooks" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p><br></p><p>总结一下使用 hooks 作为状态管理器的优点:</p><ul><li><strong>极简</strong>。如上</li><li><strong>可组合性</strong>. hooks 只是普通函数, 可以组合其他 hooks，以及其他<code>Hooks Container</code>. 上一篇文章提到 hooks 写着写着很像组件，组件写着写着很像 hooks，在用法上组件可以认为是一种’特殊’的 hooks。相比组件, hooks 有更灵活的组合特性</li><li><strong>以 react 之名</strong>. 基于 Context 实现组件状态共享，基于 hooks 实现状态管理, 这个方式足够通用.</li><li>hooks 很多灵活的特性足以取代类似 Mobx 这些框架的大部分功能</li><li>只是普通的 React 组件，可以在 React inspector 上调试</li><li>强类型</li><li>基于Context API更容易实现模块化(或者分形)</li></ul><p><br></p><p>需要注意的地方</p><ul><li>没有外置的状态. 状态在组件内部，没有方法从外部触发状态变更</li><li>缺少约束. 是好处也是坏处, 对于团队和初学者来说没有约束会导致风格不统一，无法控制项目熵增。好处是可以自定义自己的约束</li><li>性能优化. 需要考虑 Context 变更带来的性能问题</li><li>调试体验不如 Redux</li><li>没有数据镜像, 不能实现诸如事件管理的需求</li><li>没有 Redux 丰富的生态</li></ul><p><strong>所以 Context+ Hooks 可以用于满足简单的状态管理需求, 对于复杂的状态管理需求还是需要用上 Redux、Mobx 这类专业的状态管理器.</strong></p><p><br></p><p>其他类似的方案</p><ul><li><a href="https://github.com/jamiebuilds/unstated" target="_blank" rel="noopener">unstated</a> unstated-next 的前身，使用 setState API</li><li><a href="https://github.com/dai-shi/react-hooks-global-state" target="_blank" rel="noopener">react-hooks-global-state</a></li></ul><p>扩展</p><ul><li><a href="https://blog.bitsrc.io/react-context-api-a-replacement-for-redux-6e20790492b3" target="_blank" rel="noopener">React Context API — A Replacement for Redux?</a></li><li><a href="https://zhuanlan.zhihu.com/p/48219978" target="_blank" rel="noopener">unstated: 可能是简单状态管理工具中最好的</a></li></ul><p><br></p><hr><r><h2 id="redux"><a href="#redux" class="headerlink" title="Redux"></a>Redux</h2><p><code>unstated</code> 是一个极简的状态管理方案，其作者也说了不要认为<strong>unstated 是一个 Redux killer</strong>, 不要在它之上构建复杂的工具，也就是不要重复造轮子。所以一般到了这个地步, 其实你就应该考虑 Redux、Mobx、Rxjs 这些复杂的状态管理框架了。</p><p>Redux 是学习 React 绕不过的一个框架. 尽管 Redux 的代码只有一百多行，概念却很多，学习曲线非常陡峭，看官方文档就知道了。即使它的实现很简洁，但是开发代码并不简洁(和 mobx 相反, 脏活留给开发者)，尤其遵循它的’最佳实践’，是从头开始构建一个项目是非常繁琐的. 还在现在有类似 dva 或 rematch 这样的二次封装库来简化它.</p><p>本文不打算深入介绍 Redux 的相关实践， 社区上面有非常多的教程，官方文档也非常详尽. 这里会介绍 Redux 的主要架构和核心思想，以及它的适用场景.</p><center><br>  <img src="/images/04/redux-design.png" width="700"><br></center><p>Redux 的主要结构如上，在此之前你先要搞清楚 Redux 的初衷是什么，才能明白它为什么要这么设计. 在我看来 Redux 主要为了解决以下两个问题:</p><ol><li><strong>可预测状态</strong></li><li><strong>简化应用数据流</strong></li></ol><p><br></p><p>其实这也是 <code>flux</code> 的初衷, 只是有些它有些东西没做好. 明白 Redux 的初衷，现在来看看它的设计就会清晰很多</p><ul><li><p><strong>单一数据源</strong> -&gt; 可预测，简化数据流：数据只能在一个地方被修改</p><ul><li><p>可以简化应用数据流. 解决传统多 model 模型数据流混乱问题(比如一个 model 可以修改其他 model，一个 view 受到多个 model 驱动)，让数据变动变得可预测可调试</p><center><br> <img src="/images/04/traditional-model.png" width="400"><br></center></li><li><p>同构化应用开发</p></li><li>方便调试</li><li>方便做数据镜像. 可以实现撤销/重做、时间旅行、热重载、状态持久化和恢复</li></ul></li><li><p><strong>单向数据流</strong> -&gt; 简化数据流, 可预测</p></li><li><strong>不能直接修改状态</strong> -&gt; 可预测<ul><li>只能通过 dispatch action 来触发状态变更. action 只是一个简单的对象， 携带事件的类型和 payload</li><li>reducer 接收 action 和旧的 state， 规约生成新的 state. reducer 只是一个纯函数，可以嵌套组合子 reducer 对复杂 state 树进行规约</li><li>不可变数据.</li><li>可测试.</li></ul></li><li><strong>范式化和反范式化</strong>. Store 只存储范式化的数据，减少数据冗余。视图需要的数据通过 reselect 等手段反范式化</li><li><strong>通过中间件隔离副作用</strong> -&gt; 可预测<br>可以说 Redux 的核心概念就是 reducer，然而这是一个纯函数。为了实现复杂的副作用，redux 提供了类似 Koa 的中间件机制，实现各种副作用. 比如异步请求. 除此之外，可以利用中间件机制，实现通用的业务模式， 减少代码重复。</li><li><strong>Devtool</strong> -&gt; 可预测。通过开发者工具可以可视化数据流</li></ul><p><br></p><p><strong>什么时候应该使用 Redux?</strong></p><p>首先还是警告一下： <a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" target="_blank" rel="noopener">You Might Not Need Redux</a>, Redux 不是你的第一选择。</p><p><strong>当我们需要处理复杂的应用状态，且 React 本身无法满足你时</strong>. 比如：</p><ul><li>你需要持久化应用状态, 这样你可以从本地存储或服务器返回数据中恢复应用</li><li>需要实现撤销重做这些功能</li><li>实现跨页面的用户协作</li><li>应用状态很复杂时</li><li>数据流比较复杂时</li><li>许多不相关的组件需要共享和更新状态</li><li>外置状态</li><li>…</li></ul><p><br></p><p><strong>最佳实践</strong></p><p>个人觉得<a href="https://github.com/react-boilerplate/react-boilerplate/blob/master/docs/general/introduction.md" target="_blank" rel="noopener">react-boilerplate</a>是最符合官方‘最佳实践’的项目模板. 它的应用工作流如下:</p><center><br> <img src="/images/04/redux-workflow.png " width="600"><br></center><p>特性:</p><ol><li>整合了 Redux 生态比较流行的方案: <code>immer</code>(不可变数据变更)，<code>redux-saga</code>(异步数据流处理)，<code>reselect</code>(选取和映射 state，支持 memo，可复合)，<code>connected-react-router</code>(绑定 react-router v4)</li><li>根据页面分割 saga 和 reducer。见下面 👇 和目录结构</li><li>按需加载 saga 和 reducer(通过 replaceReducer)</li><li>划分容器组件和展示组件</li></ol><p>再看看 react-boilerplate 目录结构. 这是我个人比较喜欢的项目组件方式，组织非常清晰，很有参考意义</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/src</span><br><span class="line">  /components        # 展示组件</span><br><span class="line">  /containers        # 🔴容器/页面组件</span><br><span class="line">    /App             # 根组件， 例如放置Provider和Router</span><br><span class="line">    /HomePage        # 页面组件</span><br><span class="line">      index.js       # 页面入口</span><br><span class="line">      constants.js   # 🔴 在这里定义各种常量。包括Action Type</span><br><span class="line">      actions.js     # 🔴 定义各种Action函数</span><br><span class="line">      saga.js        # 🔴 redux-saga 定义各种saga方法， 用于处理异步流程</span><br><span class="line">      reducer.js     # 🔴 reducer。 页面组件的reducer和saga都会按需注入到根store</span><br><span class="line">      selectors.js   # 🔴 redux state映射和计算</span><br><span class="line">      message.js</span><br><span class="line">      Form.js        # 各种局部组件</span><br><span class="line">      Input.js</span><br><span class="line">      ...</span><br><span class="line">    /FeaturePage     # 其他页面组件结构同上</span><br><span class="line">    ...</span><br><span class="line">  /translations      # i18n 翻译文件</span><br><span class="line">  /utils</span><br><span class="line">    reducerInjectors.js  # 🔴reducer 注入器, 实现和页面组件一起按需注入</span><br><span class="line">    sagaInjectors.js     # 🔴saga 注入器, 同上</span><br><span class="line">    lodable.js</span><br><span class="line">  app.js             # 应用入口</span><br><span class="line">  i18n.js            # i18n配置</span><br><span class="line">  configureStore.js  # 🔴 创建和配置Redux Store</span><br><span class="line">  reducers.js        # 🔴 根reducers, 合并所有'页面状态'和'全局状态'(如router， language， global(例如用户鉴权信息))</span><br></pre></td></tr></table></figure><p><br></p><p><strong>🤬 开始吐槽!</strong></p><p><br></p><ul><li><p><strong>一，Redux 核心库很小，只提供了 dispatch 和 reducer 机制，对于各种复杂的副作用处理 Redux 通过提供中间件机制外包出去</strong>。社区有很多解决方案，redux-promise, redux-saga, redux-observable… 查看 Redux 的<a href="https://redux.js.org/introduction/ecosystem#actions" target="_blank" rel="noopener">生态系统</a>.</p><p><strong>Redux 中间件的好处是扩展性非常好, 开发者可以利用中间件抽象重复的业务 e 中间件生态也百花齐放, 但是对于初学者则不友好</strong>.</p><p>TM 起码还得需要去了解各种各样的库，横向比较的一下才知道自己需要搭配哪个库吧? 那好吧，就选 redux-saga 吧，star 数比较多。后面又有牛人说不要面向 star 编程，选择适合自己团队的才是最好的… 所以挑选合适的方案之前还是得要了解各种方案本身吧?。</p><p>Vue 之所以学习曲线比较平缓也在于此吧。它帮助我们做了很多选择，提供简洁的解决方案，另外官方还提供了风格指南和最佳实践. 这些选择适合 80%以上的开发需求. 开发者减少了很多折腾的时间，可以专心写业务. <strong>这才是所谓的‘<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">渐进式</a>’框架吧, 对于不爱折腾的或初学者，我们帮你选择，但也不会阻碍你往高级的地方走</strong>。 这里可以感受到 React 社区和 Vue 社区的风格完全不同.</p><p>在出现选择困难症时，还是看看别人怎么选择，比如比较有影响力的团队或者流行的开源项目(如 dva，rematch)，选取一个折中方案, 后续有再慢慢深入研究. <strong>对于 Redux 目前比较流行的组合就是: <code>immer+saga+reselect</code></strong></p><p><br></p></li><li><p><strong>二，太多模板代码</strong>。比如上面的 react-boilerplate, 涉及五个文件, 需要定义各种 Action Type、Action、 Reducer、Saga、Select. 所以即便想进行一个小的状态变化也需要更改好几个地方:</p><p><img src="/images/04/redux-page.png" alt></p><p>笔者个人更喜欢类似 Vuex 这种<code>Ducks</code>风格的组织方式，将模块下的 action，saga，reducer 和 mapper 都组织在一个文件下面:</p><center><br> <img src="/codes/redux-ducks.png" width="600"><br></center><p>Redux 的二次封装框架基本采用类似的风格, 如<a href="https://github.com/rematch/rematch" target="_blank" rel="noopener"><code>rematch</code></a></p><center><br> <img src="/images/04/rematch.png" width="800"><br></center><p>这些二次封装框架一般做了以下优化(其实可以当做是 Vuex 的优点)，来提升 Redux 的开发体验:</p><ul><li><strong>使用 Ducks 风格组织代码</strong>.聚合分散的 reducer，saga，actions…</li><li><strong>更简化的 API</strong></li><li><strong>提供了简单易用的模块化(或者称为‘分形’)或者命名空间机制</strong>。模块本身支持‘状态隔离’，让模块的 reducer、saga 只专注于模块自己的状态. 另外模块还考虑<strong>动态加载</strong></li><li><strong>内置副作用处理机制</strong>。如使用 saga 或 redux-promise</li><li><strong>简化了不可变数据的操作方式</strong>。 如使用 immer</li><li><strong>简化 reducer</strong>。Redux 内置了 combineReducers 来复合多个 reducer，在 reducer 内部我们一般使用 switch 语句来接收 action 和处理数据变动, 其实写起来非常啰嗦. <strong>Vuex 和这些封装框架不约而同使用了 key/value 形式</strong>, 更为简洁明了</li><li><strong>简化 view 层的 connect 接口</strong>。如简化 mapProps，mapDispatch 这些代码写起来也比较繁琐</li></ul><p><br></p></li><li><p><strong>三，强制不可变数据</strong>。前面文章也提到过 setState 很啰嗦，为了保证状态的不可变性最简单的方式是使用对象展开或者数组展开操作符, 再复杂点可以上 Immutable.js, 这需要一点学习成本. 好在现在有 immer，可以按照 Javascript 的对象操作习惯来实现不可变数据</p><p><br></p></li><li><p><strong>四，状态设计</strong>。</p><p>数据类型一般分为<strong>领域数据(Domain data)</strong>和<strong>应用数据(或者称为 UI 数据)</strong>. 在使用 Redux 时经常需要考虑状态要放在组件局部，还是所有状态都抽取到 Redux Store？把这些数据放到 Redux Store 里面处理起来好像更麻烦？既然都使用 Redux 了，不把数据抽取到 Redux Store 是否不符合最佳实践？ 笔者也时常有这样的困惑, 你也是<a href="https://ruby-china.org/topics/38057" target="_blank" rel="noopener">最佳实践的受害者</a>?</p><p>我觉得可以从下面几个点进行考虑:</p><ul><li><strong>领域数据还是应用数据?</strong> 领域数据一般推荐放在 ReduxStore 中，我们通常会将 Redux 的 Store 看作一个数据库，存放范式化的数据。</li><li><strong>状态是否会被多个组件或者跨页面共享？</strong> Redux Store 是一个全局状态存储器，既然使用 Redux 了，有理由让 Redux 来管理跨越多组件的状态</li><li><strong>状态是否需要被镜像化?</strong> 如果你的应用要做‘时间旅行(撤销/重做)’或者应用持久化，这个状态需要被恢复，那么应该放到 Redux Store，集中化管理数据是 Redux 的强项</li><li><strong>状态是否需要跨越组件的生命周期？</strong> 将状态放在组件局部，就会跟着组件一起被销毁。如果希望状态跨越组件的生命周期，应该放到父组件或者 Redux Store 中. 比如一个模态框编辑的数据在关闭后是否需要保留</li></ul><p><strong>原则是能放在局部的就放在局部</strong>. 在局部状态和全局状态中取舍需要一点开发经验.</p><p>另外作为一个集中化的状态管理器，为了状态的可读性(更容易理解)和可操作性(更容易增删查改)，在状态结构上面的设计也需要花费一些精力的. 这个数据库结构的设计方法是一样的, <strong>在设计状态之前你需要理清各种领域对象之间的关系, 在数据获取和数据变更操作复杂度/性能之间取得平衡</strong>.</p><p>Redux 官方推荐<a href="https://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="noopener"><strong>范式化 State</strong></a>，扁平化结构树, 减少嵌套，减少数据冗余. <strong>也就是倾向于更方便被更新和存储，至于视图需要什么则交由 reselect 这些库进行计算映射和组合</strong>.</p><p>所以说 Redux 没那么简单, 当然 80%的 Web 应用也不需要这么复杂.</p><p><br></p></li><li><p><strong>五，不方便 Typescript 类型化</strong>。不管是 redux 还是二次封装框架都不是特别方便 Typescript 进行类型推导，尤其是在加入各种扩展后。你可能需要显式注解很多数据类型</p><p>扩展: <a href="https://github.com/piotrwitek/react-redux-typescript-guide#redux---typing-patterns" target="_blank" rel="noopener">react-redux-typescript-guide</a>, <a href="https://rematch.gitbooks.io/rematch/docs/recipes/typescript.html" target="_blank" rel="noopener">rematch &amp; Typescript</a><br><br></p></li><li><p><strong>六，不是分形(Fractal)</strong></p><p>在没有看到<a href="https://www.zhihu.com/people/yang-jian-feng/activities" target="_blank" rel="noopener">@杨剑锋</a>的这条<a href="https://www.zhihu.com/question/263928256/answer/275092256" target="_blank" rel="noopener">知乎回答</a>之前我也不知道什么叫分形, 我只能尝试解释一下我对分形的理解:</p><p>前面文章也提到过‘分离逻辑和视图’和‘分离容器组件和展示组件’，这两个规则都来自于 Redux 的最佳实践。<strong>Redux 就是一个’非分形的架构’，如下图，在这种简单的‘横向分层’下, 视图和逻辑(或状态)可以被单独复用，但在 Redux 中却很难将二者作为一个整体的组件来复用</strong>:</p><p>  <center><br>  <img src="/images/04/redux-and-dumb.png" width="400"><br>  </center><br>  <em>集中化的 Store，再通过 Connect 机制可以让状态在整个应用范围内被复用；Dumb 组件抽离的状态和行为，也容易被复用</em></p><p>现在假设你需要将单个 container 抽离成独立的应用，单个 container 是无法独立工作的。<strong>在分形的架构下，一个‘应用’有更小的‘应用’组成，‘应用’内部有自己的状态机制，单个应用可以独立工作，也可以作为子应用</strong>. 例如 Redux 的鼻祖 Elm 的架构:</p><p>  <center><br>  <img src="/images/04/elm.jpg" width="500"><br>  </center><br>  <em>Store的结构和应用的结构保持一致, 每个 Elm 组件也是一个 Elm 应用，包含完整的Action、Update、Model和View. 使得单独的应用可以被复用</em></p><p><strong>Redux 不是分形和 Redux 本身的定位有关，它是一个纯粹的状态管理器，不涉及组件的视图实现，所以无法像 elm 和 cyclejs 一样形成一个完整的应用闭环</strong>。 其实可以发现 react 组件本身就是分形的，组件原本就是状态和视图的集合.</p><p>分形的好处就是可以实现更灵活的复用和组合，减少胶水代码。显然现在支持纯分形架构的框架并不流行，原因可能是门槛比较高。个人认为不支持分形在工程上还不至于成为 Redux 的痛点，我们可以通过‘模块化’将 Redux 拆分为多个模块，在多个 Container 中进行独立维护，从某种程度上是否就是分形？另外这种横向隔离的 UI 和状态，也是有好处的，比如 UI 相比业务的状态变化的频度会更大.</p><p>个人感觉到页面这个级别的分化刚刚好，比如方便分工。比如最近笔者就有这样一个项目, 我们需要将一个原生 Windows 客户端转换成 electron 实现，限于资源问题，这个项目涉及到两个团队之间协作. 对于这个项目应用 Store 就是一个接口层，Windows 团队负责在这里维护状态和实现业务逻辑，而我们前端团队则负责展示层. 这样一来 Windows 不需要学习 React 和视图展示，我们也不需要关系他们复杂的业务逻辑(底层还是使用 C++, 暴露部分接口给 node)</p></li></ul><p><br></p><p><strong>七，可能还有性能问题</strong></p><ul><li><a href="https://cn.redux.js.org/docs/faq/Performance.html" target="_blank" rel="noopener">Redux 常见问题：性能</a></li><li><a href="https://www.zhihu.com/question/41904561/answer/93029393" target="_blank" rel="noopener">redux 中的 state 树太大会不会有性能问题？</a></li><li><a href="https://tech.youzan.com/mobx_vs_redux/" target="_blank" rel="noopener">我为什么从 Redux 迁移到了 Mobx</a></li><li><a href="https://zhuanlan.zhihu.com/p/52625410" target="_blank" rel="noopener">Mobx 与 Redux 的性能对比</a></li></ul><p><br></p><p>总结</p><p>本节主要介绍的 Redux 设计的动机，以及围绕着这个动机一系列设计, 再介绍了 Redux 的一些缺点和最佳实践。Redux 的生态非常繁荣，如果是初学者或不想折腾还是建议使用 Dva 或 rematch 这类二次封装框架，这些框架通常就是 Redux 一些最佳实践的沉淀, 减少折腾的时间。当然这只是个开始，组织一个大型项目你还有很多要学的。</p><p><br></p><p>扩展阅读</p><ul><li><a href="https://www.zhihu.com/question/263928256/answer/275092256" target="_blank" rel="noopener">Redux 有什么缺点</a> 知乎上的吐槽</li><li><a href="https://zhuanlan.zhihu.com/p/27093191" target="_blank" rel="noopener">Redux 状态管理之痛点、分析与改良</a></li><li><a href="https://www.zhihu.com/question/47995437/answer/108788493" target="_blank" rel="noopener">Redux 有哪些最佳实践?</a></li><li><a href="https://www.zhihu.com/question/38591713/answer/77634014" target="_blank" rel="noopener">如何评价数据流管理架构 Redux?</a></li><li><a href="https://www.zhihu.com/question/284931332/answer/441399919" target="_blank" rel="noopener">2018 年我们还有什么功能是 Redux 才适合做的吗？</a></li><li><a href="https://juejin.im/post/5c166d8fe51d45242973fdd3" target="_blank" rel="noopener">Cycle.js 状态管理模型</a></li><li><a href="https://dvajs.com/guide/develop-complex-spa.html#动态加载model" target="_blank" rel="noopener">使用 Dva 开发复杂 SPA</a></li><li><a href="https://hackernoon.com/redesigning-redux-b2baee8b8a38" target="_blank" rel="noopener">Redesigning Redux</a></li><li><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">Redux 官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/26485702" target="_blank" rel="noopener">redux 三重境</a></li></ul><p><br></p><hr><p><br></p><h2 id="mobx"><a href="#mobx" class="headerlink" title="Mobx"></a>Mobx</h2><p>Mobx 提供了一个类似 Vue 的响应式系统，相对 Redux 来说 Mobx 的架构更容易理解。 拿官方的图来看:</p><p><img src="/images/04/mobx-preview.png" alt></p><ul><li><p><strong>响应式数据</strong>. 首先使用<code>@observable</code> 将数据转换为‘响应式数据’，类似于 Vue 的 data。这些数据在一些上下文(例如 computed，observer 的包装的 React 组件，reaction)中被访问时可以被收集依赖，当这些数据变动时相关的依赖就会被通知.</p><p>响应式数据带来的两个优点是 ① 简化数据操作方式(相比 redux 和 setState); ② 精确的数据绑定，只有数据真正变动时，视图才需要渲染，组件依赖的粒度越小，视图就可以更精细地更新</p></li><li><p><strong>衍生</strong>.</p><ul><li>衍生数据。Mobx 也推荐不要在状态中放置冗余或可推导的数据，而是使用 <code>@computed</code> 计算衍生的状态. computed 的概念类似于 Redux 中的 reselect，对范式化的数据进行反范式化或者聚合计算</li><li>副作用衍生. 当数据变动时触发依赖该数据的副作用，其中包含‘视图’。视图是响应式数据的映射</li></ul></li><li><p><strong>数据变更</strong>. mobx 推荐在 <code>action/flow(异步操作)</code> 中对数据进行变更，action 可以认为是 Redux 中的 dispatch+reducer 的合体。在严格模式下 mobx 会限制只能在 action 函数中进行变更，这使得状态的变更可被追溯。<strong>推荐在 flow 函数中隔离副作用，这个东西和 Redux-saga 差不多，通过 generator 来进行异步操作和副作用隔离</strong></p></li></ul><p><br></p><p>上面就是 Mobx 的核心概念。举一个简单的例子：</p><center><br><img src="/codes/mobx-demo.png" width="650"><br></center><p>但是<strong>Mobx 不是一个框架</strong>，它不会像 Redux 一样告诉你如何去组织代码，在哪存储状态或者如何处理事件, 也没有最佳实践。好处是你可以按照自己的喜好组件项目，比如按照 Redux(Vuex)方式，也可以使用面向对象方式组织; 坏处是如果你没有相关经验, 会不知所措，不知道如何组织代码</p><p>Mobx 一般使用面向对象的方式对 Store 进行组织, 官方文档<a href="https://cn.mobx.js.org/best/store.html" target="_blank" rel="noopener">构建大型可扩展可维护项目的最佳实践</a>也介绍了这种方式, 这个其实就是经典的 MV* 模式:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/          # 展示组件</span><br><span class="line">  models/              # 🔴 放置一些领域对象</span><br><span class="line">    Order.ts</span><br><span class="line">    User.ts</span><br><span class="line">    Product.ts</span><br><span class="line">    ...</span><br><span class="line">  stores/              # store</span><br><span class="line">    AppStore.ts        # 应用Store，存放应用全局信息，如auth，language，theme</span><br><span class="line">    OrderStore.ts</span><br><span class="line">    RootStore.ts       # 根Store，组合所有下级Store</span><br><span class="line">    ...</span><br><span class="line">  containers/</span><br><span class="line">    App/               # 根组件</span><br><span class="line">    Orders/            # 页面组件</span><br><span class="line">    ...</span><br><span class="line">  utils/</span><br><span class="line">  store.ts             # store初始化</span><br><span class="line">  index.tsx</span><br></pre></td></tr></table></figure><p><br></p><p><strong>领域对象</strong></p><p>面向对象领域有太多的名词和概念，而且比较抽象，如果理解有误请纠正. 暂且不去理论领域对象是什么，尚且视作是现实世界中一个业务实体在 OOP 的抽象. 具体来说可以当做<code>MVC</code>模式中的 M, 或者是 ORM 中数据库中映射出来的对象.</p><p>对于复杂的领域对象，会抽取为单独的类，比如前面例子中的<code>Todo</code>类, 抽取为类的好处是它具有封装性，可以包含关联的行为、定义和其他对象的关联关系，相比纯对象表达能力更强. 缺点就是不好序列化</p><p>因为它们和页面的关联关系较弱，且可能在多个页面中被复用, 所以放在根目录的<code>models/</code>下. 在代码层面领域对象有以下特点：</p><ul><li>定义了一些字段(@observable)和一些领域对象的操作方法(@action), 可能还关联其他领域对象，比如订单会关联用户和产品</li><li>由 Store 来管理生命周期，或者说 Store 就 Model 的容器, 相当于数据库. Store 通常也是单例</li></ul><p>示例</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Order &#123;</span><br><span class="line">  <span class="keyword">public</span> id: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> createdDate: <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> product: Product;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> user: User;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Store</strong></p><p>Store 只是一个 Model 容器， 负责管理 model 对象的生命周期、定义衍生状态、封装副作用、和后端接口集成等等. Store 一般是单例. 在 Mobx 应用中一般会划分为多个 Store 绑定不同的页面。</p><p>示例</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, computed, reaction &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> OrderStore &#123;</span><br><span class="line">    <span class="comment">// 定义模型state</span></span><br><span class="line">  <span class="meta">@observable</span> orders: Order[] = [];</span><br><span class="line"></span><br><span class="line">  _unSubscribeOrderChange: <span class="built_in">Function</span></span><br><span class="line">  rootStore: RootStore</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义衍生数据</span></span><br><span class="line">  <span class="meta">@computed</span> <span class="keyword">get</span> finishedOrderCount() &#123;&#125;</span><br><span class="line">  <span class="meta">@computed</span> <span class="keyword">get</span> finishedOrders() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义副作用衍生</span></span><br><span class="line">  subscribeOrderChange() &#123;      <span class="keyword">this</span>._unSubscribeOrderChange = <span class="keyword">this</span>.orders.observe(<span class="function">(<span class="params">changeData</span>) =&gt;</span> &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义action</span></span><br><span class="line">  <span class="meta">@action</span>  addOrder (order) &#123;&#125;</span><br><span class="line">  <span class="meta">@action</span>  removeOrder (order) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者一些异步的action</span></span><br><span class="line">  <span class="keyword">async</span> fetchOrders () &#123;</span><br><span class="line">    <span class="keyword">const</span> orders = <span class="keyword">await</span> fetchOrders()</span><br><span class="line">    orders.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">this</span>.addOrder(<span class="keyword">new</span> OrderModel(<span class="keyword">this</span>, item)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化，初始化数据结构，初始化订阅等等</span></span><br><span class="line">  initialize () &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribeOrderChange()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一些清理工作</span></span><br><span class="line">  release () &#123;</span><br><span class="line">    <span class="keyword">this</span>._unSubscribeOrderChange()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">store: RootStore</span>) &#123;</span><br><span class="line">    <span class="comment">// 和rootStore进行通信</span></span><br><span class="line">    <span class="keyword">this</span>.rootStore = store</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根 Store</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> RootStore &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.appStore = <span class="keyword">new</span> AppStore(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.orderStore = <span class="keyword">new</span> OrderStore(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Provider rootStore=&#123;new RootStore()&#125;&gt;</span><br><span class="line">  &lt;App /&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure><p>看一个 <a href="https://github.com/gothinkster/react-mobx-realworld-example-app/blob/master/src/index.js" target="_blank" rel="noopener">真实世界的例子</a></p><p>这种传统 MVC 的组织方式主要有以下优点:</p><ul><li><strong>好理解, 容易入手</strong>. 经典的 MVC 模式、面向对象，我们再熟悉不过了. 尤其是熟悉 Java 这些传统面向对象编程范式的后端开发人员. 上文提到的跨团队的项目，我们选择的就是 mobx 作为状态管理器，对于他们来说这是最好理解的方式. 但是<strong>对于领域对象和领域 Store 的拆分和设计需要一点经验</strong></li><li><strong>强类型</strong></li><li><strong>代码简洁</strong>。相对 Redux 多余的模板代码而言</li><li><strong>数据封装性</strong>。使用类表达的数据结构可以封装相应的行为</li></ul><p>问题</p><ul><li><strong>在多个 Store 之间共享数据比较麻烦</strong>. 我们的做法是让所有 Store 都继承一个父类作为中间者，通过事件订阅模式在多个 Store 间进行数据通信</li><li><strong>缺乏组织</strong>。相对 Redux 而言, 状态过于零散，不加以约束，状态可以被随意修改。我们很多代码就是这样，懒得写 action，甚至直接在视图层给状态赋值. 所以一定要开始严格模式</li><li><strong>没有 Magic</strong>. 这是一把双刃剑, Redux 有中间件机制，可以扩展抽象许多重复的工作, 比如为异步方法添加 loading 状态, 但是对 Typescript 不友好; 基于类的方案，无处下手，代码会比较啰嗦， 但更直观</li><li><strong>无数据快照</strong>，无法实现时间回溯，这是 Redux 的强项，但大部分的应用不需要这个功能; 另外可以通过 mobx-state-tree 实现</li><li><strong>无法 hot-reload</strong></li></ul><p><br></p><p>还有一些 mobx 本身的问题, 这些问题在上一篇文章也提过, 另外可以看这篇文章(<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;mid=2697266952&amp;idx=2&amp;sn=a3389d1db237c2b23f523061da3b2359" target="_blank" rel="noopener">Mvvm 前端数据流框架精讲</a>):</p><ul><li><p><strong>组件侵入性</strong>. 需要改变 React 组件原本的结构, 例如所有需要响应数据变动的组件都需要使用 observer 装饰. 组件本地状态也需要 observable 装饰, 以及数据操作方式等等. 对 mobx 耦合较深, 日后切换框架或重构的成本很高</p></li><li><p><strong>兼容性</strong>. mobx v5 后使用 Proxy 进行重构, 但 Proxy 在 Chrome49 之后才支持. 如果要兼容旧版浏览器则只能使用 v4, v4 有一些<a href="https://cn.mobx.js.org/#mobx-4-vs-mobx-5" target="_blank" rel="noopener">坑</a>, 这些坑对于不了解 mobx 的新手很难发现:</p><ul><li>Observable 数组并非真正的数组. 比如 antd 的 Table 组件就不认 mobx 的数组, 需要传入到组件之间使用 slice 进行转换</li><li>向一个已存在的 observable 对象中添加属性不会被自动捕获</li></ul></li></ul><p><br></p><p><code>MV*</code> 只是 Mobx 的其中一种主流组织方式, 很多文章在讨论 Redux 和 mobx 时往往会沦为<strong>函数式和面向对象</strong>之争，然后就下结论说 Redux 更适合大型项目，<strong>下这种结论最主要的原因是 Redux 有更多约束(only one way to do it), 适合项目的演进和团队协作, 而不在于函数式和面向对象</strong>。当然函数式和面向对象范式都有自己擅长的领域，例如函数式适合数据处理和复杂数据流抽象，而面向对象适合业务模型的抽象, 所以不要一竿子打死.</p><p>换句话说适不适合大型项目是项目组织问题, Mobx 前期并没有提出任何解决方案和最佳实践。这不后来其作者也开发了<a href="https://github.com/mobxjs/mobx-state-tree" target="_blank" rel="noopener">mobx-state-tree</a>这个神器，作为 MobX 官方提供的状态模型构建库，MST 吸收了 Redux 等工具的优点，<strong>旨在结合不可变数据/函数式(transactionality, traceability and composition)和可变数据/面向对象(discoverability, co-location and encapsulation)两者的优点</strong>， 提供了很多诸如数据镜像(time travel)、hot reload、action middleware、集成 redux-devtools 以及强类型(Typescript + 运行时检查(争议点))等很有用的特性, 其实它更像是后端 ActiveRecord 这类 ORM 工具, 构建一个对象图。</p><center><br>  <img src="/images/04/immutable-vs-mutable.png" width="500"><br></center><p>典型的代码：</p><center><br>  <img src="/codes/mst.png" width="800"><br></center><p>限于笔者对 MST 实践不多，而且文章篇幅已经很长，所以就不展开了，后续有机会再分享分享。</p><p><br></p><p>还是得下一个结论, 选择 Mobx 还是 Redux? 这里还是引用来自<a href="https://zhuanlan.zhihu.com/p/25989654" target="_blank" rel="noopener">MobX vs Redux: Comparing the Opposing Paradigms - React Conf 2017 纪要</a>的结论:</p><ul><li>需要快速开发简单应用的小团队可以考虑使用 MobX，因为 MobX 需要开发的代码量小，学习成本低，上手快，适合于实时系统，仪表盘，文本编辑器，演示软件，但不适用于基于事件的系统</li><li>Redux 适用于大团队开发复杂应用，Redux 在可扩展性和可维护性方面可以 hold 住多人协作与业务需求多变，适合商业系统、基于事件的系统以及涉及复杂反应的游戏场景。</li></ul><p>上述结论的主要依据是 Redux 对 action / event 作出反应，而 MobX 对 state 变化作出反应。比如当一个数据变更涉及到 Mobx 的多个 Store，可以体现出 Redux 的方式更加优雅，数据流更加清晰. 前面都详尽阐述了 Mobx 和 Redux 的优缺点，mobx 还有 MST 加持， 相信读者心里早已有自己的喜好</p><p><br></p><p>扩展</p><ul><li><a href="https://zhuanlan.zhihu.com/p/33761397" target="_blank" rel="noopener">你需要 Mobx 还是 Redux？</a></li><li><a href="https://zhuanlan.zhihu.com/p/25585910" target="_blank" rel="noopener">Mobx 思想的实现原理，及与 Redux 对比</a></li><li><a href="https://zhuanlan.zhihu.com/p/25989654" target="_blank" rel="noopener">MobX vs Redux: Comparing the Opposing Paradigms - React Conf 2017 纪要</a></li><li><a href="https://github.com/dobjs/dob" target="_blank" rel="noopener">dob</a> 更轻量的类似 mobx 的轮子</li><li><a href="https://segmentfault.com/a/1190000018940757" target="_blank" rel="noopener">积梦前端采用的 React 状态管理方案: Rex</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;mid=2697266952&amp;idx=2&amp;sn=a3389d1db237c2b23f523061da3b2359" target="_blank" rel="noopener">干货 | Mvvm 前端数据流框架精讲</a></li></ul><h2 id="rxjs"><a href="#rxjs" class="headerlink" title="RxJS"></a>RxJS</h2><p>如果上文提到的状态管理工具都无法满足你的需要，你的项目复杂程度可能超过全国 99%的项目了. RxJS 可能可以助你一臂之力, <strong>RxJS 非常适合复杂异步事件流的应用</strong>，笔者在这方面实践也比较少，推荐看看<a href="https://www.zhihu.com/people/sharpmaster/posts" target="_blank" rel="noopener">徐飞的相关文章</a>, 另外 Redux(Redux-Observable)和 Mobx 实际上也可以配合 RxJS 使用</p><p><br></p><hr><p><br></p><h2 id="其他状态管理方案"><a href="#其他状态管理方案" class="headerlink" title="其他状态管理方案"></a>其他状态管理方案</h2><ul><li>Apollo+GraphQL</li><li><a href="https://github.com/FormidableLabs/freactal/" target="_blank" rel="noopener">freactal</a></li></ul><p>推荐这篇文章<a href="https://blog.bitsrc.io/state-of-react-state-management-in-2019-779647206bbc" target="_blank" rel="noopener">State of React State Management for 2019</a></p><p><br></p><hr><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/26426054" target="_blank" rel="noopener">单页应用的数据流方案探索</a></li><li><a href="https://zhuanlan.zhihu.com/p/24677176" target="_blank" rel="noopener">复杂单页应用的数据层设计</a></li><li><a href="https://blog.bitsrc.io/state-of-react-state-management-in-2019-779647206bbc" target="_blank" rel="noopener">State of React State Management for 2019</a></li><li><a href="https://zhuanlan.zhihu.com/p/32107541" target="_blank" rel="noopener">从时间旅行的乌托邦，看状态管理的设计误区</a></li></ul></r>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是 520，这是本系列最后一篇文章，主要涵盖 React 状态管理的相关方案。&lt;/p&gt;
&lt;p&gt;前几篇文章在&lt;a href=&quot;https://juejin.im&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金&lt;/a&gt;首发基本石沉大海, 没什么阅读量.
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结04 - 组件的思维</title>
    <link href="https://bobi.ink/2019/05/15/react-component-design-04/"/>
    <id>https://bobi.ink/2019/05/15/react-component-design-04/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-05-17T04:15:59.848Z</updated>
    
    <content type="html"><![CDATA[<p>在 React 的世界里”<strong>一切都是组件</strong>“， 组件可以映射作函数式编程中的函数，React 的组件和函数一样的灵活的特性不仅仅可以用于绘制 UI，还可以用于封装业务状态和逻辑，或者非展示相关的副作用, 再通过组合方式组成复杂的应用. 本文尝试解释用 React 组件的思维来处理常见的业务开发场景.</p><p><strong>系列目录</strong></p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li>05 状态管理 待更新</li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-高阶组件">1. 高阶组件</a></li><li><a href="#2-render-props">2. Render Props</a></li><li><a href="#3-使用组件的方式来抽象业务逻辑">3. 使用组件的方式来抽象业务逻辑</a></li><li><a href="#4-hooks-取代高阶组件">4. hooks 取代高阶组件</a></li><li><a href="#5-hooks-实现响应式编程">5. hooks 实现<code>响应式</code>编程</a></li><li><a href="#6-类继承也有用处">6. 类继承也有用处</a></li><li><a href="#7-模态框管理">7. 模态框管理</a></li><li><a href="#8-使用-context-进行依赖注入">8. 使用 Context 进行依赖注入</a></li><li><a href="#9-不可变的状态">9. 不可变的状态</a></li><li><a href="#10-react-router-url-即状态">10. React-router: URL 即状态</a></li><li><a href="#11-组件规范">11. 组件规范</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="1-高阶组件"><a href="#1-高阶组件" class="headerlink" title="1. 高阶组件"></a>1. 高阶组件</h2><p>在很长一段时期里，高阶组件都是增强和组合 React 组件的最流行的方式. 这个概念源自于函数式编程的高阶函数. 高阶组件可以定义为: <strong>高阶组件是函数，它接收原始组件并返回原始组件的增强/填充版本</strong>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function"><span class="params">Component</span> =&gt;</span> EnhancedComponent;</span><br></pre></td></tr></table></figure><p>首先要明白我们<strong>为什么需要高阶组件</strong>:</p><p>React 的<a href="https://react.docschina.org/docs/higher-order-components.html" target="_blank" rel="noopener">文档</a>说的非常清楚, <strong>高阶组件是一种用于复用组件逻辑模式</strong>. 最为常见的例子就是 redux 的<code>connect</code>和 react-router 的 <code>withRouter</code>. 高阶组件最初用于取代 mixin(了解<a href="https://zhuanlan.zhihu.com/p/20361937" target="_blank" rel="noopener">React Mixin 的前世今生</a>). 总结来说就是两点:</p><ul><li>逻辑复用. 把一些通用的代码逻辑提取出来放到高阶组件中, 让更多组件可以共享</li><li>分离关注点. 在之前的章节中提到”逻辑和视图分离”的原则. 高阶组件可以作为实现该原则的载体. 我们一般将行为层或者业务层抽取到高阶组件中来实现, 让展示组件只关注于 UI</li></ul><p>高阶组件的一些<strong>实现方法</strong>主要有两种:</p><ul><li><p><code>属性代理(Props Proxy)</code>: 代理传递给被包装组件的 props, 对 props 进行操作. 这种方式用得最多. 使用这种方式可以做到:</p><ul><li>操作 props</li><li>访问被包装组件实例</li><li>提取 state</li><li>用其他元素包裹被包装组件</li></ul></li><li><p><code>反向继承(Inheritance Inversion)</code>: 高阶组件继承被包装的组件. 例如:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myhoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> Enhancer <span class="keyword">extends</span> WrappedComponent &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现:</p><ul><li>渲染劫持: 即控制被包装组件的渲染输出.</li><li>操作 state: state 一般属于组件的内部细节, 通过继承的方式可以暴露给子类. 可以增删查改被包装组件的 state, 除非你知道你在干什么, 一般不建议这么做.</li></ul></li></ul><p>实际上高阶组件能做的不止上面列举的, 高阶组件非常灵活, 全凭你的想象力. 读者可以了解 <a href="https://github.com/acdlite/recompose/blob/master/docs/API.md" target="_blank" rel="noopener">recompose</a>这个库, 简直把高阶组件玩出花了.</p><p>总结一下高阶组件的<strong>应用场景</strong>:</p><ul><li>操作 props: 增删查改 props. 例如转换 props, 扩展 props, 固定 props, 重命名 props</li><li>依赖注入. 注入 context 或外部状态和逻辑, 例如 redux 的 connnect, react-router 的 withRouter. 旧 context 是实验性 API, 所以很多库都不会将 context 保留出来, 而是通过高阶组件形式进行注入</li><li>扩展 state: 例如给函数式组件注入状态</li><li>避免重复渲染: 例如 React.memo</li><li>分离逻辑, 让组件保持 dumb</li></ul><blockquote><p>高阶组件相关文档在网上有很多, 本文不打算展开描述. 深入了解<a href="https://zhuanlan.zhihu.com/p/24776678" target="_blank" rel="noopener">高阶组件</a></p></blockquote><p>高阶组件的一些<strong>规范</strong>:</p><ul><li><p>包装显示名字以便于调试</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">class</span> WithSubscription <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  WithSubscription.displayName = <span class="string">`WithSubscription(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">'Component'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 React.forwardRef 来转发 ref</p></li><li><p>使用’高阶函数’来配置’高阶组件’, 这样可以让高阶组件的组合性最大化. Redux 的 connect 就是典型的例子</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ConnectedComment = connect(</span><br><span class="line">  commentSelector,</span><br><span class="line">  commentActions,</span><br><span class="line">)(Comment);</span><br></pre></td></tr></table></figure><p>当使用 compose 进行组合时就能体会到它的好处:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 🙅 不推荐</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 使用compose方法进行组合</span></span><br><span class="line"><span class="comment">// compose(f, g, h) 和 (...args) =&gt; f(g(h(...args)))是一样的</span></span><br><span class="line"><span class="keyword">const</span> enhance = compose(</span><br><span class="line">  <span class="comment">// 这些都是单独一个参数的高阶组件</span></span><br><span class="line">  withRouter,</span><br><span class="line">  connect(commentSelector),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent);</span><br></pre></td></tr></table></figure></li><li><p>转发所有不相关 props 属性给被包装的组件</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp=&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命名: 一般以 with*命名, 如果携带参数, 则以 create*命名</p></li></ul><p><br></p><hr><p><br></p><h2 id="2-render-props"><a href="#2-render-props" class="headerlink" title="2. Render Props"></a>2. Render Props</h2><p>Render Props(Function as Child) 也是一种常见的 react 模式, 比如官方的 <a href="https://reactjs.org/docs/context.html" target="_blank" rel="noopener">Context API</a> 和 <a href="https://www.react-spring.io" target="_blank" rel="noopener">react-spring</a> 动画库. 目的高阶组件差不多: 都是为了分离关注点, 对组件的逻辑进行复用; 在使用和实现上比高阶组件要简单, 在某些场景可以取代高阶组件. 官方的定义是:</p><blockquote><p><strong>是指一种在 React 组件之间使用一个值为函数的 prop 在 React 组件间共享代码的简单技术</strong></p></blockquote><p>React 并没有限定任何 props 的类型, 所以 props 也可以是函数形式. 当 props 为函数时, 父组件可以通过函数参数给子组件传递一些数据进行动态渲染. 典型代码为:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;FunctionAsChild&gt;&#123;<span class="function"><span class="params">()</span> =&gt;</span> &lt;div&gt;Hello,World!&lt;<span class="regexp">/div&gt;&#125;&lt;/</span>FunctionAsChild&gt;</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;Spring <span class="keyword">from</span>=&#123;&#123; opacity: <span class="number">0</span> &#125;&#125; to=&#123;&#123; opacity: <span class="number">1</span> &#125;&#125;&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">props</span> =&gt;</span> &lt;div style=&#123;props&#125;&gt;hello&lt;<span class="regexp">/div&gt;&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Spring&gt;</span><br></pre></td></tr></table></figure><p>某种程度上, 这种模式相比高阶组件要简单很多, 不管是实现还是使用层次. 缺点也很明显:</p><ul><li>可读性差, 尤其是多层嵌套情况下</li><li>组合性差. 只能通过 JSX 一层一层嵌套, 一般不宜多于一层</li><li>适用于动态渲染. 因为局限在 JSX 节点中, 当前组件是很难获取到 render props 传递的数据. 如果要传递给当前组件还是得通过 props, 也就是通过高阶组件传递进来</li></ul><p>再开一下脑洞. 通过一个 Fetch 组件来进行接口请求:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;Fetch method=<span class="string">"user.getById"</span> id=&#123;userId&#125;&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">&#123; data, error, retry, loading &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &#123;loading ? (</span><br><span class="line">        &lt;Loader /&gt;</span><br><span class="line">      ) : error ? (</span><br><span class="line">        &lt;ErrorMessage error=&#123;error&#125; retry=&#123;retry&#125; /&gt;</span><br><span class="line">      ) : data ? (</span><br><span class="line">        &lt;Detail data=&#123;data&#125; /&gt;</span><br><span class="line">      ) : <span class="literal">null</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/Container&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Fetch&gt;</span><br></pre></td></tr></table></figure><p>在 React Hooks 出现之前, 为了给函数组件(或者说 dumb component)添加状态, 通常会使用这种模式. 比如 <a href="https://github.com/renatorib/react-powerplug" target="_blank" rel="noopener">react-powerplug</a></p><blockquote><p>官方<a href="https://react.docschina.org/docs/render-props.html" target="_blank" rel="noopener">文档</a></p></blockquote><p><br></p><hr><p><br></p><h2 id="3-使用组件的方式来抽象业务逻辑"><a href="#3-使用组件的方式来抽象业务逻辑" class="headerlink" title="3. 使用组件的方式来抽象业务逻辑"></a>3. 使用组件的方式来抽象业务逻辑</h2><p>大部分情况下, 组件表示是一个 UI 对象. 其实组件不单单可以表示 UI, 也可以用来抽象业务对象, 有时候抽象为组件可以巧妙地解决一些问题.</p><p>举一个例子: 当一个审批人在审批一个请求时, 请求发起者是不能重新编辑的; 反之发起者在编辑时, 审批人不能进行审批. 这是一个锁定机制, 后端一般使用类似心跳机制来维护这个’锁’, 这个锁可以显式释放，也可以在超过一定时间没有激活时自动释放，比如页面关闭. 所以前端通常会使用轮询机制来激活锁.</p><p>一般的实现:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MyPage <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 根据一些条件触发, 可能还要监听这些条件的变化，然后停止加锁轮询. 这个逻辑实现起来比较啰嗦</span></span><br><span class="line">    <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">      <span class="keyword">this</span>.timer = setInterval(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 轮询</span></span><br><span class="line">        tryLock();</span><br><span class="line">        <span class="comment">// 错误处理，可以加锁失败...</span></span><br><span class="line">      &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">    <span class="comment">// 页面卸载时显式释放</span></span><br><span class="line">    releaseLock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidUpdate() &#123;</span><br><span class="line">    <span class="comment">// 监听条件变化，开始或停止锁定</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着功能的迭代, MyPage 会变得越来越臃肿, 这时候你开始考虑将这些业务逻辑抽取出去. 一般情况下通过高阶组件或者 hook 来实现, 但都不够灵活, 比如<strong>条件锁定这个功能实现起来就比较别扭</strong>.</p><p>有时候考虑将业务抽象成为组件, 可能可以巧妙地解决我们的问题, 例如 Locker:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 锁定器</span><br><span class="line"> */</span><br><span class="line">const Locker: FC&lt;&#123; onError: err =&gt; boolean, id: string &#125;&gt; = props =&gt; &#123;</span><br><span class="line">  const &#123;id, onError&#125; = props</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let timer</span><br><span class="line">    const poll = () =&gt; &#123;</span><br><span class="line">      timer = setTimeout(async () =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">        // 轮询，处理异常等情况</span><br><span class="line">      &#125;, 5000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    poll()</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      releaseLock()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [id])</span><br><span class="line"></span><br><span class="line">  return null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 Locker</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">    &#123;someCondition &amp;&amp; &lt;Locker id=&#123;<span class="keyword">this</span>.id&#125; onError=&#123;<span class="keyword">this</span>.handleError&#125;&gt;&lt;<span class="regexp">/Locker&gt;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有一个要点：我们将一个业务抽象为了一个组件后，业务逻辑有了和组件一样的生命周期。<strong>现在组件内部只需关心自身的逻辑，比如只关心资源请求和释放(即 How)，而何时进行，什么条件进行(即 When)则由父级来决定</strong>, 这样就符合了单一职责原则。 上面的例子父级通过 JSX 的条件渲染就可以动态控制锁定, 比之前的实现简单了很多</p><p><br></p><hr><p><br></p><h2 id="4-hooks-取代高阶组件"><a href="#4-hooks-取代高阶组件" class="headerlink" title="4. hooks 取代高阶组件"></a>4. hooks 取代高阶组件</h2><p>个人觉得 hooks 对于 React 开发来说是一个革命性的特性, 它改变了开发的思维和模式. 首先要问一下, “它解决了什么问题? 带来了什么新的东西?”</p><p>hooks 首先是要解决高阶组件或者 Render Props 的痛点的. 官方在’<strong>动机</strong>‘上就说了:</p><ul><li><ol><li><strong>很难在组件之间复用状态逻辑</strong>:</li></ol><ul><li>问题: React 框架本身并没有提供一种将可复用的逻辑注入到组件上的方式/原语. RenderProps 和高阶组件只是’模式层面(或者说语言层面)’的东西:</li><li>此前的方案: 高阶组件和 Render Props。<strong>这些方案都是基于组件本身的机制</strong><ul><li>高阶组件和 Render Props 会造成多余的节点嵌套. 即 Wrapper hell</li><li>需要调整你的组件结构, 会让代码变得笨重, 且难以理解</li><li>高阶组件复杂, 难以理解</li><li>此前高阶组件也要 ref 转发问题等等</li></ul></li><li><p>hooks 如何解决:</p><ul><li>将状态逻辑从组件中脱离, 让他可以被单独的测试和复用.</li><li>hooks 可以在组件之间共享, 不会影响组件的结构</li></ul><p><br></p></li></ul></li><li><ol start="2"><li><strong>复杂的组件难以理解</strong>: 复杂组件的特点是有一大堆分散的状态逻辑和副作用. 例如每个生命周期函数常常包含一些互不相关的逻辑, 这些互不相关的逻辑会慢慢变成面条式的代码, 但是你发现很难再对它们进行拆解, 更别说测试它们</li></ol><ul><li>问题:<ul><li>实际情况，我们很难将这些组件分解成更小的组件，因为状态到处都是。测试它们也很困难。</li><li>经常导致过分抽象, 比如 redux, 需要在多个文件中跳转, 需要很多模板文件和模板代码</li></ul></li><li>此前的解决方法: 高阶组件和 Render Props 或者状态管理器. 分割抽离逻辑和 UI, 切割成更小粒度的组件</li><li><p>hooks 如何解决: Hooks 允许您根据相关部分(例如设置订阅或获取数据)将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。你还可以选择使用一个 reducer 来管理组件的本地状态，以使其更加可预测</p><p><br></p></li></ul></li><li><ol start="3"><li>基于 class 的组件对机器和用户都不友好:</li></ol><ul><li>问题:<ul><li>对于人: 需要理解 this, 代码冗长</li><li>对于机器: 不好优化</li></ul></li><li>hooks 如何解决: 函数式组件</li><li>新的问题: 你要了解闭包</li></ul></li></ul><p><br></p><p>Hooks 带来的<strong>新东西</strong>: <strong>hook 旨在让组件的内部逻辑组织成可复用的更小单元，这些单元各自维护一部分组件‘状态和逻辑’</strong>。</p><p><img alt="migrate to hooks" src="/images/04/hooks-transform.png" width="800"><br>图片来源于twitter(<a href="https://twitter.com/threepointone/status/1056594421079261185/photo/1?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1056594421079261185&amp;ref_url=https%3A%2F%2Fmedium.com%2Fmedia%2Fe55e7bcbf2d4912af7e539a2646388e2%3FpostId%3Dfdbde8803889" target="_blank" rel="noopener">@sunil Pai</a>)</p><ul><li><strong>一种新的组件编写方式</strong>. 和此前基于 class 或纯函数组件的开发方式不太一样, hook 提供了更简洁的 API 和代码复用机制, 这使得组件代码变得更简短. 例如 👆 上图就是迁移到 hooks 的代码结构对比, 读者也可以看这个演讲(<a href="https://www.youtube.com/watch?v=wXLf18DsV-I" target="_blank" rel="noopener">90% Cleaner React</a>).<br><br></li><li><strong>更细粒度的状态控制(useState)</strong>. 以前一个组件只有一个 setState 集中式管理组件状态, <strong>现在 hooks 像组件一样, 是一个逻辑和状态的聚合单元. 这意味着不同的 hook 可以维护自己的状态</strong>.<br><br></li><li><p><strong>不管是 hook 还是组件，都是普通函数</strong>.</p><ul><li><strong>从某种程度上看组件和 hooks 是同质的(都包含状态和逻辑)</strong>. 统一使用函数形式开发, 这使得你不需要在类、高阶组件或者 renderProps 上下文之间切换, 降低项目的复杂度. 对于 React 的新手来说，各种高阶组件、render props 各种概念拉高了学习曲线</li><li><strong>函数是一种最简单的代码复用单元, 最简单也意味着更灵活</strong>。相比组件的 props，函数的传参更加灵活； 函数也更容易进行组合, hooks 组合其他 hook 或普通函数来实现复杂逻辑.</li><li><strong>本质上讲，hooks 就是给函数带来了状态的概念</strong><br><br></li></ul></li><li><p><strong>高阶组件之间只能简单嵌套复合(compose), 而多个 hooks 之间是平铺的, 可以定义更复杂的关系(依赖)</strong>.<br><br></p></li><li><strong>更容易进行逻辑和视图分离</strong>. hooks 天然隔离 JSX, 视图和逻辑之间的界限比较清晰, 这使得 hooks 可以更专注组件的行为.<br><br></li><li><strong>淡化组件生命周期概念, 将本来分散在多个生命周期的相关逻辑聚合起来</strong><br><br></li><li><strong>一点点’响应式编程’的味道</strong>, 每个 hooks 都包含一些状态和副作用，这些数据可以在 hooks 之间传递流动和响应， 见下文<br><br></li><li><strong>跨平台的逻辑复用</strong>. 这是我自己开的脑洞, React hooks 出来之后<a href="https://github.com/yyx990803" target="_blank" rel="noopener">尤雨溪</a>就推了一个<a href="https://github.com/yyx990803/vue-hooks" target="_blank" rel="noopener">vue-hooks</a>试验项目, 如果后面发展顺利, hooks 是可能被用于跨框架复用?</li></ul><p><br></p><p>一个<strong>示例</strong>: 无限加载列表</p><iframe src="https://codesandbox.io/embed/rwq4opm70n?codemirror=1&fontsize=14&view=editor" title="useList" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p><br></p><p>一般 hooks 的基本代码结构为:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useHook</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️states</span></span><br><span class="line">  <span class="keyword">const</span> [someState, setSomeState] = useState(initialValue);</span><br><span class="line">  <span class="comment">// ⚛️derived state</span></span><br><span class="line">  <span class="keyword">const</span> computedState = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computed, [dependencies]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️refs</span></span><br><span class="line">  <span class="keyword">const</span> refSomething = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️side effect</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, []);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, [dependencies]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️state operations</span></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setSomeState(newState)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️output</span></span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;&#123;...&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>自定义 hook 和函数组件的代码结构基本一致, 所以有时候<strong>hooks 写着写着原来越像组件, 组件写着写着越像 hooks. 我觉得可以认为组件就是一种特殊的 hook, 只不过它输出 Virtual DOM</strong>.</p><p><br></p><p>一些<strong>注意事项</strong>:</p><ul><li>只能在组件顶层调用 hooks。不要在循环，控制流和嵌套的函数中调用 hooks</li><li>只能从 React 的函数组件中调用 hooks</li><li>自定义 hooks 使用 use*命名</li></ul><p><br></p><p>总结 hooks 的<strong>常用场景</strong>:</p><ul><li><strong>副作用封装和监听</strong>: 例如 useWindowSize(监听窗口大小)，useOnlineStatus(在线状态)</li><li><strong>副作用衍生</strong>: useEffect, useDebounce, useThrottle, useTitle, useSetTimeout</li><li><strong>DOM 事件封装</strong>：useActive，useFocus, useDraggable, useTouch</li><li><strong>获取 context</strong></li><li><strong>封装可复用逻辑和状态</strong>: useInput, usePromise(异步请求), useList(列表加载)<ul><li>取代高阶组件和 render Props. 例如使用 useRouter 取代 withRouter, useSpring 取代旧的 Spring Render Props 组件</li><li>取代容器组件</li><li>状态管理器: use-global-hook, unstated</li></ul></li><li><strong>扩展状态操作</strong>: 原始的 useState 很简单，所以有很大的扩展空间，例如 useSetState(模拟旧的 setState), useToggle(boolean 值切换)，useArray, useLocalStorage(同步持久化到本地存储)</li><li>继续开脑洞…: hooks 的探索还在<a href="https://usehooks.com/" target="_blank" rel="noopener">继续</a></li></ul><p>学习 hooks:</p><ul><li><a href="https://react.docschina.org/docs/hooks-overview.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/50597236" target="_blank" rel="noopener">一篇看懂 React Hooks</a></li><li><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM" target="_blank" rel="noopener">React Today and Tomorrow and 90% Cleaner React With Hooks</a></li><li><a href="https://www.hooks.guide/" target="_blank" rel="noopener">hook-guide</a></li><li><a href="https://zhuanlan.zhihu.com/p/50274018" target="_blank" rel="noopener">精读《怎么用 React Hooks 造轮子》</a></li><li><a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" target="_blank" rel="noopener">Making Sense of React Hooks</a></li><li><a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a></li></ul><p><br></p><hr><p><br></p><h2 id="5-hooks-实现响应式编程"><a href="#5-hooks-实现响应式编程" class="headerlink" title="5. hooks 实现响应式编程"></a>5. hooks 实现<code>响应式</code>编程</h2><p><code>Vue</code>的非侵入性<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">响应式系统</a>是其最独特的特性之一, 可以按照 Javascript 的数据操作习惯来操作组件状态， 然后自动响应到页面中. 而 React 这边则提供了 setState, 对于复杂的组件状态, setState 会让代码变得的又臭又长. 例如:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  pagination: &#123;</span><br><span class="line">    ...this.state.pagination,</span><br><span class="line">    current: defaultPagination.current || <span class="number">1</span>,</span><br><span class="line">    pageSize: defaultPagination.pageSize || <span class="number">15</span>,</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后来有了<a href="https://cn.mobx.js.org" target="_blank" rel="noopener">mobx</a>, 基本接近了 Vue 开发体验:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@observer</span></span><br><span class="line"><span class="keyword">class</span> TodoView <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@observable</span> loading: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@observable</span> error?: <span class="built_in">Error</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@observable</span> list: Item[] = [];</span><br><span class="line">  <span class="comment">// 衍生状态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@computed</span> <span class="keyword">get</span> completed() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list.filter(<span class="function"><span class="params">i</span> =&gt;</span> i.completed)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.load();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> load() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.error = <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">await</span> fetchList()</span><br><span class="line">      <span class="keyword">this</span>.list = list</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.error = err</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 mobx 也有挺多缺点:</p><ul><li>代码侵入性. 所有需要响应数据变动的组件都需要使用 observer 装饰, 属性需要使用 observable 装饰, 以及数据操作方式. 对 mobx 耦合较深, 日后切换框架或重构的成本很高</li><li><p>兼容性. mobx v5 后使用 Proxy 进行重构, Proxy 在 Chrome49 之后才支持. 如果要兼容旧版浏览器则只能使用 v4, v4 有一些<a href="https://cn.mobx.js.org/#mobx-4-vs-mobx-5" target="_blank" rel="noopener">坑</a>, 这些坑对于不了解 mobx 的新手很难发现:</p><ul><li>Observable 数组并非真正的数组. 比如 antd 的 Table 组件就不认 mobx 的数组, 需要传入到组件之间使用 slice 进行转换</li><li>向一个已存在的 observable 对象中添加属性不会被自动捕获</li></ul></li></ul><p><br></p><p>于是 hooks 出现了, 它让组件的状态管理变得更简单直接, 而且它的思想也很接近 mobx 响应式编程哲学:</p><p><img src="/images/04/mobx.png" alt="mobx"></p><p><br></p><ol><li>简洁地声明状态</li></ol><p><strong>状态</strong> 是驱动应用的数据. 例如 UI 状态或者业务领域状态</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;Item[]&gt;([]);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>衍生</li></ol><p>任何 源自状态并且不会再有任何进一步的相互作用的东西就是衍生。包括用户视图, 衍生状态, 其他副作用</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props: &#123; id: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = props;</span><br><span class="line">  <span class="comment">// 取代mobx的observable: 获取列表, 在挂载或id变动时请求</span></span><br><span class="line">  <span class="keyword">const</span> [value, setValue, loading, error, retry] = usePromise(</span><br><span class="line">    <span class="keyword">async</span> id =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> getList(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    [id],</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 衍生状态: 取代mobx的computed</span></span><br><span class="line">  <span class="keyword">const</span> unreads = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> value.filter(<span class="function"><span class="params">i</span> =&gt;</span> !i.readed), [value]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 衍生副作用: value变动后自动持久化</span></span><br><span class="line">  useDebounce(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      saveList(id, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    [value],</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 衍生视图</span></span><br><span class="line">  <span class="keyword">return</span> &lt;List data=&#123;value&#125; onChange=&#123;setValue&#125; error=&#123;error&#125; loading=&#123;loading&#125; retry=&#123;retry&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/04/hook-stream.png" width="400"></p><p>所以说 hook 是一个革命性的东西, 它可以让组件的状态数据流更加清晰. 换做 class 组件, 我们通常的做法可能是在 <code>componentDidUpdate</code>生命周期方法中进行数据比较, 然后命令式地触发一些方法. 比如 id 变化时触发 getList, list 变化时进行 saveList.</p><p><strong>hook 似乎在淡化组件生命周期的概念, 让开发者更专注于状态的关系, 以数据流的方式来思考组件的开发</strong>. <a href="https://mobile.twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a>在<a href="https://overreacted.io/zh-hans/writing-resilient-components/" target="_blank" rel="noopener">编写有弹性的组件</a>也提到了一个原则”不要阻断数据流”, 证实了笔者的想法:</p><blockquote><p>无论何时使用 props 和 state，请考虑如果它们发生变化会发生什么。在大多数情况下，组件不应以不同方式处理初始渲染和更新流程。这使它能够适应逻辑上的变化。</p></blockquote><p>读者可以看一下<a href="https://github.com/rehooks/awesome-react-hooks" target="_blank" rel="noopener">awesome-react-hooks</a>, 这些开源的 hook 方案都挺有意思. 例如<a href="https://github.com/LeetCode-OpenSource/rxjs-hooks" target="_blank" rel="noopener">rxjs-hooks</a>, 巧妙地将 react hooks 和 rxjs 结合的起来:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props: &#123; foo: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 响应props的变动</span></span><br><span class="line">  <span class="keyword">const</span> value = useObservable(inputs$ =&gt; inputs$.pipe(map(<span class="function">(<span class="params">[val]</span>) =&gt;</span> val + <span class="number">1</span>)), <span class="number">200</span>, [props.foo]);</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123;value&#125;&lt;<span class="regexp">/h1&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="6-类继承也有用处"><a href="#6-类继承也有用处" class="headerlink" title="6. 类继承也有用处"></a>6. 类继承也有用处</h2><p>就如 react 官方文档说的: “我们的 React 使用了数以千计的组件，然而却还未发现任何需要推荐你使用继承的情况。”, React 偏向于函数式编程的组合模式, 面向对象的继承实际的应用场景很少.</p><p>当我们需要将一些传统的第三方库转换成 React 组件库时, 继承就可能派上用场. 因为这些库大部分是使用面向对象的范式来组织的, 比较典型的就是地图 SDK. 以<a href="http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference_3_0.html" target="_blank" rel="noopener">百度地图</a>为例:</p><p><img src="/images/04/overlay.png" alt="baidu overlay"></p><p>百度地图有各种组件类型: controls, overlays, tileLayers. 这些类型都有多个子类, 如上图, overlay 有 Label, Marker, Polyline 等这些子类, 且这些子类有相同的生命周期, 都是通过 addOverlay 方法来渲染到地图画布上. 我们可以通过继承的方式将他们生命周期管理抽取到父类上, 例如:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overlay抽象类, 负责管理Overlay的生命周期</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Overlay&lt;P&gt; <span class="keyword">extends</span> React.PureComponent&lt;OverlayProps &amp; P&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> initialize?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 子类在constructor或initialize方法中进行实例化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.initialize) &#123;</span><br><span class="line">      <span class="keyword">this</span>.initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.instance &amp;&amp; <span class="keyword">this</span>.context) &#123;</span><br><span class="line">      <span class="comment">// 渲染到Map画布中</span></span><br><span class="line">      <span class="keyword">this</span>.context.nativeInstance!.addOverlay(<span class="keyword">this</span>.instance);</span><br><span class="line">      <span class="comment">// 初始化参数</span></span><br><span class="line">      <span class="keyword">this</span>.initialProperties();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidUpdate(prevProps: P &amp; OverlayProps) &#123;</span><br><span class="line">    <span class="comment">// 属性更新</span></span><br><span class="line">    <span class="keyword">this</span>.updateProperties(prevProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">// 组件卸载</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.instance &amp;&amp; <span class="keyword">this</span>.context) &#123;</span><br><span class="line">      <span class="keyword">this</span>.context.nativeInstance!.removeOverlay(<span class="keyword">this</span>.instance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 其他通用方法</span></span><br><span class="line">  <span class="keyword">private</span> forceReloadIfNeed(props: P, prevProps: P) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的工作就变得简单很多, 声明自己的属性/事件和实例化具体类:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Label <span class="keyword">extends</span> Overlay&lt;LabelProps&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    enableMassClear: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">props: LabelProps</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">const</span> &#123; position, content &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="comment">// 声明支持的属性和回调</span></span><br><span class="line">    <span class="keyword">this</span>.extendedProperties = PROPERTIES;</span><br><span class="line">    <span class="keyword">this</span>.extendedEnableableProperties = ENABLEABLE_PROPERTIES;</span><br><span class="line">    <span class="keyword">this</span>.extendedEvents = EVENTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化具体类</span></span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="keyword">new</span> BMap.Label(content, &#123;</span><br><span class="line">      position,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码来源于 <a href="https://github.com/ivan-94/react-bdmap" target="_blank" rel="noopener">react-bdmap</a></p></blockquote><p>当然这个不是唯一的解决方法, 使用高阶组件和 hooks 同样能够实现. 只不过对于原本就采用面向对象范式组织的库, 使用继承方式会更加好理解</p><p><br></p><hr><p><br></p><h2 id="7-模态框管理"><a href="#7-模态框管理" class="headerlink" title="7. 模态框管理"></a>7. 模态框管理</h2><p><img src="/images/04/modal-demo.png" alt="modal demo"></p><p>模态框是应用开发中使用频率非常高组件，尤其在中后台管理系统中. 但是在 React 中用着并不是特别爽, 典型的代码如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Demo: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const [visible, setVisible] = useState(false);</span><br><span class="line">  const [editing, setEditing] = useState();</span><br><span class="line">  const handleCancel = () =&gt; &#123;</span><br><span class="line">    setVisible(false);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const prepareEdit = async (item: Item) =&gt; &#123;</span><br><span class="line">    // 加载详情</span><br><span class="line">    const detail = await loadingDeatil(item.id);</span><br><span class="line">    setEditing(detail);</span><br><span class="line">    setVisible(true);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const handleOk = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const values = await form.validate();</span><br><span class="line">      // 保存</span><br><span class="line">      await save(editing.id, values);</span><br><span class="line">      // 隐藏</span><br><span class="line">      setVisible(false);</span><br><span class="line">    &#125; catch &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;Table</span><br><span class="line">      dataSource=&#123;list&#125;</span><br><span class="line">      columns=&#123;[</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;操作&apos;,</span><br><span class="line">          render: item =&gt; &#123;</span><br><span class="line">            return &lt;a onClick=&#123;() =&gt; prepareEdit(item)&#125;&gt;编辑&lt;/a&gt;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ]&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;Modal visible=&#123;visible&#125; onOk=&#123;handleOk&#125; onCancel=&#123;handleHide&#125;&gt;</span><br><span class="line">      &#123;/* 表单渲染 */&#125;</span><br><span class="line">    &lt;/Modal&gt;</span><br><span class="line">  &lt;/&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码太丑了， 不相关逻辑堆积在一个组件下 ，不符合单一职责. 所以我们要将模态框相关代码抽取出去, 放到 EditModal 中:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EditModal: FC&lt;&#123; id?: string; visible: boolean; onCancel: () =&gt; void; onOk: () =&gt; void &#125;&gt; = props =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const &#123; visible, id, onHide, onOk &#125; = props;</span><br><span class="line">  const detail = usePromise(async (id: string) =&gt; &#123;</span><br><span class="line">    return loadDetail(id);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    if (id != null) &#123;</span><br><span class="line">      detail.call(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [id]);</span><br><span class="line"></span><br><span class="line">  const handleOk = () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const values = await form.validate();</span><br><span class="line">      // 保存</span><br><span class="line">      await save(editing.id, values);</span><br><span class="line">      onOk();</span><br><span class="line">    &#125; catch &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Modal visible=&#123;visible&#125; onOk=&#123;onOk&#125; onCancel=&#123;onCancel&#125;&gt;</span><br><span class="line">      &#123;detail.value &amp;&amp;</span><br><span class="line">        &#123;</span><br><span class="line">          /* 表单渲染 */</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &lt;/Modal&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用</span><br><span class="line"> */</span><br><span class="line">const Demo: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const [visible, setVisible] = useState(false);</span><br><span class="line">  const [editing, setEditing] = useState&lt;string | undefined&gt;(undefined);</span><br><span class="line">  const handleHide = () =&gt; &#123;</span><br><span class="line">    setVisible(false);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const prepareEdit = async (item: Item) =&gt; &#123;</span><br><span class="line">    setEditing(item.id);</span><br><span class="line">    setVisible(true);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;Table</span><br><span class="line">      dataSource=&#123;list&#125;</span><br><span class="line">      columns=&#123;[</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;操作&apos;,</span><br><span class="line">          render: item =&gt; &#123;</span><br><span class="line">            return &lt;a onClick=&#123;() =&gt; prepareEdit(item)&#125;&gt;编辑&lt;/a&gt;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ]&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;EditModal id=&#123;editing&#125; visible=&#123;visible&#125; onOk=&#123;handleHide&#125; onCancel=&#123;handleHide&#125;&gt;</span><br><span class="line">      &#123;&apos; &apos;&#125;</span><br><span class="line">    &lt;/EditModal&gt;</span><br><span class="line">  &lt;/&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在编辑相关的逻辑抽取到了 EditModal 上，但是 Demo 组件还要维护模态框的打开状态和一些数据状态。一个复杂的页面可能会有很多模态框，这样的代码会变得越来越恶心， 各种 xxxVisible 状态满天飞. 从实际开发角度上将，模态框控制的最简单的方式应该是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const handleEdit = item =&gt; &#123;</span><br><span class="line">  EditModal.show(&#123;</span><br><span class="line">    // 🔴 通过函数调用的方式出发弹窗. 这符合对模态框的习惯用法, 不关心模态框的可见状态. 例如window.confirm, wx.showModal().</span><br><span class="line">    id: item.id, // 🔴 传递数据给模态框</span><br><span class="line">    onOk: saved =&gt; &#123;</span><br><span class="line">      // 🔴 事件回调</span><br><span class="line">      refreshList(saved);</span><br><span class="line">    &#125;,</span><br><span class="line">    onCancel: async () =&gt; &#123;</span><br><span class="line">      return confirm(&apos;确认取消&apos;); // 控制模态框是否隐藏</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式在社区上也是有争议的，有些人认为这是 React 的反模式，<a href="https://www.zhihu.com/people/yu-san-geng" target="_blank" rel="noopener">@欲三更</a>在<a href="https://zhuanlan.zhihu.com/p/54492049" target="_blank" rel="noopener">Modal.confirm 违反了 React 的模式吗？</a>就探讨了这个问题。 以图为例：</p><p><img src="/images/04/modal-confirm.jpg" alt="modal confirm"></p><p>红线表示时间驱动(或者说时机驱动), 蓝线表示数据驱动。欲三更认为“哪怕一个带有明显数据驱动特色的 React 项目，也存在很多部分不是数据驱动而是事件驱动的. 数据只能驱动出状态，只有时机才能驱动出行为, 对于一个时机驱动的行为，你非得把它硬坳成一个数据驱动的状态，你不觉得很奇怪吗?”. 他的观点正不正确笔者不做评判, 但是某些场景严格要求‘数据驱动’，可能会有很多模板代码，写着会很难受.</p><p>So 怎么实现?</p><p>可以参考 antd <a href="https://github.com/ant-design/ant-design/blob/master/components/modal/confirm.tsx" target="_blank" rel="noopener">Modal.confirm</a>的实现, 它使用<code>ReactDOM.render</code>来进行外挂渲染，也有人使用<a href="https://medium.com/@BogdanSoare/how-to-use-reacts-new-context-api-to-easily-manage-modals-2ae45c7def81" target="_blank" rel="noopener">Context API</a>来实现的. 笔者认为比较接近理想的(至少 API 上看)是<a href="https://github.com/haradakunihiko/react-confirm" target="_blank" rel="noopener">react-comfirm</a>这样的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EditModal.tsx</span><br><span class="line"> */</span><br><span class="line">import &#123; confirmable &#125; from &apos;react-confirm&apos;;</span><br><span class="line">const EditModal = props =&gt; &#123;</span><br><span class="line">  /*...*/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default confirmable(EditModal);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Demo.tsx</span><br><span class="line"> */</span><br><span class="line">import EditModal from &apos;./EditModal&apos;;</span><br><span class="line"></span><br><span class="line">const showEditModal = createConfirmation(EditModal);</span><br><span class="line"></span><br><span class="line">const Demo: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span><br><span class="line">  const prepareEdit = async (item: Item) =&gt; &#123;</span><br><span class="line">    showEditModal(&#123;</span><br><span class="line">      id: item.id, // 🔴 传递数据给模态框</span><br><span class="line">      onOk: saved =&gt; &#123;</span><br><span class="line">        // 🔴 事件回调</span><br><span class="line">        refreshList(saved);</span><br><span class="line">      &#125;,</span><br><span class="line">      onCancel: async someValues =&gt; &#123;</span><br><span class="line">        return confirm(&apos;确认取消&apos;); // 控制模态框是否隐藏</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>ReactDOM.render</code>外挂渲染形式的缺点就是无法访问 Context，所以还是要妥协一下，结合 Context API 来实现示例：</p><iframe src="https://codesandbox.io/embed/lryom9617l?autoresize=1&fontsize=14" title="useModal" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>扩展</p><ul><li><a href="https://github.com/ant-design/ant-design/blob/master/components/modal/confirm.tsx" target="_blank" rel="noopener">Modal.confirm</a></li><li><a href="https://zhuanlan.zhihu.com/p/54492049" target="_blank" rel="noopener">Modal.confirm 违反了 React 的模式吗？</a></li><li><a href="https://www.zhihu.com/search?type=content&amp;q=react%20modal" target="_blank" rel="noopener">使用 render props 抽象 Modal 组件的状态</a></li><li><a href="https://github.com/haradakunihiko/react-confirm" target="_blank" rel="noopener">react-confirm</a></li><li><a href="https://medium.com/@BogdanSoare/how-to-use-reacts-new-context-api-to-easily-manage-modals-2ae45c7def81" target="_blank" rel="noopener">How to use React’s new Context API to easily manage modals</a> 基于 Context 的方案</li></ul><p><br></p><hr><p><br></p><h2 id="8-使用-context-进行依赖注入"><a href="#8-使用-context-进行依赖注入" class="headerlink" title="8. 使用 Context 进行依赖注入"></a>8. 使用 Context 进行依赖注入</h2><p>Context 为组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性.</p><p>Context 在 React 应用中使用非常频繁, 新的<a href="https://react.docschina.org/docs/context.html#when-to-use-context" target="_blank" rel="noopener">Context API</a>也非常易用. Context 常用于以下场景:</p><ul><li><strong>共享那些被认为对于一个’组件树’而言是“全局”的数据</strong>. 如当前认证的用户, 主题, i18n 配置, 表单状态</li><li><strong>组件配置</strong>. 配置组件的行为, 如 antd 的 ConfigProvider</li><li><strong>跨组件通信</strong>. 不推荐通过’事件’进行通信, 而是通过’状态’进行通信</li><li><strong>依赖注入</strong></li><li><strong>状态管理器</strong>. Context 经过一些封装可以基本取代 Redux 和 Mobx 这些状态管理方案. 后续有专门文章介绍</li></ul><p>Context 的作用域是子树, 也就是说一个 Context Provider 可以应用于多个子树, 子树的 Provider 也可以覆盖父级的 Provider 的 value. 基本结构:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useContext&#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export inteface MyContextValue &#123;</span><br><span class="line">  state: number</span><br><span class="line">  setState: (state: number) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const MyContext = React.createContext&lt;MyContextValue&gt;(</span><br><span class="line">  &#123;</span><br><span class="line">    state: 1,</span><br><span class="line">    // 设置默认值, 抛出错误, 必须配合Provider使用</span><br><span class="line">    setState: () =&gt; throw new Error(&apos;请求MyContextProvider组件下级调用&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export const MyContextProvider: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span><br><span class="line">  const [state, setState] = useState(1)</span><br><span class="line">  return &lt;MyContext.Provider value=&#123;&#123;state, setState&#125;&#125;&gt;&#123;props.children&#125;&lt;/MyContext.Provider&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useMyContext() &#123;</span><br><span class="line">  return useContext(MyContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default MyContextProvider</span><br></pre></td></tr></table></figure><blockquote><p>Context 默认值中的方法应该抛出错误, 警告不规范的使用</p></blockquote><p>扩展：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/50336226" target="_blank" rel="noopener">避免 React Context 导致的重复渲染</a></li></ul><p><br></p><hr><p><br></p><h2 id="9-不可变的状态"><a href="#9-不可变的状态" class="headerlink" title="9. 不可变的状态"></a>9. 不可变的状态</h2><p>对于函数式编程范式的 React 来说，不可变状态有重要的意义.</p><ul><li><p>不可变数据具有可预测性。 可不变数据可以让应用更好调试，对象的变更更容易被跟踪和推导.<br>就比如 Redux, 它要求只能通过 dispatch+reducer 进行状态变更，配合它的 Devtool 可以很好的跟踪状态是如何被变更的. 这个特性对于大型应用来说意义重大，因为它的状态非常复杂，如果不加以组织和约束，你不知道是哪个地方修改了状态， 出现 bug 时很难跟踪.</p><p>所以说对于严格要求单向数据流的状态管理器(Redux)来说，不可变数据是基本要求，它要求整个应用由一个单一的状态进行映射，不可变数据可以让整个应用变得可被预测.</p></li><li><p>不可变数据还使一些复杂的功能更容易实现。避免数据改变，使我们能够安全保留对旧数据的引用，可以方便地实现撤销重做，或者时间旅行这些功能</p></li><li>可以精确地进行重新渲染判断。可以简化 shouldComponentUpdate 比较。</li></ul><p>实现不可变数据的流行方法:</p><ul><li><a href="https://github.com/immerjs/immer" target="_blank" rel="noopener">immer</a></li><li><a href="https://github.com/immutable-js/immutable-js" target="_blank" rel="noopener">Immutable.js</a></li></ul><p>笔者比较喜欢 immer，没有什么心智负担, 按照 JS 习惯的对象操作方式就可以实现不可变数据。</p><p><br></p><hr><p><br></p><h2 id="10-react-router-url-即状态"><a href="#10-react-router-url-即状态" class="headerlink" title="10. React-router: URL 即状态"></a>10. React-router: URL 即状态</h2><center><br> <img src="/images/04/static-router.png" width="300"><br></center><p>传统的路由主要用于区分页面, 所以一开始前端路由设计也像后端路由(也称为<strong>静态路由</strong>)一样, 使用对象配置方式, 给不同的 url 分配不同的页面组件, 当应用启动时, 在路由配置表中查找匹配 URL 的组件并渲染出来.</p><p>React-Router v4 算是一个真正意义上符合<em>组件化</em>思维的路由库, React-Router 官方称之为‘动态路由’, 官方的解释是”指的是在应用程序渲染时发生的路由，而不是在运行应用程序之外的配置或约定中发生的路由”, 具体说, <code>&lt;Route/&gt;</code>变成了一个普通 React 组件, 它在渲染时判断是否匹配 URL, 如果匹配就渲染指定的组件, 不匹配就返回 null.</p><p>这时候 URL 意义已经不一样了, <strong>URL 不再是简单的页面标志, 而是应用的状态</strong>; <strong>应用构成也不再局限于扁平页面, 而是多个可以响应 URL 状态的区域(可嵌套)</strong>. 因为思维转变很大, 所以它刚出来时并不受青睐. 这种方式更加灵活， 所以选择 v4 不代表放弃旧的路由方式, 你完全可以按照<a href="https://react-router.docschina.org/core/guides/static-routes" target="_blank" rel="noopener">旧的方式</a>来实现页面路由.</p><p>举个应用实例: 一个应用由三个区域组成: 侧边栏放置多个入口, 点击这些入口会加载对应类型的列表, 点击列表项需要加载详情. 三个区域存在级联关系</p><p><img src="/images/04/router-demo.png" alt="router demo"></p><p>首先设计能够表达这种级联关系的 URL, 比如<code>/{group}/{id}</code>, URL 设计一般遵循<a href="https://ruby-china.github.io/rails-guides/v5.0/routing.html#嵌套资源" target="_blank" rel="noopener">REST 风格</a>, 那么应用的大概结构是这样子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// App</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  &lt;div className=&quot;app&quot;&gt;</span><br><span class="line">    &lt;SideBar /&gt;</span><br><span class="line">    &lt;Route path=&quot;/:group&quot; component=&#123;ListPage&#125; /&gt;</span><br><span class="line">    &lt;Route path=&quot;/:group/:id&quot; component=&#123;Detail&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// SideBar</span><br><span class="line">const Sidebar = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;sidebar&quot;&gt;</span><br><span class="line">      &#123;/* 使用NavLink 在匹配时显示激活状态 */&#125;</span><br><span class="line">      &lt;NavLink to=&quot;/message&quot;&gt;消息&lt;/NavLink&gt;</span><br><span class="line">      &lt;NavLink to=&quot;/task&quot;&gt;任务&lt;/NavLink&gt;</span><br><span class="line">      &lt;NavLink to=&quot;/location&quot;&gt;定位&lt;/NavLink&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ListPage</span><br><span class="line">const ListPage = props =&gt; &#123;</span><br><span class="line">  const &#123; group &#125; = props.match.params;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 响应group变化, 并加载指定类型列表</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    load(group);</span><br><span class="line">  &#125;, [group]);</span><br><span class="line"></span><br><span class="line">  // 列表项也会使用NavLink, 用于匹配当前展示的详情, 激活显示</span><br><span class="line">  return &lt;div className=&quot;list&quot;&gt;&#123;renderList()&#125;&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// DetailPage</span><br><span class="line">const DetailPage = props =&gt; &#123;</span><br><span class="line">  const &#123; group, id &#125; = props.match.params;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 响应group和id, 并加载详情</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    loadDetail(group, id);</span><br><span class="line">  &#125;, [group, id]);</span><br><span class="line"></span><br><span class="line">  return &lt;div className=&quot;detail&quot;&gt;&#123;renderDetail()&#125;&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>扩展</p><ul><li><a href="https://react-router.docschina.org/core/guides/philosophy" target="_blank" rel="noopener">React Router 哲学</a></li><li><a href="https://juejin.im/post/5986d1456fb9a03c3f405bd2" target="_blank" rel="noopener">聊聊 React Router v4 的设计思想</a></li></ul><p><br></p><hr><p><br></p><h2 id="11-组件规范"><a href="#11-组件规范" class="headerlink" title="11. 组件规范"></a>11. 组件规范</h2><ul><li>开启严格模式: 开启 StrictMode，尽早发现潜在问题和不规范用法</li><li>第三方开发规范:<ul><li><a href="https://github.com/airbnb/javascript/tree/master/react#ordering" target="_blank" rel="noopener">Airbnb React/JSX Style Guide</a></li><li><a href="https://vasanthk.gitbooks.io/react-bits/patterns/30.component-switch.html" target="_blank" rel="noopener">React bits</a></li><li><a href="https://github.com/krasimir/react-in-patterns" target="_blank" rel="noopener">react-in-patterns</a></li></ul></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://github.com/acdlite/recompose/blob/master/docs/API.md" target="_blank" rel="noopener">recompose</a></li><li><a href="https://overreacted.io/zh-hans/writing-resilient-components/" target="_blank" rel="noopener">编写有弹性的组件</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 React 的世界里”&lt;strong&gt;一切都是组件&lt;/strong&gt;“， 组件可以映射作函数式编程中的函数，React 的组件和函数一样的灵活的特性不仅仅可以用于绘制 UI，还可以用于封装业务状态和逻辑，或者非展示相关的副作用, 再通过组合方式组成复杂的应用. 本文尝试
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结03 - 样式的管理</title>
    <link href="https://bobi.ink/2019/05/14/react-component-design-03/"/>
    <id>https://bobi.ink/2019/05/14/react-component-design-03/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-06-15T01:01:44.192Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 是前端开发的重要组成部分，但是它并不完美，本文主要探讨 React 样式管理方面的一些解决方案，目的是实现样式的高度可定制化, 让大型项目的样式代码更容易维护.</p><p><strong>系列目录</strong></p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li>05 状态管理 待更新</li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-认识-css-的局限性">1. 认识 CSS 的局限性</a><ul><li><a href="#1️⃣-全局性">1️⃣ 全局性</a></li><li><a href="#2️⃣-依赖">2️⃣ 依赖</a></li><li><a href="#3️⃣-无用代码的移除">3️⃣ 无用代码的移除</a></li><li><a href="#4️⃣-压缩">4️⃣ 压缩</a></li><li><a href="#5️⃣-常量共享">5️⃣ 常量共享</a></li><li><a href="#6️⃣-css-解析方式的不确定性">6️⃣ CSS 解析方式的不确定性</a></li></ul></li><li><a href="#2-组件的样式管理">2. 组件的样式管理</a><ul><li><a href="#1️⃣-组件的样式应该高度可定制化">1️⃣ 组件的样式应该高度可定制化</a></li><li><a href="#2️⃣-避免使用内联-css">2️⃣ 避免使用内联 CSS</a></li><li><a href="#3️⃣-使用-css-in-js">3️⃣ 使用 CSS-in-js</a><ul><li><a href="#0-基本用法">0. 基本用法</a></li><li><a href="#1-样式扩展">1. 样式扩展</a></li><li><a href="#2-mixin-机制">2. mixin 机制</a></li><li><a href="#3-类-scss-的语法">3. 类 SCSS 的语法</a></li><li><a href="#5-js-带来的动态性">5. JS 带来的动态性</a></li><li><a href="#6-绑定组件的全局样式">6. 绑定组件的<code>全局样式</code></a></li><li><a href="#7-theme-机制及-theme-对象的设计">7. Theme 机制及 Theme 对象的设计</a></li><li><a href="#8-提升开发体验">8. 提升开发体验</a></li><li><a href="#9-了解-styled-components-的局限性">9. 了解 styled-components 的局限性</a></li><li><a href="#10-一些开发规范">10. 一些开发规范</a></li><li><a href="#11-其他-css-in-js-方案">11. 其他 CSS-in-js 方案</a></li></ul></li><li><a href="#4️⃣-通用的组件库不应该耦合-css-in-jscss-module-的方案">4️⃣ 通用的组件库不应该耦合 CSS-in-js/CSS-module 的方案</a></li><li><a href="#5️⃣-优先使用原生-css">5️⃣ 优先使用原生 CSS</a></li><li><a href="#6️⃣-选择合适自己团队的技术栈">6️⃣ 选择合适自己团队的技术栈</a></li><li><a href="#7️⃣-使用-svgr-转换-svg-图标">7️⃣ 使用 svgr 转换 svg 图标</a></li><li><a href="#8️⃣-结合使用-rem-和-em-等相对单位-创建更有弹性的组件">8️⃣ 结合使用 rem 和 em 等相对单位, 创建更有弹性的组件</a></li></ul></li><li><a href="#3-规范">3. 规范</a><ul><li><a href="#1️⃣-促进建立统一的-ui-设计规范">1️⃣ 促进建立统一的 UI 设计规范</a></li><li><a href="#2️⃣-css-编写规范">2️⃣ CSS 编写规范</a></li><li><a href="#3️⃣-使用stylelint进行样式规范检查">3️⃣ 使用stylelint进行样式规范检查</a></li></ul></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="1-认识-css-的局限性"><a href="#1-认识-css-的局限性" class="headerlink" title="1. 认识 CSS 的局限性"></a>1. 认识 CSS 的局限性</h2><center><br> <img src="/images/04/vjeux-speak.png" alt="vjeux-speak" width="500"><br></center><p>2014 年<a href="https://github.com/vjeux" target="_blank" rel="noopener">vjeux</a>一个 <a href="https://speakerd.s3.amazonaws.com/presentations/2e15908049bb013230960224c1b4b8bd/css-in-javascript.pdf" target="_blank" rel="noopener">speak</a> 深刻揭示的原生 CSS 的一些局限性. 虽然它有些争议, 对于开发者来说更多的是启发. 至从那之后出现了很多 <code>CSS-in-js</code> 解决方案.</p><h3 id="1️⃣-全局性"><a href="#1️⃣-全局性" class="headerlink" title="1️⃣ 全局性"></a>1️⃣ 全局性</h3><p>CSS 的选择器是没有隔离性的, 不管是使用命名空间还是 BEM 模式组织, 最终都会污染全局命名空间. 尤其是大型团队合作的项目, 很难确定某个特定的类或者元素是否已经赋过样式. 所以在大部分情况下我们都会绞尽脑汁新创建一个类名, 而不是复用已有的类型.</p><p>解决的方向: 生成唯一的类名; shadow dom; 内联样式; Vue-scoped 方案</p><p><br></p><h3 id="2️⃣-依赖"><a href="#2️⃣-依赖" class="headerlink" title="2️⃣ 依赖"></a>2️⃣ 依赖</h3><p>由于 CSS 的’全局性’, 所以就产生了依赖问题:</p><p>一方面我们需要在组件渲染前就需要先将 CSS 加载完毕, 但是<strong>很难清晰地定义某个特定组件依赖于某段特定的 CSS 代码</strong>; 另一方面, <strong>全局性导致你的样式可能被别的组件依赖(某种程度的细节耦合)</strong>, 你不能随便修改你的样式, 以免破坏其他页面或组件的样式. 如果团队没有制定合适的 CSS 规范(例如 BEM, 不直接使用标签选择器, 减少选择器嵌套等等), 代码很快就会失控</p><p>解决的方向: 之前文章提到组件是一个内聚单元, 样式应该是和组件绑定的. 最基本的解决办法是使用类似 BEM 命名规范来避免组件之间的命名冲突, 再通过创建优于复用, 组合优于继承的原则, 来避免组件间样式耦合;</p><p><br></p><h3 id="3️⃣-无用代码的移除"><a href="#3️⃣-无用代码的移除" class="headerlink" title="3️⃣ 无用代码的移除"></a>3️⃣ 无用代码的移除</h3><p>由于上述’依赖’问题, 组件样式之间并没有明确的边界, 很难判断哪些样式属于那个组件; 在加上 CSS 的’叠层特性’, 更无法确定删除样式会带来什么影响.</p><blockquote><p>现代浏览器已支持 CSS 无用代码检查. 但对于无组织的 CSS 效果不会太大</p></blockquote><p>解决的方向: 如果样式的依赖比较明确，则可以安全地移除无用代码</p><p><br></p><h3 id="4️⃣-压缩"><a href="#4️⃣-压缩" class="headerlink" title="4️⃣ 压缩"></a>4️⃣ 压缩</h3><p>选择器和类名的压缩可以减少文件的体积, 提高加载的性能. 因为原生 CSS 一般有开发者由配置类名(在 html 或 js 动态指定), 所以工具很难对类名进行控制.</p><blockquote><p>压缩类名也会降低代码的可读性, 变得难以调试.</p></blockquote><p>解决的方向: 由工具来转换或创建类名</p><p><br></p><h3 id="5️⃣-常量共享"><a href="#5️⃣-常量共享" class="headerlink" title="5️⃣ 常量共享"></a>5️⃣ 常量共享</h3><p>常规的 CSS 很难做到在样式和 JS 之间共享变量, 例如自定义主题色, 通常通过内联样式来部分实现这种需求</p><p>解决的方向: CSS-in-js</p><p><br></p><h3 id="6️⃣-css-解析方式的不确定性"><a href="#6️⃣-css-解析方式的不确定性" class="headerlink" title="6️⃣ CSS 解析方式的不确定性"></a>6️⃣ CSS 解析方式的不确定性</h3><p>CSS 规则的加载顺序是很重要的, 他会影响属性应用的优先级, 如果按需加载 CSS, 则无法确保他们的解析顺序, 进而导致错误的样式应用到元素上. 有些开发者为了解决这个问题, 使用!important 声明属性, 这无疑是进入了另一个坑.</p><p>解决方向：避免使用全局样式，组件样式隔离；样式加载和组件生命周期绑定</p><p><br></p><hr><p><br></p><h2 id="2-组件的样式管理"><a href="#2-组件的样式管理" class="headerlink" title="2. 组件的样式管理"></a>2. 组件的样式管理</h2><h3 id="1️⃣-组件的样式应该高度可定制化"><a href="#1️⃣-组件的样式应该高度可定制化" class="headerlink" title="1️⃣ 组件的样式应该高度可定制化"></a>1️⃣ 组件的样式应该高度可定制化</h3><p>组件的样式应该是可以自由定制的, 开发者应该考虑组件的各种使用场景. 所以一个好的组件必须暴露相关的样式定制接口. 至少需要支持为顶层元素配置<code>className</code>和<code>style</code>属性:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ButtonProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性应该是每个展示型组件应该暴露的 props, 其他嵌套元素也要考虑支持配置样式, 例如 footerClassName, footerStyle.</p><p><br></p><hr><p><br></p><h3 id="2️⃣-避免使用内联-css"><a href="#2️⃣-避免使用内联-css" class="headerlink" title="2️⃣ 避免使用内联 CSS"></a>2️⃣ 避免使用内联 CSS</h3><ol><li>style props 添加的属性不能自动增加厂商前缀, 这可能会导致兼容性问题. 如果添加厂商前缀又会让代码变得啰嗦.</li><li>内联 CSS 不支持复杂的样式配置, 例如伪元素, 伪类, 动画定义, 媒体查询和媒体回退(对象不允许同名属性, 例如<code>display: -webkit-flex; display: flex;</code>)</li><li>内联样式通过 object 传入组件, 内联的 object 每次渲染会重新生成, 会导致组件重新渲染. 当然通过某些工具可以将静态的 object 提取出去</li><li>不方便调试和阅读<br>…</li></ol><p>所以 内联 CSS 适合用于设置动态且比较简单的样式属性</p><blockquote><p>社区上有许多 CSS-in-js 方案是基于内联 CSS 的, 例如 Radium, 它使用 JS 添加事件处理器来模拟伪类, 另外也媒体查询和动画. 不过不是所有东西都可以通过 JS 模拟, 比如伪元素. 所以这类解决方案用得比较少</p></blockquote><p><br></p><hr><p><br></p><h3 id="3️⃣-使用-css-in-js"><a href="#3️⃣-使用-css-in-js" class="headerlink" title="3️⃣ 使用 CSS-in-js"></a>3️⃣ 使用 CSS-in-js</h3><p>社区有很多 CSS 解决方案, 有个<a href="https://github.com/MicheleBertoli/css-in-js" target="_blank" rel="noopener">项目(MicheleBertoli/css-in-js)</a>专门罗列和对比了这些方案. 读者也可以读这篇文章(<a href="https://www.javascriptstuff.com/how-to-style-react/" target="_blank" rel="noopener">What to use for React styling?</a>)学习对 CSS 相关技术进行选型决策</p><p>社区上最流行的, 也是笔者觉得使用起来最舒服的是<a href="https://www.styled-components.com" target="_blank" rel="noopener"><code>styled-components</code></a>, styled-components 有下列特性:</p><ul><li>自动生成类名, 解决 CSS 的全局性和样式冲突. 通过组件名来标志样式, 自动生成唯一的类名, 开发者不需要为元素定义类名.</li><li>绑定组件. 隔离了 CSS 的依赖问题, 让组件 JSX 更加简洁, 反过来开发者需要考虑更多组件的语义</li><li>天生支持’关键 CSS’. 样式和组件绑定, 可以和组件一起进行代码分割和异步加载</li><li>自动添加厂商前缀</li><li>灵活的动态样式. 通过 props 和全局 theme 来动态控制样式</li><li>提供了一些 CSS 预处理器的语法</li><li>主题机制</li><li>支持 react-native. 这个用起来比较爽</li><li>支持 <a href="https://github.com/stylelint/stylelint" target="_blank" rel="noopener">stylelint</a>, 编辑器高亮和智能提示</li><li>支持服务端渲染</li><li>符合分离展示组件和行为组件原则</li></ul><blockquote><p>推荐这篇文章: <a href="https://medium.com/@gajus/stop-using-css-in-javascript-for-web-development-fa32fb873dcc" target="_blank" rel="noopener">Stop using css-in-javascript for web development</a>, styled-components 可以基本覆盖所有 CSS 的使用场景:</p></blockquote><p><br></p><h4 id="0-基本用法"><a href="#0-基本用法" class="headerlink" title="0. 基本用法"></a>0. 基本用法</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义组件props</span></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1&lt;&#123; active?: <span class="built_in">boolean</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; (props.active ? 'red' : 'gray')&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定或计算组件props</span></span><br><span class="line"><span class="keyword">const</span> Input = styled.input.attrs(&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'text'</span>,</span><br><span class="line">  size: <span class="function"><span class="params">props</span> =&gt;</span> (props.small ? <span class="number">5</span> : <span class="literal">undefined</span>),</span><br><span class="line">&#125;)<span class="string">``</span>;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-样式扩展"><a href="#1-样式扩展" class="headerlink" title="1. 样式扩展"></a>1. 样式扩展</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  color: palevioletred;</span></span><br><span class="line"><span class="string">  font-size: 1em;</span></span><br><span class="line"><span class="string">  margin: 1em;</span></span><br><span class="line"><span class="string">  padding: 0.25em 1em;</span></span><br><span class="line"><span class="string">  border: 2px solid palevioletred;</span></span><br><span class="line"><span class="string">  border-radius: 3px;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖和扩展已有的组件, 包含styled生成的组件还是自定义组件(通过className传入)</span></span><br><span class="line"><span class="keyword">const</span> TomatoButton = styled(Button)<span class="string">`</span></span><br><span class="line"><span class="string">  color: tomato;</span></span><br><span class="line"><span class="string">  border-color: tomato;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-mixin-机制"><a href="#2-mixin-机制" class="headerlink" title="2. mixin 机制"></a>2. mixin 机制</h4><p>在 SCSS 中, mixin 是重要的 CSS 复用机制, styled-components 也可以实现:</p><p>定义:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; css &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utils/styled-mixins.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> css<span class="string">`</span></span><br><span class="line"><span class="string">    width: <span class="subst">$&#123;width&#125;</span>;</span></span><br><span class="line"><span class="string">    white-space: nowrap;</span></span><br><span class="line"><span class="string">    overflow: hidden;</span></span><br><span class="line"><span class="string">    text-overflow: ellipsis;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; truncate &#125; <span class="keyword">from</span> <span class="string">'~/utils/styled-mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Box = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  // 混入</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;truncate('250px')&#125;</span></span></span><br><span class="line"><span class="string">  background: papayawhip;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-类-scss-的语法"><a href="#3-类-scss-的语法" class="headerlink" title="3. 类 SCSS 的语法"></a>3. 类 SCSS 的语法</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = styled(Component)<span class="string">`</span></span><br><span class="line"><span class="string">  // 自动厂商前缀</span></span><br><span class="line"><span class="string">  padding: 2em 1em;</span></span><br><span class="line"><span class="string">  background: papayawhip;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 伪类</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background: palevioletred;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 提供样式优先级技巧</span></span><br><span class="line"><span class="string">  &amp;&amp;&amp; &#123;</span></span><br><span class="line"><span class="string">    color: palevioletred;</span></span><br><span class="line"><span class="string">    font-weight: bold;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 覆盖内联css样式</span></span><br><span class="line"><span class="string">  &amp;[style] &#123;</span></span><br><span class="line"><span class="string">    font-size: 12px !important;</span></span><br><span class="line"><span class="string">    color: blue !important;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 支持媒体查询</span></span><br><span class="line"><span class="string">  @media (max-width: 600px) &#123;</span></span><br><span class="line"><span class="string">    background: tomato;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 嵌套规则</span></span><br><span class="line"><span class="string">    &amp;:hover &#123;</span></span><br><span class="line"><span class="string">      background: yellow;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &gt; p &#123;</span></span><br><span class="line"><span class="string">    /* descendant-selectors work as well, but are more of an escape hatch */</span></span><br><span class="line"><span class="string">    text-decoration: underline;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /* Contextual selectors work as well */</span></span><br><span class="line"><span class="string">  html.test &amp; &#123;</span></span><br><span class="line"><span class="string">    display: none;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><strong>引用其他组件</strong><br></p><p>由于 styled-components 的类名是自动生成的, 所以不能直接在选择器中声明他们, 但可以在模板字符串中引用其他组件:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Icon = styled.svg<span class="string">`</span></span><br><span class="line"><span class="string">  flex: none;</span></span><br><span class="line"><span class="string">  transition: fill 0.25s;</span></span><br><span class="line"><span class="string">  width: 48px;</span></span><br><span class="line"><span class="string">  height: 48px;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 引用其他组件的类名. 这个组件必须是styled-components生成或者包装的组件</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;Link&#125;</span>:hover &amp; &#123;</span></span><br><span class="line"><span class="string">    fill: rebeccapurple;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-js-带来的动态性"><a href="#5-js-带来的动态性" class="headerlink" title="5. JS 带来的动态性"></a>5. JS 带来的动态性</h4><p>媒体查询帮助方法:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils/styled.ts</span></span><br><span class="line"><span class="keyword">const</span> sizes = &#123;</span><br><span class="line">  giant: <span class="number">1170</span>,</span><br><span class="line">  desktop: <span class="number">992</span>,</span><br><span class="line">  tablet: <span class="number">768</span>,</span><br><span class="line">  phone: <span class="number">376</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> media = <span class="built_in">Object</span>.keys(sizes).reduce(<span class="function">(<span class="params">accumulator, label</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> emSize = sizes[label] / <span class="number">16</span>;</span><br><span class="line">  accumulator[label] = <span class="function">(<span class="params">...args</span>) =&gt;</span> css<span class="string">`</span></span><br><span class="line"><span class="string">    @media (max-width: <span class="subst">$&#123;emSize&#125;</span>em) &#123;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;css(...args)&#125;</span></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Container = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  color: #333;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;media.desktop`padding: 0 20px;`&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;media.tablet`padding: 0 10px;`&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;media.phone`padding: 0 5px;`&#125;</span></span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><blockquote><p>SCSS 也提供了很多内置工具方法, 比如颜色的处理, 尺寸的计算. styled-components 提供了一个类似的 js 库: <a href="https://github.com/styled-components/polished" target="_blank" rel="noopener">polished</a>来满足这部分需求, 另外还集成了常用的 mixin, 如 clearfix. 通过 babel 插件可以在编译时转换为静态代码, 不需要运行时.</p></blockquote><p><br></p><h4 id="6-绑定组件的全局样式"><a href="#6-绑定组件的全局样式" class="headerlink" title="6. 绑定组件的全局样式"></a>6. 绑定组件的<code>全局样式</code></h4><p>全局样式和组件生命周期绑定, 当组件卸载时也会删除全局样式. 全局样式通常用于覆盖一些第三方组件样式</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> GlobalStyle = createGlobalStyle<span class="string">`</span></span><br><span class="line"><span class="string">  body &#123;</span></span><br><span class="line"><span class="string">    color: <span class="subst">$&#123;props =&gt; (props.whiteColor ? 'white' : 'black')&#125;</span>;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line">&lt;React.Fragment&gt;</span><br><span class="line">  &lt;GlobalStyle whiteColor /&gt;</span><br><span class="line">  &lt;Navigation /&gt; &#123;<span class="comment">/* example of other top-level stuff */</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/React.Fragment&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="7-theme-机制及-theme-对象的设计"><a href="#7-theme-机制及-theme-对象的设计" class="headerlink" title="7. Theme 机制及 Theme 对象的设计"></a>7. Theme 机制及 Theme 对象的设计</h4><p>styled-components 的 <a href="https://www.styled-components.com/docs/advanced#theming" target="_blank" rel="noopener">ThemeProvider</a> 可以用于取代 SCSS 的变量机制, 只不过它更加灵活, 可以被所有下级组件共享, 并动态变化.</p><p>关于 Theme 对象的设计我觉得可以参考传统的 UI 框架, 例如<a href="https://github.com/zurb/foundation-sites/tree/develop/scss" target="_blank" rel="noopener">Foundation</a>或者<a href="https://github.com/twbs/bootstrap/tree/master/scss" target="_blank" rel="noopener">Bootstrap</a>, 经过多年的迭代它们代码组织非常好, 非常值得学习. 以 Bootstrap 的项目结构为例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _alert.scss</span><br><span class="line">├── ...                # 定义各种组件的样式</span><br><span class="line">├── _print.scss        # 打印样式适配</span><br><span class="line">├── _root.scss         # 🔴根样式, 即全局样式</span><br><span class="line">├── _transitions.scss  # 过渡效果</span><br><span class="line">├── _type.scss         # 🔴基本排版样式</span><br><span class="line">├── _reboot.scss       # 🔴浏览器重置样式, 类似于normalize.css</span><br><span class="line">├── _functions.scss</span><br><span class="line">├── _mixins.scss</span><br><span class="line">├── _utilities.scss</span><br><span class="line">├── _variables.scss    # 🔴变量配置, 包含全局配置和所有组件配置</span><br><span class="line">├── bootstrap-grid.scss</span><br><span class="line">├── bootstrap-reboot.scss</span><br><span class="line">├── bootstrap.scss</span><br><span class="line">├── mixins             # 各种mixin, 可复用的css代码</span><br><span class="line">├── utilities          # 各种工具方法</span><br><span class="line">└── vendor</span><br><span class="line">    └── _rfs.scss</span><br></pre></td></tr></table></figure><p><a href="https://github.com/twbs/bootstrap/blob/master/scss/_variables.scss" target="_blank" rel="noopener"><code>_variables.scss</code></a>包含了以下配置:</p><ul><li>颜色系统: 调色盘配置<ul><li>灰阶颜色: 提供白色到黑色之间多个级别的灰阶颜色. 例如<br><img src="/images/04/gray-scale.png" width="300"></li><li>语义颜色: 根据 UI 上面的语义, 定义各种颜色. 这个也是 CSS 开发的常见模式<br><img src="/images/04/sem-color.png" width="300"></li></ul></li><li>尺寸系统: 多个级别的间距, 尺寸大小配置</li><li>配置开关: 全局性的配置开关, 例如是否支持圆角, 阴影</li><li>链接样式配置: 如颜色, 激活状态, decoration</li><li>排版: 字体, 字体大小, font-weight, 行高, 边框, 标题等基本排版配置</li><li>网格系统断点配置</li></ul><p>bootstrap 将这些配置项有很高的参考意义. 组件可以认为是 UI 设计师 的产出, 如果你的应用有统一和规范的设计语言(参考<a href="https://ant.design/docs/spec/values-cn" target="_blank" rel="noopener">antd</a>), 这些配置会很有意义。样式可配置化可以让你的代码更灵活, 更稳定, 可复用性和可维护性更高. 不管对于 UI 设计还是客户端开发, 设计规范可以提高团队工作效率, 减少沟通成本.</p><p>styled-components 的 Theme 使用的是<code>React Context</code> API, 官方文档有详尽的描述, 这里就不展开了. 点击这里<a href="https://www.styled-components.com/docs/advanced#theming" target="_blank" rel="noopener">了解更多</a>, 另外在<a href="https://www.styled-components.com/docs/api#typescript" target="_blank" rel="noopener">这里</a>了解如何在 Typescript 中声明 theme 类型</p><p><br></p><h4 id="8-提升开发体验"><a href="#8-提升开发体验" class="headerlink" title="8. 提升开发体验"></a>8. 提升开发体验</h4><p>可以使用<code>babel-plugin-styled-components</code>或<a href="https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros" target="_blank" rel="noopener"><code>babel macro</code></a>来支持服务端渲染、 样式压缩和提升 debug 体验. 推荐使用 macro 形式, 无需安装和配置 babel 插件. 在 create-react-app 中已内置支持:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled, &#123; createGlobalStyle &#125; <span class="keyword">from</span> <span class="string">'styled-components/macro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Thing = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  color: red;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>详见<a href="https://www.styled-components.com/docs/tooling#babel-macro" target="_blank" rel="noopener">Tooling</a></p><p><br></p><h4 id="9-了解-styled-components-的局限性"><a href="#9-了解-styled-components-的局限性" class="headerlink" title="9. 了解 styled-components 的局限性"></a>9. 了解 styled-components 的局限性</h4><p>比较能想到的局限性是性能问题:</p><ol><li>css-in-js: 需要一个 JS 运行时, 会增加 js 包体积(大约 15KB)</li><li>相比原生 CSS 会有更多节点嵌套(例如 ThemeConsumer)和计算消耗. 这个对于复杂的组件树的渲染影响尤为明显</li><li>不能抽取为 CSS 文件, 这通常不算问题</li></ol><blockquote><p>官方<a href="https://github.com/styled-components/styled-components/tree/master/packages/styled-components/benchmarks" target="_blank" rel="noopener">benchmark</a></p></blockquote><p>下面是基于 v4.0 基准测试对比图, 在众多 CSS-in-js 方案中, styled-components 处于中上水平:</p><p><img src="/images/04/styled-benchmark.png" alt="styled-components benchmark"></p><p><br></p><h4 id="10-一些开发规范"><a href="#10-一些开发规范" class="headerlink" title="10. 一些开发规范"></a>10. 一些开发规范</h4><ul><li>避免无意义的组件名. 避免类似<code>Div</code>, <code>Span</code>这类直接照搬元素名的无意义的组件命名</li></ul><p><br></p><ul><li><p>在一个文件中定义 styled-components 组件. 对于比较简单的组件, 一般会在同一个文件中定义 styled-components 组件就行了. 下面是典型组件的文件结构:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components/macro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在顶部定义所有styled-components组件</span></span><br><span class="line"><span class="keyword">const</span> Header = styled.header<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> Title = styled.div<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> StepName = styled.div<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> StepBars = styled.div<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> StepBar = styled.div&lt;&#123; active?: <span class="built_in">boolean</span> &#125;&gt;<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> FormContainer = styled.div<span class="string">``</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Steps: FC&lt;StepsProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;&gt;...&lt;<span class="regexp">/&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Steps;</span></span><br></pre></td></tr></table></figure><p>然而对于比较复杂的页面组件来说, 会让文件变得很臃肿, 扰乱组件的主体, 所以笔者一般会像抽取到单独的<code>styled.tsx</code>文件中:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Header, Title, StepName, StepBars, StepBar, FormContainer &#125; <span class="keyword">from</span> <span class="string">'./styled'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Steps: FC&lt;StepsProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;&gt;...&lt;<span class="regexp">/&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Steps;</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p>考虑导出 styled-components 组件, 方便上级组件设置样式</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ---Foo/index.ts---</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Styled <span class="keyword">from</span> <span class="string">'./styled'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; Styled &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Bar/index.ts----</span></span><br><span class="line"><span class="keyword">import</span> &#123; Styled &#125; <span class="keyword">from</span> <span class="string">'../Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  &amp; <span class="subst">$&#123;Styled.SomeComponent&#125;</span> &#123;</span></span><br><span class="line"><span class="string">    color: red;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="11-其他-css-in-js-方案"><a href="#11-其他-css-in-js-方案" class="headerlink" title="11. 其他 CSS-in-js 方案"></a>11. 其他 CSS-in-js 方案</h4><ul><li>CSS-module</li><li>JSS</li><li>emotion</li><li>glamorous</li></ul><p>这里值得一提的是<a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener">CSS-module</a>, 这也是社区比较流行的解决方案. 严格来说, 这不是 CSS-in-js. 有兴趣的读者可以看这篇文章<a href="https://zhuanlan.zhihu.com/p/20495964" target="_blank" rel="noopener">CSS Modules 详解及 React 中实践</a>.</p><p>特性:</p><ul><li>比较轻量, 不需要 JS 运行时, 因为他在编译阶段进行计算</li><li>所有样式默认都是 local, 通过导入模块方式可以导入这些生成的类名</li><li>可以和 CSS proprocessor 配合</li><li>采用非标准的语法, 例如:global, :local, :export, compose:</li></ul><p>CSS module 同样也有外部样式覆盖问题, 所以需要通过其他手段对关键节点添加其他属性(如 data-name).</p><blockquote><p>如果使用 css-module, 建议使用<code>*.module.css</code>来命名 css 文件, 和普通 CSS 区分开来.</p></blockquote><p>扩展:</p><ul><li><a href="https://github.com/stereobooster/css-in-js-101" target="_blank" rel="noopener">CSS-in-JS 101: All you need to know</a></li></ul><p><br></p><hr><p><br></p><h3 id="4️⃣-通用的组件库不应该耦合-css-in-js-css-module-的方案"><a href="#4️⃣-通用的组件库不应该耦合-css-in-js-css-module-的方案" class="headerlink" title="4️⃣ 通用的组件库不应该耦合 CSS-in-js/CSS-module 的方案"></a>4️⃣ 通用的组件库不应该耦合 CSS-in-js/CSS-module 的方案</h3><p>如果是作为第三方组件库形式开发, 个人觉得不应该耦合各种 CSS-in-js/CSS-module. 不能强求你的组件库使用者耦合这些技术栈, 而且部分技术是需要构建工具支持的. 建议使用原生 CSS 或者将 SCSS/Less 这些预处理工具作为增强方案</p><p><br></p><hr><p><br></p><h3 id="5️⃣-优先使用原生-css"><a href="#5️⃣-优先使用原生-css" class="headerlink" title="5️⃣ 优先使用原生 CSS"></a>5️⃣ 优先使用原生 CSS</h3><p>笔者的项目大部分都是使用<code>styled-components</code>, 但对于部分极致要求性能的组件, 一般我会回退使用原生 CSS, 再配合 BEM 命名规范. 这种最简单方式, 能够满足大部分需求.</p><p><br></p><hr><p><br></p><h3 id="6️⃣-选择合适自己团队的技术栈"><a href="#6️⃣-选择合适自己团队的技术栈" class="headerlink" title="6️⃣ 选择合适自己团队的技术栈"></a>6️⃣ 选择合适自己团队的技术栈</h3><p>每个团队的情况和偏好不一样, 选择合适自己的才是最好的. 关于 CSS 方面的技术栈搭配也非常多样:</p><p><img src="/images/04/css-determination.png" alt="css determination"></p><ul><li><strong>选择 CSS-in-js 方案</strong>:<br>优点: 这个方案解决了大部分 CSS 的缺陷, 灵活, 动态性强, 学习成本比较低, 非常适合组件化的场景.<br>缺点: 性能相比静态 CSS 要弱, 不过这点已经慢慢在改善. 可以考虑在部分组件使用原生 CSS</li><li><strong>选择 CSS 方案</strong>:<ul><li><strong>选择原生 CSS 方案</strong>: 这种方案最简单</li><li><strong>选择 Preprocessor</strong>: 添加 CSS 预处理器, 可以增强 CSS 的可编程性: 例如模块化, 变量, 函数, mixin.<br>优点: 预处理器可以减少代码重复, 让 CSS 更好维护. 适合组织性要求很高的大型项目.<br>缺点: 就是需要学习成本, 所以这里笔者建议使用标准的 cssnext 来代替 SCSS/Less 这些方案</li><li><strong>方法论</strong>: CSS 的各种方法论旨在提高 CSS 的组织性, 提供一些架构建议, 让 CSS 更好维护.</li><li><strong>postcss</strong>: 对 CSS 进行优化增强, 例如添加厂商前缀</li><li><strong>css-module</strong>: 隔离 CSS, 支持暴露变量给 JS, 解决 CSS 的一些缺陷, 让 CSS 适合组件化场景.<br>可选, 通过合适的命名和组织其实是可以规避 CSS 的缺陷</li></ul></li></ul><p>综上所述, CSS-in-js 和 CSS 方案各有适用场景. 比如对于组件库, 如 antd 则选择了 Preprocessor 方案; 对于一般应用笔者建议使用 CSS-in-js 方案, 它学习成本很低, 并且<code>There&#39;s Only One Way To Do It</code> 没有太多心智负担, 不需要学习冗杂的方法论, 代码相对比较可控; 另外它还支持跨平台, 在 ReactNative 下, styled-components 是更好的选择. 而 CSS 方案, 对于大型应用要做到有组织有纪律和规划化, 需要花费较大的精力, 尤其是团队成员能力不均情况下, 很容易失控</p><p><br></p><hr><p><br></p><h3 id="7️⃣-使用-svgr-转换-svg-图标"><a href="#7️⃣-使用-svgr-转换-svg-图标" class="headerlink" title="7️⃣ 使用 svgr 转换 svg 图标"></a>7️⃣ 使用 svgr 转换 svg 图标</h3><p>如今 CSS-Image-Sprite 早已被 <a href="https://github.com/jkphl/svg-sprite" target="_blank" rel="noopener">SVG-Sprite</a> 取代. 而在 React 生态中使用<a href="https://github.com/smooth-code/svgr#webpack-usage" target="_blank" rel="noopener"><code>svgr</code></a>更加方便, 它可以将 svg 文件转换为 React 组件, 也就是一个普通的 JS 模块, 它有以下优势:</p><ul><li>转换为普通 JS 文件, 方便代码分割和异步加载</li><li>相比 svg-sprite 和 iconfont 方案更容易管理</li><li>svg 可以通过 CSS/JS 配置, 可操作性更强; 相比 iconfont 支持多色</li><li>支持 svgo 压缩</li></ul><p>基本用法:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> starUrl, &#123; ReactComponent <span class="keyword">as</span> Star &#125; <span class="keyword">from</span> <span class="string">'./star.svg'</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;img src=&#123;starUrl&#125; alt=<span class="string">"star"</span> /&gt;</span><br><span class="line">    &lt;Star /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>了解<a href="https://www.smooth-code.com/open-source/svgr/docs/webpack/" target="_blank" rel="noopener">更多</a></p><blockquote><p>antd 3.9 之后使用 svg 图标<a href="https://ant.design/components/icon-cn/#SVG-图标" target="_blank" rel="noopener">代替了 font 图标</a> <br><br>对比<a href="https://aotu.io/notes/2018/11/23/SVG_vs_Image_vs_iconfont/index.html" target="_blank" rel="noopener">SVG vs Image, SVG vs Iconfont</a></p></blockquote><p><br></p><hr><p><br></p><h3 id="8️⃣-结合使用-rem-和-em-等相对单位-创建更有弹性的组件"><a href="#8️⃣-结合使用-rem-和-em-等相对单位-创建更有弹性的组件" class="headerlink" title="8️⃣ 结合使用 rem 和 em 等相对单位, 创建更有弹性的组件"></a>8️⃣ 结合使用 rem 和 em 等相对单位, 创建更有弹性的组件</h3><p>Bootstrap v4 全面使用 rem 作为基本单位, 这使得所有组件都可以响应浏览器字体的调整:</p><p><img src="/images/04/bootstrap-rem.gif" alt></p><p>rem 可以让整个文档可以响应 html 字体的变化, 经常用于移动端等比例还原设计稿, 详见<a href="https://www.zhihu.com/column/p/30413803" target="_blank" rel="noopener">Rem 布局的原理解析</a>. 我个人对于觉得弹性组件来说更重要的是 em 单位, 尤其是那些比例固定组件, 例如 Button, Switch, Icon. 比如我会这样定义 svg Icon 的样式:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.svg-icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">fill</span>: currentColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像 iconfont 一样, 外部只需要设置<code>font-size</code>就可以配置 icon 到合适的尺寸, 默认则继承当前上下文的字体大小:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyIcon style=&#123;&#123; fontSize: 17 &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>em 可以让<code>Switch</code>这类固定比例的组件的样式可以更容易的被配置, 可以配合函数将px转换为em:</p><iframe src="https://codesandbox.io/embed/z67r8rpnr4?fontsize=14" title="Switch" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>扩展:</p><ul><li><a href="https://www.sitepoint.com/understanding-and-using-rem-units-in-css/" target="_blank" rel="noopener">Understanding and Using rem Units in CSS</a></li><li><a href="https://www.zhihu.com/column/p/30413803" target="_blank" rel="noopener">Rem 布局的原理解析</a></li></ul><p><br></p><hr><p><br></p><h2 id="3-规范"><a href="#3-规范" class="headerlink" title="3. 规范"></a>3. 规范</h2><h3 id="1️⃣-促进建立统一的-ui-设计规范"><a href="#1️⃣-促进建立统一的-ui-设计规范" class="headerlink" title="1️⃣ 促进建立统一的 UI 设计规范"></a>1️⃣ 促进建立统一的 UI 设计规范</h3><p>上文已经阐述了 UI 设计规范的重要性, 有兴趣的读者可以看看这篇文章<a href="https://juejin.im/post/5b766ac56fb9a009aa154c27" target="_blank" rel="noopener">开发和设计沟通有多难？ - 你只差一个设计规范</a>. 简单总结一下:</p><ul><li>提供团队协作效率</li><li>提高组件的复用率. 统一的组件规范可以让组件更好管理</li><li>保持产品迭代过程中品牌一致性</li></ul><h3 id="2️⃣-css-编写规范"><a href="#2️⃣-css-编写规范" class="headerlink" title="2️⃣ CSS 编写规范"></a>2️⃣ CSS 编写规范</h3><p>可以参考以下规范:</p><ul><li><a href="https://codeguide.bootcss.com" target="_blank" rel="noopener">编码规范 by @mdo</a> bootstrap 使用的规范</li><li><a href="https://github.com/airbnb/css" target="_blank" rel="noopener">Airbnb CSS/Sass styleguide</a></li><li><a href="https://guide.aotu.io/docs/css/code.html#CSS3浏览器私有前缀写法" target="_blank" rel="noopener">Aotu 实验室代码规范</a></li><li><a href="https://github.com/fex-team/styleguide/blob/master/css.md" target="_blank" rel="noopener">FEX-Team 编码规范</a></li></ul><h3 id="3️⃣-使用stylelint进行样式规范检查"><a href="#3️⃣-使用stylelint进行样式规范检查" class="headerlink" title="3️⃣ 使用stylelint进行样式规范检查"></a>3️⃣ 使用stylelint进行样式规范检查</h3><p><br></p><hr><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://reactjs.org/docs/faq-styling.html" target="_blank" rel="noopener">Styling and CSS</a></li><li><a href="https://medium.com/@gajus/stop-using-css-in-javascript-for-web-development-fa32fb873dcc" target="_blank" rel="noopener">Stop using CSS in JavaScript for web development</a></li><li><a href="https://zhuanlan.zhihu.com/p/26878157" target="_blank" rel="noopener">精读《请停止 css-in-js 的行为》</a></li><li><a href="https://github.com/MicheleBertoli/css-in-js" target="_blank" rel="noopener">MicheleBertoli/css-in-js</a></li><li><a href="https://www.javascriptstuff.com/how-to-style-react/" target="_blank" rel="noopener">What to use for React styling?</a></li><li><a href="https://www.styled-components.com/docs/faqs" target="_blank" rel="noopener">styled-components FAQ</a></li><li><a href="https://medium.com/ansarada-thinking/styled-components-v4-the-good-the-bad-and-something-completely-different-e891139e0138" target="_blank" rel="noopener">Styled components V4: the good, the bad, and something completely different</a></li><li><a href="https://reactarmory.com/answers/should-i-use-css-in-js" target="_blank" rel="noopener">Should I use CSS-in-JS?</a></li><li><a href="http://qinsman.com/1606_uispec/" target="_blank" rel="noopener">聊聊 UI 设计规范：移动端、H5 与 Web 端</a></li><li><a href="https://juejin.im/post/5b768e18e51d45565d23e52c" target="_blank" rel="noopener">开发也能构建 UI 组件设计规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS 是前端开发的重要组成部分，但是它并不完美，本文主要探讨 React 样式管理方面的一些解决方案，目的是实现样式的高度可定制化, 让大型项目的样式代码更容易维护.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系列目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结02 - 组件的组织</title>
    <link href="https://bobi.ink/2019/05/11/react-component-design-02/"/>
    <id>https://bobi.ink/2019/05/11/react-component-design-02/</id>
    <published>2019-05-10T16:00:00.000Z</published>
    <updated>2019-05-15T01:12:31.303Z</updated>
    
    <content type="html"><![CDATA[<p>一个复杂的应用都是由简单的应用发展而来的, 随着越来越多的功能加入项目, 代码就会变得越来越难以控制. 本文章主要探讨在大型项目中如何对组件进行组织, 让项目具备可维护性.</p><p><strong>系列目录</strong></p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li>05 状态管理 待更新</li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-组件设计的基本原则">1. 组件设计的基本原则</a><ul><li><a href="#基本原则"><strong>基本原则</strong></a></li><li><a href="#高质量组件的特征"><strong>高质量组件的特征</strong></a></li></ul></li><li><a href="#2-基本技巧">2. 基本技巧</a></li><li><a href="#3-组件的分类">3. 组件的分类</a><ul><li><a href="#1️⃣-容器组件和展示组件分离">1️⃣ <strong>容器组件</strong>和<strong>展示组件</strong>分离</a></li><li><a href="#2️⃣-分离逻辑和视图">2️⃣ 分离逻辑和视图</a></li><li><a href="#3️⃣-有状态组件和无状态组件">3️⃣ 有状态组件和无状态组件</a></li><li><a href="#4️⃣-纯组件和非纯组件">4️⃣ 纯组件和非纯组件</a></li><li><a href="#5️⃣-按照-ui-划分为布局组件和内容组件">5️⃣ 按照 UI 划分为<code>布局组件</code>和<code>内容组件</code></a></li><li><a href="#6️⃣-接口一致的数据录入组件">6️⃣ 接口一致的数据录入组件</a></li></ul></li><li><a href="#4-目录划分">4. 目录划分</a><ul><li><a href="#1️⃣-基本目录结构">1️⃣ 基本目录结构</a></li><li><a href="#2️⃣-多页应用的目录划分">2️⃣ 多页应用的目录划分</a></li><li><a href="#3️⃣-多页应用的目录划分-monorepo-模式">3️⃣ 多页应用的目录划分: monorepo 模式</a></li><li><a href="#4️⃣-跨平台应用">4️⃣ 跨平台应用</a></li><li><a href="#5️⃣-跨平台的另外一种方式-taro">5️⃣ 跨平台的另外一种方式: taro</a></li></ul></li><li><a href="#5-模块">5. 模块</a><ul><li><a href="#1️⃣-创建严格的模块边界">1️⃣ 创建严格的模块边界</a></li><li><a href="#2️⃣-named-export-vs-default-export">2️⃣ <code>Named export</code> vs <code>default export</code></a></li><li><a href="#3️⃣-避免循环依赖">3️⃣ 避免循环依赖</a></li><li><a href="#4️⃣-相对路径不要超过两级">4️⃣ 相对路径不要超过两级</a></li></ul></li><li><a href="#6-拆分">6. 拆分</a><ul><li><a href="#1️⃣-拆分-render-方法">1️⃣ 拆分 render 方法</a></li><li><a href="#2️⃣-拆分为组件">2️⃣ 拆分为组件</a></li></ul></li><li><a href="#7-组件划分示例">7. 组件划分示例</a><ul><li><a href="#1️⃣-划分页面">1️⃣ 划分页面</a></li><li><a href="#2️⃣-划分基础-ui-组件">2️⃣ 划分基础 UI 组件</a></li><li><a href="#3️⃣-设计组件的状态">3️⃣ 设计组件的状态</a></li></ul></li><li><a href="#8-文档">8. 文档</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="1-组件设计的基本原则"><a href="#1-组件设计的基本原则" class="headerlink" title="1. 组件设计的基本原则"></a>1. 组件设计的基本原则</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a><strong>基本原则</strong></h3><p><strong>单一职责(Single Responsibility Principle)</strong>. 这原本来源于面向对象编程, 规范定义是”一个类应该只有一个发生变化的原因”, 白话说”一个类只负责一件事情”. 不管是什么编程范式, 只要是模块化的程序设计都适用单一职责原则. 在 React 中, 组件就是模块.</p><p>单一职责要求将组件限制在一个’合适’的粒度. 这个粒度是比较主观的概念, 换句话说’单一’是一个相对的概念. 我个人觉得单一职责并不是追求职责粒度的’最小’化, 粒度最小化是一个极端, 可能会导致大量模块, 模块离散化也会让项目变得难以管理. <strong>单一职责要求的是一个适合被复用的粒度</strong>.</p><p>往往一开始我们设计的组件都可能复合多个职责, 后来出现了代码重复或者模块边界被打破(比如一个模块依赖另一个模块的’细节’), 我们才会惰性将可复用的代码抽离. 随着越来越多的重构和迭代, 模块职责可能会越来越趋于’单一’(😂 看谁, 也可能变成面条).</p><p>当然有经验的开发者可以一开始就能考虑组件的各种应用场景, 可以观察到模块的重合边界. <strong>对于入门者来说<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener"><code>Don&#39;t repeat yourself</code></a>原则更有用, 不要偷懒/多思考/重构/消除重复代码, 你的能力就会慢慢提升</strong></p><p>单一职责的收益:</p><ul><li>降低组件的复杂度. 职责单一组件代码量少, 容易被理解, 可读性高</li><li>降低对其他组件的耦合. 当变更到来时可以降低对其他功能的影响, 不至于牵一发而动全身</li><li>提高可复用性. 功能越单一可复用性越高, 就比如一些基础组件</li></ul><p><br></p><h3 id="高质量组件的特征"><a href="#高质量组件的特征" class="headerlink" title="高质量组件的特征"></a><strong>高质量组件的特征</strong></h3><p><strong>一个高质量的组件一定是<code>高内聚, 低耦合</code>的</strong>, 这两个原则或者特征是组件独立性的一个判断标准.</p><p><strong>高内聚</strong>, 要求一个组件有一个明确的组件边界, 将紧密相关的内容聚集在一个组件下, 实现”专一”的功能. 和传统的前端编程不一样, 一个组件是一个<strong>自包含</strong>的单元, 它包含了逻辑/样式/结构, 甚至是依赖的静态资源. 这也使得组件天然就是一个比较独立的个体. 当然这种独立性是相对的, 为了最大化这种独立性, 需要根据<strong>单一职责</strong>将组件拆分为更小粒度的组件, 这样可以被更灵活的组合和复用.</p><p>虽然组件是独立的, 但是他需要和其他组件进行组合才能实现应用, 这就有了’关联’. <strong>低耦合</strong>要求最小化这种关联性, 比如明确模块边界不应该访问其他组件的内部细节, 组件的接口最小化, 单向数据流等等</p><p>文章后续内容主要讨论实现<em>高内聚/低耦合</em>主要措施</p><p><br></p><hr><p><br></p><h2 id="2-基本技巧"><a href="#2-基本技巧" class="headerlink" title="2. 基本技巧"></a>2. 基本技巧</h2><p>这些技巧来源于<a href="https://vasanthk.gitbooks.io/react-bits/ux-variations/" target="_blank" rel="noopener">react-bits</a>:</p><ul><li>如果组件不需要状态, 则使用<strong>无状态组件</strong></li><li>性能上比较: <strong>无状态函数 &gt; 有状态函数 &gt; class 组件</strong></li><li>最小化 props(接口). 不要传递超过要求的 props</li><li>如果组件内部存在较多条件控制流, 这通常意味着需要对组件进行抽取</li><li>不要过早优化. 只要求组件在当前需求下可被复用, 然后’随机应变’</li></ul><p><br></p><hr><p><br></p><h2 id="3-组件的分类"><a href="#3-组件的分类" class="headerlink" title="3. 组件的分类"></a>3. 组件的分类</h2><h3 id="1️⃣-容器组件和展示组件分离"><a href="#1️⃣-容器组件和展示组件分离" class="headerlink" title="1️⃣ 容器组件和展示组件分离"></a>1️⃣ <strong>容器组件</strong>和<strong>展示组件</strong>分离</h3><p><em>容器组件和展示组件分离</em>是 React 开发的重要思想, 它影响的 React 应用项目的组织和架构. 下面总结一下两者的区别:</p><p><br></p><table><thead><tr><th></th><th>容器组件</th><th>展示组件</th></tr></thead><tbody><tr><td>关注点</td><td>业务</td><td>UI</td></tr><tr><td>数据源</td><td>状态管理器/后端</td><td>props</td></tr><tr><td>组件形式</td><td>高阶组件</td><td>普通组件</td></tr></tbody></table><p><br></p><ul><li><p><strong>展示组件</strong>是一个只关注展示的’元件’, 为了可以在多个地方被复用, 它不应该耦合’业务/功能’, 或者说不应该过渡耦合. 像<code>antd</code>这类组件库提供通用组件显然就是’展示组件’</p><p>下面是一个典型的应用目录结构, 我们可以看到<strong>展示组件与业务/功能是可能有不同的耦合程度的, 和业务的耦合程度越低, 通用性/可复用性越强</strong>:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node_modules/antd/     🔴 通用的组件库, 不能和任何项目的业务耦合</span><br><span class="line">src/</span><br><span class="line">  components/          🔴 项目通用的组件库, 可以被多个容器/页面组件共享</span><br><span class="line">  containers/</span><br><span class="line">    Foo/</span><br><span class="line">      components/      🔴 容器/页面组件特有的组件库, 和一个业务/功能深度耦合. 以致于不能被其他容器组件共享</span><br><span class="line">      index.tsx</span><br><span class="line">    Bar/</span><br><span class="line">      components/</span><br><span class="line">      index.tsx</span><br></pre></td></tr></table></figure><p>对于展示组件，我们要以一种’第三方组件库’的标准来考虑组件的设计, 减少与业务的耦合度, 考虑各种应用的场景, 设计好公开的接口.</p><p><br></p></li><li><p><strong>容器组件</strong>主要关注业务处理. 容器组件一般以’高阶组件’形式存在, 它一般 ① 从外部数据源(redux 这些状态管理器或者直接请求服务端数据)获取数据, 然后 ② 组合<em>展示组件</em>来构建完整的视图.</p><p><img src="/images/04/container.png" width="400"></p><p><em>容器组件</em>通过组合<em>展示组件</em>来构建完整视图, 但两者未必是简单的包含与被包含的关系.</p><p><br></p></li></ul><p><code>容器组件和展示组件的分离</code>可以带来好处主要是<strong>可复用性</strong>和<strong>可维护性</strong>:</p><ul><li>可复用性: 展示组件可以用于多个不同的数据源(容器组件). 容器组件(业务逻辑)也可以被复用于不同’平台’的展示组件</li><li>展示和容器组件更好的分离，有助于更好的理解应用和 UI, 两者可以被独立地维护</li><li>展示组件变得轻量(无状态/或局部状态), 更容易被测试</li></ul><p><br></p><p>了解更多<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">Presentational and Container Components</a></p><p><br></p><hr><p><br></p><h3 id="2️⃣-分离逻辑和视图"><a href="#2️⃣-分离逻辑和视图" class="headerlink" title="2️⃣ 分离逻辑和视图"></a>2️⃣ 分离逻辑和视图</h3><p><code>容器组件和展示组件</code>的分离本质上是<code>逻辑和视图</code>的分离. 在<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener"><code>React Hooks</code></a>出现后, 容器组件可以被 Hooks 形式取代, Hooks 可以和视图层更自然的分离, 为视图层提供纯粹的数据来源.</p><p>抽离的后业务逻辑可以复用于不同的’展示平台’, 例如 web 版和 native 版:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Login/</span><br><span class="line">  useLogin.ts   // 可复用的业务逻辑</span><br><span class="line">  index.web.tsx</span><br><span class="line">  index.tsx</span><br></pre></td></tr></table></figure><p>上面使用了<code>useLogin.tsx</code>来单独维护业务逻辑. 可以被 web 平台和 native 平台的代码复用.</p><p><br></p><p>  <img src="/images/04/demo.png" width="300"></p><p>不仅仅是<strong>业务逻辑</strong>, 展示<strong>组件逻辑</strong>也可以分离. 例如上图, <code>FilePicker</code>和<code>ImagePicker</code>两个组件的’文件上传’逻辑是共享的, 这部分逻辑可以抽取到高阶组件或者 hooks, 甚至是 Context 中(可以统一配置文件上传行为)</p><p>分离逻辑和视图的主要方式有:</p><ul><li>hooks</li><li>高阶组件</li><li>Render Props</li><li>Context</li></ul><p><br></p><hr><p><br></p><h3 id="3️⃣-有状态组件和无状态组件"><a href="#3️⃣-有状态组件和无状态组件" class="headerlink" title="3️⃣ 有状态组件和无状态组件"></a>3️⃣ 有状态组件和无状态组件</h3><p><strong>无状态组件内部不存储状态, 完全由外部的 props 来映射</strong>. 这类组件以函数组件形式存在, 作为低级/高复用的底层展示型组件.<br>无状态组件天然就是’纯组件’, 如果无状态组件的映射需要一点成本, 可以使用 React.memo 包裹避免重复渲染</p><p><br></p><hr><p><br></p><h3 id="4️⃣-纯组件和非纯组件"><a href="#4️⃣-纯组件和非纯组件" class="headerlink" title="4️⃣ 纯组件和非纯组件"></a>4️⃣ 纯组件和非纯组件</h3><p>纯组件的’纯’来源于函数式编程. 指的是<strong>对于一个函数而言, 给定相同的输入, 它总是返回相同的输出, 过程没有副作用, 没有额外的状态依赖</strong>. 对应到 React 中, 纯组件指的是 props(严格上说还有 state 和 context, 它们也是组件的输入)没有变化, 组件的输出就不会变动.</p><center><br>  <img src="/images/04/input-output.png" width="450"><br></center><p>和 React 组件的输出输出模型相比, <a href="http://cyclejs.cn" target="_blank" rel="noopener">Cyclejs</a>对组件输入/输出的抽象则做的更加彻底，更加‘函数式’👇。它的组件就是一个普通的函数，只有’单向’的输入和输出:</p><center><br>  <img src="/images/04/cyclejs.png" width="400"><br></center><p>函数式编程和组件式编程思想某种意义上是一致的, 它们都是’组合’的艺术. 一个大的函数可以有多个职责单一函数组合而成. 组件也是如此. <strong>我们将一个大的组件拆分为子组件, 对组件做更细粒度的控制, 保持它们的纯净性, 让它们的职责更单一, 更独立. 这带来的好处就是可复用性, 可测试性和可预测性.</strong></p><p><strong>纯组件对 React 的性能优化也有重要意义</strong>. 如果一个组件是一个纯组件, 如果’输入’没有变动, 那么这个组件就不需要重新渲染. 组件树越大, 纯组件带来的性能优化收益就越高.</p><p>我们可以很容易地保证一个底层组件的纯净性, 因为它本来就很简单. 但是对于一个复杂的组件树, 则需要花点心思进行构建, 所以就有了’状态管理’的需求. <strong>这些状态管理器通常都在组件树的<em>外部</em>维护一个或多个状态库, 然后通过依赖注入形式, 将局部的状态注入到子树中. 通过视图和逻辑分离的原则, 来维持组件树的纯净性</strong>.</p><p>Redux 就是一个典型的解决方案, 在 Redux 的世界里可以认为<strong>一个复杂的组件树就是一颗状态树的映射</strong>, 只要状态树(需要依靠不可变数据来保证状态的可预测性)不变, 组件树就不变. Redux 建议保持组件的纯净性, 将组件状态交给 Redux 和配套的异步处理工具来维护, 这样就将整个应用抽象成了一个”单向的数据流”, 这是一种简单的”输入/输出”关系</p><center><br>  <img src="/images/04/redux.png" width="400"><br></center><p>不管是 Cyclejs 还是 Redux，抽象是需要付出一点代价的，就比如 redux 代码可能会很罗嗦; 一个复杂的状态树, 如果缺乏良好的组织，整个应用会变得很难理解。实际上, 并不是所有场景都能够顺利/优雅通过’数据驱动’进行表达(可以看一下这篇文章<a href="https://zhuanlan.zhihu.com/p/54492049" target="_blank" rel="noopener">Modal.confirm 违反了 React 的模式吗？</a>), 例如文本框焦点, 或者模态框. 所以不必极端追求无副作用或者数据驱动</p><p>后续会专门写篇文章来回顾总结状态管理.</p><p>扩展:</p><ul><li><a href="https://hackernoon.com/redesigning-redux-b2baee8b8a38" target="_blank" rel="noopener">Redesigning Redux</a></li><li><a href="http://cyclejs.cn/#-组件化" target="_blank" rel="noopener">Cyclejs</a></li></ul><p><br></p><hr><p><br></p><h3 id="5️⃣-按照-ui-划分为布局组件和内容组件"><a href="#5️⃣-按照-ui-划分为布局组件和内容组件" class="headerlink" title="5️⃣ 按照 UI 划分为布局组件和内容组件"></a>5️⃣ 按照 UI 划分为<code>布局组件</code>和<code>内容组件</code></h3><ul><li>布局组件用于控制页面的布局，为内容组件提供占位。通过 props 传入组件来进行填充. 比如<code>Grid</code>, <code>Layout</code>, <code>HorizontalSplit</code></li><li>内容组件会包含一些内容，而不仅有布局。内容组件通常被布局组件约束在占位内. 比如<code>Button</code>, <code>Label</code>, <code>Input</code></li></ul><p>例如下图, List/List.Item 就是布局组件，而 Input，Address 则是内容组件</p><center><br>  <img src="/images/04/layout-vs-content.png" lazyload width="500"><br></center><p>将布局从内容组件中抽取出来，分离布局和内容，可以让两者更好维护，比如布局变动不会影响内容，内容组件可以被应用不同的布局; 另一方面组件是一个自包含内聚的隔离单元, 不应该影响其外部的状态, 例如一个按钮不应该修改外部的布局, 另外也要避免影响全局的样式</p><p><br></p><hr><p><br></p><h3 id="6️⃣-接口一致的数据录入组件"><a href="#6️⃣-接口一致的数据录入组件" class="headerlink" title="6️⃣ 接口一致的数据录入组件"></a>6️⃣ 接口一致的数据录入组件</h3><p>数据录入组件, 或者称为表单, 是客户端开发必不可少的元素. 对于自定义表单组件, 我认为应该保持一致的 API:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props&lt;T&gt; &#123;</span><br><span class="line">  value?: T;</span><br><span class="line">  onChange: <span class="function">(<span class="params">value?: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处:</p><ul><li>接近原生表单元素原语. 自定义表单组件一般不需要封装到 event 对象中</li><li>几乎所有组件库的自定义表单都使用这种 API. 这使得我们的自定义组件可以和第三方库兼容, 比如<a href="https://ant.design/components/form-cn/#components-form-demo-validate-other" target="_blank" rel="noopener">antd 的表单验证机制</a></li><li>更容易被动态渲染. 因为接口一致, 可以方便地进行动态渲染或集中化处理, 减少代码重复</li><li><p>回显问题. 状态回显是表单组件的功能之一, 我个人的最佳实践是<code>value</code>应该是自包含的:</p><p>比如一个支持搜索的用户选择器, option 都是异步从后端加载, 如果 value 只保存用户 id, 那么回显的时候就无法显示用户名, 按照我的实践的 value 的结构应该为: <code>{id: string, name: string}</code>, 这样就解决了回显问题. 回显需要的数据都是由父节点传递进来, 而不是组件自己维护</p></li><li><p>组件都是受控的. 在实际的 React 开发中, 非受控组件的场景非常少, 我认为自定义组件都可以忽略这种需求, 只提供完全受控表单组件, 避免组件自己维护缓存状态</p></li></ul><p><br></p><hr><p><br></p><h2 id="4-目录划分"><a href="#4-目录划分" class="headerlink" title="4. 目录划分"></a>4. 目录划分</h2><h3 id="1️⃣-基本目录结构"><a href="#1️⃣-基本目录结构" class="headerlink" title="1️⃣ 基本目录结构"></a>1️⃣ 基本目录结构</h3><p>关于项目目录结构的划分有两种流行的模式:</p><ul><li><strong><a href="https://ruby-china.github.io/rails-guides/getting_started.html#say-hello-rails" target="_blank" rel="noopener">Rails-style</a>/by-type</strong>: 按照文件的类型划分为不同的目录，例如<code>components</code>、<code>constants</code>、 <code>typings</code>、<code>views</code></li><li><strong>Domain-style/by-feature</strong>: 按照一个功能特性或业务创建单独的文件夹，包含多种类型的文件或目录</li></ul><p>实际的项目环境我们一般使用的是<strong>混合模式</strong>，下面是一个典型的 React 项目结构:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/      # 🔴 项目通用的‘展示组件’</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx    # 组件的入口, 导出组件</span><br><span class="line">      Groups.tsx   # 子组件</span><br><span class="line">      loading.svg  # 静态资源</span><br><span class="line">      style.css    # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts       # 到处所有组件</span><br><span class="line">  containers/      # 🔴 包含'容器组件'和'页面组件'</span><br><span class="line">    LoginPage/     # 页面组件, 例如登录</span><br><span class="line">      components/  # 页面级别展示组件，这些组件不能复用与其他页面组件。</span><br><span class="line">        Button.tsx # 组件未必是一个目录形式，对于一个简单组件可以是一个单文件形式. 但还是推荐使用目录，方便扩展</span><br><span class="line">        Panel.tsx</span><br><span class="line">      reducer.ts   # redux reduces</span><br><span class="line">      useLogin.ts  # (可选)放置'逻辑', 按照👆分离逻辑和视图的原则，将逻辑、状态处理抽取到hook文件</span><br><span class="line">      types.ts     # typescript 类型声明</span><br><span class="line">      style.css</span><br><span class="line">      logo.png</span><br><span class="line">      message.ts</span><br><span class="line">      constants.ts</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx      # 🔴应用根组件</span><br><span class="line">  hooks/           # 🔴可复用的hook</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.tsx        # 应用入口, 在这里使用ReactDOM对跟组件进行渲染</span><br><span class="line">  stores.ts        # redux stores</span><br><span class="line">  contants.ts      # 全局常量</span><br></pre></td></tr></table></figure><p>上面使用<code>Domain-style</code>风格划分了<code>LoginPage</code>和<code>HomePage</code>目录, 将所有该业务或者页面相关的文件聚合在一起; 这里也使用<code>Rails-style</code>模式根据文件<strong>类型/职责</strong>划分不同的目录, 比如<code>components</code>, <code>hooks</code>, <code>containers</code>; 你会发现在<code>LoginPage</code>内部也有类似<code>Rails-Style</code>的结构, 如<code>components</code>, 只不过它的<strong>作用域</strong>不同, 它只归属于<code>LoginPage</code>, 不能被其他 Page 共享</p><p>前端项目一般按照页面路由来拆分组件, 这些组件我们暂且称为‘页面组件’, 这些组件是和业务功能耦合的，而且每个页面之间具有一定的独立性.</p><p>这里将页面组件放置在<code>containers</code>, 如其名，这个目录原本是用来放置容器组件的, 实际项目中通常是将‘容器组件’和‘页面组件’混合在了一起, 现阶段如果要实现纯粹的逻辑分离，我个人觉得还是应该抽取到 hook 中. 这个目录也可以命名为 views, pages…(whatever), 命名为 containers 只是一种习惯(来源于 Redux).</p><p>扩展:</p><ul><li><a href="https://github.com/react-boilerplate/react-boilerplate" target="_blank" rel="noopener">react-boilerplate</a></li></ul><p><br></p><hr><p><br></p><h3 id="2️⃣-多页应用的目录划分"><a href="#2️⃣-多页应用的目录划分" class="headerlink" title="2️⃣ 多页应用的目录划分"></a>2️⃣ 多页应用的目录划分</h3><p>对于大型应用可能有多个应用入口, 例如很多 electron 应用有多个 windows; 再比如很多应用除了 App 还有后台管理界面. 我一般会这样组织多页应用:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/       # 共享组件</span><br><span class="line">  containers/</span><br><span class="line">    Admin/          # 后台管理页面</span><br><span class="line">      components/   # 后台特定的组件库</span><br><span class="line">      LoginPage/</span><br><span class="line">      index.tsx</span><br><span class="line">      ...</span><br><span class="line">    App/</span><br><span class="line">      components/  # App特定的组件库</span><br><span class="line">      LoginPage/   # App页面</span><br><span class="line">      index.tsx</span><br><span class="line">      stores.ts    # redux stores</span><br><span class="line">    AnotherApp/    # 另外一个App页面</span><br><span class="line">  hooks/</span><br><span class="line">  ...</span><br><span class="line">  app.tsx          # 应用入口</span><br><span class="line">  anotherApp.tsx   # 应用入口</span><br><span class="line">  admin.tsx        # 后台入口</span><br></pre></td></tr></table></figure><p>webpack 支持多页应用的构建, 我一般会将应用入口文件命名为<code>*.page.tsx</code>, 然后在 src 自动扫描匹配的文件作为入口.</p><p>利用 webpack 的<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener"><code>SplitChunksPlugin</code></a>可以自动为多页应用抽取共享的模块, 这个对于功能差不多和有较多共享代码的多页应用很有意义. 意味着资源被一起优化, 抽取共享模块, 有利于减少编译文件体积, 也便于共享浏览器缓存.</p><blockquote><p><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener"><code>html-webpack-plugin</code></a>4.0 开始支持注入共享 chunk. 在此之前需要通过 SplitChunksPlugin 显式定义共享的 chunk, 然后也要 html-webpack-plugin 显式注入该 chunk, 比较挫.</p></blockquote><p><br></p><hr><p><br></p><h3 id="3️⃣-多页应用的目录划分-monorepo-模式"><a href="#3️⃣-多页应用的目录划分-monorepo-模式" class="headerlink" title="3️⃣ 多页应用的目录划分: monorepo 模式"></a>3️⃣ 多页应用的目录划分: monorepo 模式</h3><p>上面的方式, 所有页面都聚集在一个项目下面, 共享一样的依赖和 npm 模块. 这可能会带了一些问题:</p><ol><li>不能允许不同页面有不同版本的依赖</li><li>对于毫无相关的应用, 这种组织方式会让代码变得混乱, 例如 App 和后台, 他们使用的技术栈/组件库/交互体验都可能相差较大, 而且容易造成命名冲突.</li><li>构建性能. 你希望单独对某个页面进行构建和维护, 而不是所有页面混合在一起构建</li></ol><p>这种场景可以利用<a href="https://lernajs.io" target="_blank" rel="noopener">lerna</a>或者 <a href="https://yarnpkg.com/zh-Hans/docs/workspaces" target="_blank" rel="noopener">yarn workspace</a> 这里 monorepo 机制, 将多页应用隔离在不同的 npm 模块下, 以 yarn workspace 为例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">yarn.lock</span><br><span class="line">node_modules/      # 所有依赖都会安装在这里, 方便yarn对依赖进行优化</span><br><span class="line">share/             # 🔴 共享模块</span><br><span class="line">  hooks/</span><br><span class="line">  utils/</span><br><span class="line">admin/             # 🔴 后台管理应用</span><br><span class="line">  components/</span><br><span class="line">  containers/</span><br><span class="line">  index.tsx</span><br><span class="line">  package.json     # 声明自己的模块以及share模块的依赖</span><br><span class="line">app/               # 🔴 后台管理应用</span><br><span class="line">  components/</span><br><span class="line">  containers/</span><br><span class="line">  index.tsx</span><br><span class="line">  package.json     # 声明自己的模块以及share模块的依赖</span><br></pre></td></tr></table></figure><p>扩展:</p><ul><li><a href="https://juejin.im/post/5cd8c1d6e51d456e55623bf2" target="_blank" rel="noopener">精读《Monorepo 的优势》</a></li></ul><p><br></p><hr><p><br></p><h3 id="4️⃣-跨平台应用"><a href="#4️⃣-跨平台应用" class="headerlink" title="4️⃣ 跨平台应用"></a>4️⃣ 跨平台应用</h3><p>使用 ReactNative 可以将 React 衍生到原生应用的开发领域. 尽管也有<a href="https://github.com/necolas/react-native-web" target="_blank" rel="noopener"><code>react-native-web</code></a>这样的解决方案, Web 和 Native 的 API/功能/开发方式, 甚至产品需求上可能会相差很大, 久而久之就可能出现大量无法控制的适配代码; 另外 react-native-web 本身也可能成为风险点。 所以一些团队需要针对不同平台进行开发, 一般按照下面风格来组织跨平台应用:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx     # 🔴 ReactNative 组件</span><br><span class="line">      index.web.tsx # 🔴 web组件, 以web.tsx为后缀</span><br><span class="line">      loading.svg   # 静态资源</span><br><span class="line">      style.css     # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts</span><br><span class="line">    index.web.ts</span><br><span class="line">  containers/</span><br><span class="line">    LoginPage/</span><br><span class="line">      components/</span><br><span class="line">      ....</span><br><span class="line">      useLogin.ts   # 🔴 存放分离的逻辑，可以在React Native和Web组件中共享</span><br><span class="line">      index.web.tsx</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx</span><br><span class="line">  hooks/</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.web.tsx        # web应用入口</span><br><span class="line">  index.tsx            # React Native 应用入口</span><br></pre></td></tr></table></figure><p>可以通过 webpack 的<code>resolve.extensions</code>来配置扩展名补全的优先级. 早期的<a href="https://github.com/ant-design/ant-design-mobile" target="_blank" rel="noopener">antd-mobile</a>就是这样组织的.</p><p><br></p><hr><p><br></p><h3 id="5️⃣-跨平台的另外一种方式-taro"><a href="#5️⃣-跨平台的另外一种方式-taro" class="headerlink" title="5️⃣ 跨平台的另外一种方式: taro"></a>5️⃣ 跨平台的另外一种方式: taro</h3><p>对于国内的开发者来说，跨平台可不只 Native 那么简单，我们还有各种各样的小程序、小应用。终端的<strong>碎片化</strong>让前端的开发工作越来越有挑战性.</p><p>Taro 就这样诞生了, Taro 基于 React 的标准语法(DSL), 结合编译原理的思想, 将一套代码转换为多种终端的目标代码, 并提供一套统一的内置组件库和 SDK 来抹平多端的差异</p><center><br>  <img src="/images/04/taro.png" width="500"><br></center><p>因为 Taro 使用 React 的标准语法和 API，这使得我们按照原有的 React 开发约定和习惯来开发多端应用，且只保持一套代码. 但是不要忘了抽象都是有代价的</p><blockquote><p>可以查看 Taro 官方文档<a href="https://github.com/NervJS/taro" target="_blank" rel="noopener">了解更多</a> <br></p></blockquote><blockquote><p><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter</a>是近期比较或的跨平台方案，但是跟本文主题无关</p></blockquote><p><br></p><hr><p><br></p><h2 id="5-模块"><a href="#5-模块" class="headerlink" title="5. 模块"></a>5. 模块</h2><h3 id="1️⃣-创建严格的模块边界"><a href="#1️⃣-创建严格的模块边界" class="headerlink" title="1️⃣ 创建严格的模块边界"></a>1️⃣ 创建严格的模块边界</h3><p>下图是一个某页面的模块导入，相当混乱，这还算可以接受，笔者还见过上千行的组件，其中模块导入语句就占一百多行. 这有一部分原因可能是 VsCode 自动导入功能导致(可以使用 tslint 规则对导入语句进行排序和分组规范)，更大的原因是这些模块缺乏组织。</p><center><br>  <img src="/images/04/imports.png" width="600"><br></center><p>我觉得应该创建严格的模块边界，<strong>一个模块只有一个统一的’出口’</strong>。例如一个复杂的组件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ComplexPage/</span><br><span class="line">  components/</span><br><span class="line">    Foo.tsx</span><br><span class="line">    Bar.tsx</span><br><span class="line">  constants.ts</span><br><span class="line">  reducers.ts</span><br><span class="line">  style.css</span><br><span class="line">  types.ts</span><br><span class="line">  index.tsx # 出口</span><br></pre></td></tr></table></figure><p>可以认为<strong>一个‘目录’就是一个模块边界</strong>. 你<em>不应该</em>这样子导入模块:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComplexPage <span class="keyword">from</span> <span class="string">'../ComplexPage'</span>;</span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../ComplexPage/components/Foo'</span>;</span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../ComplexPage/components/Bar'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; XXX &#125; <span class="keyword">from</span> <span class="string">'../ComplexPage/components/constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User, ComplexPageProps &#125; <span class="keyword">from</span> <span class="string">'../ComplexPage/components/type'</span>;</span><br></pre></td></tr></table></figure><p><strong>一个模块/目录应该由一个‘出口’文件来统一管理模块的导出，限定模块的可见性</strong>. 比如上面的模块，<code>components/Foo</code>、 <code>components/Bar</code>和<code>constants.ts</code>这些文件其实是 <code>ComplexPage</code> 组件的’实现细节’. 这些是外部模块不应该去耦合实现细节，但这个在语言层面并没有一个限定机制，只能依靠规范约定.</p><blockquote><p>当其他模块依赖某个模块的’细节’时, 可能是一种重构的信号: 比如依赖一个模块的一个工具函数或者是一个对象类型声明, 这时候可能应该将其抬升到父级模块, 让兄弟模块共享它.</p></blockquote><p>在前端项目中 <code>index</code> 文件最适合作为一个’出口’文件, 当导入一个目录时，模块查找器会查找该目录下是否存在的 index 文件. 开发者设计一个模块的 API 时, 需要考虑模块各种使用方式, 并使用 index 文件控制模块可见性:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入外部模块需要使用的类型</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./type'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不暴露外部不需要关心的实现细节</span></span><br><span class="line"><span class="comment">// export * from './components/Foo'</span></span><br><span class="line"><span class="comment">// export * from './components/Bar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块的默认导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; ComplexPage <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./ComplexPage'</span>;</span><br></pre></td></tr></table></figure><p>现在导入语句可以更加简洁:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComplexPage, &#123; ComplexPageProps, User, XXX &#125; <span class="keyword">from</span> <span class="string">'../ComplexPage'</span>;</span><br></pre></td></tr></table></figure><p><br></p><p>这条规则也可以用于组件库. 在 webpack 的 Tree-shaking 特性还不成熟之前， 我们都使用了各种各样的技巧来实现<code>按需导入</code>. 例如<a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener"><code>babel-plugin-import</code></a>或直接子路径导入:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> TextField <span class="keyword">from</span> <span class="string">'~/components/TextField'</span>;</span><br><span class="line"><span class="keyword">import</span> SelectField <span class="keyword">from</span> <span class="string">'~/components/SelectField'</span>;</span><br><span class="line"><span class="keyword">import</span> RaisedButton <span class="keyword">from</span> <span class="string">'~/components/RaisedButton'</span>;</span><br></pre></td></tr></table></figure><p>现在可以使用<code>Named import</code>直接导入，让 webpack 来帮你优化:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TextField, SelectField, RaisedButton &#125; <span class="keyword">from</span> <span class="string">'~/components'</span>;</span><br></pre></td></tr></table></figure><p><strong>但不是所有目录都有出口文件, 这时候目录就不是模块的边界了</strong>. 典型的有<code>utils/</code>, <code>utils</code> 只是一个模块命名空间, <code>utils</code> 下面的文件都是一些互不相关或者不同类型的文件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">utils/</span><br><span class="line">  common.ts</span><br><span class="line">  dom.ts</span><br><span class="line">  sdk.ts</span><br></pre></td></tr></table></figure><p>我们习惯直接引用这些文件, 而不是通过一个入口文件, 这样可以更明确导入的是什么类型的:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'./utils/dom'</span>; <span class="comment">// 通过文件名可以知道, 这可能是隐藏某个DOM元素</span></span><br><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'./utils/sdk'</span>; <span class="comment">// webview sdk 提供的的某个方法</span></span><br></pre></td></tr></table></figure><p>最后再总结一下:</p><p>  <img src="/images/04/module-boundary.png" width="600"></p><p>根据模块边界原则(如上图): <strong>一个模块可以访问兄弟(同个作用域下)、 祖先及祖先的兄弟模块</strong>. 例如:</p><ul><li>Bar 可以访问 Foo, 但不能再向下访问它的细节, 即不能访问<code>../Foo/types.ts</code>, 但可以访问它的出口文件<code>../Foo</code></li><li>src/types.ts 不能访问 containers/HomePage</li><li>LoginPage 和访问 HomePage</li><li>LoginPage 可以访问 utils/sdk</li></ul><p><br></p><hr><p><br></p><h3 id="2️⃣-named-export-vs-default-export"><a href="#2️⃣-named-export-vs-default-export" class="headerlink" title="2️⃣ Named export vs default export"></a>2️⃣ <code>Named export</code> vs <code>default export</code></h3><p>这两种导出方式都有各自的适用场景，这里不应该一棒子打死就不使用某种导出方式. 首先看一下<strong>named export 有什么优点</strong>:</p><ul><li><p>命名确定</p><ul><li>方便 Typescript 进行重构</li><li>方便智能提醒和自动导入(auto-import)识别</li><li><p>方便 reexport</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// named</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./named-export'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Foo &#125; <span class="keyword">from</span> <span class="string">'./default-export'</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一个模块支持多个<code>named export</code></p></li></ul><p><br></p><p><strong>再看一下<code>default export</code>有什么优点?</strong>:</p><ul><li><p><code>default export</code>一般代表‘模块本身’, 当我们使用‘默认导入’导入一个模块时, 开发者是自然而然知道这个默认导入的是一个什么对象。</p><p>例如 react 导出的是一个 React 对象; LoginPage 导出的是一个登录页面; somg.png 导入的是一张图片. 这类模块总有一个确定的’主体对象’. 所以默认导入的名称和模块的名称一般是保持一致的(Typescript 的 auto-import 就是基于文件名).</p><p>当然’主体对象’是一种隐式的概念, 你只能通过规范去约束它</p></li><li><p><code>default export</code>的导入语句更加简洁。例如<code>lazy(import(&#39;./MyPage&#39;))</code></p></li></ul><p><code>default export</code>也有一些缺点:</p><ul><li>和其他模块机制(commonjs)互操作时比较难以理解. 例如我们会这样子导入<code>default export</code>: <code>require(&#39;./xx&#39;).default</code></li><li><code>named import</code> 优点就是<code>default export</code>的缺点</li></ul><p>所以总结一下:</p><ol><li>对于’主体对象’明确的模块需要有默认导出, 例如页面组件，类</li><li>对于’主体对象’不明确的模块不应该使用默认导出，例如组件库、utils(放置各种工具方法)、contants 常量</li></ol><p>按照这个规则可以这样子组织 components 目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">  Foo/</span><br><span class="line">    Foo.tsx</span><br><span class="line">    types.ts</span><br><span class="line">    constants.ts</span><br><span class="line">    index.ts         # 导出Foo组件</span><br><span class="line">  Bar/</span><br><span class="line">    Bar.tsx</span><br><span class="line">    index.tsx</span><br><span class="line">  index.ts           # 导出所有组件</span><br></pre></td></tr></table></figure><p>对于 Foo 模块来说， 存在一个主体对象即 Foo 组件, 所以这里使用<code>default export</code>导出的 Foo 组件， 代码为:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="comment">// 这三个文件全部使用named export导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./contants'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./types'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入主体对象</span></span><br><span class="line"><span class="keyword">export</span> &#123; Foo <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br></pre></td></tr></table></figure><p>现在假设 Bar 组件依赖于 Foo:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/Bar/Bar.tsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入Foo组件, 根据模块边界规则, 不能直接引用../Foo/Foo.tsx</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Bar;</span></span><br></pre></td></tr></table></figure><p>对于<code>components</code>模块来说，它的所有子模块都是平等的，所以不存在一个主体对象，<code>default export</code>在这里不适用。 <code>components/index.ts</code>代码:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/index.ts</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./Bar'</span>;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="3️⃣-避免循环依赖"><a href="#3️⃣-避免循环依赖" class="headerlink" title="3️⃣ 避免循环依赖"></a>3️⃣ 避免循环依赖</h3><p><strong>循环依赖是模块糟糕设计的一个表现</strong>, 这时候你需要考虑拆分和设计模块文件, 例如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- Foo.tsx ---</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./Bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">Foo.Bar = Bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Bar.tsx ----</span></span><br><span class="line"><span class="keyword">import</span> &#123; SomeType &#125; <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面 Foo 和 Bar 组件就形成了一个简单循环依赖, 尽管它不会造成什么运行时问题. 解决方案就是将 SomeType 抽取到单独的文件:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- types.ts ---</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Foo.tsx ---</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./Bar'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;SomeType&#125; <span class="keyword">from</span> <span class="string">'./types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">...</span><br><span class="line">Foo.Bar = Bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Bar.tsx ----</span></span><br><span class="line"><span class="keyword">import</span> &#123;SomeType&#125; <span class="keyword">from</span> <span class="string">'./types'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="4️⃣-相对路径不要超过两级"><a href="#4️⃣-相对路径不要超过两级" class="headerlink" title="4️⃣ 相对路径不要超过两级"></a>4️⃣ 相对路径不要超过两级</h3><p>当项目越来越复杂, 目录可能会越来越深, 这时候会出现这样的导入路径:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'../../../utils/dom'</span>;</span><br></pre></td></tr></table></figure><p>首先这种导入语句非常不优雅, 而且可读性很差. 当你在不清楚当前文件的目录上下文时, 你不知道具体模块在哪; 即使你知道当前文件的位置, 你也需要跟随导入路径在目录树中向上追溯在能定位到具体模块. 所以这种相对路径是比较反人类的.</p><p>另外这种导入路径不方便模块迁移(尽管 Vscode 支持移动文件时重构导入路径), 文件迁移需要重写这些相对导入路径.</p><p><strong>所以一般推荐相对路径导入不应该超过两级, 即只能是<code>../</code>和<code>./</code></strong>. 可以尝试将<strong>相对路径转换成绝对路径形式</strong>, 例如<code>webpack</code>中可以配置<code>resolve.alias</code>属性来实现:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">resolve: &#123;</span><br><span class="line">  ...</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="comment">// 可以直接使用~访问相对于src目录的模块</span></span><br><span class="line">    <span class="comment">// 如 ~/components/Button</span></span><br><span class="line">    <span class="string">'~'</span>: context,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以这样子导入相对于<code>src</code>的模块:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'~/utils/dom'</span>;</span><br></pre></td></tr></table></figure><p>扩展</p><ul><li>对于 Typescript 可以配置<a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping" target="_blank" rel="noopener">paths</a>选项;</li><li>对于 babel 可以使用<a href="https://www.npmjs.com/package/babel-plugin-module-resolver" target="_blank" rel="noopener"><code>babel-plugin-module-resolver</code></a>插件来转换为相对路径</li></ul><p><br></p><hr><p><br></p><h2 id="6-拆分"><a href="#6-拆分" class="headerlink" title="6. 拆分"></a>6. 拆分</h2><h3 id="1️⃣-拆分-render-方法"><a href="#1️⃣-拆分-render-方法" class="headerlink" title="1️⃣ 拆分 render 方法"></a>1️⃣ 拆分 render 方法</h3><p>当 render 方法的 JSX 结构非常复杂的时候, 首先应该尝试分离这些 JSX, 最简单的做法的就是拆分为多个子 render 方法:</p><p>  <img src="/images/04/sub-render.png" width="600"></p><p>当然这种方式只是暂时让 render 方法看起来没有那么复杂, 它并没有拆分组件本身, 所有输入和状态依然聚集在一个组件下面. 所以通常拆分 render 方法只是重构的第一步: 随着组件越来越复杂, 表现为文件越来越长, 笔者一般将 300 行作为一个阈值, <strong>超过 300 行则说明需要对这个组件进进一步拆分</strong></p><p><br></p><hr><p><br></p><h3 id="2️⃣-拆分为组件"><a href="#2️⃣-拆分为组件" class="headerlink" title="2️⃣ 拆分为组件"></a>2️⃣ 拆分为组件</h3><p>如果已经按照 👆 上述方法对组件的 render 拆分为多个子 render, 当一个组件变得臃肿时, 就可以方便地将这些子 render 方法拆分为组件. 一般组件抽离有以下几种方式:</p><ol><li>纯渲染拆分: 子 render 方法一般是纯渲染的, 他们可以很直接地抽离为<em>无状态组件</em></li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; visible &#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Modal</span><br><span class="line">      visible=&#123;visible&#125;</span><br><span class="line">      title=&#123;<span class="keyword">this</span>.getLocale(<span class="string">'title'</span>)&#125;</span><br><span class="line">      width=&#123;<span class="keyword">this</span>.width&#125;</span><br><span class="line">      maskClosable=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">      onOk=&#123;<span class="keyword">this</span>.handleOk&#125;</span><br><span class="line">      onCancel=&#123;<span class="keyword">this</span>.handleCancel&#125;</span><br><span class="line">      footer=&#123;&lt;Footer &#123;...&#125;&gt;&lt;<span class="regexp">/Footer&gt;&#125;</span></span><br><span class="line"><span class="regexp">    &gt;</span></span><br><span class="line"><span class="regexp">    &lt;Body &#123;...&#125;&gt;&lt;/</span>Body&gt;</span><br><span class="line">  &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>纯逻辑拆分: 按照<code>逻辑和视图分离</code>的原则, 将逻辑控制部分抽离到 hooks 或高阶组件中</li><li>逻辑和渲染拆分: 将相关的视图和逻辑抽取出去形成一个独立的组件, 这是更为彻底的拆分方式, 贯彻单一职责原则.</li></ol><p><br></p><hr><p><br></p><h2 id="7-组件划分示例"><a href="#7-组件划分示例" class="headerlink" title="7. 组件划分示例"></a>7. 组件划分示例</h2><p>我们一般会从 UI 原型图中分析和划分组件, 在 React 官方的<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">Thinking in react</a>也提到通过 UI 来划分组件层级: “<em>这是因为 UI 和数据模型往往遵循着相同的信息架构，这意味着将 UI 划分成组件的工作往往是很容易的。只要把它划分成能准确表示你数据模型的一部分的组件就可以</em>“. 组件划分除了需要遵循上文 👆 提到的一些原则, 他还依赖于你的开发经验.</p><p>本节通过一个简单的应用讲述划分组件的过程. 这是某政府部门的服务申报系统, 一共由四个页面组成:</p><center><br>  <img src="/images/04/demo-all.png" width="800"><br></center><h3 id="1️⃣-划分页面"><a href="#1️⃣-划分页面" class="headerlink" title="1️⃣ 划分页面"></a>1️⃣ 划分页面</h3><p>页面通常是最顶层的组件单元, 划分页面非常简单, 我们根据原型图就可以划分四个页面: <code>ListPage</code>, <code>CreatePage</code>, <code>PreviewPage</code>, <code>DetailPage</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  containers/</span><br><span class="line">    ListPage/</span><br><span class="line">    CreatePage/</span><br><span class="line">    PreviewPage/</span><br><span class="line">    DetailPage/</span><br><span class="line">    index.tsx     # 根组件, 一般在这里定义路由</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="2️⃣-划分基础-ui-组件"><a href="#2️⃣-划分基础-ui-组件" class="headerlink" title="2️⃣ 划分基础 UI 组件"></a>2️⃣ 划分基础 UI 组件</h3><p>首先看<code>ListPage</code></p><p>  <img src="/images/04/ListPage.png" width="400"></p><p>ListPage 根据 UI 可以划分为下面这些组件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ScrollView        # 滚动视图, 提供下拉刷新, 无限加载等功能</span><br><span class="line">  List            # 列表容器, 布局组件</span><br><span class="line">    Item          # 列表项, 布局组件, 提供header, body等占位符</span><br><span class="line">      props - header</span><br><span class="line">         Title       # 渲染标题</span><br><span class="line">      props - after</span><br><span class="line">         Time        # 渲染时间</span><br><span class="line">      props - body</span><br><span class="line">         Status      # 渲染列表项的状态</span><br></pre></td></tr></table></figure><p>再看看<code>CreatePage</code></p><p>  <img src="/images/04/CreatePage.png" width="400"></p><p>这是一个表单填写页面, 为了提高表单填写体验, 这里划分为多个步骤; 每个步骤里有还有多个表单分组; 每个表单的结构都差不多, 左边是 label 展示, 右边是实际表单组件, 所以根据 UI 可以对组件进行这样的划分:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CreatePage</span><br><span class="line">  Steps            # 步骤容器, 提供了步骤布局和步骤切换等功能</span><br><span class="line">    Step           # 单一步骤容器</span><br><span class="line">      List         # 表单分组</span><br><span class="line">        List.Item  # 表单容器, 支持设置label</span><br><span class="line">          Input    # 具体表单类型</span><br><span class="line">          Address</span><br><span class="line">          NumberInput</span><br><span class="line">          Select</span><br><span class="line">          FileUpload</span><br></pre></td></tr></table></figure><blockquote><p>组件命名的建议: 对于集合型组件, 一般会使用单复数命名, 例如上面的 Steps/Step; List/Item 这种形式也比较常见, 例如 Form/Form.Item, 这种形式比较适合作为子组件形式. 可以学习一下第三方组件库是怎么给组件命名的.</p></blockquote><p>再看一下<code>PreviewPage</code>, PreviewPage 是创建后的数据预览页面, 数据结构和页面结构和 CreatePage 差不多. 将 Steps 对应到 Preview 组件, Step 对应到 Preview.Item. Input 对应到 Input.Preview:</p><p>  <img src="/images/04/PreviewPage.png" width="400"></p><p><br></p><hr><p><br></p><h3 id="3️⃣-设计组件的状态"><a href="#3️⃣-设计组件的状态" class="headerlink" title="3️⃣ 设计组件的状态"></a>3️⃣ 设计组件的状态</h3><p>对于 ListPage 来说状态比较简单, 这里主要讨论 CreatePage 的状态. CreatePage 的特点:</p><ul><li>表单组件使用受控模式, 本身不会存储表单的状态. 另外表单之间的状态可能是联动的</li><li>状态需要在 CreatePage 和 PreviewPage 之间共享</li><li>需要对表单进行统一校验</li><li>草稿保存</li></ul><p>由于需要在 CreatePage 和 PreviewPage 中共享数据, 表单的状态应该抽取和提升到父级. 在这个项目的实际开发中, 我的做法是创建一个 FormStore 的 Context 组件, 下级组件通过这个 context 来统一存储数据. 另外我决定使用配置的方式, 来渲染动态这些表单. 大概的结构如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// CreatePage/index.tsx</span><br><span class="line">&lt;FormStore defaultValue=&#123;draft&#125; onChange=&#123;saveDraft&#125;&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&quot;/create/preview&quot; component=&#123;Preview&#125; /&gt;</span><br><span class="line">    &lt;Route path=&quot;/create&quot; component=&#123;Create&#125; /&gt;</span><br><span class="line">  &lt;/Switch&gt;</span><br><span class="line">&lt;/FormStore&gt;</span><br><span class="line"></span><br><span class="line">// CreatePage/Create.tsx</span><br><span class="line">&lt;Steps&gt;</span><br><span class="line">  &#123;steps.map(i =&gt;</span><br><span class="line">    &lt;Step key=&#123;i.name&#125;&gt;</span><br><span class="line">      &lt;FormRenderer forms=&#123;i.forms&#125;  /&gt; &#123;/* forms为表单配置, 根据配置的表单类型渲染表单组件, 从FormStore的获取和存储值 */&#125;</span><br><span class="line">    &lt;/Step&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/Steps&gt;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="8-文档"><a href="#8-文档" class="headerlink" title="8. 文档"></a>8. 文档</h2><p>组件的文档化推荐使用<a href="https://storybook.js.org" target="_blank" rel="noopener">Storybook</a>, 这是一个组件 <code>Playground</code>, 有以下特性</p><ul><li>可交互的组件示例</li><li>可以用于展示组件的文档. 支持 props 生成和 markdown</li><li>可以用于组件测试. 支持组件结构测试, 交互测试, 可视化测试, 可访问性或者手动测试</li><li>丰富的插件生态</li></ul><p><a href="https://storybooks-official.netlify.com" target="_blank" rel="noopener">React 示例</a>. 由于篇幅原因, Storybook 就不展开细节, 有兴趣的读者可以参考官方文档.</p><p><br></p><hr><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://jaysoo.ca/2016/02/28/organizing-redux-application/#rule-2-create-strict-module-boundaries" target="_blank" rel="noopener">Three Rules For Structuring (Redux) Applications</a></li><li><a href="https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/" target="_blank" rel="noopener">How To Scale React Applications</a></li><li><a href="http://cn.redux.js.org/docs/faq/CodeStructure.html" target="_blank" rel="noopener">Redux 常见问题：代码结构</a></li><li><a href="https://basarat.gitbooks.io/typescript/docs/tips/defaultIsBad.html" target="_blank" rel="noopener">export default considered harmful</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html" target="_blank" rel="noopener">JavaScript 模块的循环加载</a></li><li><a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">thinking-in-react</a></li><li><a href="https://speakerdeck.com/vasa/building-multitenant-ui-with-react-dot-js?slide=16" target="_blank" rel="noopener">Building Multitenant UI with React.js</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个复杂的应用都是由简单的应用发展而来的, 随着越来越多的功能加入项目, 代码就会变得越来越难以控制. 本文章主要探讨在大型项目中如何对组件进行组织, 让项目具备可维护性.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系列目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结01 - 类型检查</title>
    <link href="https://bobi.ink/2019/05/10/react-component-design-01/"/>
    <id>https://bobi.ink/2019/05/10/react-component-design-01/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-15T01:12:07.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系列引言"><a href="#系列引言" class="headerlink" title="系列引言"></a>系列引言</h2><p>最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对<strong>React 组件设计的相关实践和规范</strong>整理了一些文档, 将部分章节分享了出来. 由于经验有限, 文章可能会有某些错误, 希望大家指出, 互相交流.</p><p>由于篇幅太长, 所以拆分为几篇文章. 主要有以下几个主题:</p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li>05 状态管理 待更新</li></ul><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>静态类型检查对于当今的前端项目越来越不可或缺, 尤其是大型项目. <strong>它可以在开发时就避免许多类型问题, 减少低级错误的; 另外通过类型智能提示, 可以提高编码的效率; 有利于书写自描述的代码(类型即文档); 方便代码重构(配合 IDE 可以自动重构)</strong>. 对于静态类型检查的好处这里就不予赘述, 读者可以查看这个回答<a href="https://www.zhihu.com/question/28016252/answer/39056940" target="_blank" rel="noopener">flow.js/typescript 这类定义参数类型的意义何在？</a>.</p><p>Javascript 的类型检查器主要有<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">Typescript</a>和<a href="https://flow.org" target="_blank" rel="noopener">Flow</a>, 笔者两者都用过, Typescript 更强大一些, 可以避免很多坑, 有更好的生态(例如第三方库类型声明), 而且 VSCode 内置支持. 而对于 Flow, 连 Facebook 自己的开源项目(如 Yarn, Jest)都抛弃了它, 所以不建议入坑. 所以本篇文章使用 Typescript(v3.3) 对 React 组件进行类型检查声明</p><p>建议通过官方文档来<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">学习 Typescript</a>. 笔者此前也整理了 Typescript 相关的<a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">思维导图(mindnode)</a></p><blockquote><p>当然 Flow 也有某些 Typescript 没有的特性: <a href="https://github.com/niieani/typescript-vs-flowtype" target="_blank" rel="noopener">typescript-vs-flowtype</a></p></blockquote><blockquote><p>React 组件类型检查依赖于<code>@types/react</code>和<code>@types/react-dom</code></p></blockquote><blockquote><p>直接上手使用试用 <br> <a href="https://codesandbox.io/s/5vx5wwmkvx?fontsize=14" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit typescript-react-playground"></a></p></blockquote><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#系列引言">系列引言</a></li><li><a href="#类型检查">类型检查</a><ul><li><a href="#1-函数组件">1. 函数组件</a><ul><li><a href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出">1️⃣ <strong>使用<code>ComponentNameProps</code> 形式命名 Props 类型, 并导出</strong></a></li><li><a href="#2️⃣-优先使用fc类型来声明函数组件">2️⃣ <strong>优先使用<code>FC</code>类型来声明函数组件</strong></a></li><li><a href="#3️⃣-不要直接使用export-default导出组件">3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</a></li><li><a href="#4️⃣-默认-props-声明">4️⃣ <strong>默认 props 声明</strong></a></li><li><a href="#5️⃣-泛型函数组件">5️⃣ <strong>泛型函数组件</strong></a></li><li><a href="#6️⃣-子组件声明">6️⃣ <strong>子组件声明</strong></a></li><li><a href="#7️⃣-forwarding-refs">7️⃣ <strong>Forwarding Refs</strong></a></li></ul></li><li><a href="#2-类组件">2. 类组件</a><ul><li><a href="#1️⃣-继承-component-或-purecomponent">1️⃣ <strong>继承 Component 或 PureComponent</strong></a></li><li><a href="#2️⃣-使用static-defaultprops定义默认-props">2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></a></li><li><a href="#3️⃣-子组件声明">3️⃣ <strong>子组件声明</strong></a></li><li><a href="#4️⃣-泛型">4️⃣ <strong>泛型</strong></a></li></ul></li><li><a href="#3-高阶组件">3. 高阶组件</a></li><li><a href="#4-render-props">4. Render Props</a></li><li><a href="#5-context">5. Context</a></li><li><a href="#6-杂项">6. 杂项</a><ul><li><a href="#1️⃣-使用handleevent命名事件处理器">1️⃣ <strong>使用<code>handleEvent</code>命名事件处理器</strong>.</a></li><li><a href="#2️⃣-内置事件处理器的类型">2️⃣ <strong>内置事件处理器的类型</strong></a></li><li><a href="#3️⃣-自定义组件暴露事件处理器类型">3️⃣ <strong>自定义组件暴露事件处理器类型</strong></a></li><li><a href="#4️⃣-获取原生元素-props-定义">4️⃣ <strong>获取原生元素 props 定义</strong></a></li><li><a href="#5️⃣-不要使用-proptypes">5️⃣ <strong>不要使用 PropTypes</strong></a></li><li><a href="#6️⃣-styled-components">6️⃣ <strong>styled-components</strong></a></li><li><a href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明">7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></a></li><li><a href="#8️⃣-为文档生成做好准备">8️⃣ <strong>为文档生成做好准备</strong></a></li><li><a href="#9️⃣-开启-strict-模式">9️⃣ <strong>开启 strict 模式</strong></a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h3 id="1-函数组件"><a href="#1-函数组件" class="headerlink" title="1. 函数组件"></a>1. 函数组件</h3><p>React Hooks 出现后, 函数组件有了更多出镜率. 由于函数组件只是普通函数, 它非常容易进行类型声明</p><p><br></p><h4 id="1️⃣-使用componentnameprops-形式命名-props-类型-并导出"><a href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出" class="headerlink" title="1️⃣ 使用ComponentNameProps 形式命名 Props 类型, 并导出"></a>1️⃣ <strong>使用<code>ComponentNameProps</code> 形式命名 Props 类型, 并导出</strong></h4><p><br></p><h4 id="2️⃣-优先使用fc类型来声明函数组件"><a href="#2️⃣-优先使用fc类型来声明函数组件" class="headerlink" title="2️⃣ 优先使用FC类型来声明函数组件"></a>2️⃣ <strong>优先使用<code>FC</code>类型来声明函数组件</strong></h4><p><code>FC</code>是<code>FunctionComponent</code>的简写, 这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Props类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyComponent: FC&lt;MyComponentProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>你也可以直接使用普通函数来进行组件声明, 下文会看到这种形式更加灵活:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  <span class="comment">// 手动声明children</span></span><br><span class="line">  children?: React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props: MyComponentProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="3️⃣-不要直接使用export-default导出组件"><a href="#3️⃣-不要直接使用export-default导出组件" class="headerlink" title="3️⃣ 不要直接使用export default导出组件."></a>3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</h4><p>这种方式导出的组件在<code>React Inspector</code>查看时会显示为<code>Unknown</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (props: &#123;&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>如果非得这么做, 请使用<code>命名 function</code> 定义:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">props: &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;xxx&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-默认-props-声明"><a href="#4️⃣-默认-props-声明" class="headerlink" title="4️⃣ 默认 props 声明"></a>4️⃣ <strong>默认 props 声明</strong></h4><p>实际上截止目前对于上面的使用<code>FC</code>类型声明的函数组件并<a href="https://github.com/Microsoft/TypeScript/issues/27425" target="_blank" rel="noopener">不能完美支持 defaultProps</a>:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ❌! missing name</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure><p>笔者一般喜欢这样子声明默认 props:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>; <span class="comment">// 声明为可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用对象默认属性值语法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name = 'TJ' &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br></pre></td></tr></table></figure><p>如果非得使用 defaultProps, 可以这样子声明 👇. Typescript 可以推断和在函数上定义的属性, 这个特性在 Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#properties-declarations-on-functions" target="_blank" rel="noopener">3.1</a>开始支持.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用函数参数声明</span></span><br><span class="line"><span class="comment">// PropsWithChildren只是扩展了children, 完全可以自己声明</span></span><br><span class="line"><span class="comment">// type PropsWithChildren&lt;P&gt; = P &amp; &#123;</span></span><br><span class="line"><span class="comment">//    children?: ReactNode;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">const</span> Hello = <span class="function">(<span class="params">&#123; name &#125;: PropsWithChildren&lt;HelloProps&gt;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ✅ ok!</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure><p>这种方式也非常简洁, 只不过 defaultProps 的类型和组件本身的 props 没有关联性, 这会使得 defaultProps 无法得到类型约束, 所以必要时进一步显式声明 defaultProps 的类型:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Hello.defaultProps = &#123; name: <span class="string">'TJ'</span> &#125; <span class="keyword">as</span> Partial&lt;HelloProps&gt;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5️⃣-泛型函数组件"><a href="#5️⃣-泛型函数组件" class="headerlink" title="5️⃣ 泛型函数组件"></a>5️⃣ <strong>泛型函数组件</strong></h4><p>泛型在一下列表型或容器型的组件中比较常用, 直接使用<code>FC</code>无法满足需求:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ListProps&lt;T&gt; &#123;</span><br><span class="line">  visible: <span class="built_in">boolean</span>;</span><br><span class="line">  list: T[];</span><br><span class="line">  renderItem: <span class="function">(<span class="params">item: T, index: <span class="built_in">number</span></span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: ListProps&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;List</span><br><span class="line">      list=&#123;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">      renderItem=&#123;<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/*自动推断i为number类型*/</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="6️⃣-子组件声明"><a href="#6️⃣-子组件声明" class="headerlink" title="6️⃣ 子组件声明"></a>6️⃣ <strong>子组件声明</strong></h4><p>使用<code>Parent.Child</code>形式的 JSX 可以让节点父子关系更加直观, 它类似于一种命名空间的机制, 可以避免命名冲突. 相比<code>ParentChild</code>这种命名方式, <code>Parent.Child</code>更为优雅些. 当然也有可能让代码变得啰嗦.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutProps &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutHeaderProps &#123;&#125; <span class="comment">// 采用ParentChildProps形式命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutFooterProps &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">props: PropsWithChildren&lt;LayoutProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 作为父组件的属性</span></span><br><span class="line"><span class="regexp">Layout.Header = (props: PropsWithChildren&lt;LayoutHeaderProps&gt;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;div className="header"&gt;&#123;props.children&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Layout.Footer = <span class="function">(<span class="params">props: PropsWithChildren&lt;LayoutFooterProps&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"footer"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Test</span></span><br><span class="line"><span class="regexp">&lt;Layout&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Layout.Header&gt;header&lt;/</span>Layout.Header&gt;</span><br><span class="line">  &lt;Layout.Footer&gt;footer&lt;<span class="regexp">/Layout.Footer&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Layout&gt;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="7️⃣-forwarding-refs"><a href="#7️⃣-forwarding-refs" class="headerlink" title="7️⃣ Forwarding Refs"></a>7️⃣ <strong>Forwarding Refs</strong></h4><p><code>React.forwardRef</code> 在 16.3 新增, 可以用于转发 ref, 适用于 HOC 和函数组件.</p><p>函数组件在 16.8.4 之前是不支持 ref 的, 配合 forwardRef 和 useImperativeHandle 可以让函数组件向外暴露方法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment"> * MyModal.tsx</span></span><br><span class="line"><span class="comment"> ****************************/</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useImperativeHandle, FC, useRef, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalProps &#123;</span><br><span class="line">  title?: React.ReactNode;</span><br><span class="line">  onOk?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onCancel?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露的方法, 适用`&#123;ComponentName&#125;Methods`形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalMethods &#123;</span><br><span class="line">  show(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyModal = React.forwardRef&lt;MyModalMethods, MyModalProps&gt;<span class="function">(<span class="params">(<span class="params">props, ref</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> [visible, setVisible] = useState(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 初始化ref暴露的方法</span></span></span></span><br><span class="line"><span class="function"><span class="params">  useImperativeHandle(<span class="params">ref, (<span class="params"></span>) =&gt; (<span class="params">&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">    show: (<span class="params"></span>) =&gt; setVisible(<span class="params"><span class="literal">true</span></span>),</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">  &#125;</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> &lt;Modal visible=&#123;visible&#125;&gt;...&lt;/Modal&gt;;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/*******************</span></span><br><span class="line"><span class="function"> * <span class="params">Test</span>.<span class="params">tsx</span></span></span><br><span class="line"><span class="function"> *******************/</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">Test</span>: <span class="params">FC</span>&lt;&#123;&#125;&gt; = <span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 引用</span></span><br><span class="line">  <span class="keyword">const</span> modal = useRef&lt;MyModalMethods | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> confirm = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modal.current) &#123;</span><br><span class="line">      modal.current.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleOk = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;confirm&#125;&gt;show&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MyModal ref=&#123;modal&#125; onOk=&#123;handleOk&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="2-类组件"><a href="#2-类组件" class="headerlink" title="2. 类组件"></a>2. 类组件</h3><p>相比函数, 基于类的类型检查可能会更好理解(例如那些熟悉传统面向对象编程语言的开发者).</p><h4 id="1️⃣-继承-component-或-purecomponent"><a href="#1️⃣-继承-component-或-purecomponent" class="headerlink" title="1️⃣ 继承 Component 或 PureComponent"></a>1️⃣ <strong>继承 Component 或 PureComponent</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先导出Props声明, 同样是&#123;ComponentName&#125;Props形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> CounterProps &#123;</span><br><span class="line">  defaultCount: <span class="built_in">number</span>; <span class="comment">// 可选props, 不需要?修饰</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组件状态, 不需要暴露</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类注释</span></span><br><span class="line"><span class="comment"> * 继承React.Component, 并声明Props和State类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Counter <span class="keyword">extends</span> React.Component&lt;CounterProps, State&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    defaultCount: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化State</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> state = &#123;</span><br><span class="line">    count: <span class="keyword">this</span>.props.defaultCount,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 声明周期方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 建议靠近componentDidMount, 资源消费和资源释放靠近在一起, 方便review</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentWillUnmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidCatch() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidUpdate(prevProps: CounterProps, prevState: State) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 渲染函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.decrement&#125;&gt;Decrement&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>**</span><br><span class="line">   * ① 组件私有方法, 不暴露</span><br><span class="line">   * ② 使用类实例属性+箭头函数形式绑定<span class="keyword">this</span></span><br><span class="line">   *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  private increment = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count + 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  private decrement = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count - 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="2️⃣-使用static-defaultprops定义默认-props"><a href="#2️⃣-使用static-defaultprops定义默认-props" class="headerlink" title="2️⃣ 使用static defaultProps定义默认 props"></a>2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></h4><p>Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx" target="_blank" rel="noopener">3.0</a>开始支持对使用 defaultProps 对 JSX props 进行推断, 在 defaultProps 中定义的 props 可以不需要’?’可选操作符修饰. 代码如上 👆</p><p><br></p><h4 id="3️⃣-子组件声明"><a href="#3️⃣-子组件声明" class="headerlink" title="3️⃣ 子组件声明"></a>3️⃣ <strong>子组件声明</strong></h4><p>类组件可以使用静态属性形式声明子组件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Layout <span class="keyword">extends</span> React.Component&lt;LayoutProps&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Header = Header;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Footer = Footer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-泛型"><a href="#4️⃣-泛型" class="headerlink" title="4️⃣ 泛型"></a>4️⃣ <strong>泛型</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> List&lt;T&gt; <span class="keyword">extends</span> React.Component&lt;ListProps&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="3-高阶组件"><a href="#3-高阶组件" class="headerlink" title="3. 高阶组件"></a>3. 高阶组件</h3><p>在 React Hooks 出来之前, 高阶组件是 React 的一个重要逻辑复用方式. 相比较而言高阶组件比较重, 且难以理解, 容易造成<code>嵌套地狱(wrapper)</code>. 另外对 Typescript 类型化也不友好(以前会使用<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/9c1c7e78a9a2b4af8e2cda842c3693f67bb9e42d/types/react-router/index.d.ts#L137" target="_blank" rel="noopener">Omit</a>来计算导出的 props). 所以新项目还是建议使用 React Hooks.</p><p>一个简单的高阶组件:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给指定组件注入'主题'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withTheme</span>&lt;<span class="title">P</span>&gt;(<span class="params">Component: React.ComponentType&lt;P &amp; ThemeProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * WithTheme 自己暴露的Props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件的props, 忽略ThemeProps, 外部不需要传递这些属性</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">type</span> WithThemeProps = P &amp; OwnProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> WithTheme = <span class="function">(<span class="params">props: WithThemeProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">    <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">      primary: <span class="string">'red'</span>,</span><br><span class="line">      secondary: <span class="string">'blue'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  WithTheme.displayName = <span class="string">`withTheme<span class="subst">$&#123;Component.displayName&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> WithTheme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">const</span> Foo: FC&lt;&#123; a: <span class="built_in">number</span> &#125; &amp; ThemeProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &lt;div style=&#123;&#123; color: props.primary &#125;&#125; /&gt;;</span><br><span class="line"><span class="keyword">const</span> FooWithTheme = withTheme(Foo);</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  &lt;FooWithTheme a=&#123;<span class="number">1</span>&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再重构一下:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽取出通用的高阶组件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> HOC&lt;InjectedProps, OwnProps = &#123;&#125;&gt; = &lt;P&gt;(</span><br><span class="line">  Component: React.ComponentType&lt;P &amp; InjectedProps&gt;,</span><br><span class="line">) =&gt; React.ComponentType&lt;P &amp; OwnProps&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withTheme: HOC&lt;ThemeProps&gt; = <span class="function"><span class="params">Component</span> =&gt;</span> props =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">  <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用高阶组件还有一些痛点:</p><ul><li>无法完美地使用 ref(这已不算什么痛点)<ul><li>在 React.forwardRef 发布之前, 有一些库会使用 innerRef 或者 wrapperRef, 转发给封装的组件的 ref.</li><li>无法推断 ref 引用组件的类型, 需要显式声明.</li></ul></li><li>高阶组件类型报错很难理解</li></ul><p><br></p><hr><p><br></p><h3 id="4-render-props"><a href="#4-render-props" class="headerlink" title="4. Render Props"></a>4. Render Props</h3><p>React 的 props(包括 children)并没有限定类型, 它可以是一个函数. 于是就有了 render props, 这是和高阶组件一样常见的模式:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeConsumerProps &#123;</span><br><span class="line">  children: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeConsumer = <span class="function">(<span class="params">props: ThemeConsumerProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fakeTheme = &#123; primary: <span class="string">'red'</span>, secondary: <span class="string">'blue'</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> props.children(fakeTheme);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line">&lt;ThemeConsumer&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">&#123; primary &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div style=&#123;&#123; color: primary &#125;&#125; /&gt;;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/ThemeConsumer&gt;;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="5-context"><a href="#5-context" class="headerlink" title="5. Context"></a>5. Context</h3><p>Context 提供了一种跨组件间状态共享机制</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Theme &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Context的类型, 以&#123;Name&#125;ContextValue命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeContextValue &#123;</span><br><span class="line">  theme: Theme;</span><br><span class="line">  onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Context, 并设置默认值, 以&#123;Name&#125;Context命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext&lt;ThemeContextValue&gt;(&#123;</span><br><span class="line">  theme: &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  onThemeChange: noop,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provider, 以&#123;Name&#125;Provider命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeProvider: FC&lt;&#123; theme: Theme; onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;&#123; theme: props.theme, onThemeChange: props.onThemeChange &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 暴露hooks, 以use&#123;Name&#125;命名</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">export function useTheme() &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="6-杂项"><a href="#6-杂项" class="headerlink" title="6. 杂项"></a>6. 杂项</h3><h4 id="1️⃣-使用handleevent命名事件处理器"><a href="#1️⃣-使用handleevent命名事件处理器" class="headerlink" title="1️⃣ 使用handleEvent命名事件处理器."></a>1️⃣ <strong>使用<code>handleEvent</code>命名事件处理器</strong>.</h4><p>如果存在多个相同事件处理器, 则按照<code>handle{Type}{Event}</code>命名, 例如 handleNameChange.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback&lt;React.MouseEventHandler&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    evt.preventDefault();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;handleClick&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2️⃣-内置事件处理器的类型"><a href="#2️⃣-内置事件处理器的类型" class="headerlink" title="2️⃣ 内置事件处理器的类型"></a>2️⃣ <strong>内置事件处理器的类型</strong></h4><p><code>@types/react</code>内置了以下事件处理器的类型 👇</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EventHandler&lt;E <span class="keyword">extends</span> SyntheticEvent&lt;<span class="built_in">any</span>&gt;&gt; = &#123; bivarianceHack(event: E): <span class="built_in">void</span> &#125;[<span class="string">'bivarianceHack'</span>];</span><br><span class="line"><span class="keyword">type</span> ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> CompositionEventHandler&lt;T = Element&gt; = EventHandler&lt;CompositionEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure><p>可以简洁地声明事件处理器类型:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ChangeEventHandler &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 可以限定具体Target的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback&lt;ChangeEventHandler&lt;HTMLInputElement&gt;&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(evt.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;input onChange=&#123;handleChange&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3️⃣-自定义组件暴露事件处理器类型"><a href="#3️⃣-自定义组件暴露事件处理器类型" class="headerlink" title="3️⃣ 自定义组件暴露事件处理器类型"></a>3️⃣ <strong>自定义组件暴露事件处理器类型</strong></h4><p>和原生 html 元素一样, 自定义组件应该暴露自己的事件处理器类型, 尤其是较为复杂的事件处理器, 这样可以避免开发者手动为每个事件处理器的参数声明类型</p><p>自定义事件处理器类型以<code>{ComponentName}{Event}Handler</code>命名. 为了和原生事件处理器类型区分, 不使用<code>EventHandler</code>形式的后缀</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadValue &#123;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露事件处理器类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> UploadChangeHandler = <span class="function">(<span class="params">value?: UploadValue, file?: File</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadProps &#123;</span><br><span class="line">  value?: UploadValue;</span><br><span class="line">  onChange?: UploadChangeHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Upload: FC&lt;UploadProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;...&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-获取原生元素-props-定义"><a href="#4️⃣-获取原生元素-props-定义" class="headerlink" title="4️⃣ 获取原生元素 props 定义"></a>4️⃣ <strong>获取原生元素 props 定义</strong></h4><p>有些场景我们希望原生元素扩展一下一些 props. 所有原生元素 props 都继承了<code>React.HTMLAttributes</code>, 某些特殊元素也会扩展了自己的属性, 例如<code>InputHTMLAttributes</code>. 具体可以参考<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/eafef8bd049017b3998939de2edbab5d8a96423b/types/react/index.d.ts#L203" target="_blank" rel="noopener"><code>React.createElement</code></a>方法的实现</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fixClass</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">T</span> <span class="title">extends</span> <span class="title">Element</span> = <span class="title">HTMLDivElement</span>,</span></span><br><span class="line"><span class="function">  <span class="title">Attribute</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt; = <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params">cls: <span class="built_in">string</span>, <span class="keyword">type</span>: keyof React.ReactHTML = 'div'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FixedClassName: FC&lt;Attribute&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="keyword">type</span>, &#123; ...props, className: <span class="string">`<span class="subst">$&#123;cls&#125;</span> <span class="subst">$&#123;props.className&#125;</span>`</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FixedClassName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Container = fixClass(<span class="string">'card'</span>);</span><br><span class="line"><span class="keyword">const</span> Header = fixClass(<span class="string">'card__header'</span>, <span class="string">'header'</span>);</span><br><span class="line"><span class="keyword">const</span> Body = fixClass(<span class="string">'card__body'</span>, <span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">const</span> Footer = fixClass(<span class="string">'card__body'</span>, <span class="string">'footer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &lt;Header&gt;header&lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Body&gt;header&lt;/</span>Body&gt;</span><br><span class="line">      &lt;Footer&gt;footer&lt;<span class="regexp">/Footer&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Container&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5️⃣-不要使用-proptypes"><a href="#5️⃣-不要使用-proptypes" class="headerlink" title="5️⃣ 不要使用 PropTypes"></a>5️⃣ <strong>不要使用 PropTypes</strong></h4><p>有了 Typescript 之后可以安全地约束 Props 和 State, 没有必要引入 React.PropTypes, 而且它的表达能力比较弱</p><p><br></p><h4 id="6️⃣-styled-components"><a href="#6️⃣-styled-components" class="headerlink" title="6️⃣ styled-components"></a>6️⃣ <strong>styled-components</strong></h4><p>styled-components 是目前最流行的<code>CSS-in-js</code>库, Typescript 在 2.9 支持泛型<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#generic-type-arguments-in-generic-tagged-templates" target="_blank" rel="noopener"><code>标签模板</code></a>. 这意味着可以简单地对 styled-components 创建的组件进行类型约束</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖于@types/styled-components</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components/macro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1&lt;&#123; active?: <span class="built_in">boolean</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; (props.active ? 'red' : 'gray')&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展已有组件</span></span><br><span class="line"><span class="keyword">const</span> NewHeader = styled(Header)&lt;&#123; customColor: <span class="built_in">string</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; props.customColor&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>了解更多<a href="https://www.styled-components.com/docs/api#typescript" target="_blank" rel="noopener">styled-components 和 Typescript</a></p><p><br></p><h4 id="7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明"><a href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明" class="headerlink" title="7️⃣ 为没有提供 Typescript 声明文件的第三方库自定义模块声明"></a>7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></h4><p>笔者一般习惯在项目根目录下(和 tsconfig.json 同在一个目录下)放置一个<code>global.d.ts</code>. 放置项目的全局声明文件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /global.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模块声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'awesome-react-component' &#123;</span><br><span class="line">  <span class="comment">// 依赖其他模块的声明文件</span></span><br><span class="line">  <span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> Foo: React.FC&lt;&#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解更多<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">如何定义声明文件</a></p><p><br></p><h4 id="8️⃣-为文档生成做好准备"><a href="#8️⃣-为文档生成做好准备" class="headerlink" title="8️⃣ 为文档生成做好准备"></a>8️⃣ <strong>为文档生成做好准备</strong></h4><p>目前社区有多种 react 组件文档生成方案, 例如<a href="https://www.docz.site" target="_blank" rel="noopener"><code>docz</code></a>, <a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener"><code>styleguidist</code></a>还有<a href="https://github.com/storybooks/storybook" target="_blank" rel="noopener">storybook</a>. 它们底层都使用<a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener">react-docgen-typescript</a>对 Typescript 进行解析. 就目前而言, 它还有些坑, 而且解析比较慢. 不管不妨碍我们使用它的风格对代码进行注释:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Props注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ColumnProps <span class="keyword">extends</span> React.HTMLAttributes&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">/** prop1 description */</span></span><br><span class="line">  prop1?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">/** prop2 description */</span></span><br><span class="line">  prop2: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * prop3 description</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  prop3: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">/** prop4 description */</span></span><br><span class="line">  prop4: <span class="string">'option1'</span> | <span class="string">'option2'</span> | <span class="string">'option3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对组件进行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Column <span class="keyword">extends</span> Component&lt;ColumnProps, &#123;&#125;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;Column&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9️⃣-开启-strict-模式"><a href="#9️⃣-开启-strict-模式" class="headerlink" title="9️⃣ 开启 strict 模式"></a>9️⃣ <strong>开启 strict 模式</strong></h4><p>为了真正把 Typescript 用起来, 应该始终开启 strict 模式, 避免使用 any 类型声明.</p><p><br></p><hr><p><br></p><h3 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h3><ul><li><a href="https://github.com/piotrwitek/react-redux-typescript-guide" target="_blank" rel="noopener">piotrwitek/react-redux-typescript-guide</a></li><li><a href="https://www.zhihu.com/question/279911703" target="_blank" rel="noopener">TypeScript 如何完美地书写 React 中的 HOC？</a></li><li><a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">Typescript 官方文档</a></li><li><a href="https://basarat.gitbooks.io/typescript/docs/why-typescript.html" target="_blank" rel="noopener">Typescript-deep-dive</a></li><li><a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">Typescript 思维导图</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系列引言&quot;&gt;&lt;a href=&quot;#系列引言&quot; class=&quot;headerlink&quot; title=&quot;系列引言&quot;&gt;&lt;/a&gt;系列引言&lt;/h2&gt;&lt;p&gt;最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对&lt;strong&gt;R
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Rx建模入门</title>
    <link href="https://bobi.ink/2019/04/19/rxjs-by-example/"/>
    <id>https://bobi.ink/2019/04/19/rxjs-by-example/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-05-21T23:07:52.763Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何使用 Rx 的响应式编程思维来对业务逻辑进行建模, 你会了解到响应式编程的优势和业务抽象能力, 学会将现有的业务流程以数据流的方式表达出来. 你的工具库中不能少了 Rx 这件利器.</p><p>Rx 学习曲线陡峭是总所周知的, 我们接触的大部分编程语言或框架都是面向对象的. 在面对 Rx 这响应式编程的方式, 会觉得无从入手,<br>笔者也是 Rx 的初学者, 拜读过多次<a href="https://www.zhihu.com/people/sharpmaster/posts" target="_blank" rel="noopener">徐飞</a>Rx 的相关文章, 基本上都是云里雾里. 主要原因还是思维没有转换过来.</p><p>如果你不理解响应式编程的奥妙，是很难在<strong>‘面向场景编程’</strong>时考虑到 Rx 的优势. 笔者一般遵循’面向场景编程’, 即在对应的场景考虑不同的技术或框架. 可能是痛点还没有到难以忍受的地步，或许是现有应用还不够复杂，我目前为止还没接触到必须要应用 Rx 的场景.</p><p>我觉得应该反过来，采取刻意学习的方式来学习 Rx, 以流的方式来思考，再将其放在现有的场景中看是否有更简洁的解决方案或化学反应.<br>不得不说写 Rx 是一个比较有趣的事情。 但也要认识到 Rx 不是万金油，正如很多教程所说的 Rx 擅长复杂的异步协调，并不是所有场景都适合，一些问题有更简洁的解决方案</p><p><br></p><h2 id="rx-的建模过程"><a href="#rx-的建模过程" class="headerlink" title="Rx 的建模过程"></a>Rx 的建模过程</h2><p>对于 Rx 的入门者, 可以使用下面的流程, 一步一步将业务逻辑转换为 Rx 数据流来进行表达.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">流程图 -&gt; 数据流抽象 -&gt; 实现</span><br></pre></td></tr></table></figure><h3 id="①-流程图"><a href="#①-流程图" class="headerlink" title="① 流程图"></a><code>① 流程图</code></h3><p>首先从流程图开始, 这个阶段没什么特别的, 不管是响应式编程还是其他范式, 编码之前都需要缕清业务逻辑.</p><p>这个阶段使用<code>流程图</code>来描述技术无关的事务过程, 让业务逻辑更加清晰, 也方便我们识别业务流程的主体和关键事件.</p><blockquote><p>什么是业务逻辑? <a href="https://en.wikipedia.org/wiki/Business_logic" target="_blank" rel="noopener">wiki</a> 上这样定义:<br><strong>Business logic</strong> or domain logic is that part of the program which encodes the real-world business rules that determine how data can be created, displayed, stored, and changed. It prescribes how business objects interact with one another, and enforces the routes and the methods by which business objects are accessed and updated.<br><br> <strong>Business Rules</strong> describe the operations, definitions and constraints that apply to an organization. The operations collectively form a process; every business uses these processes to form systems that get things done.</p></blockquote><p><br><br><br></p><h3 id="②-数据流抽象"><a href="#②-数据流抽象" class="headerlink" title="② 数据流抽象"></a><code>② 数据流抽象</code></h3><p>Rx 的世界里面<em>一切皆流</em>, 换句话说就是<strong>面向流编程</strong>. 和<em>面向对象编程</em>把现实世界的实体抽象为对象一样. 响应式编程将业务中的<em>变动实体</em>(<em>想不到更好的词, 或者变量?</em>)抽象为流</p><p><strong>(1)首先需要识别什么是<em>变动实体</em></strong>? 变动实体一般是数据流的源头, 它驱动着业务走向. 像河流一样, 源头可能不只一个. 我认为变动实体至少具备以下特征之一:</p><ul><li>它是变动的. 例如鼠标的位置, 商品的价格, 随着时间的迁移状态会进行变动</li><li>它是业务的’输入’. 变动实体是一个系统的输入(外部事件)或者是另一个流(衍生)的输入.</li><li>它是业务的参与者(或者说业务的主体).</li><li>它表示业务的状态. 例如一个 todo 列表, 这是一个纯状态的流</li></ul><p><strong>(2)接着识别<em>变动实体</em>之间的关系</strong>. 主体之间的关系也就是流之间的关系, 这是 Rx 建模的核心. 只有理解了主体之间的关系, 才能将主体与业务流程串联起来, 才能真正地使用数据流的方式将业务表达出来. 在<a href="https://www.jianshu.com/p/c95e29854cb1" target="_blank" rel="noopener">重新理解响应式编程</a>一文中对’响应式编程’的定义和笔者的理解非常契合:</p><blockquote><p>响应式编程是一种通过异步和数据流来构建事务关系的编程模型 . 事务关系是响应式编程的核心理念, “数据流”和“异步”是实现这个核心理念的关键.</p></blockquote><p>这种关系和面向对象的类关系是不一样的, 面向对象的关系一般是指依赖关系. 而<strong>数据流之间关系, 是业务之间的实际关系</strong>, 比如流程 b 依赖流程 a, 数据流是变动实体之间的沟通桥梁.</p><p>一般以下面的方法来构建流之间的关系:</p><ul><li>分治: 将业务划分为多个模块(流), 一个大的流总是由小的流组成, 小的流职责更单一, 更容易理解和测试</li><li>变换: 将流映射为另外一个流. 一般用于状态变更或业务衍生(高阶流变换)</li><li>合并: 像河流一样, 数据流最终是需要汇聚在一起注入大海的. 拆分和合并的方式都是依赖于所要表达的业务逻辑</li></ul><p>总的来说变动实体一般就是业务的’<strong>输入</strong>‘, 我们首先把它们确定为流, 再根据关系衍生出其他流(<strong>输出</strong>). 对于流本身来说, <strong>本质上只有输入和输出的关系</strong>:</p><p><img src="/images/03/stream.png" alt="stream"></p><p>例如 increment$和decrement$就是 action$的输入, action$就是 count$的输入, 以此类推. <strong>响应式编程将复杂业务关系转换成原始的输出/输出关系</strong></p><p><strong>(3)符合函数式编程的约束</strong>. 一般来说, 我们说的响应式编程指的是<code>函数式响应式编程(Functional reactive programming FRP)</code>, 所以需要符合函数式的一些约束:</p><ul><li><code>纯函数(Pure)</code>: 函数只是输入参数到输出结果的映射, 不要产生副作用<ul><li>没有共享状态: 不依赖外部变量来维护流程的状态.</li><li>幂等性: 幂等性在复杂流程中很重要, 这使得整个流程可被重试</li><li>没有副作用: 可预测, 可测试.</li></ul></li><li><code>不可变性(Immuatability)</code>: 数据一旦产生, 就肯定它的值不会变化, 这有利于代码的理解. 易于并发</li><li><code>声明式(Declarative)</code>:<ul><li>函数式编程和命令式编程相比有较高的抽象级别, 他可以让你专注于定义与事件相互依存的业务逻辑, 而不是在实现细节上. 换句话说, 函数式编程定义关系, 而命令式编程定义步骤</li><li>集中的逻辑. Rx 自然而然在一处定义逻辑, 避免其他范式逻辑分散在代码库的各个地方. 另外 Rx 的 Observable 通过订阅来创建资源, 通过取消订阅来释放资源, 一般开发几乎不需要去关心资源的生命周期, 例如时间器.</li></ul></li></ul><p>这个阶段将第一个阶段的流程图转换为 Rx <code>弹珠图(Marble Diagrams)</code>表示, 弹珠图可以描述流之间关系, 表现’时间’的流逝, 让复杂的数据流更容易理解</p><p><br><br><br></p><h3 id="③-实现"><a href="#③-实现" class="headerlink" title="③ 实现"></a><code>③ 实现</code></h3><p>这个阶段就是把弹珠图翻译为实现代码, 根据需求在 rxjs 工具箱中查找合适的操作符. 当缕清了业务逻辑, 使用数据流进行建模后,<br>代码实现就是一件很简单的事情了.</p><blockquote><p>可以配合 Rxjs 官方的<a href="https://rxjs.dev/operator-decision-tree" target="_blank" rel="noopener">操作符决策树</a>选择合适的操作符</p></blockquote><p><br></p><hr><p><br></p><p>下面使用例子来体会 Rx 的编程思维:</p><h2 id="example-1-c-a-b"><a href="#example-1-c-a-b" class="headerlink" title="Example 1: c := a + b"></a>Example 1: c := a + b</h2><p>这是最简单的实例, 我们期望当 a 和 b 变动时能够响应到 c, 我们按照上述的步骤对这个需求进行建模:</p><ul><li><p><code>流程</code>:</p><p><img src="/images/03/process-02.png" alt="c=a+b"></p></li><li><p><code>数据流抽象</code>: 从上可以识别出两个变动的实体 a 和 b, 所以 a 和 b 都可以视作流, 那么 c 就是 a 和 b 衍生出来的流, 表示 a 和 b 的实时加法结果, 使用弹珠图来描述三者的关系:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">a$</span>: ----1------------2---------------</span><br><span class="line"><span class="meta">b$</span>: --2-------4------------6------8------</span><br><span class="line">              \ (a + b) /</span><br><span class="line"><span class="meta">c$</span>: ----3-----5------6-----8------10-----</span><br></pre></td></tr></table></figure></li><li><p><code>代码实现</code>: 由弹珠图可以看出, c$流的输出值就是a$和 b$输出值的实时计算结果, 也就是说c$接收来自 a$和b$ 的最新数据, 输出他们的和.<br>另外由原本的两个流合并为单个流, 在 rxjs 工具箱中可以找到<code>combineLatest</code>操作符符合该场景. 代码实现如下:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a$ = interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> b$ = interval(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">a$.pipe(combineLatest(b$))</span><br><span class="line">  .pipe(map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b))</span><br><span class="line">  .subscribe(<span class="function"><span class="params">sum</span> =&gt;</span> <span class="built_in">console</span>.log(sum));</span><br></pre></td></tr></table></figure></li></ul><p><br></p><hr><p><br></p><h2 id="example-2-元素拖拽的例子"><a href="#example-2-元素拖拽的例子" class="headerlink" title="Example 2: 元素拖拽的例子"></a>Example 2: 元素拖拽的例子</h2><p>元素拖拽也是 Rx 的经典例子的的例子. 假设我们需要先移动端和桌面端都支持元素拖拽移动.</p><p><code>流程图</code></p><p><img src="/images/03/process-01.png" alt></p><p><code>数据流抽象</code></p><p>这里使用分治的方法, 将流程进行一步步拆解, 然后使用弹珠图的形式进行描述.</p><p>由上面的流程图可以识别出来, down, move 以及 up 都是<code>变动实体</code>, 我们可以将他们视作’流’.</p><p>① down/move/up 都是抽象的事件, 在桌面端下是 mousedown/mousemove/mouseup, 移动端下对应的是<br>touchstart/touchmove/touchend. 我们不区分这些事件, 例如接收到 mousedown 或 touchstart 事件都认为是一个’down’事件. 所以事件监听的数据流如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 1</span><br><span class="line"><span class="meta">mousedown$</span> : ---d----------d--------</span><br><span class="line"><span class="meta">touchstart$</span>: -s---s-----------s-----</span><br><span class="line">        \(merge)/</span><br><span class="line"><span class="meta">down$</span>      : -s-d-s--------d--s-----</span><br></pre></td></tr></table></figure><p>move 和 up 事件同理</p><p>② 接下来要识别 up$, move$, down$ 三个数据流之间的关系, down 事件触发后我们才会去监听 move 和 up 事件, 也就是说由 down$可以衍生出 move$和 up$流. 在 up 事件触发后整个流程就终止. up$流决定了整个流程的生命周期的结束</p><p>使用弹珠图的描述三者的关系如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 2</span><br><span class="line"><span class="meta">down$</span>: -----d-------------------------</span><br><span class="line">             \</span><br><span class="line"><span class="meta">up$</span>  :        ----------u|</span><br><span class="line"><span class="meta">move$</span>:        -m--m--m---|</span><br></pre></td></tr></table></figure><p>③ 一个拖拽结束后还可以重新再发起拖拽, 即我们会持续监听 down 事件. 上面的流程还规定如果当前拖拽还未结束,<br>其他 down 事件应该被忽略, 在移动端下多点触摸是可能导致多个 down 事件触发的.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 3</span><br><span class="line"><span class="meta">down$</span>: ---d---d--d---------d------    # 中间两个事件因为拖拽未完成被忽略</span><br><span class="line">           \                \</span><br><span class="line"><span class="meta">up$</span>:        -----u|          ------u|</span><br><span class="line"><span class="meta">move$</span>:      -m-mm-|          m-m-m--|</span><br></pre></td></tr></table></figure><p><code>实现</code>:</p><p>有了弹珠图后, 就是把翻译问题了, 现在就打开 rxjs 的工具箱, 找找有什么合适的工具.</p><p>首先是抽象事件的处理. 由#1 可以看出, 这就是一个数据流合并, 这个适合使用<code>merge</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">merge(fromEvent(el, <span class="string">'touchstart'</span>), fromEvent(el, <span class="string">'mousedown'</span>));</span><br></pre></td></tr></table></figure><p>down$流的切换可以使用<code>exhaustMap</code>操作符, 这个操作符可以将输出值映射为Observable, 最后再使用exhaust操作符对Observable进行合并.<br>这可以满足我们’当一个拖拽未结束时, 新发起的 down$输出会被忽略, 直到拖拽完结’的需求</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">down$</span><br><span class="line">  .pipe(</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">evt</span> =&gt;</span> <span class="comment">/* 转换为新的Observable流 */</span>)</span><br></pre></td></tr></table></figure><p>使用 exhaustMap 来将 down$输出值转换为move$ 流, 并在 up$ 输出后结束, 可以使用<code>takeUntil</code>操作符:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">down$</span><br><span class="line">  .pipe(</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">      evt.preventDefault();</span><br><span class="line">      <span class="keyword">if</span> (evt.type === <span class="string">'mousedown'</span>) &#123;</span><br><span class="line">        <span class="comment">// 鼠标控制</span></span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = evt <span class="keyword">as</span> MouseEvent;</span><br><span class="line">        <span class="keyword">return</span> mouseMove$.pipe(</span><br><span class="line">          map(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              deltaX: (evt <span class="keyword">as</span> MouseEvent).clientX - clientX,</span><br><span class="line">              deltaY: (evt <span class="keyword">as</span> MouseEvent).clientY - clientY,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;),</span><br><span class="line">          takeUntil(mouseUp$),</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 触摸事件</span></span><br><span class="line">        <span class="keyword">const</span> &#123; touches &#125; = evt <span class="keyword">as</span> TouchEvent;</span><br><span class="line">        <span class="keyword">const</span> touch = touches[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = touch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> getTouch = <span class="function">(<span class="params">evt: TouchEvent</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> touches = <span class="built_in">Array</span>.from(evt.changedTouches);</span><br><span class="line">          <span class="keyword">return</span> touches.find(<span class="function"><span class="params">t</span> =&gt;</span> t.identifier === touch.identifier);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> touchFilter = filter(<span class="function">(<span class="params">e: Event</span>) =&gt;</span> !!getTouch(e <span class="keyword">as</span> TouchEvent));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> touchMove$.pipe(</span><br><span class="line">          touchFilter,</span><br><span class="line">          map(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> touch = getTouch(evt <span class="keyword">as</span> TouchEvent)!;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              deltaX: touch.clientX - clientX,</span><br><span class="line">              deltaY: touch.clientY - clientY,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;),</span><br><span class="line">          takeUntil(touchUp$.pipe(touchFilter)),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">delta</span> =&gt;</span> &#123;</span><br><span class="line">    el.style.transform = <span class="string">`translate(<span class="subst">$&#123;delta.deltaX&#125;</span>px, <span class="subst">$&#123;delta.deltaY&#125;</span>px)`</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="example-3-todos"><a href="#example-3-todos" class="headerlink" title="Example 3: Todos"></a>Example 3: Todos</h2><p>如果使用 rxjs 来创建 Todos 应用, 首先是<code>流程图</code>:</p><p><img src="/images/03/process-03.png" alt></p><p><code>数据流抽象</code>:</p><p>首先识别变动的实体, 变动的实体就是 todos 列表, 所以可以认为 todos 列表就是一个流. 它从 localStorage 中恢复<br>初始化状态. 由<code>新增</code>, <code>删除</code>等事件触发状态改变, 这些事件也可以视作流</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">add$</span>:      --a-----a------</span><br><span class="line"><span class="meta">modify$</span>:   ----m----------</span><br><span class="line"><span class="meta">remove$</span>    -------r-------</span><br><span class="line"><span class="meta">complete$</span>: ------c----c---</span><br><span class="line">             \(merge)/</span><br><span class="line"><span class="meta">update$</span>    --a-m-cra--c--- # 各种事件合并为update$流</span><br><span class="line">              \(reduce)/</span><br><span class="line"><span class="meta">todos$</span>:    i-u-u-uuu--u---- # i 为初始化数据, update$的输出将触发重新计算状态</span><br></pre></td></tr></table></figure><p>todos$流会响应到 view 上, 另一方面需要持久化到本地存储. 也就是说这是一个多播流.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">todos$</span>: i-u-u-uuu--u---- #</span><br><span class="line">          \(debounce)/</span><br><span class="line"><span class="meta">save$</span>   i--u--u---u----- # 存储流, 使用debounce来避免频繁存储</span><br></pre></td></tr></table></figure><p>并行渲染到页面:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">todos$</span>: i-u-u-uuu--u---- #</span><br><span class="line">       \(render)/</span><br><span class="line"><span class="meta">dom$</span>:   i-u-u-uuu--u---- # dom渲染, 假设也是流(cycle.js就是如此)</span><br></pre></td></tr></table></figure><p>这个实例的数据流和 Redux 的模型非常像, add$, modify$, remove$和complete$就是 Action, todos 流会使用<br>类似 Reducer 的机制来处理这些 Action 生成新的 State</p><p><img src="/images/03/redux.png" alt="redux"></p><p><code>代码实现</code>:</p><p>首先 add$, modify$以及 remove$和complete$可以分别使用一个 Subject 对象来表示, 用于接收外部事件. 其实还可以简化为一个流,<br>它们的区别只是参数</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Action&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  payload: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INIT_ACTION = <span class="string">'INIT'</span>; <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> ADD_ACTION = <span class="string">'ADD'</span>;</span><br><span class="line"><span class="keyword">const</span> REMOVE_ACTION = <span class="string">'REMOVE'</span>;</span><br><span class="line"><span class="keyword">const</span> MODIFY_ACTION = <span class="string">'MODIFY'</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETE_ACTION = <span class="string">'COMPLETE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update$ = <span class="keyword">new</span> Subject&lt;Action&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: ADD_ACTION,</span><br><span class="line">    payload: value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: REMOVE_ACTION,</span><br><span class="line">    payload: id,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: COMPLETE_ACTION,</span><br><span class="line">    payload: id,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">id: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: MODIFY_ACTION,</span><br><span class="line">    payload: &#123; id, value &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建todos$流, 对update$ 的输出进行 reduce:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化Store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialStore</span>(<span class="params"></span>): <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="built_in">window</span>.localStorage.getItem(STORAGE_KEY);</span><br><span class="line">  <span class="keyword">return</span> value ? <span class="built_in">JSON</span>.parse(value) : &#123; list: [] &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos$ = update$.pipe(</span><br><span class="line">  <span class="comment">// 从INIT_ACTION 触发scan初始化</span></span><br><span class="line">  startWith(&#123; <span class="keyword">type</span>: INIT_ACTION &#125; <span class="keyword">as</span> Action),</span><br><span class="line">  <span class="comment">// reducer</span></span><br><span class="line">  scan&lt;Action, Store&gt;<span class="function">(<span class="params">(<span class="params">state, &#123; <span class="keyword">type</span>, payload &#125;</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> produce(<span class="params">state, draftState =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">let</span> idx: <span class="built_in">number</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">switch</span> (<span class="params"><span class="keyword">type</span></span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> ADD_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          draftState.list.push(<span class="params">&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">            id: <span class="built_in">Date</span>.now(<span class="params"></span>).toString(<span class="params"></span>),</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">            value: payload,</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          &#125;</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> MODIFY_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload.id</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list[idx].value = payload.value;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> REMOVE_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list.splice(<span class="params">idx, 1</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> COMPLETE_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list[idx].completed = <span class="literal">true</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">default</span>:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, initialStore(<span class="params"></span>)</span>),</span></span><br><span class="line"><span class="function">  // 支持多播</span></span><br><span class="line"><span class="function">  <span class="params">shareReplay</span><span class="params">()</span>,</span></span><br><span class="line"><span class="function">);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 持久化</span></span><br><span class="line"><span class="function"><span class="params">todos</span>$.<span class="params">pipe</span>(<span class="params">debounceTime(<span class="params">1000</span>)</span>).<span class="params">subscribe</span>(<span class="params">store =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">window</span>.localStorage.setItem(<span class="params">STORAGE_KEY, <span class="built_in">JSON</span>.stringify(<span class="params">store</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br></pre></td></tr></table></figure><blockquote><p>更多例子: 徐飞在<a href="https://github.com/xufei/blog/issues/44" target="_blank" rel="noopener">“RxJS 入门指引和初步应用&gt;”</a>提到了一个”幸福人生”的例子, 挺有意思, 读者可以尝试对其进行建模</p></blockquote><p><br></p><hr><p><br></p><p>经过上述过程, 可以深刻体会到<em>函数响应式编程</em>的<strong>优势</strong>:</p><ul><li><strong>数据流抽象了很多现实问题</strong>. 也就说数据流对业务逻辑的表达能力流程图基本一致. 可以说弹珠图是流程图的直观翻译, 而 Rx 代码则是弹珠图的直观翻译. 使用 Rx 以声明式形式编写代码, 可以让代码更容易理解, 因为它们接近业务流程.</li><li><strong>把复杂的问题分解成简单的问题的组合</strong>. Rx 编程本质上就是数据流的分治和合并</li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.jianshu.com/p/c95e29854cb1" target="_blank" rel="noopener">重新理解响应式编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/53009201" target="_blank" rel="noopener">【响应式编程的思维艺术】响应式 Vs 面向对象</a></li><li><a href="http://www.uml.org.cn/zjjs/201008021.asp" target="_blank" rel="noopener">细说业务逻辑</a></li><li><a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">Reactive programming</a></li><li><a href="https://github.com/xufei/blog/issues/44" target="_blank" rel="noopener">RxJS 入门指引和初步应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍如何使用 Rx 的响应式编程思维来对业务逻辑进行建模, 你会了解到响应式编程的优势和业务抽象能力, 学会将现有的业务流程以数据流的方式表达出来. 你的工具库中不能少了 Rx 这件利器.&lt;/p&gt;
&lt;p&gt;Rx 学习曲线陡峭是总所周知的, 我们接触的大部分编程语言或框架都
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Yarn Plug&#39;n&#39;Play可否助你脱离node_modules苦海?</title>
    <link href="https://bobi.ink/2019/04/08/plug-n-play/"/>
    <id>https://bobi.ink/2019/04/08/plug-n-play/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-07T04:18:21.737Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Yarn(v1.12+)的 Plug’n’Play 机制来取代 node_modules. 目前这还是一个实验性的特性.</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/images/node_modules-hole.png" alt="node_modules"></p><p><code>node_modules</code>早就成为的全民吐槽的对象, 其他语言的开发者看到 node_modules 对 Node 就望而祛步了,<br>用一个字来形容的话就是’重!’.</p><blockquote><p>如果不了解 Node 模块查找机制, 请点击<a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">require() 源码解读</a></p></blockquote><p>一个简单的前端项目(<em>create-react-app</em>)的大小和文件数:</p><center><br>  <img src="/images/front-end-project.png" alt="frontend-project" width="400"><br></center><p>而 macOS 的<code>/Library</code>目录的大小的文件数:</p><center><br>  <img src="/images/mac-library.png" alt="macos library" width="400"><br></center><p>一行<code>hello world</code>就需要安装 130MB 以上的依赖模块, 而且文件数是<strong>32,313</strong>. 相比之下 macOS 的<code>/Library</code><br>的空间占用 9.02GB, 文件数只是前者的两倍(<strong>67,890</strong>). 综上可以看出 node_modules 的特点是:</p><ul><li>目录树结构复杂</li><li>文件数较多且都比较小</li><li>依赖多, 一个简单的项目就要安装好几吨依赖</li></ul><p>所以说 node_modules 对于机械硬盘来说是个噩梦, 记得有一次一个同事删除 node_modules 一个下午都没搞定.<br>对于前端开发者来说, 我们有 N 个需要<code>npm install</code>的项目 😹.</p><p>除此之外, Node 的模块机制还有以下<strong>缺点</strong>:</p><ul><li><p>Node 本身并没有模块的概念, 它在运行时进行查找和加载. 这个缺点和<em>‘动态语言与静态语言的优劣对比’</em>相似,<br>你可能在开发环境运行得好好的, 可能到了线上就运行不了了, 原因是一个模块没有添加到 package.json</p></li><li><p>Node 模块的查找策略非常浪费. 这个缺点在大部分前端项目中可以进行优化,<br>比如 webpack 就可以限定只在项目根目录下的 node_modules 中查找, 但是对于嵌套的依赖, 依然需要 2 次以上的查找</p></li><li><p>node_modules 不能有效地处理重复的包. 两个名称相同但是不同版本的包是不能在一个目录下共存的.<br>所以会导致嵌套的 node_modules, 而且这些项目’依赖的依赖’是无法和项目或其他依赖共享的:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> ① 假设项目依赖a,b,c三个模块, 依赖树为:</span><br><span class="line"><span class="meta">#</span>  +- a</span><br><span class="line"><span class="meta">#</span>    +- react@15</span><br><span class="line"><span class="meta">#</span>  +- b</span><br><span class="line"><span class="meta">#</span>    +- react@16</span><br><span class="line"><span class="meta">#</span>  +- c</span><br><span class="line"><span class="meta">#</span>    +- react@16</span><br><span class="line"><span class="meta">#</span> yarn安装时会按照项目被依赖的次数作为权重, 将依赖提升(hoisting),</span><br><span class="line"><span class="meta">#</span> 安装后的node_modules结构为:</span><br><span class="line">  .</span><br><span class="line">  └── node_modules</span><br><span class="line">      ├── a</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   ├── node_modules</span><br><span class="line">      │   │   └── react  # @15</span><br><span class="line">      │   └── package.json</span><br><span class="line">      ├── b</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   └── package.json</span><br><span class="line">      ├── c</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   └── package.json</span><br><span class="line">      └── react  # @16 被依赖了两次, 所以进行提升</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> ② 现在假设在①的基础上, 根项目依赖了react@15, 对于项目自己的依赖肯定是要放在node_modules根目录的,</span><br><span class="line"><span class="meta">#</span> 由于一个目录下不能存在同名目录, 所以react@16没有的提升机会. </span><br><span class="line"><span class="meta">#</span> 安装后node_moduels结构为</span><br><span class="line">  .</span><br><span class="line">  └── node_modules</span><br><span class="line">      ├── a</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   └── package.json # react@15 提升</span><br><span class="line">      ├── b</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   ├── node_modules</span><br><span class="line">      │   │   └── react  # @16</span><br><span class="line">      │   └── package.json</span><br><span class="line">      ├── c</span><br><span class="line">      │   ├── index.js</span><br><span class="line">      │   ├── node_modules</span><br><span class="line">      │   │   └── react  # @16</span><br><span class="line">      │   └── package.json</span><br><span class="line">      └── react  # @15</span><br><span class="line"><span class="meta">#</span> 上面的结果可以看出, react@16出现了重复</span><br></pre></td></tr></table></figure></li></ul><p>为此 Yarn 集成了<code>Plug&#39;n&#39;Play</code>(简称 pnp), 中文名称可以称为’即插即用’, 来解决 node_modules’地狱’.</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>按照普通的按照流程, Yarn 会生成一个 node_modules 目录, 然后 Node 按照它的模块查找规则在 node_modules 目录中查找.<br>但实际上 Node 并不知道这个模块是什么, 它在 node_modules 查找, 没找到就在父目录的 node_modules 查找, 以此类推.<br>这个效率是非常低下的.</p><p><strong>但是 Yarn 作为一个包管理器, 它知道你的项目的依赖树. 那能不能让 Yarn 告诉 Node? 让它直接到某个目录去加载模块.<br>这样即可以提高 Node 模块的查找效率, 也可以减少 node_modules 文件的拷贝. 这就是<code>Plug&#39;n&#39;Play</code>的基本原理.</strong></p><p>在 pnp 模式下, Yarn 不会创建 node_modules 目录, 取而代之的是一个<code>.png.js</code>文件, 这是一个 node 程序,<br>这个文件包含了项目的依赖树信息, 模块查找算法, 也包含了模块查找器的 patch 代码(在 Node 环境, 覆盖 Module._load 方法).</p><p><br></p><p>使用 pnp 机制的以下<strong>优点</strong>:</p><ul><li>摆脱 node_modules.<ul><li>时间上: 相比较在热缓存(hot cache)环境下运行<code>yarn install</code>节省 70%的时间</li><li>空间上: pnp 模式下, 所有 npm 模块都会存放在全局的缓存目录下, 依赖树扁平化, 避免拷贝和重复</li></ul></li><li>提高模块加载效率. Node 为了查找模块, 需要调用大量的 stat 和 readdir 系统调用.<br>pnp 通过 Yarn 获取或者模块信息, 直接定位模块</li><li>不再受限于 node_modules 同名模块不同版本不能在同一目录</li></ul><blockquote><p>在 Mac 下 Yarn 的安装速度非常快, 热缓存下仅需几秒. 原因是 SSD + APFS 的 Copy-on-write 机制.<br>这使得文件的拷贝不用占用空间, 相当于创建一个链接. 所以拷贝和删除的速度非常快.<br>但是 node_modules 复杂的目录结构和超多的文件, 仍然需要调用大量的系统调用, 这也会拖慢安装过程.<br><br><br>💡 如果觉得 pnp 繁琐或不可靠, 那就赶紧用上 SSD 配合支持 Copy-on-write 的文件系统.</p></blockquote><p><br></p><p>使用 pnp 的<strong>风险</strong>:</p><p>目前前端社区的各种工具都依赖于 node_modules 模块查找机制. 例如</p><ul><li>Node</li><li>Electron, electron-builder 等等</li><li>Webpack</li><li>Typescript: 定位类型声明文件</li><li>Babel: 定位插件和 preset</li><li>Eslint: 定位插件和 preset, rules</li><li>Jest</li><li>编辑器, 如 VsCode</li><li>…😿</li></ul><p>pnp 一个非常新的东西, 在去年 9 月份(2018)面世. 要让这些工具和 pnp 集成是个不小的挑战, 而且这些这些工具<br>和 pnp 都是在不断迭代的, pnp 还不稳定, 未来可能变化, 这也会带来某些维护方面的负担.</p><p>除了模块查找机制, 有一些工具是直接在 node_modules 中做其他事情的, 比如缓存, 存放临时证书. 例如<code>cache-loader</code>, <code>webpack-dev-server</code></p><h2 id="开启-pnp"><a href="#开启-pnp" class="headerlink" title="开启 pnp"></a>开启 pnp</h2><p>如果只是单纯的 Node 项目, 迁入过程还算比较简单. 首先在<code>package.json</code>开启 pnp 安装模式:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"installConfig"</span>: &#123;</span><br><span class="line">    <span class="attr">"pnp"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着安装依赖:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add express</span><br></pre></td></tr></table></figure><p>安装后项目根目录就会出现一个<code>.pnp.js</code>文件. 下一步编写代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; res.send(<span class="string">'Hello World!'</span>));</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>));</span><br></pre></td></tr></table></figure><p>接下来就是运行 Node 代码了, 如果直接<code>node index.js</code>会报<code>Error: Cannot find module &#39;express&#39;</code>异常.<br>这是因为还没有 patch Node 的模块查找器. 可以通过以下命令运行:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"></span><br><span class="line">node --require="./.pnp.js" index.js</span><br></pre></td></tr></table></figure><blockquote><p><code>.pnp.js</code>文件不应该提交到版本库, 这个文件里面包含了硬编码的缓存目录. 在 Yarn v2 中会进行重构</p></blockquote><h2 id="怎么集成到现有项目"><a href="#怎么集成到现有项目" class="headerlink" title="怎么集成到现有项目?"></a>怎么集成到现有项目?</h2><p>pnp 集成无非就是重新实现现有工具的模块查找机制. 随着前端工程化的发展, 一个前端项目会集成非常多的工具,<br>如果这些工具没法适配, 可以说 pnp 很难往前走. 然而这并不是 pnp 能够控制的, 需要这些工具开发者的配合.</p><p>社区上不少项目已经集成了 pnp:</p><ul><li><a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a></li><li><a href="https://github.com/gatsbyjs/gatsby" target="_blank" rel="noopener">gastby</a></li></ul><p><br></p><h3 id="node"><a href="#node" class="headerlink" title="Node"></a>Node</h3><p>对于 Node, pnp 是开箱即用的, 直接使用<code>--require=&quot;./.pnp.js&quot;</code>导入<code>.pnp.js</code>文件即可,<br><code>.pnp.js</code>会对 Node 的 Module 对象进行 patch, 重新实现模块查找机制</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 使用的模块查找器是<a href="https://github.com/webpack/enhanced-resolve" target="_blank" rel="noopener"><code>enhanced-resolve</code></a>, 可以通过<a href="https://github.com/arcanis/pnp-webpack-plugin" target="_blank" rel="noopener"><code>pnp-webpack-plugin</code></a>插件来扩展<code>enhanced-resolve</code><br>来支持 pnp.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PnpWebpackPlugin = <span class="built_in">require</span>(<span class="string">`pnp-webpack-plugin`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 扩展模块查找器</span></span><br><span class="line">    plugins: [PnpWebpackPlugin],</span><br><span class="line">  &#125;,</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    <span class="comment">// 扩展loader模块查找器.</span></span><br><span class="line">    plugins: [PnpWebpackPlugin.moduleLoader(<span class="built_in">module</span>)],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h3><p><a href="http://jestjs.io" target="_blank" rel="noopener">jest</a>支持通过<code>resolver</code>来配置查找器:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolver: <span class="built_in">require</span>.resolve(<span class="string">`jest-pnp-resolver`</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="typescript"><a href="#typescript" class="headerlink" title="Typescript"></a>Typescript</h3><p>Typescript 也使用自己的模块查找器, TS团队为了性能方面的考虑, 暂时不允许第三方工具来扩展查找器. 也就是说<strong>暂时不能用</strong>.</p><p>在这个<a href="https://github.com/Microsoft/TypeScript/issues/28289" target="_blank" rel="noopener">issue</a>中, 有人提出使用<code>&quot;moduleResolution&quot;: &quot;yarnpnp&quot;</code>或者使用类似<a href="https://github.com/TypeStrong/ts-loader" target="_blank" rel="noopener"><code>ts-loader</code></a>的<a href="https://github.com/arcanis/pnp-webpack-plugin/blob/b09fbdc2a9f16dc3837454b8d367963b1a30655f/index.js#L141" target="_blank" rel="noopener"><code>resolveModuleName</code></a>的方式支持 pnp 模块查找.</p><p>TS 团队的回应是: pnp(或者 npm 的 tink)还是早期阶段, 未来可能会有变化, 例如<code>.pnp.js</code>文件, 显然不合适那么早入坑.<br>另外为了优化和控制编译器性能, TS 也没有计划在编译期间暴露接口给第三方执行代码.</p><p>所以现在 Typescript 至今也没有类似 babel 的插件机制. 除非自己实现一个’TS compiler host’, 例如<code>ts-loader</code>就自己扩展了插件机制和模块查找机制, 来支持类似<a href="https://github.com/Brooooooklyn/ts-import-plugin" target="_blank" rel="noopener">ts-import-plugin</a>等插件, 因此<code>ts-loader</code>现在是支持 pnp 的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PnpWebpackPlugin = <span class="built_in">require</span>(<span class="string">`pnp-webpack-plugin`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        loader: <span class="built_in">require</span>.resolve(<span class="string">'ts-loader'</span>),</span><br><span class="line">        options: PnpWebpackPlugin.tsLoaderOptions(),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>总结, <strong><code>Typescript</code>暂时不支持</strong>, 且近期也没有开发计划, 所以<code>VsCode</code>也别指望了. <a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin/issues/181" target="_blank" rel="noopener"><code>fork-ts-checker-webpack-plugin</code></a>也还没跟上. 显然 Typescript 是 pnp 的第一拦路虎</p><p><br></p><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ul><li><a href="https://github.com/arcanis/rollup-plugin-pnp-resolve" target="_blank" rel="noopener">rollup-plugin-pnp-resolve</a></li><li><a href="https://yarnpkg.com/en/package/resolve" target="_blank" rel="noopener">resolve</a>: babel, gulp</li><li><a href="https://github.com/yarnpkg/yarn/pull/6449" target="_blank" rel="noopener">eslint</a>: 到 v6 才能<a href="https://github.com/yarnpkg/berry/issues/8" target="_blank" rel="noopener">完美支持</a>.</li><li><a href="https://github.com/facebook/flow/issues/7014" target="_blank" rel="noopener">flow</a></li><li><a href="https://github.com/facebook/create-react-app/pull/5136" target="_blank" rel="noopener">create-react-app</a> 支持 pnp, 但是 Typescript 模式下不支持</li><li>electron: 暂时没有相关的消息. 对于一个electron应用来说, 依赖是自包含的, 所以pnp可能不适合该场景</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上, pnp 是一个不错的解决方案, 可以解决 Node 模块机制的空间和时间的效率问题. 但是在现阶段, 它还不是成熟, 有<br>很多坑要踩, 且和社区各种工具集成存在不少问题. 所以还不建议在生产环境中使用.</p><p>所以目前阶段对于普通开发者来说, 如果要提升npm安装速度, 还是得上SSD+Copy-On-Write!😂</p><p>下面是各种项目的集成情况(✅(支持)|🚧(计划中或不完美)|❌(不支持)):</p><table><thead><tr><th>项目</th><th></th></tr></thead><tbody><tr><td>Webpack</td><td>✅</td></tr><tr><td>rollup</td><td>✅</td></tr><tr><td>browserify</td><td>✅</td></tr><tr><td>gulp</td><td>✅</td></tr><tr><td>jest</td><td>✅</td></tr><tr><td>Node</td><td>✅</td></tr><tr><td>Typescript/VScode IntelliSense</td><td>❌</td></tr><tr><td>eslint</td><td>🚧</td></tr><tr><td>flow</td><td>🚧</td></tr><tr><td>create-react-app</td><td>🚧</td></tr><tr><td>ts-loader</td><td>✅</td></tr><tr><td>fork-ts-checker-webpack-plugin</td><td>🚧</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/yarnpkg/rfcs/blob/master/accepted/0000-plug-an-play.md" target="_blank" rel="noopener">Plug’n’Play Whitepaper</a> pnp的论文</li><li><a href="https://medium.freecodecamp.org/getting-rid-of-node-modules-with-yarn-plugn-play-a490e5e747d7" target="_blank" rel="noopener">How to get rid of node_modules with Yarn Plug’n’Play</a></li><li><a href="https://yarnpkg.com/en/docs/pnp" target="_blank" rel="noopener">Yarn 官方文档</a></li><li><a href="https://github.com/yarnpkg/pnp-sample-app" target="_blank" rel="noopener">pnp-sample-app</a> pnp 官方示例</li><li><a href="https://github.com/yarnpkg/yarn/issues/6953" target="_blank" rel="noopener">Yarn’s Future - v2 and beyond</a></li><li><a href="https://medium.com/@thomasreggi/yarn-plugn-play-1c398bf3e417" target="_blank" rel="noopener">Hacker News Discussion</a></li></ul><p>相关 issues:</p><ul><li><a href="https://github.com/yarnpkg/yarn/issues/6388" target="_blank" rel="noopener">Yarn Plug ‘N Play should generate a static manifest file, not <code>.pnp.js</code></a></li><li><a href="https://github.com/Microsoft/TypeScript/issues/28289" target="_blank" rel="noopener">Typescript: Add new moduleResolution option: <code>yarn-pnp</code></a></li><li><a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin/issues/181" target="_blank" rel="noopener">fork-ts-checker-webpack-plugin: Custom resolveModuleName</a></li></ul><p>其他方案</p><ul><li><a href="https://github.com/npm/tink" target="_blank" rel="noopener">npm tink</a>: a dependency unwinder for javascript</li><li><a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">pnpm</a> Fast, disk space efficient package manager</li><li><a href="https://yarnpkg.com/en/docs/workspaces" target="_blank" rel="noopener">Yarn Workspaces</a> 多个项目共有依赖</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 Yarn(v1.12+)的 Plug’n’Play 机制来取代 node_modules. 目前这还是一个实验性的特性.&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Rxjs 操作符决策树 - Mindnode</title>
    <link href="https://bobi.ink/2019/04/06/rx-operations/"/>
    <id>https://bobi.ink/2019/04/06/rx-operations/</id>
    <published>2019-04-05T16:00:00.000Z</published>
    <updated>2019-04-06T09:27:17.301Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Mindnode</strong> 是 macOS 下一个美观简洁的思维导图工具, 它是一个强大的学习/整理工具, 本文列举了近日学习<code>rxjs</code>所整理出来的思维导图.</p><blockquote><p>图片较大, 加载可能需要一点时间. 建议右击图片在新的 Tab 中查看</p></blockquote><blockquote><p>Mindode项目<a href="https://github.com/ivan-94/mindnodes/tree/master/rxjs/操作符" target="_blank" rel="noopener">地址</a>, 可以在这个项目获取原始的Mindode文件.</p></blockquote><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul><li><a href="https://rxjs.dev" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://rxmarbles.com/#distinctUntilChanged" target="_blank" rel="noopener">可交互的弹珠图</a> 直观地理解操作符的功能</li><li><a href="https://rxjs-cn.github.io/learn-rxjs-operators/" target="_blank" rel="noopener">reactive.how</a> 学习响应式编程的动画卡片</li><li><a href="https://rxjs-cn.github.io/learn-rxjs-operators/" target="_blank" rel="noopener">学习RxJS操作符</a></li><li><a href="https://www.amazon.cn/dp/B07CXZ9D8N/ref=sr_1_1?__mk_zh_CN=亚马逊网站&amp;keywords=rxjs&amp;qid=1554539743&amp;s=gateway&amp;sr=8-1" target="_blank" rel="noopener">book: 深入浅出RxJS</a></li></ul><h2 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/创建操作符.png" alt="创建操作符"></p><h2 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/过滤.png" alt="过滤操作符"></p><h2 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/转换.png" alt="转换操作符"></p><h2 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/组合.png" alt="组合操作符"></p><h2 id="分组操作符"><a href="#分组操作符" class="headerlink" title="分组操作符"></a>分组操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/分组.png" alt="分组操作符"></p><h2 id="错误处理操作符"><a href="#错误处理操作符" class="headerlink" title="错误处理操作符"></a>错误处理操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/错误处理.png" alt="错误处理操作符"></p><h2 id="辅助-条件-数学-配置操作符"><a href="#辅助-条件-数学-配置操作符" class="headerlink" title="辅助-条件-数学-配置操作符"></a>辅助-条件-数学-配置操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/辅助-条件-数学-配置.png" alt="辅助-条件-数学-配置操作符"></p><h2 id="多播操作符"><a href="#多播操作符" class="headerlink" title="多播操作符"></a>多播操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/多播.png" alt="多播操作符"></p><h2 id="高阶-observable-操作符"><a href="#高阶-observable-操作符" class="headerlink" title="高阶 Observable 操作符"></a>高阶 Observable 操作符</h2><p><img src="https://raw.githubusercontent.com/ivan-94/mindnodes/master/rxjs/操作符/高阶Observable.png" alt="高阶Observable操作符"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Mindnode&lt;/strong&gt; 是 macOS 下一个美观简洁的思维导图工具, 它是一个强大的学习/整理工具, 本文列举了近日学习&lt;code&gt;rxjs&lt;/code&gt;所整理出来的思维导图.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图片较大, 加载可能需要一
      
    
    </summary>
    
      <category term="Mindnode" scheme="https://bobi.ink/categories/Mindnode/"/>
    
    
  </entry>
  
</feed>
