<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2019-08-03T13:48:56.924Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈React事件机制和未来(react-events)</title>
    <link href="https://bobi.ink/2019/07/29/react-event/"/>
    <id>https://bobi.ink/2019/07/29/react-event/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-08-03T13:48:56.924Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react-event/sample.png" alt></p><p>当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发. </p><p>具体来讲，React利用事件委托机制在Document上统一监听DOM事件，再根据触发的target将事件分发到具体的组件实例。另外上面e是一个合成事件对象(SyntheticEvent), 而不是原始的DOM事件对象.</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#那为什么要自定义一套事件系统">那为什么要自定义一套事件系统?</a></li><li><a href="#基本概念">基本概念</a><ul><li><a href="#整体的架构">整体的架构</a></li><li><a href="#事件分类与优先级">事件分类与优先级</a></li></ul></li><li><a href="#实现细节">实现细节</a><ul><li><a href="#事件是如何绑定的">事件是如何绑定的？</a></li><li><a href="#事件是如何分发的">事件是如何分发的？</a><ul><li><a href="#事件触发调度">事件触发调度</a></li><li><a href="#插件是如何处理事件">插件是如何处理事件?</a></li><li><a href="#批量执行">批量执行</a></li></ul></li></ul></li><li><a href="#未来">未来</a><ul><li><a href="#初探responder的创建">初探Responder的创建</a></li><li><a href="#react-events意义何在">react-events意义何在?</a></li></ul></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><blockquote><p>截止本文写作时，React版本是16.8.6</p></blockquote><p><br></p><h2 id="那为什么要自定义一套事件系统"><a href="#那为什么要自定义一套事件系统" class="headerlink" title="那为什么要自定义一套事件系统?"></a>那为什么要自定义一套事件系统?</h2><p>如果了解过Preact(笔者之前写过一篇文章<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">解析Preact的源码</a>)，Preact裁剪了很多React的东西，其中包括事件机制，Preact是直接在DOM元素上进行事件绑定的。</p><p>在研究一个事物之前，我首先要问为什么？了解它的动机，才有利于你对它有本质的认识。</p><p>React自定义一套事件系统的动机有以下几个:</p><ul><li><p><strong>1. 抹平浏览器之间的兼容性差异</strong>。 这是估计最原始的动机，React根据<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C 规范</a>来定义这些合成事件(SyntheticEvent), 意在抹平浏览器之间的差异。</p><p>另外React还会试图通过其他相关事件来模拟一些低版本不兼容的事件, 这才是‘合成’的本来意思吧？。</p></li><li><p><strong>2. 事件‘合成’, 即事件自定义</strong>。事件合成除了处理兼容性问题，还可以用来自定义高级事件，比较典型的是React的onChange事件，它为表单元素定义了统一的值变动事件。另外第三方也可以通过React的事件插件机制来合成自定义事件，尽管很少人这么做。</p></li><li><p><strong>3. 抽象跨平台事件机制</strong>。 和VirtualDOM的意义差不多，VirtualDOM抽象了跨平台的渲染方式，那么对应的SyntheticEvent目的也是想提供一个抽象的跨平台事件机制。</p></li><li><p><strong>4. React打算做更多优化</strong>。比如利用事件委托机制，大部分事件最终绑定到了Document，而不是DOM节点本身. 这样简化了DOM事件处理逻辑，减少了内存开销. 但这也意味着，<strong>React需要自己模拟一套事件冒泡的机制</strong>。</p></li><li><p><strong>5. React打算干预事件的分发</strong>。v16引入Fiber架构，React为了优化用户的交互体验，会干预事件的分发。不同类型的事件有不同的优先级，比如高优先级的事件可以中断渲染，让用户代码可以及时响应用户交互。</p></li></ul><p><br></p><p>Ok, 后面我们会深入了解React的事件实现，我会尽量不贴代码，用流程图说话。</p><p><br></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="整体的架构"><a href="#整体的架构" class="headerlink" title="整体的架构"></a>整体的架构</h3><p><img src="/images/react-event/st.png" alt></p><ul><li><strong>ReactEventListener</strong> - 事件处理器. 在这里进行事件处理器的绑定。当DOM触发事件时，会从这里开始调度分发到React组件树</li><li><strong>ReactEventEmitter</strong> - 暴露接口给React组件层用于添加事件订阅</li><li><strong>EventPluginHub</strong> - 如其名，这是一个‘插件插槽’，负责管理和注册各种插件。在事件分发时，调用插件来生成合成事件</li><li><p><strong>Plugin</strong> - React事件系统使用了插件机制来管理不同行为的事件。这些插件会处理自己感兴趣的事件类型，并生成合成事件对象。目前ReactDOM有以下几种插件类型:</p><ul><li><strong>SimpleEventPlugin</strong> - 简单事件, 处理一些比较通用的事件类型，例如click、input、keyDown、mouseOver、mouseOut、pointerOver、pointerOut</li><li><p><strong>EnterLeaveEventPlugin</strong> - mouseEnter/mouseLeave和pointerEnter/pointerLeave这两类事件比较特殊, 和<code>*over/*leave</code>事件相比, 它们不支持事件冒泡, <code>*enter</code>会给所有进入的元素发送事件, 行为有点类似于<code>:hover</code>; 而<code>*over</code>在进入元素后，还会冒泡通知其上级. 可以通过这个<a href="https://codesandbox.io/s/enter-and-over-608cl" target="_blank" rel="noopener">实例</a>观察enter和over的区别.</p><p>如果树层次比较深，大量的mouseenter触发可能导致性能问题。另外其不支持冒泡，无法在Document完美的监听和分发, 所以ReactDOM使用<code>*over/*out</code>事件来模拟这些<code>*enter/*leave</code>。</p></li><li><p><strong>ChangeEventPlugin</strong> - change事件是React的一个自定义事件，旨在规范化表单元素的变动事件。</p><p>它支持这些表单元素: input, textarea, select </p></li><li><p><strong>SelectEventPlugin</strong> - 和change事件一样，React为表单元素规范化了select(选择范围变动)事件，适用于input、textarea、contentEditable元素.</p></li><li><strong>BeforeInputEventPlugin</strong> - beforeinput事件以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart" target="_blank" rel="noopener">composition</a>事件处理。</li></ul><p>本文主要会关注<code>SimpleEventPlugin</code>的实现，有兴趣的读者可以自己阅读React的源代码.</p></li><li><p><strong>EventPropagators</strong> 按照DOM事件传播的两个阶段，遍历React组件树，并收集所有组件的事件处理器.</p></li><li><strong>EventBatching</strong> 负责批量执行事件队列和事件处理器，处理事件冒泡。</li><li><p><strong>SyntheticEvent</strong> 这是‘合成’事件的基类，可以对应DOM的Event对象。只不过React为了减低内存损耗和垃圾回收，使用一个对象池来构建和释放事件对象， 也就是说SyntheticEvent不能用于异步引用，它在同步执行完事件处理器后就会被释放。</p><p>SyntheticEvent也有子类，和DOM具体事件类型一一匹配:</p><ul><li>SyntheticAnimationEvent</li><li>SyntheticClipboardEvent</li><li>SyntheticCompositionEvent</li><li>SyntheticDragEvent</li><li>SyntheticFocusEvent</li><li>SyntheticInputEvent</li><li>SyntheticKeyboardEvent</li><li>SyntheticMouseEvent</li><li>SyntheticPointerEvent</li><li>SyntheticTouchEvent</li><li>….</li></ul></li></ul><p><br></p><h3 id="事件分类与优先级"><a href="#事件分类与优先级" class="headerlink" title="事件分类与优先级"></a>事件分类与优先级</h3><p>SimpleEventPlugin将事件类型划分成了三类, 对应不同的优先级(<strong>优先级由低到高</strong>):</p><ul><li><strong>DiscreteEvent</strong> 离散事件. 例如blur、focus、 click、 submit、 touchStart. 这些事件都是离散触发的</li><li><strong>UserBlockingEvent</strong> 用户阻塞事件. 例如touchMove、mouseMove、scroll、drag、dragOver等等。这些事件会’阻塞’用户的交互。</li><li><strong>ContinuousEvent</strong> 可连续事件。例如load、error、loadStart、abort、animationEnd. 这个优先级最高，也就是说它们应该是立即同步执行的，这就是Continuous的意义，即可连续的执行，不被打断.</li></ul><p>可能要先了解一下React调度(Schedule)的优先级，才能理解这三种事件类型的区别。截止到本文写作时，React有5个优先级级别:</p><ul><li><code>Immediate</code> - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms timeout) 这些任务一般是用户交互的结果, 需要即时得到反馈 .</li><li><code>Normal</code> (5s timeout) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s timeout) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (no timeout) 一些没有必要做的任务 (e.g. 比如隐藏的内容).</li></ul><p>目前ContinuousEvent对应的是Immediate优先级; UserBlockingEvent对应的是UserBlocking(需要手动开启); 而DiscreteEvent对应的也是UserBlocking, 只不过它在执行之前，先会执行完其他Discrete任务。</p><p>本文不会深入React Fiber架构的细节，有兴趣的读者可以阅读文末的扩展阅读列表.</p><p><br><br><br></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>现在开始进入文章正题，React是怎么实现事件机制？主要分为两个部分: <strong>绑定</strong>和<strong>分发</strong>.</p><h3 id="事件是如何绑定的？"><a href="#事件是如何绑定的？" class="headerlink" title="事件是如何绑定的？"></a>事件是如何绑定的？</h3><p>为了避免后面绕晕了，有必要先了解一下React事件机制中的插件协议。 每个插件的结构如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> EventTypes = &#123;[key: <span class="built_in">string</span>]: DispatchConfig&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PluginModule&lt;NativeEvent&gt; = &#123;</span><br><span class="line">  eventTypes: EventTypes,          <span class="comment">// 声明插件支持的事件类型</span></span><br><span class="line">  extractEvents: (                 <span class="comment">// 对事件进行处理，并返回合成事件对象</span></span><br><span class="line">    topLevelType: TopLevelType,</span><br><span class="line">    targetInst: <span class="literal">null</span> | Fiber,</span><br><span class="line">    nativeEvent: NativeEvent,</span><br><span class="line">    nativeEventTarget: EventTarget,</span><br><span class="line">  ) =&gt; ?ReactSyntheticEvent,</span><br><span class="line">  tapMoveThreshold?: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>eventTypes</strong>声明该插件负责的事件类型, 它通过<code>DispatchConfig</code>来描述:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DispatchConfig = &#123;</span><br><span class="line">  dependencies: <span class="built_in">Array</span>&lt;TopLevelType&gt;, <span class="comment">// 依赖的原生事件，表示关联这些事件的触发. ‘简单事件’一般只有一个，复杂事件如onChange会监听多个, 如下图👇</span></span><br><span class="line">  phasedRegistrationNames?: &#123;    <span class="comment">// 两阶段props事件注册名称, React会根据这些名称在组件实例中查找对应的props事件处理器</span></span><br><span class="line">    bubbled: <span class="built_in">string</span>,             <span class="comment">// 冒泡阶段, 如onClick</span></span><br><span class="line">    captured: <span class="built_in">string</span>,            <span class="comment">// 捕获阶段，如onClickCapture</span></span><br><span class="line">  &#125;,</span><br><span class="line">  registrationName?: <span class="built_in">string</span>      <span class="comment">// props事件注册名称, 比如onMouseEnter这些不支持冒泡的事件类型，只会定义  registrationName，不会定义phasedRegistrationNames</span></span><br><span class="line">  eventPriority: EventPriority,  <span class="comment">// 事件的优先级，上文已经介绍过了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>看一下实例:</p><p><img src="/images/react-event/dispatch-config.png" alt></p><p>上面列举了三个典型的EventPlugin：</p><ul><li><p><strong>SimpleEventPlugin</strong> - 简单事件最好理解，它们的行为都比较通用，没有什么Trick, 例如不支持事件冒泡、不支持在Document上绑定等等. 和原生DOM事件是一一对应的关系，比较好处理.</p></li><li><p><strong>EnterLeaveEventPlugin</strong> - 从上图可以看出来，<code>mouseEnter</code>和<code>mouseLeave</code>依赖的是<code>mouseout</code>和<code>mouseover</code>事件。也就是说<code>*Enter/*Leave</code>事件在React中是通过<code>*Over/*Out</code>事件来模拟的。这样做的好处是可以在document上面进行委托监听，还有避免<code>*Enter/*Leave</code>一些奇怪而不实用的行为。</p></li><li><p><strong>ChangeEventPlugin</strong> - onChange是React的一个自定义事件，可以看出它依赖了多种原生DOM事件类型来模拟onChange事件.</p></li></ul><p><br></p><p>另外每个插件还会定义<code>extractEvents</code>方法，这个方法接受事件名称、原生DOM事件对象、事件触发的DOM元素以及React组件实例, 返回一个合成事件对象，如果返回空则表示不作处理. 关于extractEvents的细节会在下一节阐述.</p><p><br></p><p>在ReactDOM启动时就会向<code>EventPluginHub</code>注册这些插件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EventPluginHubInjection.injectEventPluginsByName(&#123;</span><br><span class="line">  SimpleEventPlugin: SimpleEventPlugin,</span><br><span class="line">  EnterLeaveEventPlugin: EnterLeaveEventPlugin,</span><br><span class="line">  ChangeEventPlugin: ChangeEventPlugin,</span><br><span class="line">  SelectEventPlugin: SelectEventPlugin,</span><br><span class="line">  BeforeInputEventPlugin: BeforeInputEventPlugin,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>Ok, 回到正题，事件是怎么绑定的呢？ 打个断点看一下调用栈:</p><p><img src="/images/react-event/listento.png" alt></p><p>前面调用栈关于React树如何更新和渲染就不在本文的范围内了，通过调用栈可以看出React在props初始化和更新时会进行事件绑定。这里先看一下流程图，忽略杂乱的跳转：</p><p><img src="/images/react-event/binding.png" alt></p><ul><li><strong>1. 在props初始化和更新时会进行事件绑定</strong>。首先React会判断元素是否是<code>媒体类型</code>，<strong>媒体类型的事件是无法在Document监听的，所以会直接在元素上进行绑定</strong></li><li><strong>2. 反之就在Document上绑定</strong>. 这里面需要两个信息，一个就是上文提到的’事件依赖列表’, 比如<code>onMouseEnter</code>依赖<code>mouseover/mouseout</code>; 第二个是ReactBrowserEventEmitter维护的’已订阅事件表’。<strong>事件处理器只需在Document订阅一次，所以相比在每个元素上订阅事件会节省很多资源</strong>.</li></ul><p>代码大概如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">listenTo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  registrationName: <span class="built_in">string</span>,           <span class="comment">// 注册名称，如onClick</span></span></span></span><br><span class="line"><span class="function"><span class="params">  mountAt: Document | Element | Node, <span class="comment">// 组件树容器，一般是Document</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeningSet = getListeningSetForElement(mountAt);             <span class="comment">// 已订阅事件表</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = registrationNameDependencies[registrationName]; <span class="comment">// 事件依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dependency = dependencies[i];</span><br><span class="line">    <span class="keyword">if</span> (!listeningSet.has(dependency)) &#123;                               <span class="comment">// 未订阅</span></span><br><span class="line">      <span class="keyword">switch</span> (dependency) &#123;</span><br><span class="line">        <span class="comment">// ... 特殊的事件监听处理</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">const</span> isMediaEvent = mediaEventTypes.indexOf(dependency) !== <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">if</span> (!isMediaEvent) &#123;</span><br><span class="line">            trapBubbledEvent(dependency, mountAt);                     <span class="comment">// 设置事件处理器</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      listeningSet.add(dependency);                                    <span class="comment">// 更新已订阅表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>接下来就是根据事件的’优先级’和’捕获阶段’(是否是capture)来设置事件处理器</strong>:</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trapEventForPluginEventSystem</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: Document | Element | Node,   <span class="comment">// 绑定到元素，一般是Document</span></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType: DOMTopLevelEventType,   <span class="comment">// 事件名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">  capture: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> listener;</span><br><span class="line">  <span class="keyword">switch</span> (getEventPriority(topLevelType)) &#123;</span><br><span class="line">    <span class="comment">// 不同优先级的事件类型，有不同的事件处理器进行分发, 下文会详细介绍</span></span><br><span class="line">    <span class="keyword">case</span> DiscreteEvent:                      <span class="comment">// ⚛️离散事件</span></span><br><span class="line">      listener = dispatchDiscreteEvent.bind(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        topLevelType,</span><br><span class="line">        PLUGIN_EVENT_SYSTEM,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingEvent:                 <span class="comment">// ⚛️用户阻塞事件</span></span><br><span class="line">      listener = dispatchUserBlockingUpdate.bind(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        topLevelType,</span><br><span class="line">        PLUGIN_EVENT_SYSTEM,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ContinuousEvent:                   <span class="comment">// ⚛️可连续事件</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      listener = dispatchEvent.bind(<span class="literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rawEventName = getRawEventName(topLevelType);</span><br><span class="line">  <span class="keyword">if</span> (capture) &#123;                            <span class="comment">// 绑定事件处理器到元素</span></span><br><span class="line">    addEventCaptureListener(element, rawEventName, listener);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addEventBubbleListener(element, rawEventName, listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件绑定的过程还比较简单, 接下来看看事件是如何分发的。</p><p><br></p><h3 id="事件是如何分发的？"><a href="#事件是如何分发的？" class="headerlink" title="事件是如何分发的？"></a>事件是如何分发的？</h3><p>按惯例还是先上流程图:</p><p><img src="/images/react-event/binding.png" alt></p><h4 id="事件触发调度"><a href="#事件触发调度" class="headerlink" title="事件触发调度"></a>事件触发调度</h4><p>通过上面的<code>trapEventForPluginEventSystem</code>函数可以知道，不同的事件类型有不同的事件处理器, 它们的区别是调度的优先级不一样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 离散事件</span></span><br><span class="line"><span class="comment">// discrentUpdates 在UserBlocking优先级中执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchDiscreteEvent</span>(<span class="params">topLevelType, eventSystemFlags, nativeEvent</span>) </span>&#123;</span><br><span class="line">  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);</span><br><span class="line">  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchUserBlockingUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果开启了enableUserBlockingEvents, 则在UserBlocking优先级中调度，</span></span><br><span class="line">  <span class="comment">// 开启enableUserBlockingEvents可以防止饥饿问题，因为阻塞事件中有scroll、mouseMove这类频繁触发的事件</span></span><br><span class="line">  <span class="comment">// 否则同步执行</span></span><br><span class="line">  <span class="keyword">if</span> (enableUserBlockingEvents) &#123;</span><br><span class="line">    runWithPriority(</span><br><span class="line">      UserBlockingPriority,</span><br><span class="line">      dispatchEvent.bind(<span class="literal">null</span>, topLevelType, eventSystemFlags, nativeEvent),</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dispatchEvent(topLevelType, eventSystemFlags, nativeEvent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可连续事件则直接同步调用dispatchEvent</span></span><br></pre></td></tr></table></figure><p><br></p><p>最终不同的事件类型都会调用<code>dispatchEvent</code>函数. <code>dispatchEvent</code>中会从DOM原生事件对象获取事件触发的target，再根据这个target获取关联的React节点实例.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatchEvent</span>(<span class="params">topLevelType: DOMTopLevelEventType, eventSystemFlags: EventSystemFlags, nativeEvent: AnyNativeEvent</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取事件触发的目标DOM</span></span><br><span class="line">  <span class="keyword">const</span> nativeEventTarget = getEventTarget(nativeEvent);</span><br><span class="line">  <span class="comment">// 获取离该DOM最近的组件实例(只能是DOM元素组件)</span></span><br><span class="line">  <span class="keyword">let</span> targetInst = getClosestInstanceFromNode(nativeEventTarget);</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>接着(中间还有一些步骤，这里忽略)会调用<code>EventPluginHub</code>的<code>runExtractedPluginEventsInBatch</code>，这个方法遍历插件列表来处理事件，生成一个SyntheticEvent列表:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runExtractedPluginEventsInBatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst: <span class="literal">null</span> | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历插件列表, 调用插件的extractEvents，生成SyntheticEvent列表</span></span><br><span class="line">  <span class="keyword">const</span> events = extractPluginEvents(</span><br><span class="line">    topLevelType,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件处理器执行, 见后文批量执行</span></span><br><span class="line">  runEventsInBatch(events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="插件是如何处理事件"><a href="#插件是如何处理事件" class="headerlink" title="插件是如何处理事件?"></a>插件是如何处理事件?</h4><p>现在来看看插件是如何处理事件的，我们以<code>SimpleEventPlugin</code>为例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleEventPlugin: PluginModule&lt;MouseEvent&gt; &amp; &#123;</span><br><span class="line">  getEventPriority: <span class="function">(<span class="params">topLevelType: TopLevelType</span>) =&gt;</span> EventPriority,</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  eventTypes: eventTypes,</span><br><span class="line">  <span class="comment">// 抽取事件对象</span></span><br><span class="line">  extractEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">    targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEvent: MouseEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">null</span> | <span class="title">ReactSyntheticEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事件配置</span></span><br><span class="line">    <span class="keyword">const</span> dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1️⃣ 根据事件类型获取SyntheticEvent子类事件构造器</span></span><br><span class="line">    <span class="keyword">let</span> EventConstructor;</span><br><span class="line">    <span class="keyword">switch</span> (topLevelType) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_DOWN:</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_UP:</span><br><span class="line">        EventConstructor = SyntheticKeyboardEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_BLUR:</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_FOCUS:</span><br><span class="line">        EventConstructor = SyntheticFocusEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ... 省略</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_GOT_POINTER_CAPTURE:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_UP:</span><br><span class="line">        EventConstructor = SyntheticPointerEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        EventConstructor = SyntheticEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2️⃣ 构造事件对象, 从对象池中获取</span></span><br><span class="line">    <span class="keyword">const</span> event = EventConstructor.getPooled(</span><br><span class="line">      dispatchConfig,</span><br><span class="line">      targetInst,</span><br><span class="line">      nativeEvent,</span><br><span class="line">      nativeEventTarget,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3️⃣ 根据DOM事件传播的顺序获取用户事件处理器</span></span><br><span class="line">    accumulateTwoPhaseDispatches(event);</span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>SimpleEventPlugin</code>的<code>extractEvents</code>主要做以下三个事情:</p><ul><li>1️⃣ 根据事件的类型确定SyntheticEvent构造器</li><li>2️⃣ 构造SyntheticEvent对象。</li><li>3️⃣ 根据DOM事件传播的顺序获取用户事件处理器列表</li></ul><p><br></p><p><strong>为了避免频繁创建和释放事件对象导致性能损耗(对象创建和垃圾回收)，React使用一个事件池来负责管理事件对象，使用完的事件对象会放回池中，以备后续的复用</strong>。</p><p>这也意味着，<strong>在事件处理器同步执行完后，SyntheticEvent对象就会马上被回收</strong>，所有属性都会无效。所以一般不会在异步操作中访问SyntheticEvent事件对象。你也可以通过以下方法来保持事件对象的引用：</p><ul><li>调用<code>SyntheticEvent#persist()</code>方法，告诉React不要回收到对象池</li><li>直接引用<code>SyntheticEvent#nativeEvent</code>, nativeEvent是可以持久引用的，不过为了不打破抽象，建议不要直接引用nativeEvent</li></ul><p><br></p><p>构建完SyntheticEvent对象后，就需要<strong>遍历组件树来获取订阅该事件的用户事件处理器</strong>了:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateTwoPhaseDispatchesSingle</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以_targetInst为基点, 按照DOM事件传播的顺序遍历组件树</span></span><br><span class="line">  traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历方法其实很简单：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverseTwoPhase</span>(<span class="params">inst, fn, arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="keyword">while</span> (inst) &#123;           <span class="comment">// 从inst开始，向上级回溯</span></span><br><span class="line">    path.push(inst);</span><br><span class="line">    inst = getParent(inst);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="comment">// 捕获阶段，先从最顶层的父组件开始, 向下级传播</span></span><br><span class="line">  <span class="keyword">for</span> (i = path.length; i-- &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">    fn(path[i], <span class="string">'captured'</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 冒泡阶段，从inst，即事件触发点开始, 向上级传播</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">    fn(path[i], <span class="string">'bubbled'</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>accumulateDirectionalDispatches</code>函数则是简单查找当前节点是否有对应的事件处理器:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateDirectionalDispatches</span>(<span class="params">inst, phase, event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否存在事件处理器</span></span><br><span class="line">  <span class="keyword">const</span> listener = listenerAtPhase(inst, event, phase);</span><br><span class="line">  <span class="comment">// 所有处理器都放入到_dispatchListeners队列中，后续批量执行这个队列</span></span><br><span class="line">  <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">    event._dispatchListeners = accumulateInto(</span><br><span class="line">      event._dispatchListeners,</span><br><span class="line">      listener,</span><br><span class="line">    );</span><br><span class="line">    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>例如下面的组件树, 遍历过程是这样的：</p><p><img src="/images/react-event/event-delivery.png" alt></p><p>最终计算出来的<code>_dispatchListeners</code>队列是这样的：<code>[handleB, handleC, handleA]</code></p><p><br></p><h4 id="批量执行"><a href="#批量执行" class="headerlink" title="批量执行"></a>批量执行</h4><p>遍历执行插件后，会得到一个SyntheticEvent列表，<code>runEventsInBatch</code>就是批量执行这些事件中的<code>_dispatchListeners</code>事件队列</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runEventsInBatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  events: Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👇</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> executeDispatchesAndRelease = <span class="function"><span class="keyword">function</span>(<span class="params">event: ReactSyntheticEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event) &#123;</span><br><span class="line">    <span class="comment">// 按顺序执行_dispatchListeners</span></span><br><span class="line">    <span class="comment">// 👇</span></span><br><span class="line">    executeDispatchesInOrder(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有调用persist()方法则直接回收</span></span><br><span class="line">    <span class="keyword">if</span> (!event.isPersistent()) &#123;</span><br><span class="line">      event.constructor.release(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">executeDispatchesInOrder</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历dispatchListeners</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 通过调用 stopPropagation 方法可以禁止执行下一个事件处理器</span></span><br><span class="line">    <span class="keyword">if</span> (event.isPropagationStopped()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行事件处理器</span></span><br><span class="line">    executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/react-event/dispatch.png" alt></p><p>OK, 到这里React的事件机制就基本介绍完了，这里只是简单了介绍了一下<code>SimpleEventPlugin</code>, 实际代码中还有很多事件处理的细节，限于篇幅，本文就不展开去讲了。有兴趣的读者可以亲自去观摩React的源代码.</p><p><br><br><br></p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>React内部有一个实验性的事件API，React内部称为<code>React Flare</code>、正式名称是<a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener"><code>react-events</code></a>, <strong>通过这个API可以实现跨平台、跨设备的高级事件封装</strong>.</p><p>react-events定义了一个<strong>事件响应器(Event Responders)</strong>的概念，这个事件响应器可以捕获子组件树或应用根节点的事件，然后转换为自定义事件.</p><p>比较典型的高级事件是press、longPress、swipe这些手势。通常我们需要自己或者利用第三方库来实现这一套手势识别, 例如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Gesture <span class="keyword">from</span> <span class="string">'rc-gesture'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Gesture</span><br><span class="line">    onTap=&#123;handleTap&#125;</span><br><span class="line">    onSwipe=&#123;onSwipe&#125;</span><br><span class="line">    onPinch=&#123;handlePinch&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;div&gt;container&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Gesture&gt;,</span><br><span class="line">container);</span><br></pre></td></tr></table></figure><p><br></p><p>那么react-events的目的就是<strong>提供一套通用的事件机制给开发者来实现’高级事件’的封装, 甚至实现事件的跨平台、跨设备</strong>, 现在你可以通过react-events来封装这些手势事件.</p><p>react-events除了核心的<code>Responder</code>接口，还封装了一些内置模块, 实现跨平台的、常用的高级事件封装：</p><ul><li>Focus module</li><li>Hover module</li><li>Press module</li><li>FocusScope module</li><li>Input module</li><li>KeyBoard module</li><li>Drag module</li><li>Pan module</li><li>Scroll module</li><li>Swipe module</li></ul><p>举<code>Press</code>模块作为例子, <a href="https://github.com/facebook/react/blob/master/packages/react-events/docs/Press.md" target="_blank" rel="noopener">Press模块</a>会响应它包裹的元素的press事件。press事件包括onContextMenu、onLongPress、onPress、onPressEnd、onPressMove、onPressStart等等. 其底层通过mouse、pen、touch、trackpad等事件来转换.</p><p>看看使用示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PressResponder, usePressListener &#125; <span class="keyword">from</span> <span class="string">'react-events/press'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">const</span> listener = usePressListener(&#123;  <span class="comment">// ⚛️通过hooks创建Responder</span></span><br><span class="line">    onPressStart,</span><br><span class="line">    onPress,</span><br><span class="line">    onPressEnd,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div listeners=&#123;listener&#125;&gt;</span><br><span class="line">      &#123;subtrees&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><p>react-events的运作流程图如下, <strong>事件响应器(Event Responders)会挂载到host节点，它会在host节点监听host或子节点分发的原生事件(DOM或React Native), 并将它们转换/合并成高级的事件</strong>:</p><p><img src="/images/react-event/responder.png" alt></p><p><br></p><blockquote><p>你可以通过这个Codesanbox玩一下<code>react-events</code>: <a href="https://codesandbox.io/s/github/ivan-94/react-events-playground" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit react-events-playground"></a></p></blockquote><p><br></p><h3 id="初探responder的创建"><a href="#初探responder的创建" class="headerlink" title="初探Responder的创建"></a>初探Responder的创建</h3><p>我们挑一个简单的模块来了解一些react-events的核心API, 目前最简单的是Keyboard模块. Keyboard模块的目的就是规范化keydown和keyup事件对象的key属性(部分浏览器key属性的行为不一样)，它的实现如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Responder的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> keyboardResponderImpl = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1️⃣定义Responder需要监听的子树的DOM事件，对于Keyboard来说是['keydown', 'keyup';]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  targetEventTypes,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 2️⃣监听子树触发的事件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onEvent(</span><br><span class="line">    event: ReactDOMResponderEvent,     <span class="comment">// 包含了当前触发事件的相关信息，如原生事件对象，事件触发的节点，事件类型等等</span></span><br><span class="line">    context: ReactDOMResponderContext, <span class="comment">// Responder的上下文，给Responder提供了一些方法来驱动事件分发</span></span><br><span class="line">    props: KeyboardResponderProps,     <span class="comment">// 传递给Responder的props</span></span><br><span class="line">  ): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;responderTarget, type&#125; = event;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (props.disabled) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'keydown'</span>) &#123;</span><br><span class="line">      dispatchKeyboardEvent(</span><br><span class="line">        <span class="string">'onKeyDown'</span>,</span><br><span class="line">        event,</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">'keydown'</span>,</span><br><span class="line">        ((responderTarget: any): Element | Document),</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'keyup'</span>) &#123;</span><br><span class="line">      dispatchKeyboardEvent(</span><br><span class="line">        <span class="string">'onKeyUp'</span>,</span><br><span class="line">        event,</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">'keyup'</span>,</span><br><span class="line">        ((responderTarget: any): Element | Document),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看看dispatchKeyboardEvent:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchKeyboardEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  eventPropName: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  event: ReactDOMResponderEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: ReactDOMResponderContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: KeyboardEventType,</span></span></span><br><span class="line"><span class="function"><span class="params">  target: Element | Document,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️创建合成事件对象，在这个函数中会规范化事件的key属性</span></span><br><span class="line">  <span class="keyword">const</span> syntheticEvent = createKeyboardEvent(event, context, type, target);</span><br><span class="line">  <span class="comment">// ⚛️通过Responder上下文分发事件</span></span><br><span class="line">  context.dispatchEvent(eventPropName, syntheticEvent, DiscreteEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出Responder:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️createResponder把keyboardResponderImpl转换为组件形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> KeyboardResponder = React.unstable_createResponder(</span><br><span class="line">  <span class="string">'Keyboard'</span>,</span><br><span class="line">  keyboardResponderImpl,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️创建hooks形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useKeyboardListener</span>(<span class="params">props: KeyboardListenerProps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  React.unstable_useListener(KeyboardResponder, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在读者应该对<strong>Responder的职责</strong>有了一些基本的了解，它主要做以下几件事情:</p><ul><li>声明要监听的原生事件(如DOM), 如上面的<code>targetEventTypes</code></li><li>处理和转换合成事件，如上面的<code>onEvent</code></li><li>创建并分发自定义事件。如上面的<code>context.dispatchEvent</code></li></ul><p><br></p><p>和上面的Keyboard模块相比，现实中的很多高级事件，如longPress, 它们的实现则要复杂得多. 它们可能要维持一定的<strong>状态</strong>、也可能要独占响应的<strong>所有权</strong>(即同一时间只能有一个Responder可以对事件进行处理, 这个常用于移动端触摸手势，例如React Native的<a href="https://reactnative.cn/docs/gesture-responder-system/" target="_blank" rel="noopener">GestureResponderSystem</a>)。</p><p>react-events目前都考虑了这些场景, 看一下API概览:</p><p><img src="/images/react-event/react-events.png" alt></p><p><br></p><p>详细可以看react-events<a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener">官方仓库</a></p><p><br></p><h3 id="react-events意义何在"><a href="#react-events意义何在" class="headerlink" title="react-events意义何在?"></a>react-events意义何在?</h3><p>上文提到了React事件内部采用了插件机制，来实现事件处理和合成，比较典型的就是onChange事件。onChange事件其实就是所谓的‘高级事件’，它是通过表单组件的各种原生事件来模拟的。</p><p>也就是说，React通过插件机制本质上是可以实现高级事件的封装的。但是如果读者看过源代码，就会觉得里面逻辑比较绕，而且依赖React的很多内部实现。<strong>所以这种内部的插件机制并不是面向普通开发者的</strong>。</p><p><code>react-events</code>接口就简单很多了，它屏蔽了很多内部细节，面向普通开发者。我们可以利用它来实现高性能的自定义事件分发，更大的意义是通过它可以实现跨平台/设备的事件处理方式.</p><p>目前react-events还是实验阶段，特性是默认关闭，API可能会出现变更, 所以不建议在生产环境使用。可以通过这个<a href="https://github.com/facebook/react/issues/15257" target="_blank" rel="noopener">Issue</a>来关注它的进展。</p><p><br></p><p>最后赞叹一下React团队的创新能力！</p><p><br></p><p>完！</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://segmentfault.com/a/1190000013094932" target="_blank" rel="noopener">input事件中文触发多次问题研究</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">完全理解React Fiber</a></li><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark – A Cartoon Intro to Fiber – React Conf 2017</a></li><li><a href="https://philippspiess.com/scheduling-in-react/" target="_blank" rel="noopener">Scheduling in React</a></li><li><a href="https://github.com/facebook/react/issues/15257" target="_blank" rel="noopener">[Umbrella] React Flare</a></li><li><a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener">react-events</a></li></ul><p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=3rta2ztqa3sw4" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=3rta2ztqa3sw4</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react-event/sample.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发. &lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端团队Leader，怎么制定前端协作规范?</title>
    <link href="https://bobi.ink/2019/07/19/frontend-standard/"/>
    <id>https://bobi.ink/2019/07/19/frontend-standard/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2019-07-29T03:22:24.765Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢</p></blockquote><p><br></p><p>笔者长期单枪匹马在前端领域厮杀(言外之意就是团队就一个人)，自己就是规范。随着公司业务的扩展，扩充了一些人员，这时候就要开始考虑协作和编码规范问题了。本文记录了笔者在制定<code>前端协作规范</code>时的一些思考，希望能给你们也带来一些帮助.</p><p><strong>一个人走的更快，一群人可以走得更远，前提是统一的策略，还要不断地反省和优化</strong>。</p><p><br></p><p><strong>以下是目录概览, 看出这是一篇浩浩荡荡的长文</strong></p><!-- TOC --><ul><li><a href="#1-工作流规范">1 工作流规范</a><ul><li><a href="#11-开发">1.1 开发</a><ul><li><a href="#111-版本规范">1.1.1 版本规范</a></li><li><a href="#112-版本控制系统规范">1.1.2 版本控制系统规范</a></li><li><a href="#113-提交信息规范">1.1.3 提交信息规范</a></li></ul></li><li><a href="#12-构建规范">1.2 构建规范</a></li><li><a href="#13-发布工作流规范">1.3 发布工作流规范</a></li><li><a href="#14-持续集成">1.4 持续集成</a></li><li><a href="#15-任务管理">1.5 任务管理</a></li></ul></li><li><a href="#2-技术栈规范">2 技术栈规范</a><ul><li><a href="#21-技术选型">2.1 技术选型</a></li><li><a href="#22-迎接新技术">2.2 迎接新技术</a></li></ul></li><li><a href="#3-浏览器兼容规范">3 浏览器兼容规范</a><ul><li><a href="#31-确定兼容策略">3.1 确定兼容策略</a></li><li><a href="#32-确定浏览器分级">3.2 确定浏览器分级</a></li><li><a href="#33-获取统计数据">3.3 获取统计数据</a></li></ul></li><li><a href="#4-项目组织规范">4 项目组织规范</a><ul><li><a href="#41-通用的项目组织规范">4.1 通用的项目组织规范</a></li><li><a href="#42-目录组织的风格">4.2 目录组织的风格</a></li><li><a href="#43-脚手架和项目模板">4.3 脚手架和项目模板</a></li></ul></li><li><a href="#5-编码规范">5 编码规范</a><ul><li><a href="#51-javascript">5.1 Javascript</a></li><li><a href="#52-html">5.2 HTML</a></li><li><a href="#53-css">5.3 CSS</a></li><li><a href="#54-代码格式化">5.4 代码格式化</a></li><li><a href="#55-集大成的">5.5 集大成的</a></li><li><a href="#56-特定框架风格指南">5.6 特定框架风格指南</a></li><li><a href="#57-code-review">5.7 Code Review</a></li></ul></li><li><a href="#6-文档规范">6 文档规范</a><ul><li><a href="#61-建立文档中心">6.1 建立文档中心</a></li><li><a href="#62-文档格式">6.2 文档格式</a></li><li><a href="#63-定义文档的模板">6.3 定义文档的模板</a></li><li><a href="#64-讨论即文档">6.4 讨论即文档</a></li><li><a href="#65-注释即文档">6.5 注释即文档</a></li><li><a href="#66-代码即文档">6.6 代码即文档</a></li></ul></li><li><a href="#7-ui设计规范">7 UI设计规范</a></li><li><a href="#8-测试规范">8 测试规范</a><ul><li><a href="#81-测试的流程">8.1 测试的流程</a></li><li><a href="#82-单元测试">8.2 单元测试</a></li></ul></li><li><a href="#9-异常处理监控和调试规范">9 异常处理、监控和调试规范</a><ul><li><a href="#91-异常处理">9.1 异常处理</a></li><li><a href="#92-日志">9.2 日志</a></li><li><a href="#93-异常监控">9.3 异常监控</a></li></ul></li><li><a href="#10-前后端协作规范">10 前后端协作规范</a><ul><li><a href="#101-协作流程规范">10.1 协作流程规范</a></li><li><a href="#102-接口规范">10.2 接口规范</a></li><li><a href="#103-接口文档规范">10.3 接口文档规范</a></li><li><a href="#104-接口测试与模拟">10.4 接口测试与模拟</a></li></ul></li><li><a href="#11-培训知识管理技术沉淀">11 培训/知识管理/技术沉淀</a><ul><li><a href="#111-新人培训">11.1 新人培训</a></li><li><a href="#112-营造技术氛围">11.2 营造技术氛围</a></li></ul></li><li><a href="#12-反馈">12 反馈</a></li></ul><!-- /TOC --><p><br></p><p><strong>CHANGELOG</strong></p><ul><li>2019.7.28<br>新增<a href="#tech-select">技术选型</a></li><li>2019.7.29<br>新增<a href="#brw-anly">浏览器统计数据获取</a></li></ul><p><br></p><p><strong>什么是规范?</strong></p><p>规范，名词意义上：即明文规定或约定俗成的标准，如：道德规范、技术规范等。 动词意义上：是指按照既定标准、规范的要求进行操作，使某一行为或活动达到或超越规定的标准，如：规范管理、规范操作.</p><p><br></p><p><strong>为什么需要规范?</strong></p><ul><li>降低新成员融入团队的成本, 同时也一定程度避免挖坑</li><li>提高开发效率、团队协作效率, 降低沟通成本</li><li>实现高度统一的代码风格，方便review, 另外一方面可以提高项目的可维护性</li><li>规范是实现自动化的基础</li><li>规范是一个团队知识沉淀的直接输出</li></ul><p><br></p><p><strong>规范包含哪些内容?</strong></p><p>如文章标题，<strong>前端协作规范并不单单指‘编码规范’，这个规范涉及到前端开发活动的方方面面</strong>，例如代码库的管理、前后端协作、代码规范、兼容性规范；</p><p>不仅仅是前端团队内部需要协作，一个完整的软件生命周期内，我们需要和产品/设计、后端(或者原生客户端团队)、测试进行协作, 我们需要覆盖这些内容.</p><p><br></p><p>下面就开始介绍，<strong>如果我是前端团队的Leader，我会怎么制定前端规范，这个规范需要包含哪些内容</strong>?</p><p><br></p><h2 id="1-工作流规范"><a href="#1-工作流规范" class="headerlink" title="1 工作流规范"></a>1 工作流规范</h2><h3 id="1-1-开发"><a href="#1-1-开发" class="headerlink" title="1.1 开发"></a>1.1 开发</h3><h4 id="1-1-1-版本规范"><a href="#1-1-1-版本规范" class="headerlink" title="1.1.1 版本规范"></a>1.1.1 版本规范</h4><p>项目的版本号应该根据某些规则进行迭代, 这里推荐使用<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a>规范, <strong>通过这个规范，用户可以了解版本变更的影响范围</strong>。 规则如下:</p><ul><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h4 id="1-1-2-版本控制系统规范"><a href="#1-1-2-版本控制系统规范" class="headerlink" title="1.1.2 版本控制系统规范"></a>1.1.2 版本控制系统规范</h4><p>大部分团队都使用git作为版本库，管理好代码也是一种学问。尤其是涉及多人并发协作、需要管理多个软件版本的情况下，定义良好的版本库管理规范，可以让大型项目更有组织性，也可以提高成员协作效率.</p><p>比较流行的git分支模型/工作流是<a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" target="_blank" rel="noopener">git-flow</a>, 但是大部分团队会根据自己的情况制定自己的git工作流规范, 例如我们团队的<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/development.md#git-%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">分支规范</a></p><p><strong>Git 有很多工作流方法论，这些工作流的选择可能依赖于项目的规模、项目的类型以及团队成员的结构</strong>.</p><p>比如一个简单的个人项目可能不需要复杂的分支划分，我们的变更都是直接提交到 master 分支;</p><p>再比如开源项目，除了核心团队成员，其他贡献者是没有提交的权限的，而且我们也需要一定的手段来验证和讨论贡献的代码是否合理。 所以对于开源项目 fork 工作流更为适合.</p><p>了解常见的工作流有利于组织或创建适合自己团队的工作流, 提交团队协作的效率:</p><p><img src="/images/frontend-standard/branch.png" alt></p><ul><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/centralized.md" target="_blank" rel="noopener">简单的集中式</a></li><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/feature.md" target="_blank" rel="noopener">基于功能分支的工作流</a></li><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/gitflow.md" target="_blank" rel="noopener">Git Flow</a> 🔥</li><li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/fork.md" target="_blank" rel="noopener">Fork/Pull Request 工作流</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h4 id="1-1-3-提交信息规范"><a href="#1-1-3-提交信息规范" class="headerlink" title="1.1.3 提交信息规范"></a>1.1.3 提交信息规范</h4><p><img src="/images/frontend-standard/commit.png" alt></p><p>组织好的提交信息, 可以提高项目的整体质量. 至少具有下面这些优点:</p><ul><li><strong>格式统一的提交信息有助于自动化生成CHANGELOG</strong></li><li><strong>版本库不只是存放代码的仓库, 它记录项目的开发日志, 它应该要清晰表达这次提交的做了什么</strong>. 这些记录应该可以帮助后来者快速地学习和回顾代码, 也应该方便其他协作者review你的代码</li><li><strong>规范化提交信息可以促进提交者提交有意义的、粒度合适的’提交’</strong>. 提交者要想好要怎么描述这个提交，这样被动促进了他们去把控<strong>提交的粒度</strong></li></ul><p><br></p><p>社区上比较流行的提交信息规范是<a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit" target="_blank" rel="noopener">Angular的提交信息规范</a>, 除此之外，这些也很不错:</p><ul><li><a href="https://github.com/atom/atom/blob/master/CONTRIBUTING.md#git-commit-messages" target="_blank" rel="noopener">Atom</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-ember" target="_blank" rel="noopener">Ember</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-eslint" target="_blank" rel="noopener">Eslint</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-jquery" target="_blank" rel="noopener">JQuery</a></li></ul><p><br></p><p>另外这些工具可以帮助你检验提交信息, 以及生成CHANGELOG:</p><ul><li><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener">conventional-changelog</a> - 从项目的提交信息中生成CHANGELOG和发布信息</li><li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">commitlint</a> - 检验提交信息</li><li><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">commitizen</a> - 🔥简单的提交规范和提交帮助工具，推荐</li><li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">standard-changelog</a> - angular风格的提交命令行工具 </li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-2-构建规范"><a href="#1-2-构建规范" class="headerlink" title="1.2 构建规范"></a>1.2 构建规范</h3><p>对于团队、或者需要维护多个项目场景，统一的构建工具链很重要, <strong>这套工具应该强调”约定大于配置”，让开发者更专注于业务的开发</strong>。笔者在<a href="https://juejin.im/post/5d2fcaacf265da1b95708f63" target="_blank" rel="noopener">&lt;为什么要用vue-cli3?&gt;</a>文章中提出了<code>vue-cli3</code>更新有很多亮点，非常适合作为团队构建工具链的基础:</p><ul><li><strong>首先这类工具是推崇’约定大于配置’</strong>。即按照他们的规范，可以实现开箱即用，快速开发业务. 在团队协作中这点很重要，我们不推荐团队成员去关心又臭又长的webpack构建配置</li><li><strong><code>vue-cli3</code>抽离了<code>cli service层</code>，可以独立更新工具链</strong>。也就是说项目的构建脚本和配置在一个独立的service项目中维护，而不是像以前一样在每个项目目录下都有webpack配置和依赖. 这样做的好处是独立地、简单地升级整个构建链</li><li><strong>灵活的插件机制</strong>。对于团队的定制化构建应该封装到插件中，这样也可以实现独立的更新。</li></ul><p><strong>我们可以选择第三方CLI, 当然也定制自己的构建链，按照上面说的这个构建链应该有以下特点</strong>:</p><ul><li><strong>强约定，体现团队的规范</strong>。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 <em>另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能</em>。</li><li><strong>方便升级</strong>。尤其是团队需要维护多个项目场景, 这一点很有意义</li></ul><p>下面是社区上比较流行的构建工具. 当然，你也可以根据自己的团队情况开发自己的CLI, 但是下面的工具依然很有<em>参考价值</em>：</p><ul><li><a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> - 🔥零配置开始React开发</li><li><a href="https://cli.vuejs.org/" target="_blank" rel="noopener">vue-cli</a> - 🔥零配置、渐进增强的项目构建CLI</li><li><a href="https://parceljs.org/" target="_blank" rel="noopener">parcel</a> - 零配置的Web应用打包工具</li><li><a href="https://github.com/fuse-box/fuse-box" target="_blank" rel="noopener">Fusebox</a> - 高速易用的打包工具</li><li><a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> - 零配置, 基于Rollup，适合用于打包‘库’</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-3-发布工作流规范"><a href="#1-3-发布工作流规范" class="headerlink" title="1.3 发布工作流规范"></a>1.3 发布工作流规范</h3><p>发布工作流指的是将‘软件成品’对外发布(如测试或生产)的一套流程, 将这套流程规范化后，可以实现自动化.</p><p>举个例子, 一个典型的发布工作流如下：</p><p><img src="/images/frontend-standard/pub.png" alt></p><ul><li>代码变更</li><li>提交代码变更到远程版本库</li><li>程序通过CI测试(例如Travis变绿)</li><li>提升package.json中的版本</li><li>生成CHANGELOG</li><li>提交package.json和CHANGELOG.md文件</li><li>打上Tag</li><li>推送</li></ul><p>如果你遵循上面的规范，那么就可以利用社区上现有的工具来自动化这个流程. 这些工具有:</p><ul><li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli" target="_blank" rel="noopener">conventional-changelog-cli</a></li><li><a href="https://github.com/conventional-changelog/conventional-github-releaser" target="_blank" rel="noopener">conventional-github-releaser</a></li><li>实际上自己开发一个也不是特别难的事情.</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-4-持续集成"><a href="#1-4-持续集成" class="headerlink" title="1.4 持续集成"></a>1.4 持续集成</h3><p>将整套开发工作流确定下来之后, 就可以使用<code>持续集成服务</code>来自动化执行整个流程。比如一个典型的CI流程:</p><p><img src="/images/frontend-standard/ci.png" alt></p><p><strong>持续集成是什么，有什么意义呢</strong>?</p><p>我们需要<code>持续集成</code>拆成两个词分别来理解, 什么是<code>持续</code>? 什么是<code>集成</code>?</p><p><strong>持续(Continuous), 可以理解为’频繁’或者‘连续性’</strong>. 不管是持续集成还是敏捷开发思维、看板，都认为‘持续’是它们的基础。</p><p>举一个通俗的例子，<strong>比如代码检查，‘持续的’的代码检查就是代码一变动(如保存，或者IDE实时检查、或者提交到版本库时)就马上检查代码，而‘非持续’的代码检查就是在完成所有编码后，再进行检查</strong>。对比两者可以发现，持续性的代码检查可以尽早地发现错误，而且错误也比较容易理解和处理，反之非持续性的代码检查，可能会发现一堆的错误，失之毫厘谬以千里，错误相互牵连，最终会变得难以收拾。</p><p><strong>‘持续’的概念，可以用于软件开发的方方面面，本质上就是把传统瀑布式的软件开发流程打碎，形成一个个更小的开发闭环，持续地输出产品，同时产品也持续地给上游反馈和纠正</strong>。</p><p><img src="/images/frontend-standard/continous.png" alt></p><p><strong>那什么是‘集成’呢</strong>？狭义的集成可以简单认为是<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe#heading-26" target="_blank" rel="noopener">‘集成测试’</a>吧. 集成测试可以对代码静态测试、单元测试、通过单元测试后可以进行集成测试，在应用组成一个整体后在模拟环境中跑E2E测试等等。也就是说，在这里进行一系列的自动化测试来验证软件系统。</p><p>广义的持续集成服务，不仅仅是测试，它还衍生出很多概念，例如持续交付、持续部署，如下图</p><p><img src="/images/frontend-standard/devops.png" alt></p><p>OK, <strong>总结一下为什么持续集成的好处</strong>:</p><ul><li>尽早发现错误，快速试错。越早发现错误，处理错误的成本越低</li><li>自动化工作流，减少人工干预。人类比机器容易犯错, 而且机器擅长做重复的事情</li></ul><p><br></p><p><strong>对于持续集成规范一般会定义这些内容</strong>:</p><ul><li>执行的环境. 比如容器、Node版本、操作系统等等</li><li>触发的条件。比如定时触发、在哪个分支触发、会触发什么任务等等</li><li>执行的任务</li><li>划分持续集成的阶段. 比如<ul><li>检查：包括单元测试和代码lint. 所有push到版本库的代码都会跑这个阶段. 一般可以在提交title中包含[ci skip]来跳过这个阶段</li><li>构建: 对前端项目进行构建. 只有打上版本tag的提交或release分支会跑构建任务</li><li>发布: 将前端的构建结果进行交付/发布.  只有打上版本tag的提交或者release分支在构建成功后会跑发布任务</li></ul></li><li>定义持续集成脚本模板</li></ul><p><br></p><p>常用的CI服务:</p><ul><li>Github<ul><li><a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a></li><li><a href="https://github.com/marketplace/circleci" target="_blank" rel="noopener">CircleCI</a></li><li><a href="https://github.com/marketplace/category/continuous-integration" target="_blank" rel="noopener">完整列表</a></li></ul></li><li>GitLab: <a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">Gitlab-CI</a></li><li>通用<ul><li><a href="https://jenkins.io" target="_blank" rel="noopener">Jenkins</a></li></ul></li></ul><p><br></p><p>扩展</p><ul><li><a href="https://juejin.im/post/58f9ee860ce46300611be392" target="_blank" rel="noopener">持续集成是什么</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="1-5-任务管理"><a href="#1-5-任务管理" class="headerlink" title="1.5 任务管理"></a>1.5 任务管理</h3><p><img src="/images/frontend-standard/kanban.png" alt></p><p>作为前端Leader少不了任务管理。<strong>看板是目前最为流行的任务管理工具，它可以帮助我们了解项目的进度、资源的分配情况、还原开发现场</strong>.</p><p>笔者毕业第一年在一家很小的外包公司中工作，初生牛犊不怕虎，我竟然给老板推销起了看板和敏捷项目管理，想要改善项目管理这块效率低下问题，老板表示很支持，但是其他成员积极性并不高, 结果当然是失败的。</p><p>当时还起草了一份<a href="https://github.com/ivan-94/kanban_enforcement/blob/master/README.md#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%8B%E6%9D%BF" target="_blank" rel="noopener">‘看板实施细则’</a>, 所以任务管理这一块也算小有心得吧.</p><p>说说一些比较好用的工具吧：</p><ul><li><strong>基于issue看板</strong> - 可以基于Gitlab或Github的Issue来做任务管理，它们都支持看板。很Geek，推荐</li><li><a href="https://tower.im/" target="_blank" rel="noopener"><strong>Tower</strong></a> - 专门做看板任务管理的。小团队基本够用。我们现在就使用这款产品</li><li><a href="https://www.teambition.com/" target="_blank" rel="noopener"><strong>teambition</strong></a> - 和Tower差不多，没有深入使用过</li><li><a href="https://trello.com/" target="_blank" rel="noopener"><strong>Trello</strong></a> - 颜值高.</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="2-技术栈规范"><a href="#2-技术栈规范" class="headerlink" title="2 技术栈规范"></a>2 技术栈规范</h2><p>笔者现在所在的公司之前前端技术栈就非常混乱，Vue、React和AngularJS三大框架都有, 而且风格相差也很大. 当时我就想收包裹走人. 关于技术栈不规范的下场可以参考印度的飞机: <a href="https://www.zhihu.com/question/26042167/answer/690035402" target="_blank" rel="noopener">&lt;为什么印度的飞机频繁被摔？&gt;</a></p><p>很少有人能精通这三个框架的，更别说是一个团队。</p><p><strong>三大框架跟编程语言一样都有自己的设计哲学，这跟库是不一样, 一个库的替换成本很低；而框架的背后是一个架构、一个生态。每个框架背后牵涉着开发思维、生态系统、配套工具、最佳实践、性能调优。要精通和熟练一个框架需要付出的成本是很高</strong>。</p><p><strong>所以说团队的开发效率是基于稳定且熟练的技术栈的</strong>。稳定的技术栈规范有利于团队协作和沟通; 另外如果团队精通这个技术栈，当出现问题或者需要深入调优, 会相对轻松。</p><p>前端技术栈规范主要包含下面这些类型:</p><ul><li>编程语言 - Typescript或Javascript</li><li>UI框架及其配套生态, 以及备选方案。其背后的生态非常庞大:<ul><li>UI框架</li><li>路由</li><li>状态管理</li><li>组件库</li><li>国际化</li><li>动画</li><li>服务端渲染</li><li>脚手架、CLI工具</li><li>组件测试</li></ul></li><li>样式. 包含了命名规范、预处理器、方法论等等</li><li>动画引擎</li><li>QA. 包含了测试、Lint、格式化工具、监控</li><li>项目构建工具流. 例如webpack、vue-cli</li><li>包管理器。npm、yarn</li><li>项目管理工具</li><li>时间处理。例如Moment.js</li><li>模板引擎</li><li>开发工具</li><li>后端开发框架</li><li>工具库</li><li>开发/调试工具</li><li>等等</li></ul><p>可以参考一下我们团队的<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/tech-stack.md" target="_blank" rel="noopener">技术栈规范</a></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="2-1-技术选型"><a href="#2-1-技术选型" class="headerlink" title="2.1 技术选型"></a>2.1 技术选型</h3><p><a id="tech-select"></a></p><p><strong>如何从零对团队的技术栈进行规范, 或者说怎么进行选型呢</strong>？举个例子, 先确定备选项, 你现在要选Vue还是选React(一个可能引起论战的主题)？</p><p>恰好前几天在SegmentFault回答了一个问题: <a href="https://segmentfault.com/q/1010000019762657/a-1020000019775888" target="_blank" rel="noopener">&lt;什么时候用vue什么时候用react？&gt;</a>, 我讲了一个我们<strong>几年前</strong>是如何决定要使用React还是Vue的例子(注意结果不重要！)：</p><p><img src="/images/frontend-standard/vue-vs-react.png" alt></p><p><br></p><p><a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a>这篇文章写得非常好，给了我一些启发。结合上面的回答的例子, 来讲一讲在对相关技术进行选型的一些方法(评分项):</p><ul><li><p><strong>选择你最熟悉的技术</strong>。上面说到团队如果熟悉该技术，则可以很好地控制使用过程中的风险，方便对程序进行调优。所以成员熟悉、或至少Leader熟悉程度，是技术选型的一个打分项。</p><p>我们团队最终选择React的一个原因，就是我们熟悉它，它已经在现有的几个应用中良好的运行了，所以 React + 1</p></li><li><p><strong>选择拥有强大生态和社区支撑的开源技术</strong>。有强大的生态和社区意味着，很多东西你不需要重复去造轮子，或者遇到问题可以很快解决，有更多的选择。从公司层面、使用活跃的技术也比较好招人。</p><p>上面的例子也提到了这点，几年前React的生态是强于Vue的，所以 React + 1</p></li><li><p><strong>选择成长期的技术</strong>。<a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a>里面有一句话：’选择一个技术的最低标准是，技术的生命周期必须显著长于项目的生命周期’</p><p> 我们选择的技术应该是向前发展的、面向未来的, 这是选型的基本原则。所以我们一般不会去选择那些’过气’的技术，比如<code>AngularJS</code>(1.x)、<code>Backbone</code>. 因为现在有更好的选择，不必过于保守。</p><p> ‘向前’还意味着Leader要能够预判该技术未来走向，这里有很多参考因素，比如大厂的支撑、目前社区的活跃度、开发活跃度等等</p><p> React、Vue都非常有动力，比如React最近的React Hook、还有未来的ConcurrentMode、Async Rendering… 在这点上Vue和React打成平手吧</p></li><li><p><strong>API的稳定性</strong>。比较典型的例子就是Angular和Python，API不稳定会导致社区的割裂，也会导致项目升级成本变高、或者无法升级, 最终成为技术债。</p><p>不过值得庆幸的是因为有这么多历史教训，现在开源项目在API变更上面是非常谨慎的，参考<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">[译] Vue 最黑暗的一天</a>事件. </p><p>这点上React和Vue依旧打平</p></li><li><p><strong>基础设施配合</strong>。一个技术往往不是孤立存在的，它需要和其他技术相互配合，这种技术之间的融合度也是需要考虑的。</p><p>这个根据团队使用情况来定，比如我们团队统一使用Typescript，Vue跟Typescript配合使用其实不理想，所以 React + 1</p></li><li><p><strong>业务考虑</strong> <a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a> 提到一点就是‘学会从业务端开始思考’. 意思<strong>就是选型需要充分地理解业务，理解用户需求，当下需要解决的首要问题，以及可能的风险有哪些，再将目标进行分解，进行具体的技术选型、模型设计、架构设计</strong>.</p><p>一个典型的例子就是10年前火遍世界的<code>Rails</code>, 后端是使用Rails还是Java/C#/PHP这些传统后端技术? 很多初创公司(如Github、Gitlab、Twitter)选择了前者，他们需要快速开发原型、快速占领市场, Rails开发很爽很快啊, 这种选型就是符合‘业务需求的’。</p><p>那么前端好像跟业务离得有点远? 随着‘大前端’的发展，我们的工作对公司业务的影响只会越来越大。</p><p>比如上面提到的React Native，我们当时有考虑在移动端应用React Native技术，实现客户端的跨平台，这就是业务影响啊。这时候React是不是又要 +1? 同理还有什么服务端渲染、Serverless等等，期待前端的地位会越来越高</p></li></ul><p>综上，在这个案例中，React是胜出的。</p><p>扩展:</p><ul><li><a href="https://www.infoq.cn/article/2017/02/Technology-selection" target="_blank" rel="noopener">谈谈技术选型</a></li><li><a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">谈谈技术选型的注意事项</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="2-2-迎接新技术"><a href="#2-2-迎接新技术" class="headerlink" title="2.2 迎接新技术"></a>2.2 迎接新技术</h3><p>当然，对于团队而言也要鼓励学习新的技术、淘汰旧的技术栈。因为一般而言新的技术或解决方案，是为了更高的生产力而诞生的。<strong>当团队容纳一个新的技术选型需要考虑以下几点</strong>：</p><ul><li><strong>学习成本</strong>。考虑团队成员的接纳能力。如果成本小于收获的利益，在团队里面推行估计阻力会比较大</li><li><strong>收益</strong>。是否能够解决当前的某些痛点</li><li><strong>考虑风险</strong>。一般我们不能将一个实验阶段的技术使用的生产环境中</li></ul><p>就我们团队而言，每个成员都有自己感兴趣的方向和领域，所以我们可以分工合作，探索各自的领域，再将成果分享出来，如果靠谱的话则可以在实验项目中先试验一下，最后才推广到其他项目.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="3-浏览器兼容规范"><a href="#3-浏览器兼容规范" class="headerlink" title="3 浏览器兼容规范"></a>3 浏览器兼容规范</h2><p>前端团队应该根据针对应用所面对的用户情况、应用类型、开发成本、浏览器市场统计数据等因素，来制定自己的浏览器兼容规范，并写入应用使用手册中.</p><p><strong>有了浏览器兼容规范，前端开发和兼容性测试就有理有据，避免争议; 同时它也是前端团队的一种对外声明，除非特殊要求，不符合浏览器兼容规范的浏览器，前端开发人员可以选择忽略</strong>。</p><p><br></p><h3 id="3-1-确定兼容策略"><a href="#3-1-确定兼容策略" class="headerlink" title="3.1 确定兼容策略"></a>3.1 确定兼容策略</h3><p><img src="/images/frontend-standard/g-p.jpg" alt></p><p><strong>渐进增强</strong>还是<strong>优雅降级</strong>. 这是两个不同方向策略，<strong>渐进增强保证低版本浏览器的体验，对于支持新特性的新浏览器提供稍好的体验</strong>；<strong>优雅降级则是相反的，为现代浏览器提供最好的体验，而旧浏览器则退而求之次，保证大概的功能</strong>.</p><p>选择不同的策略对前端开发的影响是比较大的，但是开发者没有选择权。<strong>确定哪种兼容策略，应该取决于用户比重，如果大部分用户使用的是现代浏览器，就应该使用优雅降级，反之选择渐进增强</strong>.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="3-2-确定浏览器分级"><a href="#3-2-确定浏览器分级" class="headerlink" title="3.2 确定浏览器分级"></a>3.2 确定浏览器分级</h3><p><img src="/images/frontend-standard/brw-levl.gif" alt></p><p>YUI就曾提出浏览器分级原则，到今天这个原则依然适用。简单说就是将浏览器划分为多个等级，不同等级表示不同的支持程度. 比如我们团队就将浏览器划分为以下<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/browser-compatibility.md" target="_blank" rel="noopener">三个等级</a>:</p><ul><li><strong>完全兼容</strong>: 保证百分百功能正常</li><li><strong>部分兼容</strong>: 只能保证功能、样式与需求大致一致。对于一些不影响主体需求和功能的bug，会做降低优先级处理或者不处理。</li><li><strong>不兼容</strong>: 不考虑兼容性</li></ul><p>一般而言, 根据浏览器市场分布情况、用户占比、开发成本等因素划分等级.</p><p>举个例子，下面是我们对管理系统的兼容规范:</p><p><img src="/images/frontend-standard/cpt.png" alt></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="3-3-获取统计数据"><a href="#3-3-获取统计数据" class="headerlink" title="3.3 获取统计数据"></a>3.3 获取统计数据</h3><p><a id="brw-anly"></a></p><p><img src="/images/frontend-standard/bdtj.png" alt></p><p><br></p><p><a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>是中文网站使用最为广泛的、免费的流量分析平台. 如上图，通过这些统计平台可以获取到终端真实的浏览器使用情况, 点击<a href="https://tongji.baidu.com/web/demo/visit/client?siteId=5503017" target="_blank" rel="noopener">查看示例</a>。</p><p>如果公司没有开发自己监控服务，还是建议使用这些免费的，有大厂支持的监控工具:</p><ul><li><a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a></li><li><a href="https://web.umeng.com/main.php?spm=a211g2.211692.0.0.3a437d23sjzEPv&amp;c=user&amp;a=index" target="_blank" rel="noopener">友盟</a></li><li><a href="https://analytics.google.com/analytics/web/" target="_blank" rel="noopener">Google Analytics</a> 需要kx上网</li></ul><p><br></p><p><strong>可以从这些地方获取通用的浏览器统计数据</strong>:</p><ul><li><a href="http://tongji.baidu.com/data/browser" target="_blank" rel="noopener">百度流量研究院</a>：主要提供国内浏览器统计</li><li><a href="http://gs.statcounter.com/" target="_blank" rel="noopener">statcounter</a>: 国际浏览器统计</li><li><a href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers" target="_blank" rel="noopener">浏览器发布年份统计</a></li></ul><p><br></p><p><strong>确定浏览器是否支持某个特性</strong>:</p><ul><li><a href="https://caniuse.com" target="_blank" rel="noopener">caniuse</a></li><li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="4-项目组织规范"><a href="#4-项目组织规范" class="headerlink" title="4 项目组织规范"></a>4 项目组织规范</h2><p>项目组织规范定义了如何组织一个前端项目, 例如项目的命名、项目的文件结构、版本号规范等等。尤其对于开源项目，规范化的项目组织就更重要了。</p><h3 id="4-1-通用的项目组织规范"><a href="#4-1-通用的项目组织规范" class="headerlink" title="4.1 通用的项目组织规范"></a>4.1 通用的项目组织规范</h3><p>一个典型的项目组织规范如下:</p><ul><li><strong>README.md</strong>: 项目说明, 这个是最重要。你必须在这里提供关于项目的关键信息或者相关信息的入口. 一般包含下列信息:<ul><li>简要描述、项目主要特性</li><li>运行环境/依赖、安装和构建、测试指南</li><li>简单示例代码</li><li>文档或文档入口, 其他版本或相关资源入口</li><li>联系方式、讨论群</li><li>许可、贡献/开发指南</li></ul></li><li><strong>CHANGELOG.md</strong>: 放置每个版本的变动内容, 通常要描述每个版本变更的内容。方便使用者确定应该使用哪个版本. 关于CHANGELOG的规范可以参考<a href="https://keepachangelog.com/en/1.0.0/" target="_blank" rel="noopener">keep a changelog</a></li><li><strong>package.json</strong>: 前端项目必须. 描述当前的版本、<strong>可用的命令</strong>、包名、依赖、环境约束、项目配置等信息.</li><li><strong>.gitignore</strong>: 忽略不必要的文件，避免将自动生成的文件提交到版本库</li><li><strong>.gitattributes</strong>: git配置，有一些跨平台差异的行为可能需要在这里配置一下，如换行规则</li><li><strong>docs/</strong>: 项目的细化文档, 可选.</li><li><strong>examples/</strong>: 项目的示例代码，可选.</li><li><strong>build</strong>: 项目工具类脚本放置在这里，非必须。如果使用统一构建工具，则没有这个目录</li><li><strong>dist/</strong>: 项目构建结果输出目录</li><li><strong>src/</strong>: 源代码目录</li><li><p><strong><strong>tests</strong>/</strong>: 单元测试目录. 按照<a href="http://jestjs.io" target="_blank" rel="noopener">Jest</a>规范, <code>__tests__</code>目录通常和被测试的模块在同一个父目录下, 例如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/src</span><br><span class="line">  __tests__/</span><br><span class="line">    index.ts</span><br><span class="line">    a.ts</span><br><span class="line">  index.ts</span><br><span class="line">  a.ts</span><br></pre></td></tr></table></figure></li><li><p><strong>tests</strong>: 全局的测试目录，通常放应用的集成测试或E2E测试等用例</p></li><li><p><strong>.env*</strong>: 项目中我们通常会使用<code>环境变量</code>来影响应用在不同运行环境下的行为. 可以通过<a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotEnv</a>来从文件中读取环境变量. 通常有三个文件:</p><ul><li><code>.env</code> 通用的环境变量</li><li><code>.env.development</code> 开发环境的环境变量</li><li><code>.env.production</code> 生成环境的环境变量</li></ul><p>基本上这些文件的变动的频率很少，团队成员应该不要随意变动，以免影响其他成员。所以通常会使用<code>.env.*.local</code>文件来覆盖上述的配置, 另外会设置版本库来忽略<code>*.local</code>文件.</p></li></ul><p><br></p><p><strong>对于开源项目通常还包括这些目录</strong>:</p><ul><li><strong>LICENSE</strong>: 说明项目许可</li><li><strong>.github</strong>: 开源贡献规范和指南<ul><li>CONTRIBUTING: 贡献指南, 这里一般会说明贡献的规范、以及项目的基本组织、架构等信息</li><li>CODE_OF_CONDUCT: 行为准则</li><li>COMMIT_CONVENTION: 提交信息规范，上文已经提及</li><li>ISSUE_TEMPLATE: Issue的模板，github可以自动识别这个模板</li><li>PULL_REQUEST_TEMPLATE: PR模板</li></ul></li></ul><p>任意一个优秀的开源项目都是你的老师，例如<a href="https://github.com/facebook/react" target="_blank" rel="noopener">React</a>、<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue</a>…</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="4-2-目录组织的风格"><a href="#4-2-目录组织的风格" class="headerlink" title="4.2 目录组织的风格"></a>4.2 目录组织的风格</h3><p>上面只是一个通用的项目组织规范，具体源代码如何组织还取决于你们使用的技术栈和团队喜好。网上有很多教程，具体可以搜索<code>怎么组织XX项目</code>. 总结一下项目组织主要有三种风格:</p><ul><li><p><strong>Rails-style</strong>: 按照文件的类型划分为不同的目录，例如<code>components</code>、<code>constants</code>、 <code>typings</code>、<code>views</code>. 这个来源于Ruby-on-Rails框架，它按照MVC架构来划分不同的目录类型，典型的目录结构如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  models # 模型</span><br><span class="line">  views # 视图</span><br><span class="line">  controllers # 控制器</span><br><span class="line">  helpers # 帮助程序</span><br><span class="line">  assets  # 静态资源</span><br><span class="line">config     # 配置</span><br><span class="line">  application.rb</span><br><span class="line">  database.yml</span><br><span class="line">  routes.rb      # 路由控制</span><br><span class="line">  locales        # 国际化配置</span><br><span class="line">  environments/</span><br><span class="line">db        # 数据库相关</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>Domain-style</strong>:  按照一个功能特性或业务创建单独的目录，这个目录就近包含多种类型的文件或目录. 比如一个典型的Redux项目，所有项目的文件就近放置在同一个目录下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Users/</span><br><span class="line">Home/</span><br><span class="line">  components/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  constants.js</span><br><span class="line">  index.js</span><br><span class="line">  model.js</span><br><span class="line">  reducer.js</span><br><span class="line">  selectors.js</span><br><span class="line">  style.css</span><br><span class="line">index.js</span><br><span class="line">rootReducer.js</span><br></pre></td></tr></table></figure></li><li><p><strong>Ducks-style</strong>: 优点类似于Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下。Vue的单文件组件就是一个典型的例子，除此之外Vuex也是使用这种风格:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;My Todo App!&lt;/h1&gt;</span><br><span class="line">    &lt;TodoList/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import TodoList from &apos;./components/TodoList.vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    TodoList</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">@import &apos;./variables.scss&apos;;</span><br><span class="line">/* ... */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>大部分情况下, 我们都是使用混合两种方式的目录结构，例如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/      # 🔴 项目通用的‘展示组件’</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx    # 组件的入口, 导出组件</span><br><span class="line">      Groups.tsx   # 子组件</span><br><span class="line">      loading.svg  # 静态资源</span><br><span class="line">      style.css    # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts       # 到处所有组件</span><br><span class="line">  containers/      # 🔴 包含'容器组件'和'页面组件'</span><br><span class="line">    LoginPage/     # 页面组件, 例如登录</span><br><span class="line">      components/  # 页面级别展示组件，这些组件不能复用与其他页面组件。</span><br><span class="line">        Button.tsx # 组件未必是一个目录形式，对于一个简单组件可以是一个单文件形式. 但还是推荐使用目录，方便扩展</span><br><span class="line">        Panel.tsx</span><br><span class="line">      reducer.ts   # redux reduces</span><br><span class="line">      useLogin.ts  # (可选)放置'逻辑', 按照👆分离逻辑和视图的原则，将逻辑、状态处理抽取到hook文件</span><br><span class="line">      types.ts     # typescript 类型声明</span><br><span class="line">      style.css</span><br><span class="line">      logo.png</span><br><span class="line">      message.ts</span><br><span class="line">      constants.ts</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx      # 🔴应用根组件</span><br><span class="line">  hooks/           # 🔴可复用的hook</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.tsx        # 应用入口, 在这里使用ReactDOM对跟组件进行渲染</span><br><span class="line">  stores.ts        # redux stores</span><br><span class="line">  contants.ts      # 全局常量</span><br></pre></td></tr></table></figure><p><br></p><p>框架官方很少会去干预项目的组织方式，读者可以参考下面这些资源来建立自己项目组织规范:</p><ul><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fcn.redux.js.org%2Fdocs%2Ffaq%2FCodeStructure.html" target="_blank" rel="noopener">Redux 常见问题：代码结构</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Freact-boilerplate%2Freact-boilerplate" target="_blank" rel="noopener">react-boilerplate</a></li><li><a href="https://vuex.vuejs.org/zh/guide/structure.html" target="_blank" rel="noopener">vuex 项目结构</a></li><li><a href="https://juejin.im/post/5cd8fb916fb9a03218556fc1#heading-11" target="_blank" rel="noopener">React组件设计实践总结02 - 组件的组织</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="4-3-脚手架和项目模板"><a href="#4-3-脚手架和项目模板" class="headerlink" title="4.3 脚手架和项目模板"></a>4.3 脚手架和项目模板</h3><p>在将项目结构规范确定下来后，可以创建自己的脚手架工具或者项目模板，用于快速初始化一个项目或代码模板。</p><p>相关资源:</p><ul><li><a href="https://yeoman.io" target="_blank" rel="noopener">yeoman</a> - 老牌的项目脚手架工具</li><li><a href="https://github.com/amwmedia/plop" target="_blank" rel="noopener">plop</a> - 代码生成辅助CLI</li><li><a href="https://github.com/jondot/hygen" target="_blank" rel="noopener">hygen</a> - 类似于plop</li><li><a href="https://github.com/diegohaz/generact" target="_blank" rel="noopener">generact</a> - 生成React组件, 大部分组件的文件结构差不多, 这个工具就是帮助你生成这些重复的代码</li><li><a href="https://babeljs.io/docs/en/babel-generator" target="_blank" rel="noopener">babel-code-generator</a> - 利用babel来实现更高级的代码编辑和自动生成</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="5-编码规范"><a href="#5-编码规范" class="headerlink" title="5 编码规范"></a>5 编码规范</h2><p>网络上大部分‘前端规范’指的都是编码规范, 这是一种‘狭义’的前端规范. </p><p><strong>统一的编码规范对团队项目的长远维护不无裨益. 一致性的代码规范可以增强团队开发协作效率、提高代码质量、减少遗留系统维护的负担</strong>。</p><p>最直接的好处就是避免写出糟糕的代码, 糟糕的代码与新手和老手关系不大，我也见过好处工作很多年的‘资深’工程师写出恶心的代码. 这样的代码随着项目的迭代会变得难以控制。</p><p><strong>现代的Lint工具已经非常先进，几乎可以约束各种编码行为</strong>. 比如约束一个文件的长度、函数的复杂度、命名规范、注释规范、接口黑名单、DeadCode、检查简单的逻辑错误…</p><p>每一个程序员心目中对‘好代码’都有自己的主见，统一的编码规范可以像秦始皇统一战国一样，避免不必要的论战和争议。</p><p><br></p><p><strong>其实与其自己建立前端编码规范，笔者推荐选择社区沉淀下来的规范</strong>. 这方面的资源非常多，所以本文也不武断地提出自己的规范建议. 推荐下面这些资源:</p><p><br></p><h3 id="5-1-javascript"><a href="#5-1-javascript" class="headerlink" title="5.1 Javascript"></a>5.1 Javascript</h3><ul><li>Lint工具<ul><li><a href="https://cn.eslint.org" target="_blank" rel="noopener">ESLint</a> - 🔥目前是社区最流行的、通用的Javascript Lint工具，Lint界的Babel。支持定制插件、preset。如果不想折腾可以选择它的一些预定义配置</li><li><a href="https://github.com/palantir/tslint" target="_blank" rel="noopener">TSLint</a> - Typescript Lint工具。不过即将<a href="https://github.com/palantir/tslint/issues/4534" target="_blank" rel="noopener">废弃</a>了, 推荐使用ESLint</li></ul></li><li>规范<ul><li><a href="https://standardjs.com/readme-zhcn.html#why-should-i-use-javascript-standard-style" target="_blank" rel="noopener">JavaScript Standard Style</a> - 🔥 零配置的、‘标准’的Javascript编码规范. 底层基于Eslint。目前不支持Typescript</li><li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb JavaScript Style Guide</a> - Airbnb的编码规范，业界标杆</li></ul></li><li>类型检查. 暂时将它们归类到这里，因为它们同属于<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe#heading-39" target="_blank" rel="noopener">‘静态测试’</a><ul><li><a href="https://www.typescriptlang.org" target="_blank" rel="noopener">Typescript</a> - 🔥 Javascript语言的超集，这是一门‘新’的语言，而不是简单的类型检查器. 不过<strong>它也支持<a href="https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html" target="_blank" rel="noopener">原生Javascript的类型检查</a></strong></li><li><a href="https://flow.org" target="_blank" rel="noopener">Flow</a> - Facebook出品的类型检查器，语法和Typescript类似. 个人推荐使用Typescript</li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-2-html"><a href="#5-2-html" class="headerlink" title="5.2 HTML"></a>5.2 HTML</h3><ul><li>Lint工具<ul><li><a href="https://htmlhint.io" target="_blank" rel="noopener">HTMLHint</a></li><li><a href="https://github.com/twbs/bootlint" target="_blank" rel="noopener">bootlint</a></li></ul></li><li>规范<ul><li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-3-css"><a href="#5-3-css" class="headerlink" title="5.3 CSS"></a>5.3 CSS</h3><ul><li>Lint工具<ul><li><a href="https://stylelint.docschina.org" target="_blank" rel="noopener">stylelint</a> - 🔥 通用的CSS编码检查工具，支持最新的CSS语法、CSS-in-js、以及其他类CSS语法(如SCSS、Less). 它也有预定义配置，推荐使用</li></ul></li><li>规范<ul><li><a href="https://github.com/airbnb/css" target="_blank" rel="noopener">Airbnb CSS / Sass Styleguide</a></li><li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li><li><a href="https://css-tricks.com/css-style-guides/" target="_blank" rel="noopener">更多</a></li></ul></li><li>方法论<ul><li><a href="https://css-tricks.com/bem-101/" target="_blank" rel="noopener">BEM</a> - 🔥 BEM命名规范</li><li><a href="https://github.com/stubbornella/oocss/wiki" target="_blank" rel="noopener">OOCSS</a></li><li><a href="http://smacss.com" target="_blank" rel="noopener">smacss</a></li></ul></li></ul><p><br></p><p>关于CSS可以学习<a href="http://twitter.github.com/bootstrap/" target="_blank" rel="noopener">Bootstrap</a>这些传统UI框架，他们的代码组织性非常好, 值得学习</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-4-代码格式化"><a href="#5-4-代码格式化" class="headerlink" title="5.4 代码格式化"></a>5.4 代码格式化</h3><p><img src="/images/frontend-standard/prt.png" alt></p><ul><li><a href="https://prettier.io" target="_blank" rel="noopener">Prettier</a> - 🔥 关于代码格式化的所有东西都交给它吧！</li></ul><p>基本上，所有代码格式相关的工作都可以交给Prettier来做，在这个基础上再使用Eslint覆盖语义相关的检查</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-5-集大成的"><a href="#5-5-集大成的" class="headerlink" title="5.5 集大成的"></a>5.5 集大成的</h3><ul><li><a href="https://coderlmn.github.io/code-standards/#_code_reviews" target="_blank" rel="noopener">isobar 前端代码规范及最佳实践</a></li><li><a href="https://guide.aotu.io/index.html" target="_blank" rel="noopener">凹凸实验室代码规范</a></li><li><a href="https://github.com/fex-team/styleguide" target="_blank" rel="noopener">百度FEX规范</a></li><li><a href="http://nec.netease.com/standard" target="_blank" rel="noopener">老牌的NEC规范</a> - 有点老</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-6-特定框架风格指南"><a href="#5-6-特定框架风格指南" class="headerlink" title="5.6 特定框架风格指南"></a>5.6 特定框架风格指南</h3><ul><li><a href="https://vue.docschina.org/v2/style-guide/" target="_blank" rel="noopener">vue-style-guide</a></li><li><a href="https://github.com/airbnb/javascript/tree/master/react" target="_blank" rel="noopener">Airbnb React/JSX Style Guide</a></li><li><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715" target="_blank" rel="noopener">React组件设计实践总结</a> - 自荐一下笔者写的React组件设计相关实践</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="5-7-code-review"><a href="#5-7-code-review" class="headerlink" title="5.7 Code Review"></a>5.7 Code Review</h3><p><img src="/images/frontend-standard/code-review.png" alt></p><p>上述的Lint工具和类型检查器, 可以约束代码风格、避免低级的语法错误。但是即使通过上面的Lint和类型检查，代码也可能未必是‘好代码’。</p><p><strong>很多代码设计的‘最佳实践’是无法通过具象化的自动化工具或文档覆盖的, 这时候，’经验’或者’群体智慧’就派上用场了</strong>. 比如Code Review阶段会检查这些东西:</p><ul><li>编程原则、设计思想. 例如符合SOLID原则? 是否足够DRY？接口设计是否简洁易扩展、</li><li>模块耦合程度、代码重复</li><li>代码健壮性。是否存在内存泄露、是否线程安全、是否有潜在性能问题和异常、错误是否被处理</li><li>代码的性能和效率。</li><li>是否有没有考虑到的场景？</li></ul><p>如果你们是第一次推行Code Review, 可以建立一个检查列表，对照着进行检查。熟练后，心中自然无码。</p><p><br></p><p>Code Review有很多好处，比如：</p><ul><li><strong>Code Review可以让其他成员都熟悉代码</strong>。这样保证其他人都可以较快地接手你的工作，或者帮你解决某些问题</li><li><strong>提高代码质量</strong>。毫无疑问. 一方面是<em>主动性</em>的代码质量提升，比如你的代码需要被人Review，会自觉尽量的提高代码质量；另一方面，其他成员可以检查提交方的代码质量</li><li><strong>检查或提高新成员的编程水平</strong>。培养新人时，由于不信任它们提交的代码，我们会做一次Review检查代码是否过关。另一方面这是一次真实的案例讲解, 可以较快提高他们的能力</li></ul><p><br></p><p><strong>Code Review有两种方式: 一个<code>提交时</code>、一个是<code>定时</code></strong>:</p><ul><li><code>提交时</code>. 大部分开源项目采用这种方式。通俗讲就是Pull Request。只有代码通过测试、和其他成员的Review才可以合进正式版本库。这种方式也称为‘阻塞式’代码检查，一般配合GitFlow使用。</li><li><code>定时</code>. 在项目完结后、项目的某个里程碑、或者固定的时间(每天、每个星期..). 团队成员聚在一起，回顾自己写的代码, 让其他成员进行审查</li></ul><p>Code Review是比较难以推行的，不过这个也要看你们团队的情况，向我们钱少活多的团队，很少的时间去立马去兼顾其他成员的代码. 这时候<code>定时Review</code>会更有用，因为看起来更‘节省时间’.</p><p>而<code>提交时Review</code>则可以针对新人，比如你不信任他们的代码或者希望帮助他们提高编码能力。</p><p><br></p><p><strong>相关资源</strong>:</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTQwNTA3Nw==&amp;mid=400946871&amp;idx=1&amp;sn=5a125337833768d705f9d87ba8cd9fff&amp;scene=1&amp;srcid=0104FLyeXIS6N0EShgDseIfI&amp;key=41ecb04b051110031290b34976240e650f0169d239c89f125162a89c8d3412f2087198612e71fd7685cae9eebe08e295&amp;ascene=0&amp;uin=MTYyMDMzMTAwMA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C5+OSX+OSX+10.10.5+build(14F1509" target="_blank" rel="noopener">Code Review最佳实践</a>&amp;version=11020201&amp;pass_ticket=dc5bBckt1XSthRKTIsukYHIcAvKfv0jninbMlYQ5TWnE6XS%2FrRkdHKlJjNTI2Wsg)</li><li><a href="https://juejin.im/post/5c9740ba6fb9a071090d6a37" target="_blank" rel="noopener">是否要做Code Review？与BAT资深架构师争论之后的思考</a></li><li><a href="https://richardcao.me/2016/09/30/Talk-About-Codereview/" target="_blank" rel="noopener">一些Code Review工具</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="6-文档规范"><a href="#6-文档规范" class="headerlink" title="6 文档规范"></a>6 文档规范</h2><p>文档对于项目开发和维护、学习、重构、以及知识管理非常重要。</p><p>和写测试一样、大部分开发人员会觉得写文档是一件痛苦的事情，不过只有时间能够证明它的价值。比如对于人员流动比较大的公司，如果有规范的文档体系，转交工作就会变动非常轻松.</p><p><strong>广义的文档不单指‘说明文件’本身，它有很多形式、来源和载体，可以描述一个知识、以及知识形成和迭代的过程</strong>。例如版本库代码提交记录、代码注释、决策和讨论记录、CHANGELOG、示例代码、规范、传统文档等等</p><p><br></p><h3 id="6-1-建立文档中心"><a href="#6-1-建立文档中心" class="headerlink" title="6.1 建立文档中心"></a>6.1 建立文档中心</h3><p>我们公司是做IM的，所以之前我们优先使用’自己的’通讯工具来分享文档，这种方式有很大问题:</p><ol><li>如果没有存档习惯(比如后端的API文档，因为由后端维护，一般不会主动去存档), 文档就可能丢失，而且通讯工具是不会永久保存你的文档的。当丢失文件就需要重新和文档维护者索要</li><li>糟糕的是文档维护者也是自己手动在本地存档的，这样导致的问题是: 如果工作转交，其他开发者需要花费一点时间来查找; 丢失了就真的没了</li><li>每一次文档更新要重新发一份, 这很麻烦，而且可能出现漏发的情况, 导致前后不一致.</li><li>关于知识的学习、以及有意义的讨论记录无法归档。</li></ol><p>上面介绍的是一种非常原始的文档共享方式，很多小团队就是这么干的。</p><p><strong>对于项目本身的文档建议放置在关联项目版本库里面，跟随项目代码进行迭代, 当我们在检索或跟踪文档的历史记录时，这种方式是最方便的</strong>。</p><p>然而很多应用是跨越多个团队的，每个团队都会有自己的文档输出(比如需求文档、系统设计文档、API文档、配置文档等等)，而且通常也不会在一个版本库里。这时候文档就比较分散。所以一个统一的文档中心是很有必要。</p><p>我们公司现在选择的方案是<code>Git+Markdown</code>，也就是说所有的文档都放置在一个git版本库下。之前也考虑过商业的方案，譬如<a href="https://shimo.im/welcome" target="_blank" rel="noopener">石墨文档</a>、<a href="https://docs.qq.com" target="_blank" rel="noopener">腾讯文档</a>, 但管理层并不信任这些服务。</p><p>大概的git项目组织如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">规范/</span><br><span class="line">A应用/</span><br><span class="line">  产品/</span><br><span class="line">  设计/</span><br><span class="line">  API文档/</span><br><span class="line">  测试/</span><br><span class="line">  其他/</span><br><span class="line">B应用/</span><br></pre></td></tr></table></figure><p><strong>Git版本库(例如Gitlab)有很多优势，例如历史记录跟踪、版本化、问题讨论(可以关联issue、或者提交)、多人协作、搜索、权限管理(针对不同的版本库或分组为不同人员设置权限)等等</strong>。</p><p><code>Git+Markdown</code>可以满足开发者的大部分需求。但是<strong>Git最擅长的是处理纯文本文件、对于二进制是无能为力的，无法针对这些类型的文档进行在线预览和编辑</strong>。</p><p>所以<code>Git+Markdown</code>并不能满足多样化的文档处理需求，比如思维导图、图表、表格、PPT、白板等需求. 毕竟它不是专业的文档处理工具。所以对于产品、设计人员这些富文档需求场景，通常会按照传统方式或者更专业的工具对文档进行管理.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-2-文档格式"><a href="#6-2-文档格式" class="headerlink" title="6.2 文档格式"></a>6.2 文档格式</h3><p>毫无疑问，对于开发者来说，<a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown</a>是最适合的、最通用的文档格式。支持版本库在线预览和变更历史跟踪。</p><p>下面这些工具可以提高Markdown的开发效率:</p><ul><li>可视化编辑器<ul><li><strong>Visual Code</strong>: 大部分代码编辑都支持Markdown编辑和预览</li><li><a href="https://link.jianshu.com/?t=http://mouapp.com/" target="_blank" rel="noopener"><strong>Mou</strong></a>: Mac下的老牌编辑器</li><li><a href="https://typora.io" target="_blank" rel="noopener"><strong>typora</strong></a>: 跨平台的Markdown编辑器，推荐</li></ul></li><li><strong>markdownlint</strong>: 编码检查器</li><li>扩展(Visual Studio Code):<ul><li><strong>Markdown All in One</strong>: All you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more)</li><li><strong>Markdown TOC</strong>: markdown 目录生成，我最常用的markdown插件</li></ul></li><li>图表绘制工具:<ul><li><a href="https://www.draw.io" target="_blank" rel="noopener"><strong>drawio</strong></a> 基于Web的图表绘制工具、也有离线客户端</li><li><strong>KeyNote/PPT</strong> 临时绘图也不错</li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-3-定义文档的模板"><a href="#6-3-定义文档的模板" class="headerlink" title="6.3 定义文档的模板"></a>6.3 定义文档的模板</h3><p>关于如何写好文档，很难通过标准或规范来进行约束，因为它的主观性比较强, 好的文档取决于编辑者的逻辑总结能力、表达能力、以及有没有站在读者的角度去思考问题。</p><p>所以大部分情况下，我们可以为不同类型的文档提供一个模板，通过模板来说明一个文档需要包含哪些内容, 对文档的编写者进行引导.</p><p>例如一个API文档可能需要这些内容:</p><ul><li>接口的索引</li><li>接口的版本、变更记录</li><li>用法和整体描述, 认证鉴权等等</li><li>描述具体的接口<ul><li>功能说明</li><li>方法名称或者URI</li><li>参数和返回值定义</li><li>调用示例</li><li>注意事项等等</li></ul></li></ul><p>具体规范内容因团队而异，这里点到为止.</p><p><br></p><p>扩展:</p><ul><li><a href="https://github.com/ruanyf/document-style-guide/blob/master/docs/reference.md" target="_blank" rel="noopener">中文技术文档的写作规范</a></li><li><a href="https://github.com/reactjs/rfcs/blob/master/0000-template.md" target="_blank" rel="noopener">React RFC模板</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-4-讨论即文档"><a href="#6-4-讨论即文档" class="headerlink" title="6.4 讨论即文档"></a>6.4 讨论即文档</h3><p><strong>一般情况下，对于一个开源项目来说除了官方文档，Issues也是一个很重要的信息来源。在Issue中我们可以获取其他开发者遇到的问题和解决方案、给官方反馈/投票、关注官方的最新动态、和其他开发者头脑风暴唇枪舌战等等</strong>。</p><p>所以相对于使用IM，笔者更推荐Issue这种沟通模式，因为<strong>它方便归档组织，索引和查找</strong>。而IM上的讨论就像流水一样，一去不复返。</p><p>当然两种工具的适用场景不一样，你拿IM的使用方式来使用Issue，Issue就会变得很水。<strong>Issue适合做有意义的、目的明确的讨论</strong>。 所以要谴责一下在Github Issue上灌水的开发者。</p><p>关于Issue有很多妙用，推荐阅读这篇文章<a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" rel="noopener">&lt;如何使用 Issue 管理软件项目？&gt;</a></p><p>现在很多开源项目都引入了RFC(请求意见稿)流程(参考<a href="https://www.infoq.cn/article/2017/12/react-rfc-process" target="_blank" rel="noopener">React采用新的RFC流程</a>, 以及<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">Vue 最黑暗的一天</a>), 这让开发者有‘翻身农奴、当家做主’的感觉，任何人都可以参与到一个开源项目重大事件的决策之中。<strong>每个RFC会说明决策的动机、详细设计、优缺点。除了官方文档之外，这些RFC是很有价值的学习资料</strong>。</p><p>我觉得如果不涉及机密，团队应该要让更多人参与到项目的设计和决策中，对于新手可以学到很多东西，而对于发起者也可能有考虑不周的情况。</p><p>那对于企业应用开发, Issue有用吗?</p><p>当然有用, 比如我们可以将这类话题从IM转移到Issue:</p><ul><li>设计方案</li><li>决策/建议<ul><li>新功能、新技术引入</li><li>重构</li><li>性能优化</li><li>规范</li></ul></li><li>问题讨论</li><li>重大事件</li><li>计划或进度跟踪</li><li>…</li></ul><p><br></p><p>另外Issue通常通过标签来进行分类，方便组织和检索:</p><p><img src="/images/frontend-standard/issue.png" alt></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-5-注释即文档"><a href="#6-5-注释即文档" class="headerlink" title="6.5 注释即文档"></a>6.5 注释即文档</h3><p><strong>必要和适量的注释对阅读源代码的人来说就是一个路牌, 可以少走很多弯路</strong>.</p><p>关于注释的一些准则，<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6/%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6.md" target="_blank" rel="noopener">&lt;阿里巴巴Java开发手册&gt;</a>总结得非常好, 推荐基于这个来建立注释规范。另外通过ESlint是可以对注释进行一定程度的规范。</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="6-6-代码即文档"><a href="#6-6-代码即文档" class="headerlink" title="6.6 代码即文档"></a>6.6 代码即文档</h3><p>现在有很多种工具支持从代码中解析和生成文档, 这可以给开发者简化很多文档维护的工作。</p><p>举个例子，我们经常会遇到修改了代码，但是文档忘记同步的情况。通过‘代码即文档’的方式至少可以<strong>保持文档和代码同步更新</strong>；另外<strong>很多工具会分析代码的数据类型</strong>，自动帮我们生成参数和返回值定义，这也可以减少很多文档编写工作以及出错率。</p><p>比如可以通过下面注释方式来生成组件文档:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Props注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> interface ColumnProps extends React.HTMLAttributes&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">/** prop1 description */</span></span><br><span class="line">  prop1?: string;</span><br><span class="line">  <span class="comment">/** prop2 description */</span></span><br><span class="line">  prop2: number;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * prop3 description</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  prop3: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">/** prop4 description */</span></span><br><span class="line">  prop4: <span class="string">'option1'</span> | <span class="string">'option2'</span> | <span class="string">'option3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对组件进行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Column</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ColumnProps</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>相关的工具有:</p><ul><li>API文档<ul><li>Typescript<ul><li><a href="https://github.com/microsoft/tsdoc" target="_blank" rel="noopener">tsdoc</a> Typescript官方的注释文档标准</li><li><a href="https://github.com/TypeStrong/typedoc" target="_blank" rel="noopener">typedoc</a> 基于tsdoc标准的文档生成器</li></ul></li><li>Javascript<ul><li><a href="https://github.com/jsdoc/jsdoc" target="_blank" rel="noopener">jsdoc</a> Javascript文档注释标准和生成器</li></ul></li></ul></li><li>后端接口文档<ul><li><a href="https://swagger.io" target="_blank" rel="noopener">Swagger</a> Restful接口文档规范</li><li>GraphQL: 这个有很多工具，例如<a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener">graphiql</a>, 集成了Playground和文档，很先进</li><li><a href="https://easy-mock.com/login" target="_blank" rel="noopener">Easy Mock</a> 一个可视化，并且能快速生成模拟数据的服务</li></ul></li><li>组件文档<ul><li><a href="https://storybook.js.org" target="_blank" rel="noopener">StoryBook</a> 通用的组件开发、测试、文档工具</li><li>React<ul><li><a href="http://docz.site" target="_blank" rel="noopener">Docz</a></li><li><a href="https://github.com/styleguidist/react-styleguidist" target="_blank" rel="noopener">Styleguidist</a></li></ul></li><li>Vue<ul><li><a href="https://github.com/vue-styleguidist/vue-styleguidist" target="_blank" rel="noopener">vue-styleguidist</a></li><li>有更好的工具请评论告诉我</li></ul></li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="7-ui设计规范"><a href="#7-ui设计规范" class="headerlink" title="7 UI设计规范"></a>7 UI设计规范</h2><p><img src="/images/frontend-standard/ui-design.png" alt></p><p>这是一个容易被忽略的规范类型。笔者就深受其苦，我们公司初期UI并不专业，没有所谓的设计规范，这就导致他们设计出来的产品都是东借西凑，前后不统一，多个应用之间的组件不能复用。这搞得我们不得不浪费时间，写很多定制化样式和组件，为他们的不专业买单.</p><p>关于UI设计规范的重要性有兴趣的读者可以看这篇文章<a href="https://juejin.im/post/5b766ac56fb9a009aa154c27" target="_blank" rel="noopener">&lt;开发和设计沟通有多难？ - 你只差一个设计规范&gt;</a>. </p><p>简单总结一下UI设计规范的意义：</p><ul><li>提供团队协作效率(产品和开发)</li><li>提高组件的复用率. 统一的组件规范可以让组件更好管理</li><li>保持产品迭代过程中品牌一致性</li></ul><p>建立一个定义良好的设计规范需要<code>UI设计和开发</code>的紧密配合，有时候也可以由我们前端来推动。</p><p>比如很多开源的UI框架，一开始都是开发者YY出来的，并没有设计参与，后来组件库慢慢沉淀成型，UI设计师才介入规范一下。</p><p>如果你们团队不打算制定自己的UI设计规范，则推荐使用现成的开源组件库：</p><ul><li><a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant Design</a></li><li><a href="https://material-ui.com" target="_blank" rel="noopener">Material-UI</a></li><li><a href="https://element.eleme.io" target="_blank" rel="noopener">Element UI</a></li><li><a href="https://weui.io" target="_blank" rel="noopener">WeUI</a></li><li><a href="https://developer.microsoft.com/en-us/fabric#/" target="_blank" rel="noopener">Microsoft Fabric</a></li></ul><p>这些开源组件库都经过良好的设计和沉淀, 而且配套了完善的设计原则、最佳实践和设计资源文件（Sketch 和 Axure），可以帮助业务快速设计出高质量的产品原型。</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="8-测试规范"><a href="#8-测试规范" class="headerlink" title="8 测试规范"></a>8 测试规范</h2><p>测试是保障代码质量的重要手段，但是很少有人愿意在这里花太多时间。</p><p>比如笔者，我很少会去给业务代码和组件写单元测试，除非自己对代码非常没有信心，按照我的理念写测试不如将代码写得更简单一点，比如把一个函数拆分为更小的函数，保持单一职责。</p><p>但是<strong>对于一些底层、共享的代码模块还是有测试的必要的</strong>。</p><p>我在<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe" target="_blank" rel="noopener">不知道测试什么？这些是你需要知道的软件测试类型和常识</a>文章中，列举了一些开发者需要关注的测试类型和常识, 如果按照测试的阶段进行分类，大概是这样子的:</p><p><img src="/images/frontend-standard/testing.png" alt></p><p><br></p><p>其中前端开发者需要关注的主要有以下几种测试类型:</p><ul><li><strong>单元测试</strong>: 对独立的软件模块进行测试<ul><li><strong>UI组件测试</strong>: 包括了快照(Snapshot)测试</li></ul></li><li><strong>集成测试</strong>: 在单元测试的基础上，将模块组合起来，测试它们的组合性</li><li><strong>E2E测试</strong>: 在完整、真实的运行环境下模拟真实用户对应用进行测试。<strong>主要测试前端和后端的协调性</strong></li><li><strong>兼容性测试</strong>: 上面提到了浏览器兼容规范，在将版本提交给测试/发布之前，需要确保能符合兼容性要求</li><li><strong>性能测试</strong>: 测试和分析是否存在性能问题</li><li><strong>其他</strong>:<ul><li>安全测试</li><li>SEO测试</li></ul></li></ul><p>因为对于小公司来说整个软件开发流程可能没有那么规范，比如很难构建一个完整的端对端测试环境，这些都不是前端团队可以操作的范围, 所以自动化测试很难推行。但是可以根据团队和业务情况逐步进行开展。</p><p>可实施性比较高的, 也比较简单是单元测试，所以本文也重点关注单元测试.</p><p><br></p><h3 id="8-1-测试的流程"><a href="#8-1-测试的流程" class="headerlink" title="8.1 测试的流程"></a>8.1 测试的流程</h3><p>首先要定义一个合适的软件测试流程, 合适的测试流程可以降低开发和测试团队之间的沟通协作成本、提高测试效率。例如我们团队目前的测试流程:</p><p><img src="/images/frontend-standard/test-proc.png" alt></p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="8-2-单元测试"><a href="#8-2-单元测试" class="headerlink" title="8.2 单元测试"></a>8.2 单元测试</h3><p>单元测试有很多<strong>好处</strong>, 比如:</p><ul><li><strong>提高信心，适应变化和迭代</strong>. 如果现有代码有较为完善的单元测试，在代码重构时，可以检验模块是否依然可以工作, 一旦变更导致错误，单元测试也可以帮助我们快速定位并修复错误</li><li><strong>单元测试是集成测试的基础</strong></li><li><strong>测试即文档</strong>。如果文档不能解决你的问题，在你打算看源码之前，可以查看单元测试。通过这些测试用例，开发人员可以直观地理解程序单元的基础API</li><li><strong>提升代码质量。易于测试的代码，一般都是好代码</strong></li></ul><p><br></p><p><strong>测什么?</strong></p><p>业务代码或业务组件是比较难以实施单元测试的，一方面它们比较多变、另一方面很多团队很少有精力维护这部分单元测试。所以<strong>通常只要求对一些基础/底层的组件、框架或者服务进行测试, 视情况考虑是否要测试业务代码</strong></p><p><br></p><p><strong>测试的准则</strong>:</p><ul><li>推荐Petroware的<a href="https://petroware.no/unittesting.html" target="_blank" rel="noopener">Unit Testing Guidelines</a>, 总结了27条单元测试准则，非常受用.</li><li>另外&lt;阿里巴巴的Java开发手册&gt;中总结的<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.md" target="_blank" rel="noopener">单元测试准则</a>, 也不错，虽然书名是Java，准则是通用的.</li></ul><p><br></p><p><strong>单元测试指标</strong>:</p><p>一般使用<a href="https://zh.wikipedia.org/wiki/代碼覆蓋率" target="_blank" rel="noopener"><code>测试覆盖率</code></a>来量化，尽管对于覆盖率能不能衡量单元测试的有效性存在较多争议。</p><p>大部分情况下还是推荐尽可能提高覆盖率, 比如要求<code>语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%</code>. 视团队情况而定</p><p>扩展:</p><ul><li><a href="https://www.infoq.cn/article/test-coverage-rate-role" target="_blank" rel="noopener">测试覆盖（率）到底有什么用？</a></li></ul><p><br></p><p><strong>相关工具</strong></p><ul><li>Headless Browsers: 无头浏览器是网页自动化的重要运行环境。 常用于功能测试、单元测试、网络爬虫<ul><li><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">puppeteer</a></li><li><a href="https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md" target="_blank" rel="noopener">Headless Chromium</a></li></ul></li><li>测试框架<ul><li><a href="http://jest.io/" target="_blank" rel="noopener">Jest</a> 🔥Facebook的单元测试框架. 零配置, 支持组件快照测试、模块Mock、Spy. 一般场景, 单元测试学它一个就行了<ul><li>组件测试<ul><li><a href="https://github.com/testing-library" target="_blank" rel="noopener">testing-library</a> 🔥</li><li><a href="https://github.com/airbnb/enzyme" target="_blank" rel="noopener">Enzyme</a></li></ul></li></ul></li><li><a href="https://theintern.github.io/" target="_blank" rel="noopener">Intern</a></li></ul></li><li>单元测试<ul><li><a href="https://github.com/avajs/ava" target="_blank" rel="noopener">AVA</a></li><li><a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a></li><li><a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a></li><li><a href="https://github.com/substack/tape" target="_blank" rel="noopener">Tape</a></li></ul></li><li>断言库<ul><li><a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a></li><li><a href="https://github.com/Automattic/expect.js" target="_blank" rel="noopener">expect.js</a></li><li><a href="http://shouldjs.github.io/" target="_blank" rel="noopener">should.js</a></li></ul></li><li>Mock/Stubs/Spies<ul><li><a href="http://sinonjs.org/" target="_blank" rel="noopener">sinon.js</a></li></ul></li><li>代码覆盖率<ul><li><a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a></li></ul></li><li>基准测试<ul><li><a href="http://benchmarkjs.com/" target="_blank" rel="noopener">benchmark.js</a></li><li><a href="https://jsperf.com/" target="_blank" rel="noopener">jsperf.com</a></li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="9-异常处理、监控和调试规范"><a href="#9-异常处理、监控和调试规范" class="headerlink" title="9 异常处理、监控和调试规范"></a>9 异常处理、监控和调试规范</h2><p>很多开发者常常误用或者轻视异常的处理, 合理有效的异常处理可以提高应用的健壮性和可用性，另外还可以帮助开发者快速定位异常.</p><h3 id="9-1-异常处理"><a href="#9-1-异常处理" class="headerlink" title="9.1 异常处理"></a>9.1 异常处理</h3><p>&lt;阿里巴巴的Java开发手册&gt;中总结的<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.md" target="_blank" rel="noopener">异常处理规范</a>对JavaScript的异常处理也很有参考意义，比如:</p><ul><li>异常不要用来做流程控制，条件控制。</li><li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li><li>catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。不要对大段代码进行try-catch</li><li>…</li></ul><p>然后再根据JavaScript本身的异常处理特点总结一些规范行为, 例如:</p><ul><li>不要throw非Error对象</li><li>不要忽略异步异常</li><li>全局监控Javascript异常</li><li>…</li></ul><p><br></p><p>资源:</p><ul><li><a href="https://rollbar.com/blog/top-10-javascript-errors/" target="_blank" rel="noopener">从1000+个项目中总结出来的前10个JavaScript错误, 以及如何避免它们</a></li><li><a href="https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6" target="_blank" rel="noopener">Javascript异常处理‘权威’指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/63698500" target="_blank" rel="noopener">前端异常处理最佳实践</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="9-2-日志"><a href="#9-2-日志" class="headerlink" title="9.2 日志"></a>9.2 日志</h3><p>对于前端来说，日志也不是毫无意义(很多框架性能优化建议在生产环境移除console)。尤其是在<strong>生产现场</strong>调试代码时，这时候可贵的控制台日志可以帮助你快速找到异常的线索.</p><p>不过通常我们<strong>只要保留必要的、有意义的日志输出</strong>，比如你不应该将console.log放到一个React渲染函数中、或者放到一个循环中, <strong>DDos式的日志信息并不能帮助我们定位问题，反而会影响运行的性能</strong>. 所以需要一个规范来约束日志输出行为, 比如:</p><ul><li>避免重复打印日志</li><li>谨慎地记录日志, 划分日志级别。比如生产环境禁止输出debug日志；有选择地输出info日志；</li><li>使用前缀对日志进行分类, 例如: <code>[User] xxxx</code></li><li>只记录关键信息, 这些信息可以帮助你诊断问题</li><li>…</li></ul><p>扩展资源</p><ul><li><a href="https://github.com/visionmedia/debug" target="_blank" rel="noopener">debug</a> 适合Node.js和浏览器的debug日志工具, 支持动态开启日志打印</li><li><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">vConsole</a> 移动端调试利器</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="9-3-异常监控"><a href="#9-3-异常监控" class="headerlink" title="9.3 异常监控"></a>9.3 异常监控</h3><p>因为程序跑在不受控的环境，所以对于客户端应用来说，异常监控在生产环境是非常重要的，它可以收集各种意料之外生产环境问题，帮助开发者快速定位异常。</p><p><br></p><p>异常监控通常会通过三种方式来收集异常数据:</p><ol><li>全局捕获。例如使用window.onerror, 或者<code>unhandledrejection</code></li><li>主动上报。在try/catch中主动上报. </li><li>用户反馈。比如弹窗让用户填写反馈信息.</li></ol><p>和日志一样，<strong>不是所有‘异常’都应该上报给异常监控系统，譬如一些预料之内的‘异常’</strong>，比如用户输入错误、鉴权失败、网络错误等等. <strong>异常监控主要用来上报一些意料之外的、或者致命性的异常</strong>.</p><p><br></p><p>要做好前端的异常监控其实并不容易，它需要处理这些东西:</p><ul><li>浏览器兼容性。</li><li>碎片收集(breadcrumbs)。 收集‘灾难’现场的一些线索，这些线索对问题诊断很重要。例如当前用户信息、版本、运行环境、打印的日志、函数调用栈等等</li><li>调用栈的转换。通常在浏览器运行的压缩优化过的代码，这种调用栈基本没什么可读性，通常需要通过SourceMap映射到原始代码. 可以使用这个库: <a href="https://github.com/mozilla/source-map#sourcemapconsumer" target="_blank" rel="noopener">source-map</a></li><li>数据的聚合。后端监控系统需要对前端上报的信息进行分析和聚合</li></ul><p><br></p><p>对于小团队未必有能力开发这一套系统，所以推荐使用一些第三方工具。例如</p><ul><li><a href="https://sentry.io/welcome/" target="_blank" rel="noopener">Sentry</a> 🔥免费基本够用</li><li><a href="https://www.fundebug.com/price" target="_blank" rel="noopener">FunDebug</a> 付费增强</li></ul><p><strong>扩展</strong>:</p><ul><li><a href="https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/" target="_blank" rel="noopener">前端异常监控解决方案研究</a></li><li><a href="https://www.cnblogs.com/warm-stranger/p/9417084.html" target="_blank" rel="noopener">搭建前端监控系统</a></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="10-前后端协作规范"><a href="#10-前后端协作规范" class="headerlink" title="10 前后端协作规范"></a>10 前后端协作规范</h2><p>前端是Web的一个细分领域，往往不能脱离后端而存在。所以和后端协作的时间是最长的.</p><h3 id="10-1-协作流程规范"><a href="#10-1-协作流程规范" class="headerlink" title="10.1 协作流程规范"></a>10.1 协作流程规范</h3><p>前后端团队经过长期的合作，一般可以总结出一条对于双方开发效率最优的协作流程. 将这个落实为规范，后面的团队成员都遵循这个步调进行协作。</p><p>一个典型的前后端协作流程如下:</p><p><img src="/images/frontend-standard/f-b.png" alt></p><ol><li>需求分析。参与者一般有前后端、测试、以及产品. 由产品主持，对需求进行宣贯，接受开发和测试的反馈，确保大家对需求有一致的认知</li><li>前后端开发讨论。讨论应用的一些开发设计，沟通技术点、难点、以及分工问题.</li><li>设计接口文档。可以由前后端一起设计；或者由后端设计、前端确认是否符合要求</li><li>并行开发。前后端并行开发，在这个阶段，前端可以先实现静态页面; 或者根据接口文档对接口进行Mock, 来模拟对接后端接口</li><li>在联调之前，要求后端做好接口测试</li><li>真实环境联调。前端将接口请求代理到后端服务，进行真实环境联调。</li></ol><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="10-2-接口规范"><a href="#10-2-接口规范" class="headerlink" title="10.2 接口规范"></a>10.2 接口规范</h3><p>首先应该确定下来的是接口规范。其实使用哪种接口标准是其次，重要的是统一，且要满足前后端的开发效率要求.</p><p>笔者不建议后端去定义自己的接口标准，而应该去选择一些通用的、有标准定义接口形式, 例如:</p><ul><li><p><a href="https://zh.wikipedia.org/zh-hans/表现层状态转换" target="_blank" rel="noopener">RESTful</a>: RESTful是目前使用最为广泛的API设计规范, 基于HTTP本身的机制来实现. </p><p>笔者个人是比较喜欢这个API规范，但是我发现很多开发者并不能真正(或者说没心思)理解它，设计出来的接口，跟我想象的相差甚远。换句话说，对于RESTful，开发者之间很难达成一致的理解，容易产生分歧。</p><p>因为是使用最广泛的API形式，所以社区上有很多工具来对RESTful接口进行文档化、测试和模拟.</p></li><li><p><a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html" target="_blank" rel="noopener">JSONRPC</a> 这是一种非常简单、容易理解的接口规范。相对于RESTful我更推荐这个，简单则不容易产生分歧，新手也可以很快接受.</p></li><li><a href="https://graphql.org/learn/" target="_blank" rel="noopener">GraphQL</a> 🔥更为先进、更有前景的API规范。但是你要说服后端配合你使用这种标准可能很有难度</li></ul><p><br></p><p><strong>接口设计需要注意的点</strong>:</p><ul><li>明确区分是正常还是异常, 严格遵循接口的异常原语. 上述接口形式都有明确的异常原语，比如JSONRPC，当出现异常时应该返回<code>错误对象</code>响应，而不是在正常的响应体中返回错误代码. 另外要规范化的错误码, HTTP响应码就是一个不错的学习对象</li><li>明确数据类型。很多后端写的接口都是string和number不分的，如果妥协的话、前端就需要针对这个属性做特殊处理，这也可能是潜在的bug</li><li>明确空值的意义。比如在做更新操作是，空值是表示重置，还是忽略更新？</li><li>响应避免冗余的嵌套。</li><li>接口版本化，保持向下兼容。就像我们上文的‘语义化版本规范’说的，对于后端来说，API就是公共的接口. 公共暴露的接口应该有一个版本号，来说明当前描述的接口做了什么变动，是否向下兼容。<br>现在前端代码可能会在客户端被缓存，例如小程序。如果后端做了break change，就会影响这部分用户。</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="10-3-接口文档规范"><a href="#10-3-接口文档规范" class="headerlink" title="10.3 接口文档规范"></a>10.3 接口文档规范</h3><p>后端通过接口文档向前端暴露接口相关的信息。通常需要包含这些信息：</p><ul><li>版本号</li><li>文档描述</li><li>服务的入口. 例如基本路径</li><li>测试服务器. 可选</li><li>简单使用示例</li><li>安全和认证</li><li>具体接口定义<ul><li>方法名称或者URL</li><li>方法描述</li><li>请求参数及其描述，必须说明类型(数据类型、是否可选等)</li><li>响应参数及其描述, 必须说明类型(数据类型、是否可选等)</li><li>可能的异常情况、错误代码、以及描述</li><li>请求示例，可选</li></ul></li></ul><p><strong>人工维护导致的问题</strong>:</p><p>上文‘代码即文档’就提到了人工维护接口文档可能导致代码和文档不同步问题。</p><p>如果可以从代码或者规范文档(例如OpenAPI这类API描述规范)中生成接口文档，可以解决实现和文档不一致问题, 同时也可以减少文档编写和维护的投入.</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="10-4-接口测试与模拟"><a href="#10-4-接口测试与模拟" class="headerlink" title="10.4 接口测试与模拟"></a>10.4 接口测试与模拟</h3><p>为了做到高效率的前后端并行开发，接口的测试与模拟是必要的。</p><ul><li>前端要求后端在联调之前，需要测试验证好自己的接口是否可以正常工作。而不是在联调期间，把前端当‘接口测试员’，阻塞接口联调进度</li><li>另外前端需要在后端接口未准备好之前，通过接口模拟的方式，来编写业务逻辑代码。</li></ul><p>针对接口测试与模拟，存在下图这样一个理想的模型:</p><p><img src="/images/frontend-standard/api-mock.png" alt></p><p>一切从定义良好的接口文档出发，生成<code>Mock Server</code>和<code>Mock Client</code>, Mock Server给前端提供模拟数据，而Mock Client则辅助后端对它们的接口进行测试.</p><p>资源:</p><ul><li>RESTful<ul><li><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 这是最为接近上面理想模型的一个解决方案</li><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">JSON Server</a> 快速生成JSON mock服务器</li><li><a href="https://easy-mock.com" target="_blank" rel="noopener">Easy Mock</a> 可视化的、在线的接口mock服务</li></ul></li><li>GraphQl<ul><li><a href="https://github.com/APIs-guru/graphql-faker" target="_blank" rel="noopener">GraphQL Faker</a></li><li><a href="https://www.apollographql.com/docs/graphql-tools/mocking/" target="_blank" rel="noopener">graphql-tools</a></li></ul></li><li>模拟数据生成<ul><li><a href="https://github.com/Marak/faker.js" target="_blank" rel="noopener">faker.js</a> 🔥强大的模拟数据生成工具，支持Node和浏览器</li><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">Mock.js</a> 数据生成和模拟工具</li></ul></li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="11-培训-知识管理-技术沉淀"><a href="#11-培训-知识管理-技术沉淀" class="headerlink" title="11 培训/知识管理/技术沉淀"></a>11 培训/知识管理/技术沉淀</h2><p>我觉得一个团队的知识管理是非常重要的. 你要问一个刚入行的新手加入团队希望得到什么？很多人的回答是’学习’,  希望自己的技术可以更加精进, 钱倒还是其次。</p><p>然而现实是目前很多公司的氛围并不是这样的，一天到晚写业务代码、工作量大、每天做重复的事情，而且还加班，工作多年技术也没感觉有多少进步, 确实会让人非常沮丧。包括笔者也是这样的。</p><p>所以为了改善这种情况，我来聊聊最近在‘小团队’做的一些尝试.</p><h3 id="11-1-新人培训"><a href="#11-1-新人培训" class="headerlink" title="11.1 新人培训"></a>11.1 新人培训</h3><p>如果团队有规范的新成员培训手册，可以节省很多培训的时间，避免每次重复口述一样的内容。培训手册包含以下内容:</p><ul><li><p><strong>产品架构与组织架构</strong>. 介绍公司背景和产品，一般组织的团队结构和产品的架构是相关联的. 以笔者所在公司为例, 主要产品是即时通信:</p><p><img src="/images/frontend-standard/org.png" alt></p></li><li><p><strong>产品研发流程</strong>: 介绍产品开发和迭代会涉及到的流程、以及团队之间的协作衔接，例如:</p><p><img src="/images/frontend-standard/dev-proc.png" alt></p></li><li><p><strong>工作范围</strong>: 团队成员的职责范围</p></li><li><strong>建立资源索引</strong>: 开发需要设计到的资源，比如各种文档地址、研发系统入口(例如gitlab、bug跟踪系统、文件共享、发布平台、开发/测试环境、监控系统)、协作规范等等。将这些资源整理好可以减少不必要的沟通成本</li><li><strong>规范</strong>: 即本文的主体’前端协作规范’。有规范可循，可以让成员以较快的速度入手开发、同时也减少培训成本投入。</li></ul><p>培训手册将可以文档具象化的内容整理为文档，和上文说到的Code Review一样，一些东西无法通过文档来说明，所以我们一般会搭配一个‘培训导师’，在试用期间，一对一辅导。</p><p><br></p><p><a href="#">⬆️回到顶部</a></p><h3 id="11-2-营造技术氛围"><a href="#11-2-营造技术氛围" class="headerlink" title="11.2 营造技术氛围"></a>11.2 营造技术氛围</h3><ul><li><strong>鼓励成员写技术博客，或者建立自己的团队专栏</strong>. 写一篇好的文章不容易</li><li><strong>鼓励参与开源项目</strong></li><li><p><strong>定期的专题分享</strong>. 鼓励团队成员定期进行专题学习和研究，编写技术博客，并将学习的成果分享给其他成员. 这是一种抱团取暖的学习方式，旨在帮助团队成员一起学习和成长。</p><p>比如开发老手可以分享自己的经验，研究更深层次的技术；新手则可以研究某些开发技巧、新技术，例如CSS Grid，svg动画等等。推荐团队成员有个明确的研究领域，这样分工合作可以学习到更多东西.</p><p><strong>专题怎么来?</strong></p><ul><li>专题请求. 可以请求其他成员完成专题，比如比较深的知识，可以要求团队比较有经验的进行学习分享</li><li>学习总结.</li><li>项目回顾</li><li>难点攻克</li><li>项目规范</li><li>工具使用</li></ul></li><li><p><strong>落实和完善开发规范</strong>. 规范本身就是团队知识沉淀的一种直接输出</p></li><li><strong>图书分享</strong>. 和离散的文章或教程相比，图书的知识会比较系统，另外很多经典的图书是要静下来好好欣赏的。</li><li><strong>鼓励重构和持续优化代码</strong></li><li><strong>抽象一套基础库或框架，减少重复工作, 提高工作效率</strong>. 不加班先从提高工作效率开始</li></ul><p><br></p><p><a href="#">⬆️回到顶部</a></p><p><br></p><h2 id="12-反馈"><a href="#12-反馈" class="headerlink" title="12 反馈"></a>12 反馈</h2><p>大家有什么要补充或意见可以在下方评论, 一起来完善这篇文章, 谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;笔者长期单枪匹马在前端领
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[问答] 为什么要用vue-cli3?</title>
    <link href="https://bobi.ink/2019/07/18/why-vue-cli3/"/>
    <id>https://bobi.ink/2019/07/18/why-vue-cli3/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T04:20:32.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>[问答]</code>系列主要整理<a href="https://segmentfault.com/q/1010000019785471" target="_blank" rel="noopener">SegmentFault</a>上面比较有价值的问题，以及我的回答</p></blockquote><h2 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a><a href="https://segmentfault.com/q/1010000019785471/a-1020000019793827" target="_blank" rel="noopener">原问题</a></h2><p>其实这个问题主要是想了解vue-cli3与vue-cli2相比是否存在一些不得不升级的好处和优点？</p><p>产生这个问题的原因是在试用完vue-cli3之后并没有觉得好用，反而觉得束手束脚，我cli2时，webpack想怎么配怎么配为什么到了cli3我要在vue.config.js中配置<br>众所周知vue-cli的通用配置并不适合每种情况, 而在vue.config.js只能做增添和覆盖，所以一直没有用vue-cli3构建项目</p><p>所以想请教下 这个版本有没有值得升级的优点</p><p><br></p><h2 id="我的回答"><a href="#我的回答" class="headerlink" title="我的回答"></a>我的回答</h2><p>好问题，vue-cli3相对vue-cli有很多重要的更新。</p><p>首先说一些vue-cli这些工具的<strong>初衷</strong>吧: 这些工具就是为了让开发者能够<strong>开箱即用</strong>快速地进行应用开发而开发的，<strong>它们秉承的是“约定大于配置”思想，简单说就是”能不配置的就不配置，你就按照我的方式来，也不要去争论这个好不好，快速进行业务开发才是正经事”. 它们不建议你去配置，但也不会拦着你去配置</strong>。</p><p>另外Webpack对初学者并不是十分友好，‘又长又臭’的配置，普通开发者很难写入定义良好，性能优化的配置。不然就不会各种cli工具冒出来了，比如parcel，create-react-app。这些工具都宣称零配置，目的就是让开发者能够愉快的进行代码开发。</p><p><br></p><hr><p><br></p><p>现在来看看Vue-cli v3的改进，以及思考这些有什么意义呢？</p><p><br></p><p><strong>1. 抽离cli service层</strong></p><p>Create-React-App是第一个做这种事情的。vue-cli3库现在包含以下两个模块：</p><ul><li><p>CLI: 即vue全局命令，主要用于项目创建和管理，包含了<code>vue create</code>、<code>vue ui</code>这些命令。CLI命令的做的事情比较少，所以更新不会太频繁(开发者也很少会去更新这些命令)</p></li><li><p>Service层: 负责项目的实际构建，也就是webpack项目构建。这一块是频繁更新的，一般作为项目的局部依赖。</p></li></ul><p><br></p><p>OK，这么做有什么意义呢？考虑这样一个场景，这也是答主之前遇到的一个痛点：</p><p><strong>vue-cli3之前不算是一个构建CLI, 它顶多就是一个模板拷贝器, 做的事情非常少</strong>, 所有webpack配置和构建命令都是耦合在具体的项目里面，package.json会包含一大堆开发依赖。</p><p>如果去跟进webpack或相关工具更新的朋友会有这种体会，升级不是一件容易的事情。比如你升级了babel-loader, 可能要连带webpack都升级，webpack升级后可能其他工具又不兼容了。</p><p>升级方面的痛点是其一。如果你的团队需要维护很多项目，你怎么对这些项目进行维护升级？每个项目都拷贝一下？如果某个项目做了特殊配置呢？</p><p><strong>对于团队而言，项目构建这一块是应该尽量做到的统一和傻瓜化的，没有必要在这方面投入太多的精力，应该把事情外包给擅长这种事情的人去做</strong>。</p><p><strong>另外不要排斥更新，更新可以获得更好的开发体验和构建速度、运行性能, 别人在这方面比你了解的更多</strong>。</p><p><strong>分离了vue-cli-service之后，项目构建更新只是一个命令的事情，除非做了很多特殊化操作</strong>。<strong>特殊化操作应该封装到vue-cli的插件中</strong>。这就引出了vue-cli3的另外一个特色：插件</p><p><br></p><hr><p><br></p><p><strong>2. 插件化</strong></p><p>相比create-react-app, vue-cli是在太仁慈了。vue-cli的插件机制很灵活，通过<code>webpack-chain</code>和<code>webpack-merge</code>可以实现webpack完全定制化。</p><p>可以对比一下市面上流行的cli工具的可扩展性：</p><table><thead><tr><th></th><th>Vue CLI</th><th>create-react-app</th><th>parcel</th></tr></thead><tbody><tr><td>快速原型开发</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>全局模式</td><td>零配置原型开发就是全局的</td><td>-</td><td>支持</td></tr><tr><td>插件</td><td>支持</td><td>-</td><td>支持，扩展文件类型和文件输出</td></tr><tr><td>扩展性</td><td>强，通过插件扩展 wepack 配置</td><td>弱, 强约定, 无法配置 webpack，可以 eject, 然后手工配置；支持 babel-macro;(严格说可以通过<a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">react-app-rewired</a>进行扩展)</td><td>中(可以配置 babel，postcss，Typescript); 提供了 Node API; 支持插件扩展文件类型</td></tr><tr><td>多页面</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>适用范围</td><td>Vue 组件的第一公民。通过扩展可以支持任意前端框架</td><td>针对 React 开发，不支持其他框架</td><td>parcel 是一个通用的打包工具，它的竞争对手是 webpack</td></tr><tr><td>编译速度</td><td>cache-loader,thread-loader 来加速 JS 和 TS 编译</td><td>babel-loader 开启了 cache</td><td>编译速度号称是 webpack 的两倍</td></tr><tr><td>可升级性</td><td>支持升级 cli-service, 插件需要单独升级, 插件需要遵循语义化版本. 太多插件存在升级风险</td><td>支持升级 react-script, 官方维护，且强约定基本可以保障向下兼容</td><td>支持升级 parcel-bundler</td></tr><tr><td>UI</td><td>图形化管理是 CLI 的特色之一</td><td>-</td><td>-</td></tr></tbody></table><p><br></p><p>对于vue-cli的插件实现机制可以看这篇<a href="https://juejin.im/post/5cedb26451882566477b7235" target="_blank" rel="noopener">文章</a>。</p><p>因为vue-cli灵活的扩展性，所以它不仅限于vue本身，可以扩展支持react、anything…</p><p>按照上文说的，<strong>如果你要做深度的vue-cli定制化，不建议直接写在vue.config.js中，而是封装在插件中，独立的维护这个插件，然后项目再依赖这个插件。这样就可以简化升级的成本和复杂度</strong>。</p><p><br></p><hr><p><br></p><p><strong>3. GUI界面</strong></p><p>虽然大部分人都觉得作用不大，因为确实对开发效率并实际的提升效果。就是看着舒服直观，这就够了。</p><p><br></p><hr><p><br></p><p><strong>4. 快速原型开发</strong></p><p>vue-cli3也支持直接将一个vue文件跑起来，快速原型开发或验证某些想法时，挺不错。</p><p><br></p><hr><p><br></p><p><strong>5. <a href="https://cli.vuejs.org/guide/browser-compatibility.html#modern-mode" target="_blank" rel="noopener">现代模式</a></strong></p><p>给先进的浏览器配合先进的代码(ES6之后),同时兼容旧版本的浏览器，先进的代码不管从文件体积还是脚本解析效率、运行效率都有较高的提升。</p><p>体积对比:</p><table><thead><tr><th>Version</th><th>Size (minified)</th><th>Size (minified + gzipped)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>80K</td><td>21K</td></tr><tr><td>ES5 (main.es5.js)</td><td>175K</td><td>43K</td></tr></tbody></table><p><br></p><p>解析效率:</p><table><thead><tr><th>Version</th><th>Parse/eval time (individual runs)</th><th>Parse/eval time (avg)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>184ms, 164ms, 166ms</td><td>172ms</td></tr><tr><td>ES5 (main.es5.js)</td><td>389ms, 351ms, 360ms</td><td>367ms</td></tr></tbody></table><p><br></p><hr><p><br></p><p><strong>6. Standard Tooling for Vue.js Development</strong></p><p>这是vue-cli的官方介绍，vue标准开发工具. 跟进vue-cli就是跟进官方的最佳实践和前沿技术，vue团队已经为你考虑很多应用场景, why not?</p><p><br></p><hr><p><br></p><p><strong>总结一下</strong>：</p><ul><li><p>如果我们喜欢折腾，肯定会觉得vue-cli3束手束脚，这时候我们不是vue-cli3的目标用户；</p><p>就比如我们团队就自己搞了一一个CLI构建工具: <a href="https://github.com/GDJiaMi/jm-cli" target="_blank" rel="noopener">jm-cli</a>, 根据自己的团队需求进行深度定制，不过我们这个工具是强约定的，包括目录结构、编码规范等等. 因为我们不推荐团队成员去搞特殊化定制，而且为了方便进行更新，所以干脆就不让扩展了，<strong>统一和规范对团队来说才是最重要的</strong>.</p><p><strong>如果你有类似的开发经验，你会觉得vue-cli可能是所有构建CLI的最终归宿或者典范</strong>。</p></li><li><p>如果不想折腾，只想写代码, 而且想跟进vue官方最新实践，那就直接拿来用吧；</p></li><li>如果想折腾，又要考虑团队协作和构建工具链的维护成本，vue-cli是很适合的。当然你也可以造轮子</li><li>如果想学webpack的构建项目，也不推荐你使用vue-cli</li></ul><p><br></p><p>最后给vue团队点个赞👍</p><p>欢迎关注我，和我交流</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;[问答]&lt;/code&gt;系列主要整理&lt;a href=&quot;https://segmentfault.com/q/1010000019785471&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SegmentFault&lt;/a&gt;
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>现代脚本的加载</title>
    <link href="https://bobi.ink/2019/07/17/modern-module/"/>
    <id>https://bobi.ink/2019/07/17/modern-module/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-18T23:21:49.165Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址: <a href="https://jasonformat.com/modern-script-loading/" target="_blank" rel="noopener">Modern Script Loading</a>, 文章作者是Preact作者<a href="https://twitter.com/_developit" target="_blank" rel="noopener">Jason Miller</a></p><p><br></p><p><img src="/images/modern-module/modern-script-loading.jpg" alt></p><p><br></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>先简单介绍一下<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener"><code>模块script(Module script)</code></a>, 它指的是<strong>现代浏览器支持通过<code>&lt;script type=module src=main.js&gt;&lt;/script&gt;</code>来加载现代的ES6模块</strong>. 现代浏览器对ES6现代语法有良好的支持，这意味着<strong>我们可以给这些现代浏览器提供更紧凑的‘现代代码’，一方面可以减小打包的体积，减少网络传输的带宽，另外还可以提高脚本解析的效率和运行效率</strong>.</p><p>下图来源于<a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/" target="_blank" rel="noopener"><code>module/nomodule pattern</code></a>, 对比了<strong>模块script</strong>和<strong>传统(legacy) script</strong>的性能:</p><p>体积对比:</p><table><thead><tr><th>Version</th><th>Size (minified)</th><th>Size (minified + gzipped)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>80K</td><td>21K</td></tr><tr><td>ES5 (main.es5.js)</td><td>175K</td><td>43K</td></tr></tbody></table><p><br></p><p>解析效率:</p><table><thead><tr><th>Version</th><th>Parse/eval time (individual runs)</th><th>Parse/eval time (avg)</th></tr></thead><tbody><tr><td>ES2015+ (main.mjs)</td><td>184ms, 164ms, 166ms</td><td>172ms</td></tr><tr><td>ES5 (main.es5.js)</td><td>389ms, 351ms, 360ms</td><td>367ms</td></tr></tbody></table><p><br></p><p>Ok，为了兼容旧浏览器, <a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/" target="_blank" rel="noopener">module/nomodule pattern</a>这篇文章介绍了一种<strong>module/nomodule 模式</strong>, 简单说就是<strong>同时提供两个script, 由浏览器来决定加载哪个文件</strong>：</p><p><br></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 支持模块script的浏览器会加载这个文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"main.mjs"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 旧浏览器会加载这个文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为加了nomdule, 所以现代浏览器不会加载该文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"main.es5.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来很美好是吧? 现实是：<strong>中间存在一些浏览器，它们可以识别<code>模块script</code>但是不认识<code>nomodule</code>属性, 这就导致了这些浏览器会同时加载这两个文件(下文统一称为‘双重加载’(over-fetching))</strong>.</p><p><br><br><br></p><blockquote><p>OK，正式进入正文. 给正确的浏览器交付正确代码是一件棘手的事情。本文会介绍几种方式, 来解决上述的问题:</p></blockquote><p>给现代浏览器伺服’现代的代码’对性能有很大的帮助。所以你应该针对现代浏览器提供包含更紧凑和优化的现代语法的Javascript包，同时又可以保持对旧浏览器的支持</p><p>现有的工具链的生态系统基本都是在<code>module/nomodule模式</code>上整合的，它声明式加载现代和传统代码(legacy code)，即给浏览器提供两个源代码，让它来自己来决定用哪个:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"/modern.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"/legacy.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而现实总是给你当头一棒，它没我们期望的那么简单直接。上述基于HTML的加载方式在<a href="https://gist.github.com/jakub-g/5fc11af85a061ca29cc84892f1059fec" target="_blank" rel="noopener"><strong>Edge和Safari中会被同时加载</strong></a>!</p><p><br></p><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办?"></a>怎么办?</h2><p>怎么办？我们想依赖浏览器来交付不同的编译目标，但是一些旧浏览器并不能优雅地支持这种简洁的写法。</p><p>首先，Safari 在10.1开始支持JS模块, 但不支持nomodule属性。值得庆幸的是，Sam找到了一种方法，可以通过Safari 10和11中非标准的beforeload事件来模拟 nomodule, 也就是可以认为Safari 10.1开始是可以支持<code>module/nomodule模式</code></p><p><br></p><h2 id="选项1-动态加载"><a href="#选项1-动态加载" class="headerlink" title="选项1: 动态加载"></a>选项1: 动态加载</h2><p>我们可以实现一个小型script加载器来规避这个问题，工作原理类似于<a href="https://github.com/filamentgroup/loadCSS" target="_blank" rel="noopener">LoadCSS</a>。只不过这里需要依靠浏览器的来实现ES模块和nomodule属性.</p><p>我们首先尝试执行一个模块script进行’石蕊试验’(litmus test), 然后由这个试验的结果来决定加载现代代码还是传统代码:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用一个模块script来检测是否是现代浏览器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  self.modern = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 现在根据这个检测结果来决定加载现代代码还是传统代码: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (self.modern) &#123;</span></span><br><span class="line"><span class="javascript">      s.src = <span class="string">'/modern.js'</span></span></span><br><span class="line"><span class="javascript">      s.type = <span class="string">'module'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      s.src = <span class="string">'/legacy.js'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(s)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，这个解决方案必须等待进行‘石蕊试验’模块script执行完成, 才能开始注入script。这是因为<code>&lt;script type=module&gt;</code>始终是异步的，所以别无它法(延迟到load事件后)。</p><p>另一种实现方式是检查浏览器是否支持<code>nomodule</code>, 这是方式可以避免上述的延迟加载问题, 只不过这意味着像Safari 10.1这些支持模块, 却不支持nomodule的浏览器也会被当做传统浏览器，这也许<a href="https://github.com/web-padawan/polymer3-webpack-starter/issues/33#issuecomment-474993984" target="_blank" rel="noopener">可能</a>是<a href="https://jasonformat.com/modern-script-loading/" target="_blank" rel="noopener">好事</a>(相对于两个脚本都加载以及有一些bug)，代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)  </span><br><span class="line"><span class="keyword">if</span> (<span class="string">'noModule'</span> <span class="keyword">in</span> s) &#123;  <span class="comment">// 注意这里的大小写</span></span><br><span class="line">  s.type = <span class="string">'module'</span></span><br><span class="line">  s.src = <span class="string">'/modern.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">  s.src = <span class="string">'/legacy.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(s)</span><br></pre></td></tr></table></figure><p>现在把它们封装成函数，并确保两种方式都统一使用异步的方式加载(上文提到模块script是异步的，而传统script不是):</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  $loadjs(<span class="string">"/modern.js"</span>,<span class="string">"/legacy.js"</span>)</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">$loadjs</span>(<span class="params">src,fallback,s</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="string">'noModule'</span> <span class="keyword">in</span> s) s.type = <span class="string">'module'</span>, s.src = src</span></span><br><span class="line"><span class="javascript">    <span class="keyword">else</span> s.async = <span class="literal">true</span>, s.src = fallback   <span class="comment">// 统一使用异步方式加载</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(s)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来已经很完美了，还有什么问题呢？<strong>我们还没考虑预加载(preloading)</strong></p><p>这个有点蛋疼， 因为一般浏览器只会静态地扫描HTML，然后查找它可以预加载的资源。 我们上面介绍的模块加载器是完全动态的，所以浏览器在没有运行我们的代码之前，是没办法发现我们要预加载现代还是传统的Javascript资源的。</p><p>不过有一个解决办法，就是不完美：就是使用<code>&lt;link rel=modulepreload&gt;</code>来预加载现代版本的包, 旧浏览器会忽略这条规则，然而目前<a href="https://developers.google.com/web/updates/2017/12/modulepreload" target="_blank" rel="noopener">只有Chrome支持这么做</a>:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"modulepreload"</span> <span class="attr">href</span>=<span class="string">"/modern.js"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">self.modern=1</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- etc --&gt;</span></span><br></pre></td></tr></table></figure><p><strong>其实预加载这种技术是否有效，取决于嵌入你的脚本的HTML文档的大小</strong>。</p><p>如果你的HTML载荷很小, 比如只是一个启动屏或者只是简单启动客户端应用，那么放弃预加载扫描对你的应用性能影响很小。<br>如果你的应用使用服务器渲染大量有意义的HTML, 并以流(stream)的方式传输给浏览器，那么预加载扫描就是你的朋友，但这也未必是最佳方法。</p><blockquote><p>译注: 现代浏览器都支持分块编码传输，等服务端完全输出html可能有一段空闲时间，这时候可以通过预加载技术，让浏览器预先去请求资源</p></blockquote><p>大概代码如下:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"modulepreload"</span> <span class="attr">href</span>=<span class="string">"/modern.js"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">self.modern=1</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  $loadjs(<span class="string">"/modern.js"</span>,<span class="string">"/legacy.js"</span>)</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">$loadjs</span>(<span class="params">e,d,c</span>)</span>&#123;c=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>),self.modern?(c.src=e,c.type=<span class="string">"module"</span>):c.src=d,<span class="built_in">document</span>.head.appendChild(c)&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还要指出的是，支持<a href="https://caniuse.com/#feat=es6-module" target="_blank" rel="noopener">JS模块的浏览器</a>一般也<a href="https://caniuse.com/#feat=link-rel-preload" target="_blank" rel="noopener">支持</a><code>&lt;link rel = preload&gt;</code>。对于某些网站，相比依靠<code>modulepreload</code>, 使用<code>&lt;link rel=preload as=script crossorigin&gt;</code>可能更有意义。不过性能上面可能欠点，因为传统的脚本预加载不会像<code>modulepreload</code>一样随着时间的推移而去展开解析工作(<code>rel=preload</code>只是下载，不会尝试去解析脚本)。</p><p><br></p><h2 id="选项2-用户代理嗅探"><a href="#选项2-用户代理嗅探" class="headerlink" title="选项2: 用户代理嗅探"></a>选项2: 用户代理嗅探</h2><p>我办法拿出一个简洁的代码示例，因为用户代理检测不在本文的范围之内，推荐阅读这篇<a href="https://www.smashingmagazine.com/2018/10/smart-bundling-legacy-code-browsers/" target="_blank" rel="noopener">Smashing Magazine文章</a></p><p>本质上，<strong>这种技术在每个浏览器上都使用<code>&lt;script src=bundle.js&gt;</code>来加载代码，当<code>bundle.js</code>被请求时，服务器会解析浏览器的用户代理，并选择返回现代代码还是传统代码，取决于浏览器是否能被识别为现代浏览器</strong>.</p><p>尽管这种方法比较通用，但它也有一些严重的缺点：</p><ul><li>因为依赖于服务端实现，所以前端资源不能被静态部署(例如静态网站生成器(如github page)，Netlify等等)</li><li>很难进行有效的缓存. 现在这些JavaScript URL的缓存会因用户代理而异，这是非常不稳定的, 而很多缓存机制只是将URL作为缓存键，现在这些缓存中间件可能就没办法工作了。</li><li>UA检测很难，容易出现误报</li><li>用户代理字符串容易被篡改，而且每天都有新的UA出现</li></ul><p>解决这些限制的一种方法就是<strong>将<code>module/nomodule模式</code>与’用户代理区分’结合起来</strong>，首先这可以避免单纯的<code>module/nomodule模式</code>需要发送多个软件包问题，尽管这种方法仍然会降低页面(这时候指HTML，而不是Javascript包)的可缓存性，但是它可以有效地触发预加载，因为生成HTML的服务器根据用户代理知道应该使用<code>modulepreload</code>还是<code>preload</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderPage</span>(<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">`&lt;html&gt;&lt;head&gt;...`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> agent = request.headers.userAgent;</span><br><span class="line">  <span class="keyword">const</span> isModern = userAgent.isModern(agent);</span><br><span class="line">  <span class="keyword">if</span> (isModern) &#123;</span><br><span class="line">    html += <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;link rel=modulepreload href=modern.mjs&gt;</span></span><br><span class="line"><span class="string">      &lt;script type=module src=modern.mjs&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    html += <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;link rel=preload as=script href=legacy.js&gt;</span></span><br><span class="line"><span class="string">      &lt;script src=legacy.js&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  response.end(html);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于那些已经在使用服务端渲染的网站来说，用户代理嗅探是一个比较有效的解决方案</p><p><br></p><h2 id="选项-3-不考虑旧版本浏览器"><a href="#选项-3-不考虑旧版本浏览器" class="headerlink" title="选项 3:不考虑旧版本浏览器"></a>选项 3:不考虑旧版本浏览器</h2><p><strong>注意这里的‘旧版本浏览器’特指那些出现双重加载的浏览器</strong>. 对于<code>module/nomodule模式</code>支持比较差(即双重加载)的主要是一些旧版本的Chrome、Firefox和Safari. 幸运的是这部分浏览器的市场范围通常是比较窄，因为用户会自动升级到最新的版本。Edge 16-18是例外, 但还有希望： 新版本的Edge会使用基于Chromium的渲染器，可以不受该问题的影响.</p><p>对于某些应用程序来说，接受这一点妥协是完全合理的：你可以给90％的浏览器中提供现代代码，让他们获得更好的体验，而极少数旧浏览器不得不抛弃它们，它们只是付出的额外带宽(即双重加载)，并不影响功能。值得注意的是，占据移动端主要市场份额的用户代理不会有双重加载问题，所以这些流量不太可能来自于低速或者高昂流量费的手机。</p><p>如果你的网站用户主要使用移动设备或较新版本的浏览器，那么最简单的<code>module/nomodule</code>模式将适用于你的绝大多数用户, 其他用户就不考虑了，反正也是可以跑起来的, 优先考虑大多数用户的体验。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修复Safari 10.1 不支持 `nomodule` 问题: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;!(<span class="string">"noModule"</span><span class="keyword">in</span>(t=e.createElement(<span class="string">"script"</span>)))&amp;&amp;<span class="string">"onbeforeload"</span><span class="keyword">in</span> t&amp;&amp;(n=!<span class="number">1</span>,e.addEventListener(<span class="string">"beforeload"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">if</span>(e.target===t)n=!<span class="number">0</span>;<span class="keyword">else</span> <span class="keyword">if</span>(!e.target.hasAttribute(<span class="string">"nomodule"</span>)||!n)<span class="keyword">return</span>;e.preventDefault()&#125;,!<span class="number">0</span>),t.type=<span class="string">"module"</span>,t.src=<span class="string">"."</span>,e.head.appendChild(t),t.remove())&#125;(<span class="built_in">document</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 适用于90+% 的浏览器: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">modern.js</span> <span class="attr">type</span>=<span class="string">module</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 部分支持module但是不支持nomodule的浏览器，也会加载下面脚本，范围可能很小，我们可以选择忽略它们: --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- IE, Edge &lt;16, Safari &lt;10.1, old desktop: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">legacy.js</span> <span class="attr">nomodule</span> <span class="attr">async</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="选项-4-使用条件包"><a href="#选项-4-使用条件包" class="headerlink" title="选项 4: 使用条件包"></a>选项 4: 使用条件包</h2><p><strong><code>nomodule</code>可以巧妙地用来<em>条件加载</em>那些现代浏览器不需要的代码</strong>， 例如polyfills。通过这种方法，最坏的情况就是polyfill和bundle都会被加载(例如Safari 10.1)，但这毕竟是少数。鉴于目前通行的做法就是在所有浏览器中一致同仁地加载polyfills，相比而言, <em>条件polyfills</em>可以让大部分现代浏览器用户避免加载polyfill代码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- newer browsers won't load this bundle: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"polyfills.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- all browsers load this one: --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Angular CLI支持配置这种方式来加载polyfill, 查看<a href="https://blog.mgechev.com/2019/02/06/5-angular-cli-features/#conditional-polyfill-serving" target="_blank" rel="noopener">Minko Gechev的代码示例</a>.<br>了解了这种方式之后，我决定在preact-cli中支持自动polyfill注入，你可以查看这个<a href="https://github.com/preactjs/preact-cli/pull/833/files" target="_blank" rel="noopener">PR</a></p><p>如果你使用Webpack，这里有一个html-webpack-plugin<a href="https://github.com/swimmadude66/webpack-nomodule-plugin" target="_blank" rel="noopener">插件</a>可以方便地为polyfill包添加<code>nomodule</code>属性.</p><p><br></p><h2 id="你应该怎么做"><a href="#你应该怎么做" class="headerlink" title="你应该怎么做?"></a>你应该怎么做?</h2><p>答案取决于你的使用场景, 选择和你们的架构匹配的选项:<br>如果你的应用只是客户端渲染, 而且你的HTML不超过一个<code>&lt;script&gt;</code>，选项1比较合适；<br>如果你的应用使用服务端渲染，而且可以接受缓存问题，那么可以选择选项2；<br>如果你开发的是<a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#rehydration" target="_blank" rel="noopener">同构应用</a>，预加载的功能可能对你很重要，这时你可以考虑选项3和4.</p><p>就我个人而言，相比考虑桌面端浏览器资源下载成本，我更倾向于优化移动设备解析时间. 移动用户体验会受到数据解析、流量费用，电池消耗等因素的影响，而桌面用户往往不需要考虑这些因素。<br>另外这些优化适用于90%的用户，比如我工作面对的大部分用户都是使用现代或移动浏览器的。</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>有兴趣继续深入？可以从下面的文章开始挖掘：</p><ul><li>Phil的<a href="https://github.com/philipwalton/webpack-esnext-boilerplate/issues/1" target="_blank" rel="noopener">webpack-esnext-boilerplate</a>的一些附加的背景.</li><li>Ralph<a href="https://github.com/zeit/next.js/pull/7704" target="_blank" rel="noopener">在Next.js中实现了module/nomodule</a>, 并努力解决了上面的问题.</li></ul><p>感谢<a href="https://twitter.com/philwalton" target="_blank" rel="noopener">Phil</a>, <a href="https://twitter.com/shubhie" target="_blank" rel="noopener">Shubhie</a>, <a href="https://twitter.com/atcastle" target="_blank" rel="noopener">Alex</a>, <a href="https://twitter.com/hdjirdeh" target="_blank" rel="noopener">Houssein</a>, <a href="https://twitter.com/Janicklas" target="_blank" rel="noopener">Ralph</a> 以及 <a href="https://twitter.com/addyosmani" target="_blank" rel="noopener">Addy</a> 的反馈.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址: &lt;a href=&quot;https://jasonformat.com/modern-script-loading/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Modern Script Loading&lt;/a&gt;, 文章作者是Preact作者&lt;a 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript竟然没有标准库?</title>
    <link href="https://bobi.ink/2019/07/16/js-stdlib/"/>
    <id>https://bobi.ink/2019/07/16/js-stdlib/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-07-17T07:21:29.230Z</updated>
    
    <content type="html"><![CDATA[<p>最近在SegmentFault热心解题，一个问题比较让我比较印象深刻：一个初学者试图在浏览器中导入Node.js的net模块。结果就是在控制台打印后是一个空对象。</p><p>对于有点Javascript经验的人来说，这是一个‘弱智’问题，怎么可以在浏览器端运行Node程序呢？因为这些node模块经过<a href="http://webpack.docschina.org/configuration/node/#其他-node-js-核心库-node-js-core-libraries-" target="_blank" rel="noopener">webpack处理</a>, 所以变成了一个空对象，更好的处理应该是抛出异常.</p><p><strong>仔细反思一下，对于这些刚入门Javascript的或者从其他语言切换过来的，他们压根就没有概念，比如Python、Ruby、Java这些语言都有强大的标准库，可以满足80%的开发需求，不管它在什么环境、什么平台运行，都可以统一使用这套标准库。而Javascript目前的现状就是不同的运行环境API结构是割裂的</strong>。</p><p>Javascript这门十几天开发出来的、专供浏览器的语言，可能当初设计是根本就没有考虑标准库这些玩意，比如文件系统，网络等等。<strong>因为这个背景, Javascript不具备独立性，它深度依赖于浏览器这个运行环境, 处于一种给浏览器打辅助的角色</strong>, 所以Javascript很多年没有走出浏览器玩具语言这个范围. 当然这既是劣势，也是优势, 现在没任何语言能撼动Javascript在浏览器中的地位。</p><p>我想很多人跟我当初一样<strong>将浏览器提供的Web API等价于Javascript的标准库, 比如<code>console.log</code>、<code>setTimeout</code></strong>(下文会介绍这些功能都不在Javascript规范里面). 正如当年那些把JQuery当成Javascript的人.</p><p>直到NodeJS的出现，Javascript才走出浏览器约束，延伸到服务器领域, 不再是一个’沙盒语言’。NodeJS定义了很多模块来支撑服务端的开发, 如fs、os、Buffer、net。但是这些和WebAPI一样不是标准的、也就是说<strong>NodeJS !== Javascript</strong>.</p><p>再到后来，学不动了，NodeJS原作者吐槽了一通NodeJS，又搞出了一个<a href="https://deno.land" target="_blank" rel="noopener">Deno</a>, 它也会有自己标准库，会定义自己的文件系统、网络API。从名字上就暗示着这些API不可能和NodeJS兼容。Ok，现在回到文章开始那个问题，如果deno发展起来，说不定哪天又有人尝试在浏览器引用Deno的模块？</p><p><br></p><h2 id="现有的javascript-api结构"><a href="#现有的javascript-api结构" class="headerlink" title="现有的Javascript API结构"></a>现有的Javascript API结构</h2><p><img src="/images/js-stdlib/outline.png" alt></p><p>如上图, Javascript其实是有一层比较薄全局的、通用的、<strong>标准的</strong>、核心的API层，即<code>标准内置对象</code>，这是一些语言核心的内置对象，可以全局访问。关键的是这些是标准的，它们在<a href="https://tc39.es/ecma262/#sec-global-object" target="_blank" rel="noopener">ECMAScript规范</a>中被定义. 在这个基础之上，不同的运行环境拓展了自己的API。</p><p>以浏览器为例:</p><p><img src="/images/js-stdlib/brw.png" alt></p><p>浏览器端的Web API是一个非常复杂API集合，上图总结了一下基本就包含两块东西:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" target="_blank" rel="noopener">Core DOM</a>. DOM是一个通用的技术，不仅仅局限于浏览器，这个规范定义了结构化(structured document)文档的解析和操作规范。定义了基本的节点类型和操作方法。不局限于HTML的操作</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM" target="_blank" rel="noopener">HTML DOM</a>. 可以认为是Core DOM的扩展，这里面定义了各种HTML元素对象类型、扩展了元素的操作方法，另外还包含了浏览器相关的接口，如XMLHttpRequest。这一块通常也被统称为BOM</li></ul><p>WebAPI基本概览:</p><p><img src="/images/js-stdlib/webAPI.png" alt></p><p>如果你有留心查看MDN文档下面的规范引用，你会发现有些规范引用了<a href="https://www.w3.org/TR/" target="_blank" rel="noopener">W3C</a>, 有些则引用了<a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="noopener">WHATWG</a>. 到底谁说了算?</p><p>如果你掀开锅盖，就会发现这是一场闹剧. 如果前阵子有关注新闻，会看到这些标题‘WHATWG 击败 W3C，赢得 HTML 和 DOM 的控制权’、’W3C将与WHATWG合作制定最新HTML和DOM规范标准’. 大概可以猜出这两个组织之间的关系. 本文就不扯这些‘八卦’了，相关背景可以看这篇文章<a href="https://www.infoq.cn/article/bsvFxt96DOh-SBZphBwJ" target="_blank" rel="noopener">WHATWG 击败 W3C，赢得 HTML 和 DOM 的控制权</a></p><p>相对而言, 语言层则由ECMAScript规范定义的，比较独立, 近些年成果也比较显著.</p><p><br></p><h3 id="标准内置对象层主要包含这些东西"><a href="#标准内置对象层主要包含这些东西" class="headerlink" title="标准内置对象层主要包含这些东西"></a>标准内置对象层主要包含这些东西</h3><ul><li>特殊值<ul><li>Infinity</li><li>NaN</li><li>undefined</li><li>null</li><li>globalThis</li></ul></li><li>函数<ul><li>eval()</li><li>uneval() </li><li>isFinite()</li><li>isNaN()</li><li>parseFloat()</li><li>parseInt()</li><li>decodeURI()</li><li>decodeURIComponent()</li><li>encodeURI()</li><li>encodeURIComponent()</li></ul></li><li>基础对象<ul><li>Object</li><li>Function</li><li>Boolean</li><li>Symbol</li><li>Error</li><li>EvalError</li><li>InternalError </li><li>RangeError</li><li>ReferenceError</li><li>SyntaxError</li><li>TypeError</li><li>URIError</li></ul></li><li>数值和时间<ul><li>Number</li><li>BigInt</li><li>Math</li><li>Date</li></ul></li><li>文本处理<ul><li>String</li><li>RegExp</li></ul></li><li>索引容器<ul><li>Array</li><li>‘TypedArray’</li></ul></li><li>键值容器<ul><li>Map</li><li>Set</li><li>WeakMap</li><li>WeakSet</li></ul></li><li>结构化数据<ul><li>ArrayBuffer</li><li>SharedArrayBuffer </li><li>Atomics </li><li>DataView</li><li>JSON</li></ul></li><li>控制抽象化对象<ul><li>Promise</li><li>Generator</li><li>GeneratorFunction</li><li>AsyncFunction </li></ul></li><li>反射<ul><li>Reflect</li><li>Proxy</li></ul></li><li>国际化<ul><li>Intl</li></ul></li><li>WebAssembly</li><li>其他<ul><li>arguments</li></ul></li></ul><p>这些全局基本对象数量很少, 平时我们使用的非常频繁的定时器和Console都不再此列. 这些对象是每个JavaScript开发者必须掌握的.</p><p>这些对象只能满足很基本开发需求, 根本不能和其他语言的标准库相比. <strong>当然这和语言的定位也有一定关系，JavaScript最初的定位就是浏览器脚本，谁知道它现在发展得这么快？</strong></p><h2 id="什么是标准库"><a href="#什么是标准库" class="headerlink" title="什么是标准库?"></a>什么是标准库?</h2><p>标准库是什么没有一个规范化的定义，按照Wiki的说法标准库就是<strong>该语言在不同实现中都按例提供的库</strong>, 比如Ruby官方实现和基于JVM的JRuby都应该按照规范实现标准库。 <strong>标准库怎么设计，需要包含什么内容取决于语言各自秉持的哲学和定位</strong>。 我认为标准库应该有以下特征:</p><ul><li>标准化的，有规范明确定义它的内容和行为</li><li>内容经过仔细雕琢和挑选，可以覆盖大部分使用场景或者符合的语言定位</li><li>可选的、按需导入. 标准库不是全局的，需要通过模块导入, 非强制性使用</li></ul><p>至于标准库需要包含什么内容，可以参考其他语言的实现。比如：</p><ul><li><a href="https://golang.org/pkg/" target="_blank" rel="noopener">go</a></li><li><a href="http://ruby-doc.org/stdlib-2.6.3/" target="_blank" rel="noopener">ruby</a></li><li><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">python</a></li></ul><p>大概分析一下，它们标准库大致都有这些内容：</p><ul><li>网络协议</li><li>文件系统<ul><li>文件系统</li><li>流</li><li>标准输入输出</li><li>二进制处理</li></ul></li><li>算法<ul><li>密码算法</li><li>编码</li><li>压缩、归档</li><li>排序</li><li>数学</li><li>字符串、文本</li></ul></li><li>数据结构, 例如树、堆、队列等等</li><li>数据持久化和序列化. 比如JSON序列化，二进制序列化，数据库操作等等</li><li>调试/辅助</li><li>单元测试</li><li>文档处理</li><li>设计模式. 标准库中经常会携带(或辅助设计)该语言的最佳实践和设计模式, 例如go中的context, Ruby中的singleton</li><li>国际化</li><li>时间、日期</li><li>操作系统<ul><li>命令行</li><li>环境变量</li><li>系统资源</li></ul></li><li>并发<ul><li>进程</li><li>线程</li><li>协程</li></ul></li><li>语言底层原语</li></ul><p>大部分语言的核心都很小(C++除外)，我们学一门语言，大部分时间是花在标准库上，但是你会发现这些标准库一般都是大同小异，这就是为什么有经验的开发者可以很快地入手一门语言. </p><p>显然上面这些功能大部分在NodeJS中已经实现了，鉴于NodeJS这么广泛的使用率，NodeJS可以算是事实上的标准了</p><h2 id="我们需要标准库"><a href="#我们需要标准库" class="headerlink" title="我们需要标准库?"></a>我们需要标准库?</h2><p><img src="/images/js-stdlib/dep.png" alt></p><p>显然是需要的，但是要结合当前的背景来辩证地考虑。</p><p><strong>有标准库有什么好处?</strong></p><ul><li>标准库提供通用、定义良好、优化的功能和行为，减少第三方模块依赖, 而且第三方库很难保证质量</li><li>避免社区割裂, 抚平不同运行环境的差异. 现在有NodeJS、后面有Deno，可能还会有Aeno、Beno, 尽管取代NodeJS的可能性很低，有规范化的标准库可以避免重复造轮子，不然真会学不动</li><li>安全性. 近期npm投毒、删库(left-pad事件)、npm商业运作, 给社区带了不少麻烦。标准库由运行环境内置，可以避免引用第三方库导致的安全问题</li><li>今天的Javascript应用会有很多依赖(node_modules hell)，打包出来的体积很大，网络加载和脚本解析需要耗费一定的资源，而且这些资源不能在多个应用之间被缓存. 一个很大的原因是npm的依赖过于零碎(比如几行代码的包)和重复(依赖不同的版本、Dead Code)，使用标准库可以减少这部分依赖</li><li>选择困难症. 没有标准库，可以选择npm上的第三方库，有时候就是懒得去比较和选择</li><li>优雅的标准库，是学习的榜样. 网上很多教程都是钻研标准库算法和实现的，对语言的开发者来说标准库是一块宝藏</li><li>学习成本。其他语言的开发者，可以较快入手</li></ul><p><br></p><p><strong>标准库可能会有什么问题?</strong></p><ul><li>标准可能滞后跟不上社区发展. Javascript正处于快速发展阶段，很多规范的定义是由社区驱动的，比如Promise、async/await. 跟不上社区的发展结果可能就是没人用</li><li>想下WebComponent目前的境遇</li><li>标准库不可能满足所有人的口味</li></ul><p><br></p><p><strong>如何设计标准库? 标准库推进进程可能会有什么障碍?</strong></p><ul><li>NodeJS已经是事实上的标准, 怎么兼容现有的生态?</li><li>标准库应该包含什么内容，如何保持和社区同步?</li><li>如何把控标准库内容的尺度? 最小化的标准库容易被维护和升级，就可能出现没什么卵用的情况；最大化的标准库，例如Java的标准库，几乎包含了所有的东西，开发者可以快速开发一个东西, 但是过了几年很多API就会变得过时，一般为了保持向下兼容，这些API会一直像一根刺一样卡在那里，另一个非常典型的反例就是PHP的标准库，这里可以看到各种风格的API. 而且标准库是跟随语言发布的，如果你的项目中使用了过时的API，又想升级语言版本，就需要重构项目。而使用第三方库则可能可以保持不动。</li><li>Javascript的主要战场还是浏览器, 标准库是否应该有一个基本版(浏览器或者一些操作系统抽象的运行环境)还有个旗舰版(服务端), 或者只提供一个跨越所有平台的标准库?</li><li>如何处理兼容性问题?</li><li>如何与现有的全局对象或用户模块分离？</li></ul><p><br></p><h2 id="近期的一些尝试"><a href="#近期的一些尝试" class="headerlink" title="近期的一些尝试"></a>近期的一些尝试</h2><ul><li><a href="https://github.com/tc39/proposal-javascript-standard-library" target="_blank" rel="noopener">proposal-javascript-standard-library</a> 这是一个非常早期的语言提议，定义了如何引用标准库(built-in modules)，但是没有定义标准库的内容</li><li><p><a href="https://developers.google.com/web/updates/2019/03/kv-storage" target="_blank" rel="noopener">KV Storage: the Web’s First Built-in Module</a> Chrome在年初推出的实验性功能，尝试实现proposal-javascript-standard-library提议. 它通过下面方式来引用‘标准库’模块:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;storage, StorageArea&#125; <span class="keyword">from</span> <span class="string">'std:kv-storage'</span>; <span class="comment">// std: 前缀，和普通模块区分开来</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从一个SegmentFault上的一个问题开始，对比其他语言，揭露Javascript没有标准库的窘境. 接着介绍Javascript的API结构，最后介绍什么是标准库，辩证考虑标准库的优缺点，以及推行上面可能会遇到的阻碍.</p><p>Javascript发展非常快，已经不再是当初的玩具语言，相信有一天可以实现一直用一直爽.</p><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://www.infoworld.com/article/3048833/brendan-eich-javascript-standard-library-will-stay-small.html" target="_blank" rel="noopener">Brendan Eich: JavaScript standard library will stay small</a></li><li><a href="https://medium.com/@thomasfuchs/what-if-we-had-a-great-standard-library-in-javascript-52692342ee3f" target="_blank" rel="noopener">What if we had a great standard library in JavaScript?</a></li><li><a href="https://www.i-programmer.info/news/167-javascript/12608-the-javascript-standard-library.html" target="_blank" rel="noopener">The JavaScript Standard Library</a></li><li><a href="https://www.w3.org/TR/" target="_blank" rel="noopener">W3C</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API" target="_blank" rel="noopener">Web API 索引</a></li><li><a href="https://dev.to/sloan/explain-like-im-five-whats-a-standard-library-4gi" target="_blank" rel="noopener">Explain Like I’m Five: What’s a standard library?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在SegmentFault热心解题，一个问题比较让我比较印象深刻：一个初学者试图在浏览器中导入Node.js的net模块。结果就是在控制台打印后是一个空对象。&lt;/p&gt;
&lt;p&gt;对于有点Javascript经验的人来说，这是一个‘弱智’问题，怎么可以在浏览器端运行Node程
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你需要知道的软件测试类型和常识</title>
    <link href="https://bobi.ink/2019/07/10/typeof-testing/"/>
    <id>https://bobi.ink/2019/07/10/typeof-testing/</id>
    <published>2019-07-09T16:00:00.000Z</published>
    <updated>2019-07-14T14:00:23.180Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接: <a href="https://www.softwaretestinghelp.com/types-of-software-testing/" target="_blank" rel="noopener">Types Of Software Testing: Different Testing Types With Details</a></p><blockquote><p>文章为意译，并且在原文的基础之上进行演绎和扩展</p></blockquote><blockquote><p>文章篇幅较长，阅读完大概20min，读完会有收获。欢迎点赞收藏关注</p></blockquote><p><br></p><p><img src="/images/typeof-testing/Types-of-Testing1.jpg" alt></p><p><br></p><p>有多少软件测试类型呢?</p><p>我们作为测试人员了解很多种不同的软件测试类型，例如功能测试(Functional Test)、非功能测试、自动测试、敏捷测试、以及它们的各种子类型. 尽管在我们的测试过程中会接触很多种测试类型, 或者听说过某些测试类型，但是很少人敢说精通所有的测试类型.</p><p>每个测试类型都有自己的特点、优势和劣势。所以我写这篇文章，科普一下我们今天最常用的测试类型.</p><p><br></p><h2 id="不同的软件测试类型"><a href="#不同的软件测试类型" class="headerlink" title="不同的软件测试类型"></a>不同的软件测试类型</h2><p><img src="/images/typeof-testing/Types-of-Software-Testing.jpg" alt></p><p>下面是软件测试的通用类型列表</p><ul><li><p>功能测试类型:</p><ul><li>单元测试(Unit testing)</li><li>集成测试(Integration testing)</li><li>系统测试(System testing)</li><li>健全性测试(Sanity testing)</li><li>冒烟测试(Smoke testing)</li><li>接口测试(Interface testing)</li><li>回归测试(Regression testing)</li><li>Beta/验收测试(Beta/Acceptance testing)</li></ul></li><li><p>非功能测试类型:</p><ul><li>性能测试(Performance Testing)</li><li>负载测试(Load testing)</li><li>压力测试(Stress testing)</li><li>容量测试(Volume testing)</li><li>安全测试(Security testing)</li><li>兼容性测试(Compatibility testing)</li><li>安装测试(Install testing)</li><li>恢复测试(Recovery testing)</li><li>可靠性测试(Reliability testing)</li><li>可用性测试(Usability testing)</li><li>一致性测试(Compliance testing)</li><li>本地化测试(Localization testing)</li></ul></li></ul><p>来看看这些测试类型的细节</p><p><br></p><h2 id="0-a-b测试-a-b-testing"><a href="#0-a-b测试-a-b-testing" class="headerlink" title="0) A/B测试(A/B Testing)"></a>0) A/B测试(A/B Testing)</h2><p><img src="/images/typeof-testing/ab.png" alt></p><p>顾名思义， <a href="https://maxket.com/ab-test-best-practice/" target="_blank" rel="noopener">A/B测试</a>就是准备两个(A/B)或两个以上的版本，让不同的用户来随机访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。如上图，谷歌使用A/B测试来决定导航应该是红色还是蓝色。</p><p><br></p><h2 id="1-alpha测试-alpha-testing"><a href="#1-alpha测试-alpha-testing" class="headerlink" title="1) Alpha测试(Alpha Testing)"></a>1) Alpha测试(Alpha Testing)</h2><p><strong><a href="https://www.softwaretestinghelp.com/what-is-alpha-testing-beta-testing/" target="_blank" rel="noopener">Alpha测试</a>这是软件工程中很常见的测试类型。它的目标就是尽可能地在发布到市场或交付给用户之前找出所有的问题和缺陷</strong>。</p><p>Alpha测试一般在开发的末段且在Beta测试之前进行。在这个测试过程中可能会驱动开发者进行一些小(minor)的设计变动. Alpha测试一般在开发者网站进行，即只对开发者或内部用户开放，一般可以为此类测试创建内部虚拟的用户环境。</p><p><br></p><p>一般大型的软件项目都有规范化的<strong>软件版本周期</strong>:</p><p><img src="/images/typeof-testing/alpha-testing.png" alt></p><ul><li><strong>Pre-alpha</strong>: 有时候软件会在Alpha或Beta版本前先发布Pre-alpha版本, 相比Alpha和Beta，这是一个功能不完整的版本</li><li><strong>Alpha</strong>: Alpha版本功能还没完善，需要进一步测试。Alpha版本通常会发送到开发软件的组织或某群体中的软件测试者进行内部测试。</li><li><strong>Beta</strong>: 一般Beta版本会包含所有功能，但可能又有一些Bug，需要调试反馈。 Beta版本是软件最早对外公开的软件版本，由公众（通常为公司外的第三方开发者和业余玩家）参与测试。</li><li><strong>Release Candidate(rc)</strong>: 发布候选版本，如果没有出现问题则可发布成为正式的版本。这个版本包含完整且比较稳定的功能</li></ul><p>举一个典型的例子, 最近把我<a href="https://juejin.im/pin/5d1ecb656fb9a00259a176a5" target="_blank" rel="noopener">坑得有点惨</a>的iOS13的发布计划:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">June 3: iOS 13 beta 1 and first look at WWDC 2019                 # -&gt; WWDC后就可以装的，相当于pre-alpha或Alpha阶段吧</span><br><span class="line">June 17: iOS 13 beta 2 launched for developers</span><br><span class="line">June 24: iOS 13 public beta release date for adventurous testers  # -&gt; 公开Beta版本，相当于上面说的Beta阶段</span><br><span class="line">July 3: iOS 13 developer beta 3 launch with some new features     </span><br><span class="line">July 8: iOS 13 public beta 2 release date</span><br><span class="line">Early September 2019: iOS 13 Golden Master (final dev beta)       # -&gt; 九月初，该发最终Beta版本了，相当于进入RC阶段了</span><br><span class="line">Mid-September 2019: iOS 13 likely to launch with new 2019 iPhones # -&gt; 正式版本</span><br></pre></td></tr></table></figure><p><br></p><p>现在很多开源项目，已经淡化了瀑布式的软件版本周期，变成一种持续(Continuous)的、常态化的行为, 例如Firefox:</p><p><img src="/images/typeof-testing/firefox.png" alt></p><p><br></p><h2 id="2-验收测试-acceptance-testing"><a href="#2-验收测试-acceptance-testing" class="headerlink" title="2) 验收测试(Acceptance Testing)"></a>2) 验收测试(Acceptance Testing)</h2><p><strong><a href="https://www.softwaretestinghelp.com/what-is-acceptance-testing/" target="_blank" rel="noopener">验收测试</a>通常是部署软件之前的最后一个测试操作, 也称为交付测试, 由最终客户执行，他们会验证端到端(end to end)的系统流程是否符合业务需求，以及功能是否是满足最终用户的需求</strong>。只有当所有的特性和功能按照期望的运行，客户才会接受软件</p><p>这是测试的最后阶段，在验收测试之后，软件将投入生产环境. 所以它也叫用户验收测试(UAT)</p><p><img src="/images/typeof-testing/accept.png" alt></p><p>举个例子，验收测试就相当于收快递, 包裹是软件、你就是客户，是验收方，如果货物不符合你的要求，是要退货的。</p><p><br></p><h2 id="3-临时测试-ad-hoc-testing"><a href="#3-临时测试-ad-hoc-testing" class="headerlink" title="3) 临时测试(Ad-hoc Testing)"></a>3) 临时测试(Ad-hoc Testing)</h2><p>Ad-hoc中文应该理解为临时的意思。顾名思义，这种测试是在临时基础上进行的, 有时候也称为随机测试。即没有参考测试用例、没有针对该测试的任何计划和文档。Ad-hoc测试的目的就是<strong>通过执行随意的流程或任意的功能来找出应用的缺陷和问题</strong></p><p>Ad-hoc测试一种非正式的方法，可以由项目中的任何人执行。尽管没有测试用例很难识别缺陷，但是有些时候在Ad-hoc测试期间发现的缺陷可能无法使用现有的测试用例来识别, <strong>也就是说它一般用来发现‘意外’的缺陷</strong>.</p><p><br></p><h2 id="4-可访问性测试-accessibility-testing"><a href="#4-可访问性测试-accessibility-testing" class="headerlink" title="4) 可访问性测试(Accessibility Testing)"></a>4) 可访问性测试(Accessibility Testing)</h2><p><strong>可访问性测试的目的是确定软件或应用程序是否可供残疾人使用</strong>。残疾是指聋人，色盲，智障人士，失明者，老年人和其他残疾人群体。这里会执行各种检查，例如针对视觉残疾的字体大小测试，针对色盲的颜色和对比度测试等等。</p><p>不同平台、不同应用类型对可访问性支持情况不太一样，比如iOS相比其他操作系统则更重视可访问, 而国外比国内更重视可访问性。</p><p><img src="/images/typeof-testing/acs.png" alt></p><p><br></p><h2 id="5-beta测试-beta-testing"><a href="#5-beta测试-beta-testing" class="headerlink" title="5) Beta测试(Beta Testing)"></a>5) Beta测试(Beta Testing)</h2><p>上文Alpha测试已经提及Beta测试, <strong>Beta测试是一种正式的软件测试类型，在将产品发布到市场或者实际最终用户之前，由客户在真实的应用环境中执行</strong>。</p><p>执行Beta测试目的是确保软件或产品中没有重大故障，并且满足最终用户的业务需求。当客户接受软件时，Beta测试才算通过。</p><p>通常，此类测试由最终用户或其他人完成。这是在将应用发布作为商业用途之前完成的最终测试。通常，发布的软件或产品的Beta版本仅限于特定区域中的特定数量的用户。<br>所以最终用户实际使用软件后会将一些问题反馈给公司。公司可以在全面发布之前采取必要的措施。</p><p>Beta测试在正式版本之前也可能会迭代进行多次.</p><p><br></p><h2 id="6-后端测试-back-end-testing"><a href="#6-后端测试-back-end-testing" class="headerlink" title="6) 后端测试(Back-end Testing)"></a>6) 后端测试(Back-end Testing)</h2><p>前端应用输入的数据，一般都会存储在数据库，所以针对数据库的这类测试称为<strong>数据库测试或者后端测试</strong>. 市面有不同的数据库，如SQL Server，MySQL和Oracle等。数据库测试会涉及表结构，模式，存储过程，数据结构等。</p><p>后端测试一般不会涉及GUI，测试人员通过某些手段直接连接到数据库，从而可以容易地运行一些数据库请求来验证数据。<strong>通过后端测试可以发现一些数据库问题，比如数据丢失、死锁、数据损坏。这些问题在系统投入生产环境之前进行修复至关重要</strong></p><p><br></p><h2 id="7-浏览器兼容测试-browser-compatibility-testing"><a href="#7-浏览器兼容测试-browser-compatibility-testing" class="headerlink" title="7) 浏览器兼容测试(Browser Compatibility Testing)"></a>7) 浏览器兼容测试(Browser Compatibility Testing)</h2><p><img src="/images/typeof-testing/brw.png" alt></p><p>这是兼容性测试的子类型，由测试团队执行. <strong><a href="http://frontend.turing.io/lessons/module-2/cross-browser-compat.html" target="_blank" rel="noopener">浏览器兼容测试</a>主要针对Web应用，用于确保软件可以在不同浏览器或操作系统中运行; 或者验证Web应用程序是否支持在浏览器的所有版本上运行, 以确定应用最终兼容的范围</strong>.</p><p>浏览器兼容测试是前端开发者绕不开的坑。</p><p>我们有很多<strong>策略</strong>来应对浏览器兼容性，比如渐进增强或者优雅降级, 还有制定浏览器兼容规范; </p><p>为了<strong>抚平浏览器之间的差异</strong>，我们会使用各种特性检测工具(Modernizr), 还有各种polyfill(CSS Normaliz, polyfill/shim, css-autoprefixer);</p><p>当然为了<strong>测试跨浏览器兼容性</strong>，还要一些辅助工具，例如<a href="https://www.browserstack.com/" target="_blank" rel="noopener">BrowserStack</a>, 对于我们这些小团队，只能下一堆Portable(<em>Portable浏览器运行时相互隔离的, 所以不会存在配置文件等冲突问题</em>) 浏览器，手工测试了。</p><p><br></p><h2 id="8-后向兼容测试-backward-compatibility-testing"><a href="#8-后向兼容测试-backward-compatibility-testing" class="headerlink" title="8) 后向兼容测试(Backward Compatibility Testing)"></a>8) 后向兼容测试(Backward Compatibility Testing)</h2><p><strong>向后兼容测试, 用于验证新开发或更新的软件是否能在旧版本的环境中运行</strong>。</p><p>比如向后兼容测试会检查新版软件是否可以正确地处理旧版本软件创建的文件格式。例如新版的Office 2016是否可以打开2012创建的文件。</p><p>同理也可以检查新版本是否可以兼容旧版本软件创建的数据表、数据文件、数据结构、配置文件。 </p><p>任何软件更新应该在先前版本的基础之上良好地运行</p><p><br></p><h2 id="9-黑盒测试-black-box-testing"><a href="#9-黑盒测试-black-box-testing" class="headerlink" title="9) 黑盒测试(Black Box Testing)"></a>9) 黑盒测试(Black Box Testing)</h2><p><img src="/images/typeof-testing/black-box.png" alt></p><p>黑盒测试不考虑软件的内部系统设计，它基于需求和功能进行测试, 只关心系统的输入/输出以及功能流程。 </p><p>换句话说<strong>黑盒测试从用户的角度出发针对软件界面、功能及外部结构进行测试，而不考虑程序内部逻辑结构</strong>.</p><p>黑盒测试下面有很多子类，例如集成测试、系统测试、大部分非功能性测试</p><p>关于黑盒测试的优缺点以及测试类型可以看<a href="https://www.softwaretestinghelp.com/black-box-testing/" target="_blank" rel="noopener">这里</a></p><p><br></p><h2 id="10-边界值测试-boundary-value-testing"><a href="#10-边界值测试-boundary-value-testing" class="headerlink" title="10) 边界值测试(Boundary Value Testing)"></a>10) 边界值测试(Boundary Value Testing)</h2><p><strong>边界值测试, 测试应用处于边界条件(boundary level)的行为</strong>。很多边界条件开发者是很难考虑周到的，所以才有一个专门的测试类型来验证这种情况</p><p>边界值测试检查应用处于边界值时是否存在缺陷。边界值测试通常用于测试不同范围的数字, 每个范围都有一个上下边界，边界测试则是针对这些边界值进行测试。</p><p>比如数字范围为1-500, 那么边界值测试会在这些值上进行验证: 0、1、2、499、500、501</p><p><br></p><h2 id="11-分支测试-branch-testing"><a href="#11-分支测试-branch-testing" class="headerlink" title="11) 分支测试(Branch Testing)"></a>11) 分支测试(Branch Testing)</h2><p>这是白盒测试的子类型，在单元测试中实施. 顾名思义，<strong>分支测试表示测试要覆盖程序代码的各种条件分支, 避免遗漏缺陷</strong>。分支覆盖是单元测试覆盖率的一个指标之一</p><p><br></p><h2 id="12-比较测试-comparison-testing"><a href="#12-比较测试-comparison-testing" class="headerlink" title="12) 比较测试(Comparison Testing)"></a>12) 比较测试(Comparison Testing)</h2><p><img src="/images/typeof-testing/wzr.png" alt></p><p><strong>比较测试，将产品的优点和弱点与旧版本或者同类(竞品)产品进行比较.</strong></p><p>比如类似王自如这种数码测评栏目，评测一个手机或者其他数码产品时，一般会横向和友商产品进行比较，有时候也会纵向和上一代产品比较.</p><p>还有一种比较典型的例子就是和行业的领导者比较，比如我们做IM的，会经常和微信比较: ‘你这个应用的启动速度怎么比微信慢这么多?’</p><p><br></p><h2 id="13-兼容性测试-compatibility-testing"><a href="#13-兼容性测试-compatibility-testing" class="headerlink" title="13) 兼容性测试(Compatibility Testing)"></a>13) 兼容性测试(Compatibility Testing)</h2><p>这是一个大类, <strong>兼容性测试用于验证应用在不同环境、web服务器、硬件、网络条件下的行为</strong>。兼容性测试确保软件可以在不同的配置、不同的数据库、不同的浏览器，以及它们不同的版本下运行。兼容性测试由测试团队实施</p><p><br></p><h2 id="14-组件测试-component-testing"><a href="#14-组件测试-component-testing" class="headerlink" title="14) 组件测试(Component Testing)"></a>14) 组件测试(Component Testing)</h2><p><a href="https://www.guru99.com/component-testing.html" target="_blank" rel="noopener">组件测试</a>(此组件非GUI组件, 取组合测试可能更好理解一点)，<strong>一般也称为模块测试(Module Testing), 一般由开发者在完成单元测试后执行。组件测试将多个功能组合起来作为单一的整体进行测试，目的是发现多个功能在相互连接起来之后的缺陷</strong>。</p><p>组件测试可大可小，小到函数级别或者类级别的组合，大可以大到几个单独的页面、模块、子系统的组合。 举一个前端例子，将多个页面路由组合起来，测试它们的流程跳转，就属于组件测试。</p><p><img src="/images/typeof-testing/comp.png" alt></p><p><br></p><h2 id="15-端到端测试-end-to-end-testing"><a href="#15-端到端测试-end-to-end-testing" class="headerlink" title="15) 端到端测试(End-to-End Testing)"></a>15) 端到端测试(End-to-End Testing)</h2><p>端到端测试也是一种黑盒测试类型，类似于系统测试. <strong>端到端测试在模拟的、完整的、真实应用环境下模拟真实用户对应用进行测试，比如应用会和数据库交互、会使用网络通信、或者在适当的情况下和其他硬件、应用、系统进行交互</strong>. 端到端是指从一个端点到另一个端点的意思，所以端到端测试重点用于测试模块和模块之间的协调性。</p><p>当应用是分布式系统或者需要和其他外部系统协同时，端到端测试扮演着非常重要的角色, 它可以全面检查以确保软件在不同平台和环境产品能准确地交互。端到端测试有以下目的:</p><ul><li>确保应用可以和外部系统之间良好的协调。对于前端来说，是确保页面和后端之间良好协调</li><li>检查从源系统到目标系统的所有系统流</li><li>从最终用户角度验证需求</li><li>识别异构环境中的问题</li></ul><p>前端也有很多自动化的端到端测试工具，比如nightwatch，通过它们可以模拟用户对页面进行操作，从而检验整个应用流程是否正常和符合需求:</p><p><img src="/images/typeof-testing/nightwatch.png" alt></p><p>因为和<strong>系统测试</strong>很相似，所以它们也被经常拿来<a href="https://www.softwaretestinghelp.com/system-vs-end-to-end-testing/" target="_blank" rel="noopener">比较</a></p><p><br></p><h2 id="16-等价划分-equivalence-partitioning"><a href="#16-等价划分-equivalence-partitioning" class="headerlink" title="16) 等价划分(Equivalence Partitioning)"></a>16) 等价划分(Equivalence Partitioning)</h2><p>等价划分, 这是一种黑盒测试的测试技术. <strong>通过等价划分，可以将所有的输入数据合理地划分为多个分组，我们只需在每个分组中取一个数据作为测试的输入条件, 这样可以实现用少量代表性的测试数据取得较好的测试结果</strong>.</p><p>所以说这个测试的目的: 是在不导致缺陷的前提下，移除指定分组中的重复的用例, 简化测试的工作</p><p><img src="/images/typeof-testing/part.png" alt></p><p>比如一个程序应用接受-10到+10之间的值，使用等价分区方法可以划分为三个分组: 0、负值、正值. 接下来的测试只需从这个三个分组中取一个成员进行测试, 而不需要-10到+10每个成员都测试一遍.</p><p><br></p><h2 id="17-实例测试-example-testing"><a href="#17-实例测试-example-testing" class="headerlink" title="17) 实例测试(Example Testing)"></a>17) 实例测试(Example Testing)</h2><p>It means real-time testing. Example testing includes the real-time scenario, it also involves the scenarios based on the experience of the testers.</p><p>实例测试意味着实时测试。实例测试包含了实时场景、另外还涉及基于测试人员经验的场景。</p><blockquote><p>🤔 这里不是特别能理解这个测试类型，所以贴上原文。知道的告诉我呀</p></blockquote><p><br></p><h2 id="18-探索测试-exploratory-testing"><a href="#18-探索测试-exploratory-testing" class="headerlink" title="18) 探索测试(Exploratory Testing)"></a>18) 探索测试(Exploratory Testing)</h2><p><img src="/images/typeof-testing/explorer.png" alt></p><p>探索性测试有点类似于Ad-Hoc测试. 探索性测试是由测试团队进行的非正式测试。此测试的目的是探索应用并查找应用中存在的缺陷。像探险一样，在测试期间是有一定几率发现的重大、甚至可能导致系统故障的缺陷.</p><p>在探索性测试期间，建议跟踪记录好测试的流程、以及开始该流程之前的活动记录, 方便复现bug.</p><p>探索测试不需要任何文档和测试用例.</p><p><br></p><h2 id="20-功能测试-functional-testing"><a href="#20-功能测试-functional-testing" class="headerlink" title="20) 功能测试(Functional Testing)"></a>20) 功能测试(Functional Testing)</h2><p>功能测试是一个大类, 又称为行为测试，  <strong>功能测试会忽略内部实现而关注组件的输出，目的是验证是否符合需求，这是一种面向功能需求的黑盒测试类型</strong>。关于功能测试的细节请看<a href="https://www.softwaretestinghelp.com/guide-to-functional-testing/" target="_blank" rel="noopener">这里</a></p><p>功能测试是相对非功能测试而言的, 功能测试需要关心功能或者业务，需要业务耦合程度高；而非功能测试则是通用的，比如压力测试、负载测试，这些测试都有通用的工具来支持，不需要或很少定制化操作.</p><p><br></p><h2 id="21-gui测试-graphical-user-interface-gui-testing"><a href="#21-gui测试-graphical-user-interface-gui-testing" class="headerlink" title="21) GUI测试(Graphical User Interface (GUI) Testing)"></a>21) GUI测试(Graphical User Interface (GUI) Testing)</h2><p>GUI测试的目的是根据业务需求验证GUI。在详细设计文档和GUI模型(UI设计文档)中一般会提到应用期望的GUI.</p><p>常见的GUI测试包括测试屏幕上显示的按钮和输入字段的大小、表格中所有文本、表格或内容的对齐规则等等. 如果团队有UI设计规范，还会验证是否符合设计规范</p><p><br></p><h2 id="22-大猩猩测试-gorilla-testing"><a href="#22-大猩猩测试-gorilla-testing" class="headerlink" title="22) 大猩猩测试(Gorilla Testing)"></a>22) 大猩猩测试(Gorilla Testing)</h2><p><img src="/images/typeof-testing/gr.jpg" alt></p><p>大猩猩测试是由测试人员执行的测试类型，有时也由开发人员执行。在大猩猩测试中，对模块中的一个模块或功能进行了彻底和严格的测试。原文没有说出大猩猩测试的精髓，大猩猩测试会对一个功能或模块进行重复‘上百次’的测试, 人类根本受不了这样子的测试方式，所以大猩猩测试的另一个别名是‘令人沮丧的测试(Frustrating Testing)’</p><p>这种测试的目的是检查应用程序的稳健性(robustness)</p><p><br></p><h2 id="23-乐观路线测试-happy-path-testing"><a href="#23-乐观路线测试-happy-path-testing" class="headerlink" title="23) 乐观路线测试(Happy Path Testing)"></a>23) 乐观路线测试(Happy Path Testing)</h2><p><strong>乐观路线测试</strong>的目标是在正常流程上成功测试应用。它不会考虑各种负面或异常情况。重点只关注于验证应用在有效和合法输入的条件下生成期望的输出. 比如银行付款，只考虑账户有钱的正常状态😂</p><p><br></p><h2 id="24-增量集成测试-incremental-integration-testing"><a href="#24-增量集成测试-incremental-integration-testing" class="headerlink" title="24) 增量集成测试(Incremental Integration Testing)"></a>24) 增量集成测试(Incremental Integration Testing)</h2><p>增量集成测试是一种自下而上的测试方法，即在添加新功能时立即集成应用程序进行连续测试。应用程序功能和模块应该足够独立，以便单独测试。这通常由程序员或测试人员完成。</p><p><br></p><h2 id="25-安装卸载测试-install-uninstall-testing"><a href="#25-安装卸载测试-install-uninstall-testing" class="headerlink" title="25) 安装卸载测试(Install/Uninstall Testing)"></a>25) 安装卸载测试(Install/Uninstall Testing)</h2><p><img src="/images/typeof-testing/blue-screen.jpg" alt></p><p>安装和卸载测试是在不同硬件或软件环境下的不同操作系统上的进行完整/部分的安装、升级、卸载、回滚等测试. 常用于桌面端应用</p><p><br></p><h2 id="26-集成测试-integration-testing"><a href="#26-集成测试-integration-testing" class="headerlink" title="26) 集成测试(Integration Testing)"></a>26) 集成测试(Integration Testing)</h2><p>集成测试是指将所有模块集成之后，验证合并后的功能. 模块通常是代码模块、单个应用、网络上的客户端和服务器应用等等。</p><p><img src="/images/typeof-testing/ingr.png" alt></p><p>集成测试一般在单元测试之后，所以单元测试是集成测试的基础，没有进行单元测试的集成测试是不靠谱的。所以最简单的形式是：’把两个已经测试过的单元组合成一个组件，测试它们之间的接口’。也就是说<strong>集成测试在单元测试的基础之上，将单元测试中独立的单元合并起来，验证它们的协调性, 合并后的组件又是一个新的‘单元’，这样逐步合并测试，最终形成完整的应用程序</strong>。</p><p>这种类型的测试常用于B/S软件和分布式系统。</p><p><br></p><h2 id="27-负载测试-load-testing"><a href="#27-负载测试-load-testing" class="headerlink" title="27) 负载测试(Load Testing)"></a>27) 负载测试(Load Testing)</h2><p>它是一种非功能性测试，负载测试的目的是检查系统可以承受多少负载而不会降低性能, 或者说确定最大工作负载是多少。</p><p>负载测试有助于查找特定负载下系统的最大容量以及导致软件性能下降的任何原因。可以使用JMeter，LoadRunner，WebLoad，Silk执行程序等工具执行负载测试。</p><p><img src="/images/typeof-testing/perf.png" alt></p><p>负载测试经常和性能测试、压力测试、稳定性测试等联系在一起。如上图(来源于淘宝性能白皮书). 其中TPS(Transation Per Second)指的是每秒钟系统可以处理的交易或事务的数量; Server Resource指的是系统资源占有.</p><ul><li><strong>性能测试</strong>. 主要位于a-b之间. 在系统设计初期就会规划一个预期目标, 比如给定资源Ax，a点就是性能期望值。也就是说在给定固定资源Ax的情况下，如果TPS可以达到a点甚至更高，就说明系统性能达到或者好于预期. <strong>通过性能测试可以验证系统的处理能力有没有达到预期</strong></li><li><strong>负载测试</strong>. 位于b-c之间。对系统不断增加并发请求，直到系统的某项或者多项指标达到安全的临界值，如上图中的c，这个c就是所谓的最大负载量。后面再增加请求压力，系统的处理能力不但不能提高，返回会下降. <strong>通过压力测试可以得出系统最大的安全负载值</strong></li><li><strong>压力测试</strong>. 位于c-d之间。在超过安全负载的情况下，继续对系统增加压力，直到达到崩溃点, 即上图的d. <strong>通过压力测试可以得出系统的最大承受能力</strong></li><li><strong>稳定性测试</strong>. 位于a-d之间。在a、b、c、d不同的点(代表特定的硬件、软件和网络环境)，让系统运行一段较长的时间，<strong>检测系统在不同条件下的系统运行的稳定性</strong>。</li></ul><p>另外也推荐阅读&lt;&lt;大型网站技术架构&gt;&gt;这本书</p><p><br></p><h2 id="28-猴子测试-monkey-testing"><a href="#28-猴子测试-monkey-testing" class="headerlink" title="28) 猴子测试(Monkey Testing)"></a>28) 猴子测试(Monkey Testing)</h2><p><img src="/images/typeof-testing/monkey-testing.jpg" alt></p><p>猴子测试是由测试人员进行的，即把自己当成猴子，在没有任何知识背景或者理解应用前提下，随意输入和操作。</p><p>猴子测试的目标是通过提供随机输入值/数据来检查应用程序或系统是否崩溃。 猴子是随机执行的，没有测试用例, 也没有必要了解系统的全部功能</p><p><br></p><h2 id="29-变异测试-mutation-testing"><a href="#29-变异测试-mutation-testing" class="headerlink" title="29) 变异测试(Mutation Testing)"></a>29) 变异测试(Mutation Testing)</h2><p>变异测试(或者说可变性测试)是一种白盒测试，这是一种和单元测试反着来的测试类型。</p><p><img src="/images/typeof-testing/mut.png" alt></p><p><strong>通常单元测试的思路是通过测试用例来验证代码是否有效可靠，而变异测试是反过来. 它首先更改其中一个程序的源代码，再跑单元测试，如果单元测试通过则可能说明测试用例没有效果，或者测试用例没有覆盖到这处代码变异</strong>. </p><p>所以说变异测试可以反过来验证你的测试用例是否有效, 还有可以帮助我们找出一些无法被当前测试所防止的潜在错误.</p><p><br></p><h2 id="30-悲观测试-negative-testing"><a href="#30-悲观测试-negative-testing" class="headerlink" title="30) 悲观测试(Negative Testing)"></a>30) 悲观测试(Negative Testing)</h2><p>悲观测试和乐观路线测试相反, 它要求测试者要具有“打破”常规的态度，考虑各种异常情况, 使用各种邪恶的👿、不怀好意、不合法的操作来测试系统。悲观测试会使用不正确的数据、无效数据或输入来进行验证。它验证系统是否可以识别异常情况，并按预期运行。</p><p><br></p><h2 id="31-非功能测试-non-functional-testing"><a href="#31-非功能测试-non-functional-testing" class="headerlink" title="31) 非功能测试(Non-Functional Testing)"></a>31) 非功能测试(Non-Functional Testing)</h2><p>每个大型的组织都有一个独立的团队，通常称为非功能测试（NFT）团队或性能团队。</p><p>非功能性测试涉及测试非功能性需求，如负载测试、压力测试、安全性、容量，恢复测试等等. NFT测试的目标是确保软件或应用程序的响应时间是否满足业务需求。</p><p>例如加载任何页面或系统都不应该花费太多时间，并且在负载峰值期间应该维持良好运行状态。</p><p><br></p><h2 id="32-性能测试-performance-testing"><a href="#32-性能测试-performance-testing" class="headerlink" title="32) 性能测试(Performance Testing)"></a>32) 性能测试(Performance Testing)</h2><p>这个术语通常与“压力”和“负载”测试互换使用。<a href="https://en.wikipedia.org/wiki/Software_performance_testing" target="_blank" rel="noopener">性能测试</a>用于检查系统是否满足性能要求。它会使用不同的性能和负载工具来执行此测试。</p><p><a href="https://www.softwaretestinghelp.com/introduction-to-performance-testing-loadrunner-training-tutorial-part-1/" target="_blank" rel="noopener">性能测试</a>这个范围比较大，<strong>广义上的性能测试包括了上文提到的负载测试、压力测试、稳定性测试、容量测试等等。狭义的性能测试则是指在特定资源条件下，测试系统能否达到期望值, 也就是基线测试(Baseline Test).</strong></p><p>总结一下性能测试的类型:</p><ul><li><strong>基线测试(Baseline Test)</strong>: 在给定的资源下，测试最佳的性能，用作后续测量的参考‘基线’。注意基线测试和基准测试是有区别的, 这么理解，基准是你想达到的，比如100短跑世界纪录，基线是你的成绩。</li><li><strong>负载测试(Load Test)</strong>: 在预期峰值的生产负载下测量系统的性能。上文负载测试已经大概介绍了</li><li><strong>稳定性测试(Endurance Test)</strong>: 在指定负载下，长时间测量系统的稳定性</li><li><strong>压力测试(Stress Test)</strong>: 测试极端条件下的系统性能</li></ul><p><br></p><h2 id="33-恢复测试-recovery-testing"><a href="#33-恢复测试-recovery-testing" class="headerlink" title="33) 恢复测试(Recovery Testing)"></a>33) 恢复测试(Recovery Testing)</h2><p>恢复测试用于验证应用或系统中崩溃或灾难中恢复的程度. 确定系统是否能够在灾难发生后继续运行。</p><p>比如应用通过网络电缆接收数据，突然断开了网络电缆的连接, 过一段时间，再插上网线, 系统应该开始恢复由于网络电缆拔出而丢失连接的数据</p><p><br></p><h2 id="34-回归测试-regression-testing"><a href="#34-回归测试-regression-testing" class="headerlink" title="34) 回归测试(Regression Testing)"></a>34) 回归测试(Regression Testing)</h2><p>在修改任意模块或者功能后，将应用作为一个整体进行测试，称为回归测试。<strong>回归测试的目的就是验证在软件原有的功能变动后是否保持完整性</strong>. </p><p><img src="/images/typeof-testing/bug-fix.gif" alt></p><p><strong>有观点认为回归测试就是回归测试是指重复执行以前的全部或部分相同的测试工作, 其实不是不无道理。而且因为局部修改而牵一发动全身的意外在平时开发中并不少见，这种意外性就是回归测试的存在的目的</strong>.</p><p>因为在回归测试中很难覆盖所有系统，通常最好使用自动化测试工具进行这些类测试。比如每次修改完代码，跑单元测试来确保不影响确保其他软件单元。</p><p>在前端中<a href="https://jestjs.io/docs/en/snapshot-testing" target="_blank" rel="noopener">组件快照测试(Snapshot Testing)</a>和一些<a href="https://github.com/HuddleEng/PhantomCSS" target="_blank" rel="noopener">CSS UI测试</a>，都是属于回归测试类型,它们的原理都是和上一次测试生成的结果进行比对，以确保没有意外的修改:</p><p><img src="/images/typeof-testing/phantomcss.png" alt></p><p><br></p><h2 id="35-基于风险的测试-risk-based-testing-rbt"><a href="#35-基于风险的测试-risk-based-testing-rbt" class="headerlink" title="35) 基于风险的测试(Risk-Based Testing (RBT))"></a>35) 基于风险的测试(Risk-Based Testing (RBT))</h2><p>在基于风险的测试中，功能或需求将根据其优先级进行测试。基于风险的测试会优先测试高度关键的功能，因为这些功能对业务影响最大或者故障概率非常高. 而优先级由业务需求决定，因此一旦为所有功能设置了优先级，则应该首先执行高优先级功能或测试用例，然后再执行低优先级功能。 低优先级功能可以在时间充裕时测试，或者不测试。</p><p><strong>基于风险的测试应该在‘不够时间来测试整个应用，但是又要按时交付软件’的情况下执行</strong>，通常还需要客户和高级管理层的讨论和批准之后才进行</p><p><br></p><h2 id="36-完整性测试-sanity-testing"><a href="#36-完整性测试-sanity-testing" class="headerlink" title="36) 完整性测试(Sanity Testing)"></a>36) 完整性测试(Sanity Testing)</h2><p>完整性测试用于确定一个新的软件版本是否可以开始进行正式的测试，如果一个应该在一开始使用时就崩溃，那么就说明系统还不够稳定，没有必要进行下一步测试。这种情况应该打回给开发，以免浪费时间</p><p>以我们公司为例:</p><p><img src="/images/typeof-testing/smoke.png" alt></p><ul><li>在软件设计阶段，测试团队就会为编写冒烟测试用例; </li><li>开发团队在提交版本给测试之前会自己跑一下冒烟用例, 确保没有重大故障；</li><li>将版本提交给测试团队后，测试团队就会先跑一下完整性测试，检查一下有没有重大的，影响测试进程的bug，如果有则退回开发</li><li>如果通过了完整性测试, 则进行冒烟测试，如果冒烟测试没有通过也会立即打回开发。</li><li>顺利通过完整性测试和冒烟测试之后才会进入正式测试阶段。</li></ul><p>这么做的目的之一就是为了降低测试团队的工作负担，因为他们要对接多个开发团队的测试任务。</p><p><br></p><h2 id="37-安全测试-security-testing"><a href="#37-安全测试-security-testing" class="headerlink" title="37) 安全测试(Security Testing)"></a>37) 安全测试(Security Testing)</h2><p><img src="/images/typeof-testing/sec.png" alt></p><p>安全也是一个庞大的学科，而且知识每天都在更新，所以安全测试一般由特殊的安全团队执行，他们以各种黑客手段对系统进行渗透测试。</p><p>安全测试旨在确保应用或网站免受内部和外部威胁的侵害。这个测试包括预防恶意程序、病毒； 检验授权和身份验证过程的安全性。</p><p>它还会检查软件对任何黑客攻击和恶意程序的反应方式，以及在遭到黑客攻击后如何维护软件以保护数据安全</p><p><br></p><h2 id="38-冒烟测试-smoke-testing"><a href="#38-冒烟测试-smoke-testing" class="headerlink" title="38) 冒烟测试(Smoke Testing)"></a>38) 冒烟测试(Smoke Testing)</h2><p><img src="/images/typeof-testing/note7.jpg" alt></p><p>冒烟测试，每当开发团队提交新的构建时，软件测试团队就会先验证构建, 并确保不存在重大问题, 如果存在重大问题会直接打回开发团队.</p><p>如何通俗地理解冒烟测试呢？这个属于来源于硬件行业，对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。举个例子，给三星Note7加电，如果没爆炸，就说明通过了‘冒烟测试’(感觉当手机测试者不容易，容易有生命危险😂)?</p><p>测试团队在确保构建稳定后才会进一步执行详细的测试。 冒烟检查会检查构建中是否存在中断缺陷(stopper defect, 即影响继续测试的缺陷)，这将阻止测试团队进一步详细测试。 即如果测试人员发现主要功能不能工作，他们会拒绝这次构建，并退回给开发团队。</p><p>冒烟测试一般在回归测试或其他详细测试之前进行</p><p><br></p><h2 id="39-静态测试-static-testing"><a href="#39-静态测试-static-testing" class="headerlink" title="39) 静态测试(Static Testing)"></a>39) 静态测试(Static Testing)</h2><p><img src="/images/typeof-testing/review.jpg" alt></p><p>静态测试有点类似于代码Review，在不执行任何代码的情况下执行(也就是不运行应用)，它涉及对可交付成果审查(inspection)、review和演练(walkthrough). 比如检查代码语法、命名约定、项目组织。</p><p>静态测试不仅适用于代码, 也适用于测试用例、测试计划和设计文档. 如果在静态测试阶段发现缺陷，可以将缺陷成本降到最低。比如在设计阶段就发现问题，相比到开发阶段甚至到生产环境出现问题要好解决</p><p>举前端的例子，静态测试可能包括:</p><ul><li>使用Lint工具对程序进行规范检查，相关的工具有ESLint、TSLint、Stylint等, 甚至Typescript这些类型检查器也可以归到这个范畴</li><li>代码Review。有一些问题是无法通过Lint工具覆盖的，比如代码逻辑、异常捕获、项目组织、内存泄露等等，这些需要人工进行走查Review</li><li>检查代码是否与设计一致，是否符合软件需求、概要和详细设计，这不仅可以看出代码问题，也可以反过来更早发现需求或设计是否正确。</li></ul><p><br></p><h2 id="40-压力测试-stress-testing"><a href="#40-压力测试-stress-testing" class="headerlink" title="40) 压力测试(Stress Testing)"></a>40) 压力测试(Stress Testing)</h2><p><img src="/images/typeof-testing/str.jpg" alt></p><p><strong>通过压力测试，模拟系统受到超出其规格的压力时失败的方式和时间, 找出系统的崩溃点</strong>. 这个测试在高负载情况下执行的，例如存取超过容量限制的数据、执行复杂的数据库查询、连续暴力输入到系统或加载到数据库。</p><p><br></p><h2 id="41-系统测试-system-testing"><a href="#41-系统测试-system-testing" class="headerlink" title="41) 系统测试(System Testing)"></a>41) 系统测试(System Testing)</h2><p>系统测试在完整的集成系统上进行测试，也就是说<strong>系统测试一般在集成测试之后进行，集成测试之后系统成为了一个整体，系统测试在这个基础上、在真实的运行环境中验证系统是否符合业务需求</strong>。 这是一种黑盒型测试，基于总体需求规范，涵盖系统的所有组合部分。</p><p>系统测试其实不是一个具体的测试技术，而是一个测试阶段。 这个阶段会进行很多种测试，一般公司的测试团队的工作就集中在这一块。 一般包含:</p><ul><li><strong>功能测试</strong>: 即上面讲的，从系统的整体上测试是否符合业务需求</li><li><strong>各种非功能测试</strong>：例如恢复测试、性能测试、压力测试、安全测试等等。</li></ul><p>归纳一下<strong>系统测试的目的</strong>:</p><ul><li>确保应用<strong>作为一个整体</strong>可以良好地运行.</li><li>确保应用符合业务需求</li><li>确保应用在真实的环境可以良好地运行。比如进行一些非功能测试，验证系统的健壮性</li></ul><p>其实系统测试和上文说的端到端测试很像，它们要求系统作为一个整体进行测试。可以简单展开对比一下</p><table><thead><tr><th></th><th>系统测试</th><th>端到端测试</th></tr></thead><tbody><tr><td>测试范围</td><td>一般针对被测应用本身</td><td>一般针对被测应用以及其依赖的其他系统。正如其名，端到端，即从一端点到另一端点。重点关注前端、后端以及中间件之间的处理流程</td></tr><tr><td>测试类型</td><td>包含功能测试和非功能测试</td><td>一般涵盖所有源系统和目标系统之间的接口级别的测试</td></tr><tr><td>测试时机</td><td>一般在集成测试之后</td><td>一般在系统测试之后</td></tr></tbody></table><p><br></p><h2 id="42-单元测试-unit-testing"><a href="#42-单元测试-unit-testing" class="headerlink" title="42) 单元测试(Unit Testing)"></a>42) 单元测试(Unit Testing)</h2><p><img src="/images/typeof-testing/unit-test.png" alt></p><p><strong>测试独立的软件单元或模块称为单元测试</strong>。它通常由开发者完成，而不是由测试人员完成，因为它需要详细了解内部程序设计和代码。</p><p>单元测试是和我们开发者最密切相关的测试类型。它的测试对象是软件单元。<strong>软件单元可以是一个函数/方法、一个类或者一个GUI组件等</strong>。</p><p>这是一种白盒测试，所以要求由开发者自己进行，因为只有开发者才知道单元的内部实现。<strong>单元测试一般会使用测试覆盖率来验证单元测试的完成度</strong>. </p><p>前端常见的单元测试工具有Jest、Mocha、Jasmine等等. 下面是典型的BDD风格的单元测试组织:</p><p><img src="/images/typeof-testing/bdd.png" alt></p><p><br></p><h2 id="43-可用性测试-usability-testing"><a href="#43-可用性测试-usability-testing" class="headerlink" title="43) 可用性测试(Usability Testing)"></a>43) 可用性测试(Usability Testing)</h2><p>可用性测试用于检测应用的用户友好程度(User-friendliness). 它会验证新用户受可以轻松理解应用流程，如果用户陷入麻烦，测试人员要记录好并提供帮助。可以认为可用性测试是在检查系统的导航性(navigation)</p><p><br></p><h2 id="44-漏洞测试-vulnerability-testing"><a href="#44-漏洞测试-vulnerability-testing" class="headerlink" title="44) 漏洞测试(Vulnerability Testing)"></a>44) 漏洞测试(Vulnerability Testing)</h2><p>漏洞测试，涉及识别软件、硬件和网络中的漏洞。如果漏洞容易受到攻击，或者容易受到病毒和蠕虫感染，黑客或恶意程序就可以控制系统。</p><p>因此有必要在投入生产环境之前检查这些系统是否存在漏洞。</p><p><br></p><h2 id="45-容量测试-volume-testing"><a href="#45-容量测试-volume-testing" class="headerlink" title="45) 容量测试(Volume Testing)"></a>45) 容量测试(Volume Testing)</h2><p>容量测试是由性能测试团队执行的一种非功能测试。容量测试会检查应用程序遇到大量的数据时的系统行为和响应时间。这种大量数据可能会影响系统的性能和处理时间的速度。</p><p><br></p><h2 id="46-白盒测试-white-box-testing"><a href="#46-白盒测试-white-box-testing" class="headerlink" title="46) 白盒测试(White Box Testing)"></a>46) 白盒测试(White Box Testing)</h2><p><img src="/images/typeof-testing/glassbox.jpg" alt></p><p>白盒测试, 它也被称为玻璃盒测试、结构测试、逻辑驱动测试或基于代码的测试, 基于应用程序代码的内部逻辑。即测试人员应该知道内部软件和代码是如何工作的, 对所有的逻辑路径进行覆盖测试。上面提到的单元测试和静态测试就是典型的白盒测试, 基本上白盒测试可以等价于单元测试</p><p><strong>逻辑路径包括语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖等等</strong>.</p><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/typeof-testing/all.png" alt></p><p>上面提到的软件测试类型只是测试中的一部分，实际有超过100种的测试类型，但是并非所有测试类型都会被所有项目使用，所以我这里只是列举一些比较常见的软件测试类型。</p><p>另外不同的组织中可能会有不同的定义或过程，但是基本概念在任何地方都是相同的。当项目、需求和范围发生变化时，这些测试类型、过程及其实现方法会不断演变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接: &lt;a href=&quot;https://www.softwaretestinghelp.com/types-of-software-testing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Types Of Software Testing: 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你可能不知道的浏览器实时通信方案</title>
    <link href="https://bobi.ink/2019/07/07/sockjs/"/>
    <id>https://bobi.ink/2019/07/07/sockjs/</id>
    <published>2019-07-06T16:00:00.000Z</published>
    <updated>2019-07-10T08:30:04.800Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。</p><p>这里以<a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="noopener"><code>sockjs</code></a>作为切入点，这是一个流行的浏览器实时通信库，提供了’类Websocket’、一致性、跨平台的API，旨在浏览器和服务器之间创建一个低延迟、全双工、支持跨域的实时通信信道. <strong>主要特点就是仿生Websocket，它会优先使用Websocket作为传输层，在不支持WebSocket的环境回退使用其他解决方案，例如XHR-Stream、轮询</strong>. </p><p>所以<code>sockjs</code>本身就是浏览器实时通信方案的编年史, 本文也是按照由新到老这样的顺序来介绍这些解决方案. </p><blockquote><p>类似sockjs的解决方案还有 <a href="https://socket.io/" target="_blank" rel="noopener">socket.io</a></p></blockquote><blockquote><p>如果你觉得文章不错，请不要吝惜你的点赞👍，鼓励笔者写出更精彩的文章</p></blockquote><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#websocket">WebSocket</a></li><li><a href="#xhr-streaming">XHR-streaming</a></li><li><a href="#eventsource">EventSource</a></li><li><a href="#htmlfile">HtmlFile</a></li><li><a href="#polling">Polling</a></li><li><a href="#long-polling">Long polling</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="websocket"><a href="#websocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket其实不是本文的主角，而且网上已经有很多教程，本文的目的是介绍WebSocket之外的一些回退方案，在浏览器不支持Websocket的情况下, 可以选择回退到这些方案.</p><p>在此介绍Websocket之前，先来了解一些HTTP的基础知识，毕竟WebSocket本身是借用HTTP协议实现的。</p><p>HTTP协议是基于TCP/IP之上的应用层协议，也就是说HTTP在TCP连接中进行请求和响应的，<strong>浏览器会为每个请求建立一个TCP连接，请求等待服务端响应，在服务端响应后关闭连接</strong>:</p><p><img src="/images/sockjs/base-http.png" alt></p><p>后来人们发现为每个HTTP请求都建立一个TCP连接，太浪费资源了，能不能不要着急关闭TCP连接，而是将它复用起来, 在一个TCP连接中进行多次请求。</p><p><strong>这就有了HTTP持久连接(HTTP persistent connection, 也称为HTTP keep-alive), 它利用同一个TCP连接来发送和接收多个HTTP请求/响应。持久连接的方式可以大大减少等待时间, 双方不需要重新运行TCP握手，这对前端静态资源的加载也有很大意义</strong>:</p><p><img src="/images/sockjs/http-keep-alive.png" alt></p><p>Ok, 现在回到WebSocket, <strong>浏览器端用户程序并不支持和服务端直接建立TCP连接，但是上面我们看到每个HTTP请求都会建立TCP连接, TCP是可靠的、全双工的数据通信通道，那我们何不直接利用它来进行实时通信？ 这就是Websocket的原理!</strong> </p><p>我们这里通过一张图，通俗地理解一下Websocket的原理:</p><p><img src="/images/sockjs/websocket.png" alt></p><p>通过上图可以看到，<strong>WebSocket除最初建立连接时需要借助于现有的HTTP协议，其他时候直接基于TCP完成通信</strong>。这是浏览器中最靠近套接字的API，可以实时和服务端进行全双工通信. WebSocket相比传统的浏览器的<a href="https://en.wikipedia.org/wiki/Comet_(programming" target="_blank" rel="noopener">Comet</a>)(下文介绍)技术, 有很多优势：</p><ul><li>更强的实时性。基于TCP协议的全双工通信</li><li>更高效。一方面是数据包相对较小，另一方面相比传统XHR-Streaming和轮询方式更加高效，不需要重复建立TCP连接</li><li>更好的二进制支持。 Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容</li><li>保持连接状态。 相比HTTP无状态的协议，WebSocket只需要在建立连接时携带认证信息，后续的通信都在这个会话内进行</li><li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等</li></ul><p><br></p><p>它的接口也非常简单：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/socket'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">ws.onerror = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123; ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接关闭</span></span><br><span class="line">ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接建立</span></span><br><span class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 向服务端发送消息</span></span><br><span class="line">  ws.send(<span class="string">"ping"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端发送的消息</span></span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span>(msg.data <span class="keyword">instanceof</span> Blob) &#123; </span><br><span class="line">  <span class="comment">// 处理二进制信息</span></span><br><span class="line">    processBlob(msg.data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文本信息</span></span><br><span class="line">    processText(msg.data); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文不会深入解析Websocket的协议细节，有兴趣的读者可以看下列文章:</p><ul><li><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a></li><li><a href="https://mp.weixin.qq.com/s/7aXMdnajINt0C5dcJy2USg?" target="_blank" rel="noopener">WebSocket 浅析</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">阮一峰：WebSocket 教程</a></li></ul><p><br></p><p>如果不考虑低版本IE，基本上WebSocket不会有什么兼容性上面的顾虑. 下面列举了Websocket一些常见的问题, 当无法正常使用Websocket时，可以利用sockjs或者socket.io这些方案回退到传统的Comet技术方案.</p><ol><li>浏览器兼容性。<ul><li>IE10以下不支持</li><li>Safari 下不允许使用非标准接口建立连接</li></ul></li><li>心跳. WebSocket本身不会维护心跳机制，一些Websocket实现在空闲一段时间会自动断开。所以sockjs这些库会帮你维护心跳</li><li>一些负载均衡或代理不支持Websocket。</li><li>会话和消息队列维护。这些不是Websocket协议的职责，而是应用的职责。sockjs会为每个Websocket连接维护一个会话，且这个会话里面会维护一个消息队列，当Websocket意外断开时，不至于丢失数据</li></ol><p><br></p><hr><p><br></p><h2 id="xhr-streaming"><a href="#xhr-streaming" class="headerlink" title="XHR-streaming"></a>XHR-streaming</h2><p>XHR-Streming, 中文名称‘XHR流’, 这是WebSocket的最佳替补方案. XHR-streaming的原理也比较简单：<strong>服务端使用分块传输编码(Chunked transfer encoding)的HTTP传输机制进行响应，并且服务器端不终止HTTP响应流，让HTTP始终处于持久连接状态，当有数据需要发送给客户端时再进行写入数据</strong>。</p><p>没理解？没关系，我们一步一步来, 先来看一下正常的HTTP请求处理是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node.js代码</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>, <span class="comment">// 设置内容格式</span></span><br><span class="line">    <span class="string">'Content-Length'</span>: <span class="number">11</span>, <span class="comment">// 设置内容长度</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.end(<span class="string">'hello world'</span>) <span class="comment">// 响应 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端会立即接收到响应:</p><p><img src="/images/sockjs/http-req.png" alt></p><p><br></p><p>那么什么是<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener"><strong>分块传输编码</strong></a>呢?</p><p><strong>在HTTP/1.0之前, 响应是必须作为一整块数据返回客户端的(如上例)，这要求服务端在发送响应之前必须设置<code>Content-Length</code>, 浏览器知道数据的大小后才能确定响应的结束时间</strong>。这让服务器响应动态的内容变得非常低效，它必须等待所有动态内容生成完，再计算Content-Length, 才可以发送给客户端。如果响应的内容体积很大，需要占用很多内存空间.</p><p><strong>HTTP/1.1引入了<code>Transfer-Encoding: chunked;</code>报头。 它允许服务器发送给客户端应用的数据可以分为多个部分, 并以一个或多个块发送，这样服务器可以发送数据而不需要提前计算发送内容的总大小</strong>。</p><p><strong>有了分块传输机制后，动态生成内容的服务器就可以维持HTTP长连接, 也就是说服务器响应流不结束，TCP连接就不会断开</strong>. </p><p><br></p><p>现在我们切换为分块传输编码模式， 且我们不终止响应流，看会有什么情况:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    <span class="comment">// 'Content-Length': 11, // 🔴将Content-Length报头去掉，Node.js默认就是使用分块编码传输的</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.write(<span class="string">'hello world'</span>)</span><br><span class="line">  <span class="comment">// res.end() // 🔴不终止输出流</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们会发现请求会一直处于Pending状态(绿色下载图标)，<strong>除非出现异常、服务器关闭或显式关闭连接(比如设置超时机制)，请求是永远不会终止的。但是即使处于Pending状态客户端还是可以接收数据，不必等待请求结束</strong>:</p><p><img src="/images/sockjs/http-pending-req.png" alt></p><p><br></p><p>基于这个原理我们再来创建一个简单的ping-pong服务器:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/ping'</span>) &#123;</span><br><span class="line">    <span class="comment">// ping请求</span></span><br><span class="line">    <span class="keyword">if</span> (pendingResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">500</span>);</span><br><span class="line">      res.write(<span class="string">'session not found'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.writeHead(<span class="number">200</span>)</span><br><span class="line">    res.end()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给客户端推流</span></span><br><span class="line">    pendingResponse.write(<span class="string">'pong\n'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存句柄</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="string">'welcome to ping\n'</span>);</span><br><span class="line">    pendingResponse = res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>测试一下，在另一个窗口访问<code>/ping</code>路径：</p><p><img src="/images/sockjs/http-stream-ping.png" alt></p><p>Ok! 这就是XHR-Streaming!</p><p><br></p><p>那么Ajax怎么接收这些数据呢？ ①一种做法是在<code>XMLHttpRequest</code>的<code>onreadystatechange</code>事件处理器中判断<code>readyState</code>是否等于<code>XMLHttpRequest.LOADING</code>；②另外一种做法是在<code>xhr.onprogress</code>事件处理器中处理。下面是ping客户端实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.onprogress = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意responseText是获取服务端发送的所有数据，如果要获取未读数据，则需要进行划分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'progress'</span>, xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(<span class="string">'POST'</span>, HOST);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ping</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'POST'</span>, HOST + <span class="string">'/ping'</span>);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen();</span><br><span class="line">setInterval(ping, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p><br></p><p>慢着，不要高兴得太早😰. 如果运行上面的代码会发现<code>onprogress</code>并没有被正常的触发, 具体原因笔者也没有深入研究，我发现sockjs的服务器源码里面会预先写入2049个字节，这样就可以正常触发onprogress事件了:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/ping'</span>) &#123;</span><br><span class="line">    <span class="comment">// ping请求</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存句柄</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">Array</span>(<span class="number">2049</span>).join(<span class="string">'h'</span>) + <span class="string">'\n'</span>);</span><br><span class="line">    pendingResponse = res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>最后再图解一下XHR-streaming的原理:</p><p><img src="/images/sockjs/xhr-stream.png" alt></p><p>总结一下XHR-Streaming的特点:</p><ul><li>利用分块传输编码机制实现持久化连接(persistent connection): 服务器不关闭响应流，连接就不会关闭</li><li>单工(unidirectional): 只允许服务器向浏览器单向的推送数据</li></ul><p><strong>通过XHR-Streaming，可以允许服务端连续地发送消息，无需每次响应后再去建立一个连接, 所以它是除了Websocket之外最为高效的实时通信方案. 但它也并不是完美无缺</strong>。</p><p>比如XHR-streaming连接的时间越长，浏览器会占用过多内存，而且在每一次新的数据到来时，需要对消息进行划分，剔除掉已经接收的数据. 因此sockjs对它进行了一点优化, 例如sockjs默认只允许每个xhr-streaming连接输出128kb数据，超过这个大小时会关闭输出流，让浏览器重新发起请求.</p><p><br></p><hr><p><br></p><h2 id="eventsource"><a href="#eventsource" class="headerlink" title="EventSource"></a>EventSource</h2><p>了解了XHR-Streaming, 就会觉得<a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/EventSource" target="_blank" rel="noopener"><code>EventSource</code></a>并不是什么新鲜玩意: 它就是上面讲的<code>XHR-streaming</code>, 只不过浏览器给它提供了标准的API封装和协议, 你抓包一看和XHR-streaming没有太大的区别:</p><p><img src="/images/sockjs/eventsource.png" alt></p><p><br></p><p>上面可以看到请求的<code>Accept</code>为<code>text/event-stream</code>, 且服务端写入的数据都有标准的约定, 即载荷需要这样组织:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="string">`data: <span class="subst">$&#123;payload&#125;</span>\r\n\r\n`</span></span><br></pre></td></tr></table></figure><p><br></p><p>EventSource的API和Websocket类似, 实例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">'sse.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接打开</span></span><br><span class="line">evtSource.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受消息</span></span><br><span class="line">evtSource.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"message: "</span> + e.data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭流</span></span><br><span class="line">  evtSource.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常</span></span><br><span class="line">evtSource.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>因为是标准的，浏览器调试也比较方便，不需要借助第三方抓包工具:</p><p><img src="/images/sockjs/eventsource-inspect.png" alt></p><p><br></p><hr><p><br></p><h2 id="htmlfile"><a href="#htmlfile" class="headerlink" title="HtmlFile"></a>HtmlFile</h2><p>这是一种古老的‘秘术’😂，虽然我们可能永远都不会再用到它，但是它的实现方式比较有意思(类似于JSONP这种黑科技), 所以还是值得讲一下。</p><p>HtmlFile的另一个名字叫做<code>永久帧(forever-frame)</code>, 顾名思义, 浏览器会打开一个隐藏的iframe，这个iframe会请求一个分块传输编码的html文件(Transfer-Encoding: chunked), 和XHR-Streaming一样，这个请求永远都不会结束，服务器会不断在这个文档上输出内容。<strong>这里面的要点是现代浏览器都会增量渲染html文件，所以服务器可以通过添加script标签在客户端执行某些代码</strong>，先来看个抓包的实例:</p><p><img src="/images/sockjs/htmlfile.png" alt></p><p><br></p><p>从上图可以看出:</p><ul><li>① 这里会给服务器传递一个callback，通过这个callback将数据传递给父文档</li><li>② 服务器每当有新的数据，就向文档追加一个<code>&lt;script&gt;</code>标签，script的代码就是将数据传递给callback。利用浏览器会被下载边解析HTML文档的特性，新增的script会马上被执行</li></ul><p><br></p><p>最后还是用流程图描述一下：</p><p><img src="/images/sockjs/htmlfile-progress.png" alt></p><p>除了IE6、7以下不支持，大部分浏览器都支持这个方案，当浏览器不支持<code>XHR-streaming</code>时，可以作为最佳备胎。</p><p><br></p><hr><p><br></p><h2 id="polling"><a href="#polling" class="headerlink" title="Polling"></a>Polling</h2><p>轮询是最粗暴(或者说最简单)，也是效率最低下的‘实时’通信方案，这种方式的原理就是定期向服务器发起请求, 拉取最新的消息队列:</p><p><img src="/images/sockjs/polling2.png" alt></p><p>这种轮询方式比较合适<strong>服务器的信息定期更新</strong>的场景，如天气和股票行情信息。举个例子股票信息每隔5分钟更新一次，这时候客户端定期轮询, 且轮询间隔和服务端更新频率保持一致是一种理想的方式。</p><p>但是如果追求实时性，轮询会导致一些严重的问题:</p><ul><li>资源浪费。比如轮询的间隔小于服务器信息更新的频率，这会浪费很多HTTP请求, 消耗宝贵的CPU时间和带宽</li><li>容易导致请求轰炸。比如当服务器负载比较高时，第一个请求还没处理完成，这时候第二、第三个请求接踵而来，无用的额外请求对服务端进行了轰炸。</li></ul><p><br></p><hr><p><br></p><h2 id="long-polling"><a href="#long-polling" class="headerlink" title="Long polling"></a>Long polling</h2><p>还有一种优化的轮询方法，称为长轮询(Long Polling)，sockjs就是使用这种轮询方式, <strong>长轮询指的是浏览器发送一个请求到服务器，服务器只有在有可用的新数据时才响应</strong>：</p><p><img src="/images/sockjs/polling.png" alt></p><p>客户端向服务端发起一个消息获取请求，服务端会将当前的消息队列返回给客户端，然后关闭连接。<strong>当消息队列为空时，服务端不会立即关闭连接，而是等待指定的时间间隔，如果在这个时间间隔内没有新的消息，则由客户端主动超时关闭连接</strong>。</p><p>另外一个要点是，<strong>客户端的轮询请求只有在上一个请求连接关闭后才会重新发起</strong>。这就解决了上文的请求轰炸问题。服务端可以控制客户端的请求时序，因为在服务端未响应之前，客户端不会发送额外的请求(在超时期间内)。</p><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="noopener">WebRTC</a> 这是浏览器的实时通信技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。</li><li><a href="https://github.com/meteor/meteor/tree/devel/packages/ddp" target="_blank" rel="noopener">metetor DDP</a> DDP(Distributed Data Protocol), 这是一个’有状态的’实时通信协议，这个是<a href="https://github.com/meteor/meteor" target="_blank" rel="noopener">Meteor</a>框架的基础, 它就是使用这个协议来进行客户端和服务端通信. 他只是一个协议，而不是通信技术，比如它的底层可以基于Websocket、XHR-Streaming、长轮询甚至是WebRTC</li><li><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">Server-Sent Events 教程</a></li><li><a href="https://medium.com/@chijianqiang/程序员怎么会不知道-c10k-问题呢-d024cb7880f3" target="_blank" rel="noopener">程序员怎么会不知道C10K 问题呢？ - 池建强- Medium</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。&lt;/p&gt;
&lt;p&gt;这里以&lt;a href=&quot;https://github.com/sockjs/sockjs-client&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;sockjs
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[译] 不容错过的CSS变量</title>
    <link href="https://bobi.ink/2019/07/06/css-variable/"/>
    <id>https://bobi.ink/2019/07/06/css-variable/</id>
    <published>2019-07-05T16:00:00.000Z</published>
    <updated>2019-07-06T04:54:51.625Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接: <a href="https://dev.to/timdeschryver/don-t-miss-out-on-css-variables-4708" target="_blank" rel="noopener">Don’t miss out on css variables</a></p><p>当我第一次听说<a href="https://www.w3.org/TR/css-variables/" target="_blank" rel="noopener">CSS变量</a>时，我是抱着怀疑太多的。scss、sass、less和stylus这些CSS预处理器不是都有变量机制吗? 为什么还要使用它？过了几年，我发现越来越多的人开始讨论和使用它，我觉得我是错过了什么…… 虽然花费了一点功夫，但在使用后，我确实被它吸引住了。这篇文章我会阐述到底是什么推动我进一步去探索CSS变量，并在实际项目中使用它。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>在选择器里面声明变量，变量名以<code>--</code>作为前缀:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">--bgColor</span>: deeppink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个流行的方式是在<code>:root</code>选择器中定义变量，这相当于定于全局变量:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--bgColor</span>: teal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>var()</code>函数来引用变量:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--bgColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>var()</code>函数还可以接受一个参数，用作变量的默认值，当变量未定义时回退到这个默认值:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--bgColor);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color, beige);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的运行结果如下:</p><p><img src="/images/css-variable/0.png" alt></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>利用CSS变量，可以很容易地实现主题机制.</p><p>在body元素上为不同的主题创建不同的类名，并定义合适的变量值:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-class">.sunrise</span> &#123;</span><br><span class="line">  <span class="attribute">--background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">--text-color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.sunset</span> &#123;</span><br><span class="line">  <span class="attribute">--background-color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">--text-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这些变量:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--background-color);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--text-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在切换body元素的类名到sunrise或sunse，CSS变量会叠层应用到所有选择器. 效果如下:</p><p><img src="/images/css-variable/1.gif" alt></p><h2 id="javascript-api"><a href="#javascript-api" class="headerlink" title="Javascript API"></a>Javascript API</h2><p>我觉得这是CSS变量最好的部分 —— CSS变量可以通过Javascript API来获取和设置。SCSS/Less这些预处理器的变量可做不到(部分预处理器已支持编译到到CSS变量)。</p><p>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/getPropertyValue" target="_blank" rel="noopener"><code>getPropertyValue</code></a>方法来获取变量:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getComputedStyle(<span class="built_in">document</span>.documentElement).getPropertyValue(<span class="string">'--color'</span>)</span><br></pre></td></tr></table></figure><p>如果要获取具体元素的的变量值, 先通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector" target="_blank" rel="noopener"><code>querySelector</code></a>获取元素：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getComputedStyle(<span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>)).getPropertyValue(<span class="string">'--color'</span>)</span><br></pre></td></tr></table></figure><p>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/setProperty" target="_blank" rel="noopener"><code>style.setProperty</code></a>来设置变量值：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(<span class="string">'--color'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>设置具体元素的变量值:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>).style.setProperty(<span class="string">'--color'</span>, <span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure><p>这个API提供了一个简洁的方式来使用CSS变量.</p><p>几天前, 我通过<a href="https://twitter.com/DavidKPiano" target="_blank" rel="noopener">David K</a>的<a href="https://codepen.io/davidkpiano/pen/zWrRye" target="_blank" rel="noopener">XState DEMO</a>接触到了这个使用场景: 当用户鼠标拖拽时, 通过CSS变量来确定选择框的定位(基于鼠标的开始位置和当前位置):</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.selectbox</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(var(--mouse-x1));</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">calc</span>(var(--mouse-y1));</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>((var(--mouse-x2) - <span class="built_in">var</span>(--mouse-x1)));</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>((var(--mouse-y2) - <span class="built_in">var</span>(--mouse-y1)));</span><br><span class="line"></span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.5);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(0, 0, 0, 0.1);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid currentColor;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.3s</span> ease-in-out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在鼠标事件处理器中更新CSS变量：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(</span><br><span class="line">  <span class="string">'--mouse-x1'</span>,</span><br><span class="line">  ctx.selectArea.x1 + <span class="string">'px'</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(</span><br><span class="line">  <span class="string">'--mouse-y1'</span>,</span><br><span class="line">  ctx.selectArea.y1 + <span class="string">'px'</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(</span><br><span class="line">  <span class="string">'--mouse-x2'</span>,</span><br><span class="line">  ctx.selectArea.x2 + <span class="string">'px'</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(</span><br><span class="line">  <span class="string">'--mouse-y2'</span>,</span><br><span class="line">  ctx.selectArea.y2 + <span class="string">'px'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/images/css-variable/2.gif" alt></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你像我一样觉得CSS变量没有用，或者压根不知道它的存在，我希望这篇文章可以为你开启一扇门，来探索它的使用场景。</p><p>Javascript API让我踩了不少坑，但是它确实让我开了眼界，我期待未来能够更多使用和了解它们。</p><blockquote><p>译者注:<br><br>本文并非完全照搬原文，即意译. 另外女朋友也给我校验过了，确保大体没有搞错😂<br><br>因为笔者自己原创的文章阅读量比较惨淡，所以笔者近期会尝试翻译一些文章，学习这些文章是怎么写的，也积攒点人气，以便后面原创文章有更多阅读量</p></blockquote><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties" target="_blank" rel="noopener">使用CSS变量</a></li><li><a href="https://caniuse.com/#feat=css-variables" target="_blank" rel="noopener">Caniuse: CSS Variables (Custom Properties)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接: &lt;a href=&quot;https://dev.to/timdeschryver/don-t-miss-out-on-css-variables-4708&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Don’t miss out on css va
      
    
    </summary>
    
      <category term="前端,CSS" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF-CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] CodeSandbox 如何工作? 上篇</title>
    <link href="https://bobi.ink/2019/06/20/codesandbox/"/>
    <id>https://bobi.ink/2019/06/20/codesandbox/</id>
    <published>2019-06-19T16:00:00.000Z</published>
    <updated>2019-07-04T14:28:21.865Z</updated>
    
    <content type="html"><![CDATA[<p>这期来关注一下<a href="https://codesandbox.io" target="_blank" rel="noopener"><code>CodeSandbox</code></a>, 这是一个浏览器端的沙盒运行环境，支持多种流行的构建模板，例如 <code>create-react-app</code>、 <code>vue-cli</code>、<code>parcel</code>等等。 可以用于快速原型开发、DEMO 展示、Bug 还原等等.</p><p>相似的产品有很多，例如<a href="https://codepen.io/pen" target="_blank" rel="noopener"><code>codepen</code></a>、<a href="https://jsfiddle.net" target="_blank" rel="noopener"><code>JSFiddle</code></a>、<a href="https://webpackbin-prod.firebaseapp.com" target="_blank" rel="noopener"><code>WebpackBin</code></a>(已废弃).</p><p>CodeSandbox 则更加强大，可以视作是浏览器端的 Webpack 运行环境, 甚至在 V3 版本已经支持 VsCode 模式，支持 Vscode 的插件和 Vim 模式、还有主题.</p><p>另外 CodeSandbox 支持离线运行(PWA)。基本上可以接近本地 VSCode 的编程体验. 有 iPad 的同学，也可以尝试基于它来进行开发。所以快速的原型开发我一般会直接使用 CodeSandbox</p><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#引">引</a></li><li><a href="#基本目录结构">基本目录结构</a></li><li><a href="#项目构建过程">项目构建过程</a><ul><li><a href="#packager">Packager</a><ul><li><a href="#webpackdllplugin">WebpackDllPlugin</a></li><li><a href="#在线打包服务">在线打包服务</a></li><li><a href="#回退方案">回退方案</a></li></ul></li><li><a href="#transpilation">Transpilation</a><ul><li><a href="#基本对象">基本对象</a></li><li><a href="#manager">Manager</a></li><li><a href="#transpiledmodule">TranspiledModule</a></li><li><a href="#transpiler">Transpiler</a></li><li><a href="#babeltranspiler">BabelTranspiler</a></li></ul></li><li><a href="#evaluation">Evaluation</a></li></ul></li><li><a href="#技术地图">技术地图</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><center><br>  <img src="/images/08/codesandbox.png" width="800"><br></center><p><br></p><p>笔者对 CodeSandbox 的第一印象是这玩意是运行在服务器的吧？ 比如 <code>create-react-app</code> 要运行起来需要 node 环境，需要通过 npm 安装一大堆依赖，然后通过 Webpack 进行打包，最后运行一个开发服务器才能在浏览器跑起来.</p><p><strong>实际上 CodeSandbox 打包和运行并不依赖于服务器, 它是完全在浏览器进行的</strong>. 大概的结构如下:</p><center><br> <img src="/images/08/codesandbox-arch.png" width="600"><br></center><ul><li><strong>Editor</strong>: 编辑器。主要用于修改文件，CodeSandbox这里集成了 <code>VsCode</code>, 文件变动后会通知 <code>Sandbox</code> 进行转译. 计划会有文章专门介绍CodeSandbox的编辑器实现</li><li><strong>Sandbox</strong>: 代码运行器。<strong>Sandbox 在一个单独的 iframe 中运行, 负责代码的转译(Transpiler)和运行(Evalation)</strong>. 如最上面的图，左边是Editor，右边是Sandbox</li><li><strong>Packager</strong> 包管理器。类似于yarn和npm，负责拉取和缓存 npm 依赖</li></ul><p><br></p><p>CodeSandbox 的作者 <a href="https://twitter.com/CompuIves" target="_blank" rel="noopener">Ives van Hoorne</a> 也尝试过将 <code>Webpack</code> 移植到浏览器上运行，因为现在几乎所有的 CLI 都是使用 Webpack 进行构建的，如果能将 Webpack 移植到浏览器上, 可以利用 Webpack 强大的生态系统和转译机制(loader/plugin)，低成本兼容各种 CLI.</p><p>然而 Webpack 太重了😱，压缩过后的大小就得 3.5MB，这还算勉强可以接受吧；更大的问题是要在浏览器端模拟 Node 运行环境，这个成本太高了，得不偿失。</p><p>所以 CodeSandbox 决定自己造个打包器，这个打包器更轻量，并且针对 CodeSandbox 平台进行优化. 比如 CodeSandbox 只关心开发环境的代码构建, 目标就是能跑起来就行了, 跟 Webpack 相比裁剪掉了以下特性:</p><ul><li>生产模式. CodeSandbox 只考虑 development 模式，不需要考虑 production一些特性，比如<ul><li>代码压缩，优化</li><li>Tree-shaking</li><li>性能优化</li><li>代码分割</li></ul></li><li>文件输出. 不需要打包成chunk</li><li>服务器通信. Sandbox直接原地转译和运行, 而Webpack 需要和开发服务器建立一个长连接用于接收指令，例如 HMR.</li><li>静态文件处理(如图片). 这些图片需要上传到 CodeSandbox 的服务器</li><li>插件机制等等.</li></ul><p>所以可以认为<strong>CodeSandbox是一个简化版的Webpack, 且针对浏览器环境进行了优化，比如使用worker来进行并行转译</strong></p><p>CodeSandbox 的打包器使用了接近 <code>Webpack Loader</code> 的 API, 这样可以很容易地将 Webpack 的一些 loader 移植过来. 举个例子，下面是 <code>create-react-app</code> 的实现(查看<a href="https://github.com/codesandbox/codesandbox-client/blob/84972fd027fe36c53652c22f6775e1e6d3c51145/packages/app/src/sandbox/eval/presets/create-react-app/index.js#L1" target="_blank" rel="noopener">源码</a>):</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> stylesTranspiler <span class="keyword">from</span> <span class="string">"../../transpilers/style"</span>;</span><br><span class="line"><span class="keyword">import</span> babelTranspiler <span class="keyword">from</span> <span class="string">"../../transpilers/babe"</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> sassTranspiler <span class="keyword">from</span> <span class="string">"../../transpilers/sass"</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> preset = <span class="keyword">new</span> Preset(</span><br><span class="line">  <span class="string">"create-react-app"</span>,</span><br><span class="line">  [<span class="string">"web.js"</span>, <span class="string">"js"</span>, <span class="string">"json"</span>, <span class="string">"web.jsx"</span>, <span class="string">"jsx"</span>, <span class="string">"ts"</span>, <span class="string">"tsx"</span>],</span><br><span class="line">  &#123;</span><br><span class="line">    hasDotEnv: <span class="literal">true</span>,</span><br><span class="line">    setup: <span class="function"><span class="params">manager</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> babelOptions = &#123;</span><br><span class="line">        <span class="comment">/*..*/</span></span><br><span class="line">      &#125;;</span><br><span class="line">      preset.registerTranspiler(</span><br><span class="line">        <span class="built_in">module</span> =&gt;</span><br><span class="line">          /\.(t|j)sx?$/.test(<span class="built_in">module</span>.path) &amp;&amp; !<span class="built_in">module</span>.path.endsWith(<span class="string">".d.ts"</span>),</span><br><span class="line">        [</span><br><span class="line">          &#123;</span><br><span class="line">            transpiler: babelTranspiler,</span><br><span class="line">            options: babelOptions</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      );</span><br><span class="line">      preset.registerTranspiler(</span><br><span class="line">        <span class="built_in">module</span> =&gt; <span class="regexp">/\.svg$/</span>.test(<span class="built_in">module</span>.path),</span><br><span class="line">        [</span><br><span class="line">          &#123; <span class="attr">transpiler</span>: svgrTranspiler &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            transpiler: babelTranspiler,</span><br><span class="line">            options: babelOptions</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br></p><p>可以看出, CodeSandbox的Preset和Webpack的配置长的差不多. <strong>不过, 目前你只能使用 CodeSandbox 预定义的 Preset, 不支持像 Webpack 一样进行配置, 个人觉得这个是符合 CodeSandbox 定位的，这是一个快速的原型开发工具，你还折腾 Webpack 干嘛？</strong></p><p>目前支持这些Preset:</p><center><br> <img src="/images/08/presets.png" width="600"><br></center><p><br></p><hr><p><br></p><h2 id="基本目录结构"><a href="#基本目录结构" class="headerlink" title="基本目录结构"></a>基本目录结构</h2><p>CodeSandbox 的客户端是开源的，不然就没有本文了，它的基本目录结构如下:</p><ul><li><strong>packages</strong><ul><li><strong>app</strong> CodeSandbox应用<ul><li><strong>app</strong> 编辑器实现</li><li><strong>embed</strong> 网页内嵌运行 codesandbox</li><li><strong>sandbox</strong> 运行沙盒，在这里执行代码构建和预览，相当于一个缩略版的 Webpack. 运行在单独的 iframe 中<ul><li>eval<ul><li>preset<ul><li>create-react-app</li><li>parcel</li><li>vue-cli</li><li>…</li></ul></li><li>transpiler<ul><li>babel</li><li>sass</li><li>vue</li><li>…</li></ul></li></ul></li><li>compile.ts 编译器</li></ul></li></ul></li><li><strong>common</strong> 放置通用的组件、工具方法、资源</li><li><strong>codesandbox-api</strong>: 封装了统一的协议，用于 sandbox 和 editor 之间通信(基于postmessage)</li><li><strong>codesandbox-browserfs</strong>: 这是一个浏览器端的‘文件系统’，模拟了 NodeJS 的文件系统 API，支持在本地或从多个后端服务中存储或获取文件.</li><li><strong>react-sandpack</strong>: codesandbox公开的SDK，可以用于自定义自己的codesandbox</li></ul></li></ul><p><a href="https://github.com/codesandbox/codesandbox-client" target="_blank" rel="noopener">源码在这</a></p><p><br></p><hr><p><br></p><h2 id="项目构建过程"><a href="#项目构建过程" class="headerlink" title="项目构建过程"></a>项目构建过程</h2><p><code>packager -&gt; transpilation -&gt; evaluation</code></p><p>Sandbox 构建分为三个阶段:</p><ul><li><strong>Packager</strong> 包加载阶段，下载和处理所有npm模块依赖</li><li><strong>Transpilation</strong> 转译阶段，转译所有变动的代码, 构建模块依赖图</li><li><strong>Evaluation</strong> 执行阶段，使用 <code>eval</code> 运行模块代码进行预览</li></ul><p>下面会按照上述的步骤来描述其中的技术点</p><p><br><br><br></p><h3 id="packager"><a href="#packager" class="headerlink" title="Packager"></a>Packager</h3><p>尽管 npm 是个’黑洞’，我们还是离不开它。 其实大概分析一下前端项目的 <code>node_modules</code>，80%是各种开发依赖组成的. </p><p>由于 CodeSandbox 已经包揽了代码构建的部分，所以我们并不需要<code>devDependencies</code>, 也就是说 <strong>在CodeSandbox 中我们只需要安装所有实际代码运行需要的依赖，这可以减少成百上千的依赖下载. 所以暂且不用担心浏览器会扛不住</strong>.</p><p><br></p><h4 id="webpackdllplugin"><a href="#webpackdllplugin" class="headerlink" title="WebpackDllPlugin"></a>WebpackDllPlugin</h4><p>CodeSandbox 的依赖打包方式受 <code>WebpackDllPlugin</code> 启发，DllPlugin 会将所有依赖都打包到一个<code>dll</code>文件中，并创建一个 <code>manifest</code> 文件来描述dll的元数据(如下图).</p><p>Webpack 转译时或者 运行时可以根据 manifest 中的模块索引(例如<code>__webpack_require__(&#39;../node_modules/react/index.js&#39;)</code>)来加载 dll 中的模块。 因为<code>WebpackDllPlugin</code>是在运行或转译之前预先对依赖的进行转译，所以在项目代码转译阶段可以忽略掉这部分依赖代码，这样可以提高构建的速度(真实场景对npm依赖进行Dll打包提速效果并不大):</p><center><br>  <img src="/images/08/dll.png"><br></center><p>manifest文件</p><center><br>  <img src="/images/08/webpack-dll-manifest.png" width="500"><br></center><p><br></p><h4 id="在线打包服务"><a href="#在线打包服务" class="headerlink" title="在线打包服务"></a>在线打包服务</h4><p>基于这个思想, CodeSandbox 构建了自己的在线打包服务, 和WebpackDllPlugin不一样的是，CodeSandbox是在服务端预先构建Manifest文件的, 而且不区分Dll和manifest文件。 具体思路如下:</p><center><br> <img src="/images/08/packager1.png" width="800"><br></center><p>简而言之，CodeSandbox 客户端拿到<code>package.json</code>之后，将<code>dependencies</code>转换为一个由依赖和版本号组成的<code>Combination</code>(标识符, 例如 <a href="https://d1jyvh0kxilfa7.cloudfront.net/v1/combinations/babel-runtime@7.3.1%2Bcsbbust@1.0.0%2Breact@16.8.4%2Breact-dom@16.8.4%2Breact-router@5.0.1%2Breact-router-dom@5.0.1%2Breact-split-pane@0.1.87.json" target="_blank" rel="noopener"><code>v1/combinations/babel-runtime@7.3.1&amp;csbbust@1.0.0&amp;react@16.8.4&amp;react-dom@16.8.4&amp;react-router@5.0.1&amp;react-router-dom@5.0.1&amp;react-split-pane@0.1.87.json</code></a>), 再拿这个 Combination 到服务器请求。服务器会根据 Combination 作为缓存键来缓存打包结果，如果没有命中缓存，则进行打包.</p><p><strong>打包实际上还是使用<code>yarn</code>来下载所有依赖，只不过这里为了剔除 npm 模块中多余的文件，服务端还遍历了所有依赖的入口文件(package.json#main), 解析 AST 中的 require 语句，递归解析被 require 模块. 最终形成一个依赖图, 只保留必要的文件</strong>. </p><p>最终输出 Manifest 文件，它的结构大概如下, 他就相当于WebpackDllPlugin的dll.js+manifest.json的结合体:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 模块内容</span></span><br><span class="line">  <span class="string">"contents"</span>: &#123;</span><br><span class="line">    <span class="string">"/node_modules/react/index.js"</span>: &#123;</span><br><span class="line">      <span class="string">"content"</span>: <span class="string">"'use strict';↵↵if ...."</span>, <span class="comment">// 代码内容</span></span><br><span class="line">      <span class="string">"requires"</span>: [                        <span class="comment">// 依赖的其他模块</span></span><br><span class="line">        <span class="string">"./cjs/react.development.js"</span>,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"/node_modules/react-dom/index.js"</span>: &#123;<span class="comment">/*..*/</span>&#125;,</span><br><span class="line">    <span class="string">"/node_modules/react/package.json"</span>: &#123;<span class="comment">/*...*/</span>&#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 模块具体安装版本号</span></span><br><span class="line">  <span class="string">"dependencies"</span>: [&#123;<span class="attr">name</span>: <span class="string">"@babel/runtime"</span>, <span class="attr">version</span>: <span class="string">"7.3.1"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"csbbust"</span>, <span class="attr">version</span>: <span class="string">"1.0.0"</span>&#125;,<span class="comment">/*…*/</span>],</span><br><span class="line">  <span class="comment">// 模块别名, 比如将react作为preact-compat的别名</span></span><br><span class="line">  <span class="string">"dependencyAliases"</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 依赖的依赖, 即间接依赖信息. 这些信息可以从yarn.lock获取</span></span><br><span class="line">  <span class="string">"dependencyDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"object-assign"</span>: &#123;</span><br><span class="line">      <span class="string">"entries"</span>: [<span class="string">"object-assign"</span>], <span class="comment">// 模块入口</span></span><br><span class="line">      <span class="string">"parents"</span>: [<span class="string">"react"</span>, <span class="string">"prop-types"</span>, <span class="string">"scheduler"</span>, <span class="string">"react-dom"</span>], <span class="comment">// 父模块</span></span><br><span class="line">      <span class="string">"resolved"</span>: <span class="string">"4.1.1"</span>,</span><br><span class="line">      <span class="string">"semver"</span>: <span class="string">"^4.1.1"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p><strong>Serverless 思想</strong><br><br><br>值得一提的是 CodeSandbox 的 Packager 后端使用了 Serverless(基于 AWS Lambda)，基于 Serverless 的架构让 Packager 服务更具伸缩性，可以灵活地应付高并发的场景。使用 Serverless 之后 Packager 的响应时间显著提高，而且费用也下去了。</p></blockquote><blockquote><p>Packager 也是开源的, <a href="https://github.com/codesandbox/dependency-packager" target="_blank" rel="noopener">围观</a></p></blockquote><p><br></p><h4 id="回退方案"><a href="#回退方案" class="headerlink" title="回退方案"></a>回退方案</h4><p>AWS Lambda函数是有局限性的, 比如<code>/tmp</code>最多只能有 500MB 的空间. 尽管大部分依赖打包场景不会超过这个限额, 为了增强可靠性(比如上述的方案可能出错，也可能漏掉一些模块), Packager还有回退方案.</p><p>后来CodeSanbox作者开发了新的Sandbox，支持把包管理的步骤放置到浏览器端, 和上面的打包方式结合着使用。原理也比较简单: <strong>在转译一个模块时，如果发现模块依赖的npm模块未找到，则惰性从远程下载回来</strong>. 来看看它是怎么处理的:</p><center><br> <img src="/images/08/packager2.png"><br></center><p>在回退方案中CodeSandbox 并不会将 package.json 中所有的包都下载下来，而是在模块查找失败时，惰性的去加载。比如在转译入口文件时，发现 react 这个模块没有在本地缓存模块队列中，这时候就会到远程将它下载回来，然后接着转译。</p><p>也就是说，因为在转译阶段会静态分析模块的依赖，只需要将真正依赖的文件下载回来，而不需要将整个npm包下载回来，节省了网络传输的成本.</p><p>CodeSandbox 通过 <code>unpkg.com</code> 或 <code>cdn.jsdelivr.net</code> 来获取模块的信息以及下载文件, 例如</p><ul><li>获取 package.json: <code>https://unpkg.com/react@latest/package.json</code></li><li>包目录结构获取: <code>https://unpkg.com/antd@3.17.0/?meta</code> 这个会递归返回该包的所有目录信息</li><li>具体文件下载: <code>https://unpkg.com/react@16.8.6/cjs/react.production.min.js</code> 或者 <code>https://cdn.jsdelivr.net/npm/@babel/runtime@7.3.1/helpers/interopRequireDefault.js</code></li></ul><p><br></p><hr><p><br></p><h3 id="transpilation"><a href="#transpilation" class="headerlink" title="Transpilation"></a>Transpilation</h3><p>讲完 Packager 现在来看一下 Transpilation, 这个阶段<strong>从应用的入口文件开始, 对源代码进行转译, 解析AST，找出下级依赖模块，然后递归转译，最终形成一个’依赖图’</strong>:</p><center><br>  <img src="/images/08/transpile-dependency-graph.png"><br></center><p>CodeSandbox 的整个转译器是在一个单独的 iframe 中运行的：</p><center><br>  <img src="/images/08/editor-vs-compiler.png"><br></center><p>Editor 负责变更源代码，源代码变更会通过 postmessage 传递给 Compiler，这里面会携带 <code>Module+template</code></p><ul><li><strong>Module</strong> 中包含所有源代码内容和模块路径，其中还包含 package.json, Compiler 会根据 package.json 来读取 npm 依赖;</li><li><strong>template</strong> 表示 Compiler 的 Preset，例如<code>create-react-app</code>、<code>vue-cli</code>, 定义了一些 loader 规则，用来转译不同类型的文件, 另外preset也决定了应用的模板和入口文件。 通过上文我们知道, 这些 template 目前的预定义的.</li></ul><p><br></p><h4 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h4><p>在详细介绍 Transpilation 之前先大概看一些基本对象，了解这些对象之间的关系：</p><center><br> <img src="/images/08/baseobj.png"><br></center><ul><li><strong>Manager</strong> 这是 Sandbox 的核心对象，负责管理配置信息(Preset)、项目依赖(Manifest)、以及维护项目所有模块(TranspilerModule)</li><li><strong>Manifest</strong> 通过上文的 Packager 我们知道，Manifest 维护所有依赖的 npm 模块信息</li><li><strong>TranspiledModule</strong> 表示模块本身。这里面维护转译的结果、代码执行的结果、依赖的模块信息，负责驱动具体模块的转译(调用 Transpiler)和执行</li><li><strong>Preset</strong> 一个项目构建模板，例如 <code>vue-cli</code>、<code>create-react-app</code>. 配置了项目文件的转译规则, 以及应用的目录结构(入口文件)</li><li><strong>Transpiler</strong> 等价于 Webpack 的 loader，负责对指定类型的文件进行转译。例如 babel、typescript、pug、sass 等等</li><li><strong>WorkerTranspiler</strong> 这是 Transpiler 的子类，调度一个 Worker池来执行转译任务，从而提高转译的性能</li></ul><p><br></p><h4 id="manager"><a href="#manager" class="headerlink" title="Manager"></a>Manager</h4><p>Manager是一个管理者的角色，从大局上把控整个转译和执行的流程. 现在来看看整体的转译流程：</p><center><br> <img src="/images/08/compiler.png"><br></center><p>大局上基本上可以划分为以下四个阶段:</p><ul><li><strong>配置阶段</strong>：配置阶段会创建 Preset 对象，确定入口文件等等. CodeSandbox 目前只支持限定的几种应用模板，例如 vue-cli、create-react-app。不同模板之间目录结构的约定是不一样的，例如入口文件和 html 模板文件。另外文件处理的规则也不一样，比如 vue-cli 需要处理<code>.vue</code>文件。</li><li><strong>依赖下载阶段</strong>： 即 Packager 阶段，下载项目的所有依赖，生成 Manifest 对象</li><li><strong>变动计算阶段</strong>：根据 Editor 传递过来的源代码，计算新增、更新、移除的模块。</li><li><strong>转译阶段</strong>：真正开始转译了，首先重新转译上个阶段计算出来的需要更新的模块。接着从入口文件作为出发点，转译和构建新的依赖图。这里不会重复转译没有变化的模块以及其子模块</li></ul><p><br><br><br></p><h4 id="transpiledmodule"><a href="#transpiledmodule" class="headerlink" title="TranspiledModule"></a>TranspiledModule</h4><p>TranspiledModule用于管理某个具体的模块，这里面会维护转译和运行的结果、模块的依赖信息，并驱动模块的转译和执行：</p><center><br> <img src="/images/08/transpiled-module.png"><br></center><p>TranspiledModule 会从Preset中获取匹配当前模块的Transpiler列表的，遍历Transpiler对源代码进行转译，转译的过程中会解析AST，分析模块导入语句, 收集新的依赖; 当模块转译完成后，会递归转译依赖列表。 来看看大概的代码：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> transpile(manager: Manager) &#123;</span><br><span class="line">  <span class="comment">// 已转译</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.source)  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 避免重复转译, 一个模块只转译一次</span></span><br><span class="line">  <span class="keyword">if</span> (manager.transpileJobs[<span class="keyword">this</span>.getId()]) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  manager.transpileJobs[<span class="keyword">this</span>.getId()] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...重置状态 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴从Preset获取Transpiler列表</span></span><br><span class="line">  <span class="keyword">const</span> transpilers = manager.preset.getLoaders(<span class="keyword">this</span>.module, <span class="keyword">this</span>.query);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 链式调用Transpiler</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; transpilers.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> transpilerConfig = transpilers[i];</span><br><span class="line">    <span class="comment">// 🔴构建LoaderContext，见下文</span></span><br><span class="line">    <span class="keyword">const</span> loaderContext = <span class="keyword">this</span>.getLoaderContext(</span><br><span class="line">      manager,</span><br><span class="line">      transpilerConfig.options || &#123;&#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔴调用Transpiler转译源代码</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      transpiledCode,</span><br><span class="line">      sourceMap,</span><br><span class="line">    &#125; = <span class="keyword">await</span> transpilerConfig.transpiler.transpile(code, loaderContext); <span class="comment">// eslint-disable-line no-await-in-loop</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.errors.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">this</span>.errors[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.logWarnings();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    <span class="keyword">this</span>.asyncDependencies.map(<span class="keyword">async</span> p =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> tModule = <span class="keyword">await</span> p;</span><br><span class="line">        <span class="keyword">this</span>.dependencies.add(tModule);</span><br><span class="line">        tModule.initiators.add(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">/* let this handle at evaluation */</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">this</span>.asyncDependencies = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴递归转译依赖的模块</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    flattenDeep([</span><br><span class="line">      ...Array.from(<span class="keyword">this</span>.transpilationInitiators).map(<span class="function"><span class="params">t</span> =&gt;</span></span><br><span class="line">        t.transpile(manager)</span><br><span class="line">      ),</span><br><span class="line">      ...Array.from(<span class="keyword">this</span>.dependencies).map(<span class="function"><span class="params">t</span> =&gt;</span> t.transpile(manager)),</span><br><span class="line">    ])</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="transpiler"><a href="#transpiler" class="headerlink" title="Transpiler"></a>Transpiler</h4><p>Transpiler等价于webpack的loader，它配置方式以及基本API也和webpack(查看<a href="https://webpack.docschina.org/api/loaders/" target="_blank" rel="noopener">webpack的loader API</a>)大概保持一致，比如链式转译和loader-context. 来看一下Transpiler的基本定义：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Transpiler &#123;</span><br><span class="line">  initialize() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  dispose() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  cleanModule(loaderContext: LoaderContext) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 代码转换</span></span><br><span class="line">  transpile(</span><br><span class="line">    code: <span class="built_in">string</span>,</span><br><span class="line">    loaderContext: LoaderContext</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;TranspilerResult&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doTranspilation(code, loaderContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 抽象方法，由具体子类实现</span></span><br><span class="line">  <span class="keyword">abstract</span> doTranspilation(</span><br><span class="line">    code: <span class="built_in">string</span>,</span><br><span class="line">    loaderContext: LoaderContext</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;TranspilerResult&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Transpiler的接口很简单，<code>transpile</code>接受两个参数: </p><ul><li><code>code</code>即源代码.</li><li><p><code>loaderContext</code> 由TranspiledModule提供, 可以用来访问一下转译上下文信息，比如Transpiler的配置、 模块查找、注册依赖等等。大概外形如下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> LoaderContext = &#123;</span><br><span class="line">  <span class="comment">// 🔴 信息报告</span></span><br><span class="line">  emitWarning: <span class="function">(<span class="params">warning: WarningStructure</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  emitError: <span class="function">(<span class="params">error: <span class="built_in">Error</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  emitModule: <span class="function">(<span class="params">title: <span class="built_in">string</span>, code: <span class="built_in">string</span>, currentPath?: <span class="built_in">string</span>, overwrite?: <span class="built_in">boolean</span>, isChild?: <span class="built_in">boolean</span></span>) =&gt;</span> TranspiledModule;</span><br><span class="line">  emitFile: <span class="function">(<span class="params">name: <span class="built_in">string</span>, content: <span class="built_in">string</span>, sourceMap: SourceMap</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 🔴 配置信息</span></span><br><span class="line">  options: &#123;</span><br><span class="line">    context: <span class="built_in">string</span>;</span><br><span class="line">    config?: object;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  sourceMap: <span class="built_in">boolean</span>;</span><br><span class="line">  target: <span class="built_in">string</span>;</span><br><span class="line">  path: <span class="built_in">string</span>;</span><br><span class="line">  addTranspilationDependency: <span class="function">(<span class="params">depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; isEntry?: <span class="built_in">boolean</span>; &#125;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  resolveTranspiledModule: <span class="function">(<span class="params"> depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; ignoredExtensions?: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;; &#125;</span>) =&gt;</span> TranspiledModule;</span><br><span class="line">  resolveTranspiledModuleAsync: <span class="function">(<span class="params"> depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; ignoredExtensions?: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;; &#125;</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;TranspiledModule&gt;;</span><br><span class="line">   <span class="comment">// 🔴 依赖收集</span></span><br><span class="line">  addDependency: <span class="function">(<span class="params"> depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; isEntry?: <span class="built_in">boolean</span>; &#125;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  addDependenciesInDirectory: <span class="function">(<span class="params"> depPath: <span class="built_in">string</span>, options?: &#123; isAbsolute?: <span class="built_in">boolean</span>; isEntry?: <span class="built_in">boolean</span>; &#125;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  _module: TranspiledModule;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><p>先从简单的开始，来看看JSON模块的Transpiler实现, 每个Transpiler子类需要实现doTranspilation，接收源代码，并异步返回处理结果：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> JSONTranspiler <span class="keyword">extends</span> Transpiler &#123;</span><br><span class="line">  doTranspilation(code: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">      module.exports = JSON.parse(<span class="subst">$&#123;JSON.stringify(code || '')&#125;</span>)</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">      transpiledCode: result,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="babeltranspiler"><a href="#babeltranspiler" class="headerlink" title="BabelTranspiler"></a>BabelTranspiler</h4><p>并不是所有模块都像JSON这么简单，比如Typescript和Babel。 为了提高转译的效率，Codesandbox会利用Worker来进行多进程转译，多Worker的调度工作由<code>WorkerTranspiler</code>完成，这是Transpiler的子类，维护了一个Worker池。Babel、Typescript、Sass这类复杂的转译任务都是基于WorkerTranspiler实现的：</p><center><br> <img src="/images/08/transpiler.png"><br></center><p><br></p><p>其中比较典型的实现是BabelTranspiler, 在Sandbox启动时就会预先fork三个worker，来提高转译启动的速度, BabelTranspiler会优先使用这三个worker来初始化Worker池：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用worker-loader fork三个loader，用于处理babel编译</span></span><br><span class="line"><span class="keyword">import</span> BabelWorker <span class="keyword">from</span> <span class="string">'worker-loader?publicPath=/&amp;name=babel-transpiler.[hash:8].worker.js!./eval/transpilers/babel/worker/index.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.babelworkers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">window</span>.babelworkers.push(<span class="keyword">new</span> BabelWorker());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>这里面使用到了webpack的<a href="https://github.com/webpack-contrib/worker-loader" target="_blank" rel="noopener">worker-loader</a>, 将指定模块封装为 Worker 对象。让 Worker 更容易使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> Worker <span class="keyword">from</span> <span class="string">"./file.worker.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">worker.postMessage(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">worker.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>BabelTranpiler具体的流程如下:</p><center><br><img src="/images/08/babel-transpiler.png"><br></center><p>WorkerTranspiler会维护<code>空闲的Worker队列</code>和一个<code>任务队列</code>, 它的工作就是驱动Worker来消费任务队列。具体的转译工作在Worker中进行：</p><center><br><img src="/images/08/babel-worker.png"><br></center><p><br></p><hr><p><br></p><h3 id="evaluation"><a href="#evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>虽然称为打包器(bundler), 但是 CodeSandbox 并不会进行打包，也就是说他不会像 Webpack 一样，将所有的模块都打包合并成 chunks 文件.</p><p><code>Transpilation</code>从<code>入口文件</code>开始转译, 再分析文件的模块导入规则，递归转译依赖的模块. 到<code>Evaluation</code>阶段，CodeSandbox 已经构建出了一个完整的<strong>依赖图</strong>. 现在要把应用跑起来了🏃</p><p><img src="/images/08/dependency-graph.png" alt></p><p>Evaluation 的原理也比较简单，和 Transpilation 一样，也是从入口文件开始: <strong>使用<code>eval</code>执行入口文件，如果执行过程中调用了<code>require</code>，则递归 eval 被依赖的模块</strong>。</p><p>如果你了解过 Node 的模块导入原理，你可以很容易理解这个过程：</p><p><img src="/images/08/evaluation.png" alt></p><ul><li>① 首先要初始化 html，找到<code>index.html</code>文件，将 document.body.innerHTML 设置为 html 模板的 body 内容.</li><li>② 注入外部资源。用户可以自定义一些外部静态文件，例如 css 和 js，这些需要 append 到 head 中</li><li>③ evaluate 入口模块</li><li><p>④ 所有模块都会被转译成 CommonJS 模块规范。所以需要模拟这个模块环境。大概看一下代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现require方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... 拦截一些特殊模块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Manager对象中查找模块</span></span><br><span class="line">  <span class="keyword">const</span> requiredTranspiledModule = manager.resolveTranspiledModule(</span><br><span class="line">    path,</span><br><span class="line">    localModule.path</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块缓存, 如果存在缓存则说明不需要重新执行</span></span><br><span class="line">  <span class="keyword">const</span> cache = requiredTranspiledModule.compilation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache</span><br><span class="line">    ? cache.exports</span><br><span class="line">    : <span class="comment">// 🔴递归evaluate</span></span><br><span class="line">      manager.evaluateTranspiledModule(</span><br><span class="line">        requiredTranspiledModule,</span><br><span class="line">        transpiledModule</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现require.resolve</span></span><br><span class="line"><span class="built_in">require</span>.resolve = <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> manager.resolveModule(path, localModule.path).path;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一些全局变量</span></span><br><span class="line"><span class="keyword">const</span> globals = &#123;&#125;;</span><br><span class="line">globals.__dirname = pathUtils.dirname(<span class="keyword">this</span>.module.path);</span><br><span class="line">globals.__filename = <span class="keyword">this</span>.module.path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴放置执行结果，即CommonJS的module对象</span></span><br><span class="line"><span class="keyword">this</span>.compilation = &#123;</span><br><span class="line">  id: <span class="keyword">this</span>.getId(),</span><br><span class="line">  exports: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴eval</span></span><br><span class="line"><span class="keyword">const</span> exports = evaluate(</span><br><span class="line">  <span class="keyword">this</span>.source.compiledCode,</span><br><span class="line">  <span class="built_in">require</span>,</span><br><span class="line">  <span class="keyword">this</span>.compilation,</span><br><span class="line">  manager.envVariables,</span><br><span class="line">  globals</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>⑤ 使用 eval 来执行模块。同样看看代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">code, require, module, env = &#123;&#125;, globals = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> exports = <span class="built_in">module</span>.exports;</span><br><span class="line">  <span class="keyword">const</span> global = g;</span><br><span class="line">  <span class="keyword">const</span> process = buildProcess(env);</span><br><span class="line">  g.global = global;</span><br><span class="line">  <span class="keyword">const</span> allGlobals = &#123;</span><br><span class="line">    <span class="built_in">require</span>,</span><br><span class="line">    <span class="built_in">module</span>,</span><br><span class="line">    exports,</span><br><span class="line">    process,</span><br><span class="line">    setImmediate: requestFrame,</span><br><span class="line">    global,</span><br><span class="line">    ...globals</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allGlobalKeys = <span class="built_in">Object</span>.keys(allGlobals);</span><br><span class="line">  <span class="keyword">const</span> globalsCode = allGlobalKeys.length ? allGlobalKeys.join(<span class="string">", "</span>) : <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">const</span> globalsValues = allGlobalKeys.map(<span class="function"><span class="params">k</span> =&gt;</span> allGlobals[k]);</span><br><span class="line">  <span class="comment">// 🔴将代码封装到一个函数下面，全局变量以函数形式传入</span></span><br><span class="line">  <span class="keyword">const</span> newCode = <span class="string">`(function evaluate(`</span> + globalsCode + <span class="string">`) &#123;`</span> + code + <span class="string">`\n&#125;)`</span>;</span><br><span class="line">  (<span class="number">0</span>, <span class="built_in">eval</span>)(newCode).apply(<span class="keyword">this</span>, globalsValues);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Ok！到这里 Evaluation 就解释完了，实际的代码比这里要复杂得多，比如 HMR(hot module replacement)支持, 有兴趣的读者，可以自己去看 CodeSandbox 的源码.</p><p><br></p><hr><p><br></p><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><p>一不小心又写了一篇长文，要把这么复杂代码讲清楚真是一个挑战, 我还做的不够好，按照以往的经验，这又是一篇无人问津的文章, 别说是你们, 我自己都不怎么有耐心看这类文章, 后面还是尽量避免吧!</p><ul><li>worker-loader: 将指定模块封装为Worker</li><li>babel: JavaScript代码转译，支持ES, Flow, Typescript</li><li>browserfs: 在浏览器中模拟Node环境</li><li>localForage: 客户端存储库，优先使用(IndexedDB or WebSQL)这些异步存储方案，提供类LocalStorage的接口</li><li>lru-cache: least-recently-used缓存</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://hackernoon.com/how-i-created-a-parallel-offline-extensible-browser-based-bundler-886db508cc31" target="_blank" rel="noopener">Creating a parallel, offline, extensible, browser based bundler for CodeSandbox</a></li><li><a href="https://www.youtube.com/watch?v=qURPenhndYA" target="_blank" rel="noopener">year of CodeSandbox - Ives van Hoorne aka @CompuIves at @ReactEurope 2018</a></li><li><a href="https://hackernoon.com/how-we-make-npm-packages-work-in-the-browser-announcing-the-new-packager-6ce16aa4cee6" target="_blank" rel="noopener">How we make npm packages work in the browser</a></li><li><a href="https://github.com/codesandbox/dependency-packager" target="_blank" rel="noopener">codesandbox/dependency-packager</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这期来关注一下&lt;a href=&quot;https://codesandbox.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;CodeSandbox&lt;/code&gt;&lt;/a&gt;, 这是一个浏览器端的沙盒运行环境，支持多种流行的构建模板，例如 &lt;code
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React性能测量和分析</title>
    <link href="https://bobi.ink/2019/06/16/react-performance-analyze/"/>
    <id>https://bobi.ink/2019/06/16/react-performance-analyze/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T23:00:08.422Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">文章</a>讲了 React 性能优化的一些方向和手段，这篇文章再补充说一下如何进行性能测量和分析, 介绍 React 性能分析的一些工具和方法.</p><p>进行任何性能优化的前提是你要找出’性能问题‘，这样才能针对性地进行优化。我觉得对于 React 的性能优化可以分两个阶段:</p><ul><li><p><strong>1. 分析阶段</strong></p><ul><li>通过分析器(Profiler)找出重新渲染的组件、重新渲染的次数、以及重新渲染耗费的资源与时间</li><li>变动检测. 通过分析器我们可以知道’什么被重新渲染, 重新渲染的代价’，那么变动检测回答的问题就是： ’为什么这些进行了重新渲染?’</li></ul></li><li><p><strong>2. 优化阶段</strong>. 优化阶段我们针对分析阶段抛出的问题进行解决，解决的方法有很多，可以参考本文的姊妹篇&lt;<a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">浅谈React性能优化的方向</a>&gt;</p></li></ul><p><br></p><p><strong>本文大纲</strong></p><!-- TOC --><ul><li><a href="#分析器">分析器</a><ul><li><a href="#react-devtool">React Devtool</a><ul><li><a href="#高亮更新">高亮更新</a></li><li><a href="#分析器-1">分析器</a></li></ul></li><li><a href="#chrome-performance-工具">Chrome Performance 工具</a></li><li><a href="#其他工具">其他工具</a></li></ul></li><li><a href="#变动检测">变动检测</a><ul><li><a href="#props-变动检测">props 变动检测</a></li><li><a href="#mobx-变动检测">mobx 变动检测</a></li><li><a href="#context-变更检测">Context 变更检测</a></li><li><a href="#react-devtool-的-interactions">React Devtool 的 Interactions</a></li></ul></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><p>下面本文测试的样板代码.</p><blockquote><p>推荐点击 Preview 面板的<code>Open In New Window</code>, 或者直接点击该<a href="https://igz9h.codesandbox.io/" target="_blank" rel="noopener">链接</a>，在线动手实践</p></blockquote><iframe src="https://codesandbox.io/embed/react-performance-analyze-demo-igz9h?autoresize=1&fontsize=14" title="React-Performance-Analyze-Demo" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p><a href="https://codesandbox.io/s/react-performance-analyze-demo-igz9h?fontsize=14" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit React-Performance-Analyze-Demo"></a></p><p><br><br><br></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>分析哪些组件进行了渲染，以及渲染消耗的时间以及资源。主要工具有 React 官方的开发者工具以及 Chrome 的 Performance 工具。</p><h3 id="react-devtool"><a href="#react-devtool" class="headerlink" title="React Devtool"></a>React Devtool</h3><p>最先应该使用的肯定是官方提供的开发者工具，React v16.5 引入了新的 Profiler 功能，让分析组件渲染过程变得更加简单，而且可以很直观地查看哪些组件被渲染.</p><h4 id="高亮更新"><a href="#高亮更新" class="headerlink" title="高亮更新"></a>高亮更新</h4><p><strong>首先最简单也是最方便的判断组件是否被重新渲染的方式是’高亮更新(Hightlight Updates)’</strong>.</p><p>① 开启高亮更新:</p><center><br> <img src="/images/10/hightlight-update.png"><br></center><p>② 运行效果如下:</p><center><br>  <img src="/images/10/hightlight-update.gif"><br></center><p>③ 通过高亮更新，基本上可以确定哪些组件被重新渲染. 所以现在我们给 ListItem 加上 React.memo(查看 PureList 示例), 看一下效果:</p><center><br> <img src="/images/10/hightlight-update-pure.gif"><br></center><p>效果非常明显，现在只有递增的 ListItem 会被更新，而且当数组排序时只有 List 组件会被刷新. 所以说‘纯组件’是 React 优化的第一张牌, 也是最有效的一张牌.</p><p><br><br><br></p><h4 id="分析器-1"><a href="#分析器-1" class="headerlink" title="分析器"></a>分析器</h4><p>如果<code>高亮更新</code>无法满足你的需求，比如<strong>你需要知道具体哪些组件被渲染、渲染消耗多少时间、进行了多少次的提交(渲染)等等</strong>, 这时候就需要用到分析器了.</p><p>① 首先选择需要收集测量信息的节点(一般默认选中根节点，有一些应用可能存在多个组件树，这时候需要手动选择):</p><center><br> <img src="/images/10/select-profile.png"><br></center><p>② Ok，点击 Record 开始测量</p><center><br> <img src="/images/10/start-record.gif"><br></center><p><br></p><p>③ 看看测量的结果，先来了解一下 Profiler 面板的基本结构:</p><center><br> <img src="/images/10/profile-outline.png"><br></center><ul><li><p><strong>1️⃣ 这是一个 commit 列表</strong>。commit 列表表示录制期间发生的 commit(可以认为是渲染) 操作，要理解 commit 的意思还需要了解 React 渲染的基本原理.</p><p>在 v16 后 React 组件渲染会分为两个阶段，即 render 和 commit 阶段。</p><ul><li><strong>render 阶段决定需要进行哪些变更，比如 DOM</strong>。顾名思义, 这个阶段 React 会调用 render 函数，并将结果和上一次 render 的结果进行 diff, 计算出需要进行变更的操作队列</li><li><strong>commit 阶段</strong>。或者称为提交阶段, 在这个阶段会执行 render 阶段 diff 出来的变更请求。比如 DOM 插入、更新、删除、排序等等。在这个阶段 React 还会调用 componentDidMount 和 componentDidUpdate 生命周期函数.</li></ul><p>在 v16 之前，或者在 Preact 这些’类 React’ 框架中，并不区分 render 阶段和 commit 阶段，也就说这两个阶段糅合在一起，一边 diff 一边 commit。有兴趣的读者可以看笔者之前写的<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">从 Preact 中了解组件和 hooks 基本原理</a><br><br></p><p>切换 commit:</p><p><img src="/images/10/profile-commit.gif" alt><br><br></p></li><li><p><strong>2️⃣ 选择其他图形展示形式</strong>，例如 <code>Ranked 视图</code>，这个视图按照渲染消耗时间对组件进行排序：</p><p><img src="/images/10/ranked.png" alt></p><p><br></p></li><li><p><strong>3️⃣ 火焰图</strong> 这个图其实就是<strong>组件树</strong>，Profiler 使用颜色来标记哪些组件被重新渲染。<strong>和 commit 列表以及 Ranked 图一样，颜色在这里是有意义的，比如灰色表示没有重新渲染；从渲染消耗的时间上看的话: <code>黑色 &gt; 黄色 &gt; 蓝色</code>, 通过 👆Ranked 图可以直观感受到不同颜色之间的意义</strong></p><p><img src="/images/10/profile-framegraph.gif" alt></p><p><br></p></li><li><p><strong>4️⃣ 当前选中组件或者 Commit 的详情</strong>, 可以查看该组件渲染时的 props 和 state</p><p><img src="/images/10/profile-props.gif" alt></p><p>双击具体组件可以详细比对每一次 commit 消耗的时间:</p><p><img src="/images/10/profile-component-detail.png" alt></p><p><br></p></li><li><p><strong>5️⃣ 设置</strong></p><p>另外可以通过设置，筛选 Commit，以及是否显示原生元素:</p><p><img src="/images/10/profile-settings.png" alt></p></li></ul><p><br></p><p>④ 现在使用 Profiler 来分析一下 PureList 的渲染过程:</p><p><img src="/images/10/profile-demo.png" alt></p><p><br></p><blockquote><p>关于 Profiler 的详细介绍可以看这篇官方博客&lt;<a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">Introducing the React Profiler</a>&gt;</p></blockquote><p><br><br><br></p><h3 id="chrome-performance-工具"><a href="#chrome-performance-工具" class="headerlink" title="Chrome Performance 工具"></a>Chrome Performance 工具</h3><p>在 v16.5 之前，我们一般都是利用 Chrome 自带的 Performance 来进行 React 性能测量:</p><p><img src="/images/10/chrome-performance.png" alt></p><p><br></p><p>React 使用标准的<code>User Timing API</code>(所有支持该标准的浏览器都可以用来分析 React)来记录操作，所以我们在 Timings 标签中查看 React 的渲染过程。React 还特意使用 emoji 标记.</p><p>相对 React Devtool 而言 Performance 工具可能还不够直观，但是它非常强大，举个例子，<strong>如果说 React-Devtool 是<a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a>, 那么 Performance 就是<a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a>. 使用 Performance 可以用来定位一些比较深层次的问题，这可能需要你对 React 的实现原理有一定了解, 就像使用 Wireshark 你需要懂点网络协议一样</strong></p><p>所以说使用 Performance 工具有以下优势:</p><ul><li>可以测量分析整个渲染的过程细节. 它可以定位某些具体方法的调用过程和消耗, 方便定位一些深层次问题.</li><li>可以测量分析底层 DOM 的绘制、布局、合成等细节。方便定位浏览器性能问题</li></ul><p>其实 Performance 是一个通用的性能检测工具，所以其细节不在本文讨论访问。 详细参考</p><ul><li><a href="https://calibreapp.com/blog/react-performance-profiling-optimization/" target="_blank" rel="noopener">Profiling React performance with React 16 and Chrome Devtools</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Chrome 官方的 Performance 使用文档</a></li></ul><p><br></p><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><p>上面介绍的这些工具基本上已经够用了。社区上还有一些比较流行的工具，不过这些工具迟早/已经要被官方取代(招安)，而且它们也跟不上 React 的更新。</p><ul><li><a href="https://reactjs.org/docs/perf.html" target="_blank" rel="noopener">react-addons-perf</a> React v16 不支持了，不说了。老版本可用</li><li><a href="https://github.com/nitin42/react-perf-devtool" target="_blank" rel="noopener">react-perf-devtool</a> 也不活跃了，不推荐使用</li></ul><p><br></p><hr><p><br></p><h2 id="变动检测"><a href="#变动检测" class="headerlink" title="变动检测"></a>变动检测</h2><p>OK, 我们通过分析工具已经知道我们的应用存在哪些问题了，诊断出了哪些组件被无意义的渲染。下一步操作就是找出组件重新渲染的元凶, 检测为什么组件进行了更新.</p><p><strong>我们先假设我们的组件是一个’纯组件‘，也就是说我们认为只有组件依赖的状态变更时，组件才会重新渲染</strong>. 非纯组件没有讨论的意义，因为只要状态变更或父级变更他都会重新渲染。</p><p><strong>那么对于一个’纯组件‘来说，一般会有下面这些因素都可能导致组件重新渲染</strong>:</p><ul><li><strong>props + state</strong> 毫无疑问. 这里我们只需要关注<strong>来源于外部的 props</strong>. 内部 state 变动一般是人为触发的，比较容易发现</li><li><strong>Mobx observable value</strong>. 如果访问了 mobx 传进来的响应式数据，就会建立一个状态依赖关系，这个相对于 props 和 context 来说是隐式的，检测它的变动我们可能需要利用 mobx 提供的一些工具</li><li><strong>Context</strong>。 Context 的 value 的变更会强制重新渲染组件</li></ul><p><br></p><h3 id="props-变动检测"><a href="#props-变动检测" class="headerlink" title="props 变动检测"></a>props 变动检测</h3><p>在上一篇文章中我就建议简化 props，简单组件的 props 的变更很容易预测, 甚至你肉眼都可以察觉出来。另外如果你使用 Redux，如果严格按照 Redux 的最佳实践，配合 Redux 的开发者工具，也可以很直观地判断哪些状态发生了变更。</p><p>如果你没办法满足以上条件，可能就得依赖工具了。之前有一个<a href="https://github.com/maicki/why-did-you-update" target="_blank" rel="noopener">why-did-you-update</a>的库，<strong>很可惜现在已经没怎么维护了(旧版本可以使用它)</strong>。这个库使用猴补丁(monkey patches)来扩展 React，比对检测哪些 props 和 state 发生了变化：</p><p><img src="/images/10/wdyu.png" alt></p><p>后面也有人借鉴 why-did-you-update 写了个<a href="https://github.com/welldone-software/why-did-you-render" target="_blank" rel="noopener">why-did-you-render</a>. 不过笔者还是不看好这些通过猴补丁扩展 React 的实现，依赖于 React 的内部实现细节，维护成本太高了，跟不上 React 更新基本就废了.</p><p>如果你现在使用 hook 的话，自己手写一个也很简单, 这个 idea 来源于<a href="https://github.com/devhubapp/devhub/blob/master/packages/components/src/hooks/use-why-did-you-update.ts" target="_blank" rel="noopener">use-why-did-you-update</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useWhyDidYouUpdate</span>(<span class="params">name: <span class="built_in">string</span>, props: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️保存上一个props</span></span><br><span class="line">  <span class="keyword">const</span> latestProps = useRef(props);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> allKeys = <span class="built_in">Object</span>.keys(&#123; ...latestProps.current, ...props &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changesObj: Record&lt;<span class="built_in">string</span>, &#123; <span class="keyword">from</span>: <span class="built_in">any</span>; to: <span class="built_in">any</span> &#125;&gt; = &#123;&#125;;</span><br><span class="line">    allKeys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (latestProps.current[key] !== props[key]) &#123;</span><br><span class="line">        changesObj[key] = &#123; <span class="keyword">from</span>: latestProps.current[key], to: props[key] &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(changesObj).length) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[why-did-you-update]'</span>, name, changesObj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他原因导致组件渲染</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latestProps.current = props;</span><br><span class="line">  &#125;, <span class="built_in">Object</span>.values(props));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter = React.memo(props =&gt; &#123;</span><br><span class="line">  useWhyDidYouUpdate(&apos;Counter&apos;, props);</span><br><span class="line">  return &lt;div style=&#123;props.style&#125;&gt;&#123;props.count&#125;&lt;/div&gt;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果是类组件，可以在<code>componentDidUpdate</code>使用类似上面的方式来比较 props</p><p><br></p><h3 id="mobx-变动检测"><a href="#mobx-变动检测" class="headerlink" title="mobx 变动检测"></a>mobx 变动检测</h3><p>排除了 props 变更导致的重新渲染，现在来看看是否是 mobx 响应式数据导致的变更. 如果你们团队不使用 mobx，可以跳过这一节。</p><p><strong>首先不管是 Redux 和 Mobx，我们都应该让状态的变动变得可预测</strong>. 因为 Mobx 没有 Redux 那样固化的数据变更模式，Mobx 并不容易自动化地监测数据是如何被变更的。在 mobx 中我们使用<code>@action</code> 来标志状态的变更操作，但是它拿异步操作没办法。好在后面 mobx 推出了 <code>flow</code> API👏。</p><p>对于 Mobx 首先建议开启严格模式, 要求所有数据变更都放在@action 或 flow 中:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line">configure(&#123; <span class="attr">enforceActions</span>: <span class="string">'always'</span> &#125;);</span><br></pre></td></tr></table></figure><p>定义状态变更操作</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, action, flow &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterStore</span> </span>&#123;</span><br><span class="line">  @observable count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步操作</span></span><br><span class="line">  @action(<span class="string">'increment count'</span>)</span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">  <span class="comment">// 这是一个生成器，类似于saga的机制</span></span><br><span class="line">  fetchCount = flow(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="keyword">yield</span> getCount();</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok 有了上面的约定，现在可以在控制台(通过 mobx-logger)或者 <a href="https://github.com/mobxjs/mobx-devtools" target="_blank" rel="noopener">Mobx 开发者工具</a>中跟踪 Mobx 响应式数据的变动了。</p><p><img src="/images/10/mobx-devtool.png" alt></p><p><br></p><p>如果不按照规范来，出现问题会比较浪费时间, 但也不是没办法解决。Mobx 还提供了一个<a href="https://mobx.js.org/best/trace.html" target="_blank" rel="noopener">trace</a>函数, 用来检测为什么会执行 SideEffect:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ListItem = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; item, onShiftDown &#125; = props;</span><br><span class="line">  trace();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"list-item"</span>&gt;</span>&#123;/*...*/&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行效果(递增了 value 值):</p><p><img src="/images/10/mobx-trace.png" alt="mobx-trace"></p><p><br></p><h3 id="context-变更检测"><a href="#context-变更检测" class="headerlink" title="Context 变更检测"></a>Context 变更检测</h3><p>Ok, 如果排除了 props 和 mobx 数据变更还会重新渲染，那么 100%是 Context 导致的，因为一旦 Context 数据变动，组件就会被强制渲染。笔者在<a href="https://juejin.im/post/5d045350f265da1b695d5bf2#heading-14" target="_blank" rel="noopener">浅谈 React 性能优化的方向</a>提到了 ContextAPI 的一些陷阱。先排除一下是否是这些原因导致的.</p><p>现在并没有合适的跟踪 context 变动的机制，我们可以采取像上文的<code>useWhyDidYouUpdate</code>一样的方式来比对 Context 的值：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useIsContextUpdate</span>(<span class="params">contexts: object = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> latestContexts = useRef(contexts);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> changedContexts: string[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> contexts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (contexts[key] !== latestContexts.current[key]) &#123;</span><br><span class="line">        changedContexts.push(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changedContexts.length) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`[is-context-update]: <span class="subst">$&#123;changedContexts.join(<span class="string">', '</span>)&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latestContexts.current = contexts;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = useRouter();</span><br><span class="line"><span class="keyword">const</span> myContext = useContext(MyContext);</span><br><span class="line"></span><br><span class="line">useIsContextUpdate(&#123;</span><br><span class="line">  router,</span><br><span class="line">  myContext,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="react-devtool-的-interactions"><a href="#react-devtool-的-interactions" class="headerlink" title="React Devtool 的 Interactions"></a>React Devtool 的 Interactions</h3><p>这是 React Devtool 的一个实验性功能，Interactions 翻译为中文是‘交互’？这个东西目的其实就是为了跟踪‘什么导致了更新’，也就是我们上面说的变动检测。React希望提供一个通用的API给开发者或第三方工具，方便开发者直观地定位更新的原因:</p><p><img src="/images/10/interaction.png" alt></p><p>上图表示在记录期间跟踪到了四个交互，以及交互触发的时间和耗时。因为还是一个Idea阶段，所以我们就挑选一些API代码随便看看：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 跟踪状态变更 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; unstable_trace <span class="keyword">as</span> trace &#125; <span class="keyword">from</span> <span class="string">"scheduler/tracing"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleLoginButtonClick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 跟踪setState</span></span><br><span class="line">    trace(<span class="string">"Login button click"</span>, performance.now(), () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">isLoggingIn</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// render ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 跟踪异步操作 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  unstable_trace <span class="keyword">as</span> trace,</span><br><span class="line">  unstable_wrap <span class="keyword">as</span> wrap</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"scheduler/tracing"</span>;</span><br><span class="line"></span><br><span class="line">trace(<span class="string">"Some event"</span>, performance.now(), () =&gt; &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    wrap(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Do some async work</span></span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 跟踪初始化渲染 **/</span></span><br><span class="line">trace(<span class="string">"initial render"</span>, performance.now(), () =&gt; render(<span class="xml"><span class="tag">&lt;<span class="name">Application</span> /&gt;</span>));</span></span><br></pre></td></tr></table></figure><p>好了行文结束，如果觉得可以就点个 👍 吧</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">Introducing the React Profiler</a></li><li><a href="https://calibreapp.com/blog/react-performance-profiling-optimization/" target="_blank" rel="noopener">Profiling React performance with React 16 and Chrome Devtools.</a></li><li><a href="https://www.youtube.com/watch?v=nl8VVig_9aM" target="_blank" rel="noopener">Tools For Measuring React Performance - Brenda Jimenez @ ReactNYC</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇&lt;a href=&quot;https://juejin.im/post/5d045350f265da1b695d5bf2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;讲了 React 性能优化的一些方向和手段，这篇文章再补充说一下如何进行性能测
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈React性能优化的方向</title>
    <link href="https://bobi.ink/2019/06/14/react-performance/"/>
    <id>https://bobi.ink/2019/06/14/react-performance/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-06-16T01:03:44.939Z</updated>
    
    <content type="html"><![CDATA[<p>本文来源于公司内部的一次闪电分享，稍作润色分享出来。主要讨论 React 性能优化的主要方向和一些小技巧。<strong>如果你觉得可以，请多点赞，鼓励我写出更精彩的文章</strong>🙏。</p><p><br></p><p>React 渲染性能优化的三个方向，其实也适用于其他软件开发领域，这三个方向分别是:</p><ul><li><strong>减少计算的量</strong>。 -&gt; 对应到 React 中就是<strong>减少渲染的节点 或者 降低组件渲染的复杂度</strong></li><li><strong>利用缓存</strong>。-&gt; 对应到 React 中就是<strong>如何避免重新渲染，利用函数式编程的 memo 方式来避免组件重新渲染</strong></li><li><strong>精确重新计算的范围</strong>。 对应到 React 中就是<strong>绑定组件和状态关系, 精确判断更新的’时机’和’范围’. 只重新渲染’脏’的组件，或者说降低渲染范围</strong></li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#减少渲染的节点降低渲染计算量复杂度">减少渲染的节点/降低渲染计算量(复杂度)</a><ul><li><a href="#0️⃣-不要在渲染函数都进行不必要的计算">0️⃣ 不要在渲染函数都进行不必要的计算</a></li><li><a href="#1️⃣-减少不必要的嵌套">1️⃣ 减少不必要的嵌套</a></li><li><a href="#2️⃣-虚拟列表">2️⃣ 虚拟列表</a></li><li><a href="#3️⃣-惰性渲染">3️⃣ 惰性渲染</a></li><li><a href="#4️⃣-选择合适的样式方案">4️⃣ 选择合适的样式方案</a></li></ul></li><li><a href="#避免重新渲染">避免重新渲染</a><ul><li><a href="#0️⃣-简化-props">0️⃣ 简化 props</a></li><li><a href="#1️⃣-不变的事件处理器">1️⃣ 不变的事件处理器</a></li><li><a href="#2️⃣-不可变数据">2️⃣ 不可变数据</a></li><li><a href="#3️⃣-简化-state">3️⃣ 简化 state</a></li><li><a href="#4️⃣-使用-recompose-精细化比对">4️⃣ 使用 recompose 精细化比对</a></li></ul></li><li><a href="#精细化渲染">精细化渲染</a><ul><li><a href="#0️⃣-响应式数据的精细化渲染">0️⃣ 响应式数据的精细化渲染</a></li><li><a href="#1️⃣-不要滥用-context">1️⃣ 不要滥用 Context</a></li></ul></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="减少渲染的节点-降低渲染计算量-复杂度"><a href="#减少渲染的节点-降低渲染计算量-复杂度" class="headerlink" title="减少渲染的节点/降低渲染计算量(复杂度)"></a>减少渲染的节点/降低渲染计算量(复杂度)</h2><p>首先从计算的量上下功夫，减少节点渲染的数量或者降低渲染的计算量可以显著的提高组件渲染性能。</p><p><br></p><h3 id="0️⃣-不要在渲染函数都进行不必要的计算"><a href="#0️⃣-不要在渲染函数都进行不必要的计算" class="headerlink" title="0️⃣ 不要在渲染函数都进行不必要的计算"></a>0️⃣ 不要在渲染函数都进行不必要的计算</h3><p>比如不要在渲染函数(render)中进行数组排序、数据转换、订阅事件、创建事件处理器等等. <strong>渲染函数中不应该放置太多副作用</strong></p><p><br></p><h3 id="1️⃣-减少不必要的嵌套"><a href="#1️⃣-减少不必要的嵌套" class="headerlink" title="1️⃣ 减少不必要的嵌套"></a>1️⃣ 减少不必要的嵌套</h3><center><br> <img src="/images/09/styled-components.png"><br></center><p>我们团队是重度的 <code>styled-components</code> 用户，<strong>其实大部分情况下我们都不需要这个玩意</strong>，比如纯静态的样式规则，以及需要重度性能优化的场景。除了性能问题，另外一个困扰我们的是它带来的节点嵌套地狱(如上图)。</p><p>所以我们需要理性地选择一些工具，比如使用原生的 CSS，减少 React 运行时的负担.</p><p><strong>一般不必要的节点嵌套都是滥用高阶组件/RenderProps 导致的。所以还是那句话‘只有在必要时才使用 xxx’</strong>。 有很多种方式来代替高阶组件/RenderProps，例如优先使用 props、React Hooks</p><p><br></p><h3 id="2️⃣-虚拟列表"><a href="#2️⃣-虚拟列表" class="headerlink" title="2️⃣ 虚拟列表"></a>2️⃣ 虚拟列表</h3><p>虚拟列表是常见的‘长列表’和’复杂组件树’优化方式，它优化的本质就是减少渲染的节点。</p><p>虚拟列表只渲染当前视口可见元素:</p><center><br> <img src="/images/09/vl.png" width="500"><br></center><p>虚拟列表渲染性能对比:</p><center><br> <img src="/images/09/vl-compare.png" width="500"><br></center><p>虚拟列表常用于以下组件场景:</p><ul><li>无限滚动列表，grid, 表格，下拉列表，spreadsheets</li><li>无限切换的日历或轮播图</li><li>大数据量或无限嵌套的树</li><li>聊天窗，数据流(feed), 时间轴</li><li>等等</li></ul><p>相关组件方案:</p><ul><li><a href="https://github.com/bvaughn/react-virtualized" target="_blank" rel="noopener">react-virtualized</a></li><li><a href="https://github.com/bvaughn/react-window" target="_blank" rel="noopener">react-window</a> 更轻量的 react-virtualized, 同出一个作者</li><li><a href="https://github.com/bvaughn/react-virtualized#friends" target="_blank" rel="noopener">更多</a></li></ul><p>扩展：</p><ul><li><a href="https://bvaughn.github.io/forward-js-2017/#/0/0" target="_blank" rel="noopener">Creating more efficient React views with windowing</a></li><li><a href="https://addyosmani.com/blog/react-window/" target="_blank" rel="noopener">Rendering large lists with react-window</a></li></ul><p><br><br><br></p><h3 id="3️⃣-惰性渲染"><a href="#3️⃣-惰性渲染" class="headerlink" title="3️⃣ 惰性渲染"></a>3️⃣ 惰性渲染</h3><p><strong>惰性渲染的初衷本质上和虚表一样，也就是说我们只在必要时才去渲染对应的节点</strong>。</p><p>举个典型的例子，我们常用 Tab 组件，我们没有必要一开始就将所有 Tab 的 panel 都渲染出来，而是等到该 Tab 被激活时才去惰性渲染。</p><p>还有很多场景会用到惰性渲染，例如树形选择器，模态弹窗，下拉列表，折叠组件等等。</p><p>这里就不举具体的代码例子了，留给读者去思考.</p><p><br></p><h3 id="4️⃣-选择合适的样式方案"><a href="#4️⃣-选择合适的样式方案" class="headerlink" title="4️⃣ 选择合适的样式方案"></a>4️⃣ 选择合适的样式方案</h3><center><br>  <img src="/images/09/style-compare.png" width="500"><br></center><p>如图(图片来源于<a href="https://blog.primehammer.com/the-performance-of-styled-react-components/" target="_blank" rel="noopener">THE PERFORMANCE OF STYLED REACT COMPONENTS</a>), 这个图片是17年的了，但是大抵的趋势还是这样。</p><p>所以在样式运行时性能方面大概可以总结为：<code>CSS &gt; 大部分CSS-in-js &gt; inline style</code></p><p><br></p><hr><p><br></p><h2 id="避免重新渲染"><a href="#避免重新渲染" class="headerlink" title="避免重新渲染"></a>避免重新渲染</h2><p>减少不必要的重新渲染也是 React 组件性能优化的重要方向. 为了避免不必要的组件重新渲染需要在做到两点:</p><ol><li>保证组件纯粹性。即控制组件的副作用，如果组件有副作用则无法安全地缓存渲染结果</li><li>通过<code>shouldComponentUpdate</code>生命周期函数来比对 state 和 props, 确定是否要重新渲染。对于函数组件可以使用<code>React.memo</code>包装</li></ol><p>另外这些措施也可以帮助你更容易地优化组件重新渲染:</p><p><br></p><h3 id="0️⃣-简化-props"><a href="#0️⃣-简化-props" class="headerlink" title="0️⃣ 简化 props"></a>0️⃣ 简化 props</h3><p><strong>① 如果一个组件的 props 太复杂一般意味着这个组件已经违背了‘单一职责’，首先应该尝试对组件进行拆解</strong>.<br><strong>② 另外复杂的 props 也会变得难以维护, 比如会影响<code>shallowCompare</code>效率, 还会让组件的变动变得难以预测和调试</strong>.</p><p>下面是一个典型的例子, 为了判断列表项是否处于激活状态，这里传入了一个当前激活的 id:</p>  <center><br>    <img src="/images/09/list.png" width="500"><br>  </center><p>这是一个非常糟糕的设计，一旦激活 id 变动，所有列表项都会重新刷新. 更好的解决办法是使用类似<code>actived</code>这样的布尔值 prop. actived 现在只有两种变动情况，也就是说激活 id 的变动，最多只有两个组件需要重新渲染.</p><p><strong>简化的 props 更容易理解, 且可以提高组件缓存的命中率</strong></p><p><br></p><h3 id="1️⃣-不变的事件处理器"><a href="#1️⃣-不变的事件处理器" class="headerlink" title="1️⃣ 不变的事件处理器"></a>1️⃣ 不变的事件处理器</h3><p>①<strong>避免使用箭头函数形式的事件处理器</strong>, 例如:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ComplexComponent onClick=&#123;evt =&gt; onClick(evt.id)&#125; otherProps=&#123;values&#125; /&gt;</span><br></pre></td></tr></table></figure><p>假设 ComplexComponent 是一个复杂的 PureComponent, 这里使用箭头函数，其实每次渲染时都会创建一个新的事件处理器，这会导致 ComplexComponent 始终会被重新渲染.</p><p>更好的方式是使用实例方法:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;ComplexComponent onClick=&#123;<span class="keyword">this</span>.handleClick&#125; otherProps=&#123;values&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <br></p><p>② 即使现在使用<code>hooks</code>，我依然会<strong>使用<code>useCallback</code>来包装事件处理器</strong>，尽量给下级组件暴露一个静态的函数:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ComplexComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> <span class="attr">otherProps</span>=<span class="string">&#123;values&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>但是如果<code>useCallback</code>依赖于很多状态，你的<code>useCallback</code>可能会变成这样:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="comment">// 🤭</span></span><br><span class="line">&#125;, [foo, bar, baz, bazz, bazzzz]);</span><br></pre></td></tr></table></figure><p>这种写法实在让人难以接受，这时候谁还管什么函数式非函数式的。我是这样处理的:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRefProps</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef &lt; T &gt; props;</span><br><span class="line">  <span class="comment">// 每次渲染更新props</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = props;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsRef = useRefProps(props);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在handleClick是始终不变的</span></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; foo, bar, baz, bazz, bazzzz &#125; = propsRef.current;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>③<strong>设计更方便处理的 Event Props</strong>. 有时候我们会被逼的不得不使用箭头函数来作为事件处理器：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;List&gt;</span><br><span class="line">  &#123;list.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">    &lt;Item key=&#123;i.id&#125; onClick=&#123;() =&gt; handleDelete(i.id)&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;<span class="regexp">/List&gt;</span></span><br></pre></td></tr></table></figure><p>上面的 onClick 是一个糟糕的实现，它没有携带任何信息来标识事件来源，所以这里只能使用闭包形式，更好的设计可能是这样的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onClick传递事件来源信息</span></span><br><span class="line"><span class="keyword">const</span> handleDelete = useCallback(<span class="function">(<span class="params">id: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*删除操作*/</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;List&gt;</span><br><span class="line">    &#123;list.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">      &lt;Item key=&#123;i.id&#125; id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/List&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>如果是第三方组件或者 DOM 组件呢? 实在不行，看能不能传递<code>data-*</code>属性:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleDelete = useCallback(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = event.dataset.id;</span><br><span class="line">  <span class="comment">/*删除操作*/</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;list.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">      &lt;li key=&#123;i.id&#125; data-id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="2️⃣-不可变数据"><a href="#2️⃣-不可变数据" class="headerlink" title="2️⃣ 不可变数据"></a>2️⃣ 不可变数据</h3><p>不可变数据可以让状态变得可预测，也让 shouldComponentUpdate ‘浅比较’变得更可靠和高效. 笔者在<a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-8" target="_blank" rel="noopener">React 组件设计实践总结 04 - 组件的思维</a>介绍过不可变数据，有兴趣读者可以看看.</p><p>相关的工具有<a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">Immutable.js</a>、<a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">Immer</a>、immutability-helper 以及 seamless-immutable。</p><p><br></p><h3 id="3️⃣-简化-state"><a href="#3️⃣-简化-state" class="headerlink" title="3️⃣ 简化 state"></a>3️⃣ 简化 state</h3><p><strong>不是所有状态都应该放在组件的 state 中</strong>. 例如缓存数据。按照我的原则是：<strong>如果需要组件响应它的变动, 或者需要渲染到视图中的数据才应该放到 state 中。这样可以避免不必要的数据变动导致组件重新渲染.</strong></p><p><br></p><h3 id="4️⃣-使用-recompose-精细化比对"><a href="#4️⃣-使用-recompose-精细化比对" class="headerlink" title="4️⃣ 使用 recompose 精细化比对"></a>4️⃣ 使用 recompose 精细化比对</h3><p>尽管 hooks 出来后，recompose 宣称不再更新了，但还是不影响我们使用 recompose 来控制<code>shouldComponentUpdate</code>方法, 比如它提供了以下方法来精细控制应该比较哪些 props:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 相当于React.memo */</span></span><br><span class="line">pure()</span><br><span class="line"><span class="comment">/* 自定义比较 */</span></span><br><span class="line">shouldUpdate(test: <span class="function">(<span class="params">props: <span class="built_in">Object</span>, nextProps: <span class="built_in">Object</span></span>) =&gt;</span> <span class="built_in">boolean</span>): HigherOrderComponent</span><br><span class="line"><span class="comment">/* 只比较指定key */</span></span><br><span class="line">onlyUpdateForKeys( propKeys: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;): HigherOrderComponent</span><br></pre></td></tr></table></figure><p>其实还可以再扩展一下，比如<code>omitUpdateForKeys</code>忽略比对某些 key.</p><p><br><br><br></p><h2 id="精细化渲染"><a href="#精细化渲染" class="headerlink" title="精细化渲染"></a>精细化渲染</h2><p>所谓精细化渲染指的是<strong>只有一个数据来源导致组件重新渲染</strong>, 比如说 A 只依赖于 a 数据，那么只有在 a 数据变动时才渲染 A, 其他状态变化不应该影响组件 A。</p><p>Vue 和 Mobx 宣称自己性能好的一部分原因是它们的’响应式系统’, <strong>它允许我们定义一些‘响应式数据’，当这些响应数据变动时，依赖这些响应式数据视图就会重新渲染</strong>. 来看看 Vue 官方是如何描述的:</p><center><br>  <img src="/images/09/vue-compare.png" width="500"><br></center><p><br></p><h3 id="0️⃣-响应式数据的精细化渲染"><a href="#0️⃣-响应式数据的精细化渲染" class="headerlink" title="0️⃣ 响应式数据的精细化渲染"></a>0️⃣ 响应式数据的精细化渲染</h3><p><strong>大部分情况下，响应式数据可以实现视图精细化的渲染, 但它还是不能避免开发者写出低效的程序</strong>. <strong>本质上还是因为组件违背‘单一职责’</strong>.</p><p>举个例子，现在有一个 MyComponent 组件，依赖于 A、B、C 三个数据源，来构建一个 vdom 树。现在的问题是什么呢？现在只要 A、B、C 任意一个变动，那么 MyComponent 整个就会重新渲染:</p><center><br>  <img src="/images/09/my-component1.png" width="300"><br></center><p>更好的做法是让组件的职责更单一，精细化地依赖响应式数据，或者说对响应式数据进行‘隔离’. 如下图, A、B、C 都抽取各自的组件中了，现在 A 变动只会渲染 A 组件本身，而不会影响父组件和 B、C 组件:</p><center><br>  <img src="/images/09/my-component2.png" width="480"><br></center><p><br></p><p>举一个典型的例子，列表渲染:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react-lite'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialList = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  initialList.push(&#123; <span class="attr">id</span>: i, <span class="attr">name</span>: <span class="string">`name-<span class="subst">$&#123;i&#125;</span>`</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = observable(&#123;</span><br><span class="line">  list: initialList,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> List = observer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> list = store.list;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'List渲染'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"list-container"</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map(<span class="function">(<span class="params">i, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;div className=<span class="string">"list-item"</span> key=&#123;i.id&#125;&gt;</span><br><span class="line">            &#123;<span class="comment">/* 假设这是一个复杂的组件 */</span>&#125;</span><br><span class="line">            &#123;<span class="built_in">console</span>.log(<span class="string">'render'</span>, i.id)&#125;</span><br><span class="line">            &lt;span className=<span class="string">"list-item-name"</span>&gt;&#123;i.name&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span className="list-item-value"&gt;&#123;i.value&#125; &lt;/</span>span&gt;</span><br><span class="line">            &lt;button</span><br><span class="line">              className=<span class="string">"list-item-increment"</span></span><br><span class="line">              onClick=&#123;() =&gt; &#123;</span><br><span class="line">                i.value++;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'递增'</span>);</span><br><span class="line">              &#125;&#125;</span><br><span class="line">            &gt;</span><br><span class="line">              递增</span><br><span class="line">            &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button</span></span><br><span class="line"><span class="regexp">              className="list-item-increment"</span></span><br><span class="line"><span class="regexp">              onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                if (idx &lt; list.length - 1) &#123;</span></span><br><span class="line"><span class="regexp">                  console.log('移位');</span></span><br><span class="line"><span class="regexp">                  let t = list[idx];</span></span><br><span class="line"><span class="regexp">                  list[idx] = list[idx + 1];</span></span><br><span class="line"><span class="regexp">                  list[idx + 1] = t;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">              &#125;&#125;</span></span><br><span class="line"><span class="regexp">            &gt;</span></span><br><span class="line"><span class="regexp">              下移</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><p><br></p><p>上述的例子是存在性能问题的，单个 list-item 的递增和移位都会导致整个列表的重新渲染:</p><center><br>  <img src="/images/09/list-demo.png" width="380"><br></center><p>原因大概能猜出来吧? 对于 Vue 或者 Mobx 来说，<strong>一个组件的渲染函数就是一个依赖收集的上下文</strong>。上面 List 组件渲染函数内’访问’了所有的列表项数据，那么 Vue 或 Mobx 就会认为你这个组件依赖于所有的列表项，这样就导致，只要任意一个列表项的属性值变动就会重新渲染整个 List 组件。</p><p>解决办法也很简单，就是将数据隔离抽取到单一职责的组件中。<strong>对于 Vue 或 Mobx 来说，越细粒度的组件，可以收获更高的性能优化效果</strong>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ListItem = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; item, onShiftDown &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"list-item"</span>&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'render'</span>, item.id)&#125;</span><br><span class="line">      &#123;<span class="comment">/* 假设这是一个复杂的组件 */</span>&#125;</span><br><span class="line">      &lt;span className=<span class="string">"list-item-name"</span>&gt;&#123;item.name&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span className="list-item-value"&gt;&#123;item.value&#125; &lt;/</span>span&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        className=<span class="string">"list-item-increment"</span></span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          item.value++;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'递增'</span>);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        递增</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button className="list-item-increment" onClick=&#123;() =&gt; onShiftDown(item)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        下移</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export const List = observer(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const list = store.list;</span></span><br><span class="line"><span class="regexp">  const handleShiftDown = useCallback(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const idx = list.findIndex(i =&gt; i.id === item.id);</span></span><br><span class="line"><span class="regexp">    if (idx !== -1 &amp;&amp; idx &lt; list.length - 1) &#123;</span></span><br><span class="line"><span class="regexp">      console.log('移位');</span></span><br><span class="line"><span class="regexp">      let t = list[idx];</span></span><br><span class="line"><span class="regexp">      list[idx] = list[idx + 1];</span></span><br><span class="line"><span class="regexp">      list[idx + 1] = t;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ eslint-disable-next-line react-hooks/</span>exhaustive-deps</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'List 渲染'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"list-container"</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map(<span class="function">(<span class="params">i, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;ListItem key=&#123;i.id&#125; item=&#123;i&#125; onShiftDown=&#123;handleShiftDown&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果很明显, list-item 递增只会重新渲染本身; 而移位只会重新渲染 List， 因为列表项没有变动, 所以下级 list-item 也不需要重新渲染:</p><center><br>  <img src="/images/09/list-demo2.png" width="380"><br></center><p><br><br><br></p><h3 id="1️⃣-不要滥用-context"><a href="#1️⃣-不要滥用-context" class="headerlink" title="1️⃣ 不要滥用 Context"></a>1️⃣ 不要滥用 Context</h3><p><strong>其实 Context 的用法和响应式数据正好相反</strong>。笔者也看过不少滥用 Context API 的例子, 说到底还是没有处理好‘状态的作用域问题’.</p><p>首先要理解 Context API 的更新特点，<strong>它是可以穿透<code>React.memo</code>或者<code>shouldComponentUpdate</code>的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate</strong>.</p><p><strong>这个和 Mobx 和 Vue 的响应式系统不同，Context API 并不能细粒度地检测哪些组件依赖哪些状态，所以说上节提到的‘精细化渲染’组件模式，在 Context 这里就成为了‘反模式’</strong>.</p><p>总结一下使用 Context API 要遵循一下原则:</p><p><br></p><ul><li><p><strong>明确状态作用域, Context 只放置必要的，关键的，被大多数组件所共享的状态</strong>。比较典型的是鉴权状态</p><p>举一个简单的例子:</p><center><br>  <img src="/images/09/use-context1.png" width="400"><br></center><center><br>  <img src="/images/09/use-context2.png" width="650"><br></center><p>扩展：Context其实有个实验性或者说非公开的选项<code>observedBits</code>, 可以用于控制ContextConsumer是否需要更新. 详细可以看这篇文章&lt;<a href="https://zhuanlan.zhihu.com/p/51073183" target="_blank" rel="noopener">ObservedBits: React Context的秘密功能</a>&gt;. 不过不推荐在实际项目中使用，而且这个API也比较难用，不如直接上mobx。</p></li><li><p><strong>粗粒度地订阅 Context</strong></p><p>如下图. 细粒度的 Context 订阅会导致不必要的重新渲染, 所以这里推荐粗粒度的订阅. 比如在父级订阅 Context，然后再通过 props 传递给下级。</p><center><br>  <img src="/images/09/context-vs-props.png" width="600"><br></center></li></ul><p><br></p><p>另外程墨 Morgan 在<a href="https://zhuanlan.zhihu.com/p/50336226" target="_blank" rel="noopener">避免 React Context 导致的重复渲染</a>一文中也提到 ContextAPI 的一个陷阱:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Context.Provider</span><br><span class="line">  value=&#123;&#123; <span class="attr">theme</span>: <span class="keyword">this</span>.state.theme, <span class="attr">switchTheme</span>: <span class="keyword">this</span>.switchTheme &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &lt;Content /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Context.Provider&gt;</span><br></pre></td></tr></table></figure><p>上面的组件会在 state 变化时重新渲染整个组件树，至于为什么留给读者去思考。</p><p>所以我们一般都不会裸露地使用 Context.Provider, 而是封装为独立的 Provider 组件:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 顺便暴露useTheme, 让外部必须直接使用Context</span></span><br><span class="line"><span class="regexp">export function useTheme() &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(Context);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>现在 theme 变动就不会重新渲染整个组件树，因为 props.children 由外部传递进来，并没有发生变动。</p><p><strong>其实上面的代码还有另外一个比较难发现的陷阱(官方文档也有<a href="https://zh-hans.reactjs.org/docs/context.html#caveats" target="_blank" rel="noopener">提到</a>)</strong>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;<span class="comment">/* 👇 💣这里每一次渲染ThemeProvider, 都会创建一个新的value(即使theme和switchTheme没有变动),</span></span><br><span class="line"><span class="comment">        从而导致强制渲染所有依赖该Context的组件 */</span>&#125;</span><br><span class="line">    &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>所以<strong>传递给 Context 的 value 最好做一下缓存</strong>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  <span class="keyword">const</span> value = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; theme, switchTheme &#125;), [theme]);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://react.docschina.org/docs/optimizing-performance.html" target="_blank" rel="noopener">Optimizing Performance</a> React 官方文档，最好的教程, 利用好 React 的性能分析工具。</li><li><a href="https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3" target="_blank" rel="noopener">Twitter Lite and High Performance React Progressive Web Apps at Scale</a> 看看 Twitter 如何优化的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文来源于公司内部的一次闪电分享，稍作润色分享出来。主要讨论 React 性能优化的主要方向和一些小技巧。&lt;strong&gt;如果你觉得可以，请多点赞，鼓励我写出更精彩的文章&lt;/strong&gt;🙏。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;React 渲染性能优化的三个方向，其实
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] Preact</title>
    <link href="https://bobi.ink/2019/06/02/preact-map/"/>
    <id>https://bobi.ink/2019/06/02/preact-map/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-06-07T23:04:38.874Z</updated>
    
    <content type="html"><![CDATA[<p>React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路).</p><p>Preact 是 React 的缩略版, 体积非常小, 但五脏俱全. 如果你想了解 React 的基本原理, 可以去学习学习 Preact 的源码, 这也正是本文的目的。</p><p>关于 React 原理的优秀的文章已经非常多, 本文就是老酒装新瓶, 算是自己的一点总结，也为后面的文章作一下铺垫吧.</p><p>文章篇幅较长，阅读时间约 20min，主要被代码占据，另外也画了流程图配合理解代码。</p><blockquote><p>注意：代码有所简化，忽略掉 svg、replaceNode、context 等特性<br>本文代码基于 Preact v10 版本</p></blockquote><p><br></p><!-- TOC --><ul><li><a href="#virtual-dom">Virtual-DOM</a></li><li><a href="#从-createelement-开始">从 createElement 开始</a></li><li><a href="#component-的实现">Component 的实现</a></li><li><a href="#diff-算法">diff 算法</a><ul><li><a href="#diffchildren">diffChildren</a></li><li><a href="#diff">diff</a></li><li><a href="#diffelementnodes">diffElementNodes</a></li><li><a href="#diffprops">diffProps</a></li></ul></li><li><a href="#hooks-的实现">Hooks 的实现</a><ul><li><a href="#usestate">useState</a></li><li><a href="#useeffect">useEffect</a></li></ul></li><li><a href="#技术地图">技术地图</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="Virtual-DOM"></a>Virtual-DOM</h2><center><br> <img src="/images/07/vd.png" width="500"><br></center><p>Virtual-DOM 其实就是一颗对象树，没有什么特别的，这个对象树最终要映射到图形对象. Virtual-DOM 比较核心的是它的<code>diff算法</code>.</p><p>你可以想象这里有一个<code>DOM映射器</code>，见名知义，<strong>这个’DOM 映射器‘的工作就是将 Virtual-DOM 对象树映射浏览器页面的 DOM，只不过为了提高 DOM 的’操作性能’. 它不是每一次都全量渲染整个 Virtual-DOM 树，而是支持接收两颗 Virtual-DOM 对象树(一个更新前，一个更新后), 通过 diff 算法计算出两颗 Virtual-DOM 树差异的地方，然后只应用这些差异的地方到实际的 DOM 树, 从而减少 DOM 变更的成本.</strong></p><p>Virtual-DOM 是比较有争议性，推荐阅读<a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noopener">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a> 。切记永远都不要离开场景去评判一个技术的好坏。当初网上把 React 吹得多么牛逼, 一些小白就会觉得 Virtual-DOM 很吊，JQuery 弱爆了。</p><p>我觉得两个可比性不大，从性能上看, <strong>框架再怎么牛逼它也是需要操作原生 DOM 的，而且它未必有你使用 JQuery 手动操作 DOM 来得’精细’</strong>. 框架不合理使用也可能出现修改一个小状态，导致渲染雪崩(大范围重新渲染)的情况; 同理 JQuery 虽然可以精细化操作 DOM, 但是不合理的 DOM 更新策略可能也会成为应用的性能瓶颈. 所以关键还得看你怎么用.</p><p>那为什么需要 Virtual-DOM？</p><p><strong>我个人的理解就是为了解放生产力。现如今硬件的性能越来越好，web 应用也越来越复杂，生产力也是要跟上的</strong>. 尽管手动操作 DOM 可能可以达到更高的性能和灵活性，但是这样对大部分开发者来说太低效了，我们是可以接受牺牲一点性能换取更高的开发效率的.</p><p>所以说 Virtual-DOM 更大的意义在于开发方式的改变: 声明式、 数据驱动, 让开发者不需要关心 DOM 的操作细节(属性操作、事件绑定、DOM 节点变更)，也就是说应用的开发方式变成了<code>view=f(state)</code>, 这对生产力的解放是有很大推动作用的.</p><p>当然 Virtual-DOM 不是唯一，也不是第一个的这样解决方案. 比如 AngularJS, Vue1.x 这些基于模板的实现方式, 也可以说实现这种开发方式转变的. 那相对于他们 Virtual-DOM 的买点可能就是更高的性能了, 另外 Virtual-DOM 在渲染层上面的抽象更加彻底, 不再耦合于 DOM 本身，比如可以渲染为 ReactNative，PDF，终端 UI 等等。</p><p><br></p><hr><p><br></p><h2 id="从-createelement-开始"><a href="#从-createelement-开始" class="headerlink" title="从 createElement 开始"></a>从 createElement 开始</h2><p>很多小白将 <code>JSX</code> 等价为 Virtual-DOM，其实这两者并没有直接的关系, 我们知道 <strong>JSX 不过是一个语法糖</strong>.</p><p>例如<code>&lt;a href=&quot;/&quot;&gt;&lt;span&gt;Home&lt;/span&gt;&lt;/a&gt;</code>最终会转换为<code>h(&#39;a&#39;, { href:&#39;/&#39; }, h(&#39;span&#39;, null, &#39;Home&#39;))</code>这种形式, <code>h</code>是 JSX Element 工厂方法.</p><p><code>h</code> 在 React 下约定是<code>React.createElement</code>, 而大部分 Virtual-DOM 框架则使用<code>h</code>. <code>h</code> 是 <code>createElement</code> 的别名, Vue 生态系统也是使用这个惯例, 具体为什么没作考究(比较简短？)。</p><p>可以使用<code>@jsx</code>注解或 babel 配置项来配置 JSX 工厂：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @jsx h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello jsx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, el);</span><br></pre></td></tr></table></figure><p>本文不是 React 或 Preact 的入门文章，所以点到为止，更多内容可以查看<a href="https://preactjs.com/guide/getting-started" target="_blank" rel="noopener">官方教程</a>.</p><p>现在来看看<code>createElement</code>, <strong>createElement 不过就是构造一个对象(VNode)</strong>:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️type 节点的类型，有DOM元素(string)和自定义组件，以及Fragment, 为null时表示文本节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  props.children = children;</span><br><span class="line">  <span class="comment">// ⚛️应用defaultProps</span></span><br><span class="line">  <span class="keyword">if</span> (type != <span class="literal">null</span> &amp;&amp; type.defaultProps != <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> type.defaultProps)</span><br><span class="line">      <span class="keyword">if</span> (props[i] === <span class="literal">undefined</span>) props[i] = type.defaultProps[i];</span><br><span class="line">  <span class="keyword">let</span> ref = props.ref;</span><br><span class="line">  <span class="keyword">let</span> key = props.key;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️构建VNode对象</span></span><br><span class="line">  <span class="keyword">return</span> createVNode(type, props, key, ref);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createVNode</span>(<span class="params">type, props, key, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; type, props, key, ref, <span class="comment">/* ... 忽略部分内置字段 */</span> <span class="keyword">constructor</span>: undefined &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>通过 JSX 和组件, 可以构造复杂的对象树:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;SideBar /&gt;</span><br><span class="line">    &lt;Body /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  root,</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="component-的实现"><a href="#component-的实现" class="headerlink" title="Component 的实现"></a>Component 的实现</h2><p>对于一个视图框架来说，组件就是它的灵魂, 就像函数之于函数式语言，类之于面向对象语言, 没有组件则无法组成复杂的应用.</p><p>组件化的思维推荐将一个应用分而治之, 拆分和组合不同级别的组件，这样可以简化应用的开发和维护，让程序更好理解. 从技术上看<strong>组件是一个自定义的元素类型，可以声明组件的输入(props)、有自己的生命周期和状态以及方法、最终输出 Virtual-DOM 对象树, 作为应用 Virtual-DOM 树的一个分支存在</strong>.</p><p>Preact 的自定义组件是基于 Component 类实现的. 对组件来说最基本的就是状态的维护, 这个通过 setState 来实现:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️setState实现</span></span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">update, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 克隆下一次渲染的State, _nextState会在一些生命周期方式中用到(例如shouldComponentUpdate)</span></span><br><span class="line">  <span class="keyword">let</span> s = (<span class="keyword">this</span>._nextState !== <span class="keyword">this</span>.state &amp;&amp; <span class="keyword">this</span>._nextState) ||</span><br><span class="line">    (<span class="keyword">this</span>._nextState = assign(&#123;&#125;, <span class="keyword">this</span>.state));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// state更新</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> update !== <span class="string">'function'</span> || (update = update(s, <span class="keyword">this</span>.props)))</span><br><span class="line">    assign(s, update);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._vnode) &#123; <span class="comment">// 已挂载</span></span><br><span class="line">    <span class="comment">// 推入渲染回调队列, 在渲染完成后批量调用</span></span><br><span class="line">    <span class="keyword">if</span> (callback) <span class="keyword">this</span>._renderCallbacks.push(callback);</span><br><span class="line">    <span class="comment">// 放入异步调度队列</span></span><br><span class="line">    enqueueRender(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p><code>enqueueRender</code> 将组件放进一个异步的批执行队列中，这样可以归并频繁的 setState 调用，实现也非常简单:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> q = [];</span><br><span class="line"><span class="comment">// 异步调度器，用于异步执行一个回调</span></span><br><span class="line"><span class="keyword">const</span> defer = <span class="keyword">typeof</span> <span class="built_in">Promise</span> == <span class="string">'function'</span></span><br><span class="line">    ? <span class="built_in">Promise</span>.prototype.then.bind(<span class="built_in">Promise</span>.resolve()) <span class="comment">// micro task</span></span><br><span class="line">    : setTimeout; <span class="comment">// 回调到setTimeout</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueRender</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不需要重复推入已经在队列的Component</span></span><br><span class="line">  <span class="keyword">if</span> (!c._dirty &amp;&amp; (c._dirty = <span class="literal">true</span>) &amp;&amp; q.push(c) === <span class="number">1</span>)</span><br><span class="line">    defer(process); <span class="comment">// 当队列从空变为非空时，开始调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量清空队列, 调用Component的forceUpdate</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p;</span><br><span class="line">  <span class="comment">// 排序队列，从低层的组件优先更新?</span></span><br><span class="line">  q.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b._depth - a._depth);</span><br><span class="line">  <span class="keyword">while</span> ((p = q.pop()))</span><br><span class="line">    <span class="keyword">if</span> (p._dirty) p.forceUpdate(<span class="literal">false</span>); <span class="comment">// false表示不要强制更新，即不要忽略shouldComponentUpdate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>Ok, 上面的代码可以看出 <code>setState</code> 本质上是调用 <code>forceUpdate</code> 进行组件重新渲染的，来往下挖一挖 forceUpdate 的实现.</p><blockquote><p>这里暂且忽略 diff, <strong>将 diff 视作一个黑盒，他就是一个 DOM 映射器, 像上面说的 diff 接收两棵 VNode 树, 以及一个 DOM 挂载点, 在比对的过程中它可以会创建、移除或更新组件和 DOM 元素，触发对应的生命周期方法</strong>.</p></blockquote><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; <span class="comment">// callback放置渲染完成后的回调</span></span><br><span class="line">  <span class="keyword">let</span> vnode = <span class="keyword">this</span>._vnode, dom = <span class="keyword">this</span>._vnode._dom, parentDom = <span class="keyword">this</span>._parentDom;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentDom) &#123; <span class="comment">// 已挂载过</span></span><br><span class="line">    <span class="keyword">const</span> force = callback !== <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> mounts = [];</span><br><span class="line">    <span class="comment">// 调用diff对当前组件进行重新渲染和Virtual-DOM比对</span></span><br><span class="line">    <span class="comment">// ⚛️暂且忽略这些参数, 将diff视作一个黑盒，他就是一个DOM映射器，</span></span><br><span class="line">    dom = diff(parentDom, vnode, vnode, mounts, <span class="keyword">this</span>._ancestorComponent, force, dom);</span><br><span class="line">    <span class="keyword">if</span> (dom != <span class="literal">null</span> &amp;&amp; dom.parentNode !== parentDom)</span><br><span class="line">      parentDom.appendChild(dom);</span><br><span class="line">    commitRoot(mounts, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (callback) callback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>在看看 <code>render</code> 方法, 实现跟 forceUpdate 差不多, 都是调用 diff 算法来执行 DOM 更新，只不过由外部指定一个 DOM 容器:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, parentDom</span>) </span>&#123;</span><br><span class="line">  vnode = createElement(Fragment, <span class="literal">null</span>, [vnode]);</span><br><span class="line">  parentDom.childNodes.forEach(<span class="function"><span class="params">i</span> =&gt;</span> i.remove())</span><br><span class="line">  <span class="keyword">let</span> mounts = [];</span><br><span class="line">  diffChildren(parentDom, <span class="literal">null</span> oldVNode, mounts, vnode, EMPTY_OBJ);</span><br><span class="line">  commitRoot(mounts, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>梳理一下上面的流程:</p><center><br>  <img src="/images/07/setState.png" width="800"><br></center><p>到目前为止没有看到组件的其他功能，如初始化、生命周期函数。这些特性在 diff 函数中定义，也就是说在组件挂载或更新的过程中被调用。下一节就会介绍 diff</p><p><br></p><hr><p><br></p><h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p>千呼万唤始出来，通过上文可以看出，<code>createElement</code> 和 <code>Component</code> 逻辑都很薄， 主要的逻辑还是集中在 diff 函数中. React 将这个过程称为 <code>Reconciliation</code>, 在 Preact 中称为 <code>Differantiate</code>.</p><p>为了简化程序 Preact 的实现将 diff 和 DOM 杂糅在一起, 但逻辑还是很清晰，看下目录结构就知道了:</p><p><br></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/diff</span><br><span class="line">├── children.js # 比对children数组</span><br><span class="line">├── index.js    # 比对两个节点</span><br><span class="line">└── props.js    # 比对两个DOM节点的props</span><br></pre></td></tr></table></figure><center><br>  <img src="/images/07/diff.png" width="600"><br></center><p><br></p><p>在深入 diff 程序之前，先看一下基本的对象结构, 方便后面理解程序流程. 先来看下 VNode 的外形:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type ComponentFactory&lt;P&gt; = preact.ComponentClass&lt;P&gt; | FunctionalComponent&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">interface VNode&lt;P = &#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="comment">// 节点类型, 内置DOM元素为string类型，而自定义组件则是Component类型，Preact中函数组件只是特殊的Component类型</span></span><br><span class="line">  type: string | ComponentFactory&lt;P&gt; | <span class="literal">null</span>;</span><br><span class="line">  props: P &amp; &#123; <span class="attr">children</span>: ComponentChildren &#125; | string | number | <span class="literal">null</span>;</span><br><span class="line">  key: Key</span><br><span class="line">  ref: Ref&lt;any&gt; | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 内部缓存信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// VNode子节点</span></span><br><span class="line">  _children: <span class="built_in">Array</span>&lt;VNode&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 关联的DOM节点, 对于Fragment来说第一个子节点</span></span><br><span class="line">  _dom: PreactElement | Text | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// Fragment, 或者组件返回Fragment的最后一个DOM子节点，</span></span><br><span class="line">  _lastDomChild: PreactElement | Text | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// Component实例</span></span><br><span class="line">  _component: Component | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="diffchildren"><a href="#diffchildren" class="headerlink" title="diffChildren"></a>diffChildren</h3><p>先从最简单的开始, 上面已经猜出 diffChildren 用于比对两个 VNode 列表.</p><center><br>  <img src="/images/07/diffChildren-base.png" width="600"><br></center><p>如上图, 首先这里需要维护一个表示当前插入位置的变量 oldDOM, 它一开始指向 DOM childrenNode 的第一个元素, 后面每次插入更新或插入 newDOM，都会指向 newDOM 的下一个兄弟元素.</p><p>在遍历 newChildren 列表过程中, 会尝试找出相同 key 的旧 VNode，和它进行 diff. 如果新 VNode 和旧 VNode 位置不一样，这就需要移动它们;对于新增的 DOM，如果插入位置(oldDOM)已经到了结尾，则直接追加到父节点, 否则插入到 oldDOM 之前。</p><p>最后卸载旧 VNode 列表中未使用的 VNode.</p><p>来详细看看源码:</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentDom,         <span class="regexp">//</span> children的父DOM元素</span></span></span><br><span class="line"><span class="function"><span class="params">  newParentVNode,    <span class="regexp">//</span> children的新父VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  oldParentVNode,    <span class="regexp">//</span> children的旧父VNode，diffChildren主要比对这两个Vnode的children</span></span></span><br><span class="line"><span class="function"><span class="params">  mounts,            <span class="regexp">//</span> 保存在这次比对过程中被挂载的组件实例，在比对后，会触发这些组件的componentDidMount生命周期函数</span></span></span><br><span class="line"><span class="function"><span class="params">  ancestorComponent, <span class="regexp">//</span> children的直接父<span class="string">'组件'</span>, 即渲染(render</span>)<span class="title">VNode</span>的组件实例</span></span><br><span class="line"><span class="function">  <span class="title">oldDom</span>,            // 当前挂载的<span class="title">DOM</span>，对于<span class="title">diffChildren</span>来说，<span class="title">oldDom</span>一开始指向第一个子节点</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newChildren = newParentVNode._children || toChildArray(newParentVNode.props.children, (newParentVNode._children = []), coerceToVNode, <span class="literal">true</span>,);</span><br><span class="line">  <span class="keyword">let</span> oldChildren = (oldParentVNode &amp;&amp; oldParentVNode._children) || EMPTY_ARR;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️遍历新children</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">    childVNode = newChildren[i] = coerceToVNode(newChildren[i]); <span class="comment">// 规范化VNode</span></span><br><span class="line">    <span class="keyword">if</span> (childVNode == <span class="literal">null</span>) <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">// ⚛️查找oldChildren中是否有对应的元素，如果找到则通过设置为undefined，从oldChildren中移除</span></span><br><span class="line">    <span class="comment">// 如果没有找到则保持为null</span></span><br><span class="line">    oldVNode = oldChildren[i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; oldChildrenLength; j++) &#123;</span><br><span class="line">      oldVNode = oldChildren[j];</span><br><span class="line">      <span class="keyword">if</span> (oldVNode &amp;&amp; childVNode.key == oldVNode.key &amp;&amp; childVNode.type === oldVNode.type) &#123;</span><br><span class="line">        oldChildren[j] = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      oldVNode = <span class="literal">null</span>; <span class="comment">// 没有找到任何旧node，表示是一个新的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⚛️ 递归比对VNode</span></span><br><span class="line">    newDom = diff(parentDom, childVNode, oldVNode, mounts, ancestorComponent, <span class="literal">null</span>, oldDom);</span><br><span class="line">    <span class="comment">// vnode没有被diff卸载掉</span></span><br><span class="line">    <span class="keyword">if</span> (newDom != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (childVNode._lastDomChild != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ⚛️当前VNode是Fragment类型</span></span><br><span class="line">        <span class="comment">// 只有Fragment或组件返回Fragment的Vnode会有非null的_lastDomChild, 从Fragment的结尾的DOM树开始比对:</span></span><br><span class="line">        <span class="comment">// &lt;A&gt;                               &lt;A&gt;</span></span><br><span class="line">        <span class="comment">//  &lt;&gt;                                 &lt;&gt;   👈 Fragment类型，diff会递归比对它的children，所以最后我们只需要将newDom指向比对后的最后一个子节点即可</span></span><br><span class="line">        <span class="comment">//    &lt;a&gt;a&lt;/a&gt;           &lt;- diff -&gt;      &lt;b&gt;b&lt;/b&gt;</span></span><br><span class="line">        <span class="comment">//    &lt;b&gt;b&lt;/b&gt;                           &lt;a&gt;a&lt;/a&gt; ----+</span></span><br><span class="line">        <span class="comment">//  &lt;/&gt;                                &lt;/&gt;             \</span></span><br><span class="line">        <span class="comment">//                                     &lt;div&gt;x&lt;/div&gt;     👈oldDom会指向这里</span></span><br><span class="line">        <span class="comment">// &lt;/A&gt;                              &lt;/A&gt;</span></span><br><span class="line">        newDom = childVNode._lastDomChild;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVNode == <span class="literal">null</span> || newDom != oldDom || newDom.parentNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ newDom和当前oldDom不匹配，尝试新增或修改位置</span></span><br><span class="line">        outer: <span class="keyword">if</span> (oldDom == <span class="literal">null</span> || oldDom.parentNode !== parentDom) &#123;</span><br><span class="line">          <span class="comment">// ⚛️oldDom指向了结尾, 即后面没有更多元素了，直接插入即可; 首次渲染一般会调用到这里</span></span><br><span class="line">          parentDom.appendChild(newDom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 这里是一个优化措施，去掉也不会影响正常程序. 为了便于理解可以忽略这段代码</span></span><br><span class="line">          <span class="comment">// 尝试向后查找oldChildLength/2个元素，如果找到则不需要调用insertBefore. 这段代码可以减少insertBefore的调用频率</span></span><br><span class="line">          <span class="keyword">for</span> (sibDom = oldDom, j = <span class="number">0</span>; (sibDom = sibDom.nextSibling) &amp;&amp; j &lt; oldChildrenLength; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sibDom == newDom)</span><br><span class="line">              <span class="keyword">break</span> outer;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ⚛️insertBefore() 将newDom移动到oldDom之前 </span></span><br><span class="line">          parentDom.insertBefore(newDom, oldDom);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ⚛️其他情况，newDom === oldDOM不需要处理</span></span><br><span class="line">      <span class="comment">// ⚛️ oldDom指向下一个DOM节点</span></span><br><span class="line">      oldDom = newDom.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 卸载掉没有被置为undefined的元素</span></span><br><span class="line">  <span class="keyword">for</span> (i = oldChildrenLength; i--; )</span><br><span class="line">    <span class="keyword">if</span> (oldChildren[i] != <span class="literal">null</span>) unmount(oldChildren[i], ancestorComponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>配图理解一下 diffChilrend 的调用过程:</p><center><br>  <img src="/images/07/diffChildren.png" width="600"><br></center><p><br></p><p>总结一下流程图</p><center><br>  <img src="/images/07/diffChildren-process.png" width="800"><br></center><p><br></p><hr><p><br></p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>diff 用于比对两个 VNode 节点. diff 函数比较冗长, 但是这里面并没有特别复杂逻辑，主要是一些自定义组件生命周期的处理。所以先上流程图，代码不感兴趣可以跳过.</p><center><br>  <img src="/images/07/diff-process.png" width="800"><br></center><p><br></p><p>源代码解析：</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentDom,         <span class="regexp">//</span> 父DOM节点</span></span></span><br><span class="line"><span class="function"><span class="params">  newVNode,          <span class="regexp">//</span> 新VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  oldVNode,          <span class="regexp">//</span> 旧VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  mounts,            <span class="regexp">//</span> 存放已挂载的组件, 将在diff结束后批量处理</span></span></span><br><span class="line"><span class="function"><span class="params">  ancestorComponent, <span class="regexp">//</span> 直接父组件</span></span></span><br><span class="line"><span class="function"><span class="params">  force,             <span class="regexp">//</span> 是否强制更新, 为true将忽略掉shouldComponentUpdate</span></span></span><br><span class="line"><span class="function"><span class="params">  oldDom,            <span class="regexp">//</span> 当前挂载的DOM节点</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    outer: <span class="keyword">if</span> (oldVNode.type === Fragment || newType === Fragment) &#123;</span><br><span class="line">      <span class="comment">// ⚛️ Fragment类型，使用diffChildren进行比对</span></span><br><span class="line">      diffChildren(parentDom, newVNode, oldVNode, mounts, ancestorComponent, oldDom);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️记录Fragment的起始DOM和结束DOM</span></span><br><span class="line">      <span class="keyword">let</span> i = newVNode._children.length;</span><br><span class="line">      <span class="keyword">if</span> (i &amp;&amp; (tmp = newVNode._children[<span class="number">0</span>]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        newVNode._dom = tmp._dom;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">          tmp = newVNode._children[i];</span><br><span class="line">          <span class="keyword">if</span> (newVNode._lastDomChild = tmp &amp;&amp; (tmp._lastDomChild || tmp._dom))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newType === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️自定义组件类型</span></span><br><span class="line">      <span class="keyword">if</span> (oldVNode._component) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ ️已经存在组件实例</span></span><br><span class="line">        c = newVNode._component = oldVNode._component;</span><br><span class="line">        newVNode._dom = oldVNode._dom;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️初始化组件实例</span></span><br><span class="line">        <span class="keyword">if</span> (newType.prototype &amp;&amp; newType.prototype.render) &#123;</span><br><span class="line">          <span class="comment">// ⚛️类组件</span></span><br><span class="line">          newVNode._component = c = <span class="keyword">new</span> newType(newVNode.props, cctx); <span class="comment">// eslint-disable-line new-cap</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️函数组件</span></span><br><span class="line">          newVNode._component = c = <span class="keyword">new</span> Component(newVNode.props, cctx);</span><br><span class="line">          c.constructor = newType;</span><br><span class="line">          c.render = doRender;</span><br><span class="line">        &#125;</span><br><span class="line">        c._ancestorComponent = ancestorComponent;</span><br><span class="line">        c.props = newVNode.props;</span><br><span class="line">        <span class="keyword">if</span> (!c.state) c.state = &#123;&#125;;</span><br><span class="line">        isNew = c._dirty = <span class="literal">true</span>;</span><br><span class="line">        c._renderCallbacks = [];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      c._vnode = newVNode;</span><br><span class="line">      <span class="keyword">if</span> (c._nextState == <span class="literal">null</span>) c._nextState = c.state;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️getDerivedStateFromProps 生命周期方法</span></span><br><span class="line">      <span class="keyword">if</span> (newType.getDerivedStateFromProps != <span class="literal">null</span>)</span><br><span class="line">        assign(c._nextState == c.state</span><br><span class="line">            ? (c._nextState = assign(&#123;&#125;, c._nextState)) <span class="comment">// 惰性拷贝</span></span><br><span class="line">            : c._nextState,</span><br><span class="line">          newType.getDerivedStateFromProps(newVNode.props, c._nextState),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isNew) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 调用挂载前的一些生命周期方法</span></span><br><span class="line">        <span class="comment">// ⚛️ componentWillMount</span></span><br><span class="line">        <span class="keyword">if</span> (newType.getDerivedStateFromProps == <span class="literal">null</span> &amp;&amp; c.componentWillMount != <span class="literal">null</span>) c.componentWillMount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ componentDidMount</span></span><br><span class="line">        <span class="comment">// 将组件推入mounts数组，在整个组件树diff完成后批量调用, 他们在commitRoot方法中被调用</span></span><br><span class="line">        <span class="comment">// 按照先进后出(栈)的顺序调用, 即子组件的componentDidMount会先调用</span></span><br><span class="line">        <span class="keyword">if</span> (c.componentDidMount != <span class="literal">null</span>) mounts.push(c);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 调用重新渲染相关的一些生命周期方法</span></span><br><span class="line">        <span class="comment">// ⚛️ componentWillReceiveProps</span></span><br><span class="line">        <span class="keyword">if</span> (newType.getDerivedStateFromProps == <span class="literal">null</span> &amp;&amp; force == <span class="literal">null</span> &amp;&amp; c.componentWillReceiveProps != <span class="literal">null</span>)</span><br><span class="line">          c.componentWillReceiveProps(newVNode.props, cctx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ shouldComponentUpdate</span></span><br><span class="line">        <span class="keyword">if</span> (!force &amp;&amp; c.shouldComponentUpdate != <span class="literal">null</span> &amp;&amp; c.shouldComponentUpdate(newVNode.props, c._nextState, cctx) === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="comment">// shouldComponentUpdate返回false，取消渲染更新</span></span><br><span class="line">          c.props = newVNode.props;</span><br><span class="line">          c.state = c._nextState;</span><br><span class="line">          c._dirty = <span class="literal">false</span>;</span><br><span class="line">          newVNode._lastDomChild = oldVNode._lastDomChild;</span><br><span class="line">          <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ componentWillUpdate</span></span><br><span class="line">        <span class="keyword">if</span> (c.componentWillUpdate != <span class="literal">null</span>) c.componentWillUpdate(newVNode.props, c._nextState, cctx);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️至此props和state已经确定下来，缓存和更新props和state准备渲染</span></span><br><span class="line">      oldProps = c.props;</span><br><span class="line">      oldState = c.state;</span><br><span class="line">      c.props = newVNode.props;</span><br><span class="line">      c.state = c._nextState;</span><br><span class="line">      <span class="keyword">let</span> prev = c._prevVNode || <span class="literal">null</span>;</span><br><span class="line">      c._dirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️渲染</span></span><br><span class="line">      <span class="keyword">let</span> vnode = (c._prevVNode = coerceToVNode(c.render(c.props, c.state)));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️getSnapshotBeforeUpdate</span></span><br><span class="line">      <span class="keyword">if</span> (!isNew &amp;&amp; c.getSnapshotBeforeUpdate != <span class="literal">null</span>) snapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️组件层级，会影响更新的优先级</span></span><br><span class="line">      c._depth = ancestorComponent ? (ancestorComponent._depth || <span class="number">0</span>) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// ⚛️递归diff渲染结果</span></span><br><span class="line">      c.base = newVNode._dom = diff(parentDom, vnode, prev, mounts, c, <span class="literal">null</span>, oldDom);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (vnode != <span class="literal">null</span>) &#123;</span><br><span class="line">        newVNode._lastDomChild = vnode._lastDomChild;</span><br><span class="line">      &#125;</span><br><span class="line">      c._parentDom = parentDom;</span><br><span class="line">      <span class="comment">// ⚛️应用ref</span></span><br><span class="line">      <span class="keyword">if</span> ((tmp = newVNode.ref)) applyRef(tmp, c, ancestorComponent);</span><br><span class="line">      <span class="comment">// ⚛️调用renderCallbacks，即setState的回调</span></span><br><span class="line">      <span class="keyword">while</span> ((tmp = c._renderCallbacks.pop())) tmp.call(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️componentDidUpdate</span></span><br><span class="line">      <span class="keyword">if</span> (!isNew &amp;&amp; oldProps != <span class="literal">null</span> &amp;&amp; c.componentDidUpdate != <span class="literal">null</span>) c.componentDidUpdate(oldProps, oldState, snapshot);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️比对两个DOM元素</span></span><br><span class="line">      newVNode._dom = diffElementNodes(oldVNode._dom, newVNode, oldVNode, mounts, ancestorComponent);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((tmp = newVNode.ref) &amp;&amp; oldVNode.ref !== tmp) applyRef(tmp, newVNode._dom, ancestorComponent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ⚛️捕获渲染错误，传递给上级组件的didCatch生命周期方法</span></span><br><span class="line">    catchErrorInComponent(e, ancestorComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newVNode._dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><hr><p><br></p><h3 id="diffelementnodes"><a href="#diffelementnodes" class="headerlink" title="diffElementNodes"></a>diffElementNodes</h3><p>比对两个 DOM 元素, 流程非常简单:</p><center><br>  <img src="/images/07/diffElementNodes-process.png" width="600"><br></center><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffElementNodes</span>(<span class="params">dom, newVNode, oldVNode, mounts, ancestorComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️创建DOM节点</span></span><br><span class="line">  <span class="keyword">if</span> (dom == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVNode.type === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️文本节点, 没有属性和子级，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(newProps);</span><br><span class="line">    &#125;</span><br><span class="line">    dom = <span class="built_in">document</span>.createElement(newVNode.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newVNode.type === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ⚛️文本节点更新</span></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps) dom.data = newProps;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVNode !== oldVNode) &#123;</span><br><span class="line">      <span class="comment">// newVNode !== oldVNode 这说明是一个静态节点</span></span><br><span class="line">      <span class="keyword">let</span> oldProps = oldVNode.props || EMPTY_OBJ;</span><br><span class="line">      <span class="keyword">let</span> newProps = newVNode.props;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ dangerouslySetInnerHTML处理</span></span><br><span class="line">      <span class="keyword">let</span> oldHtml = oldProps.dangerouslySetInnerHTML;</span><br><span class="line">      <span class="keyword">let</span> newHtml = newProps.dangerouslySetInnerHTML;</span><br><span class="line">      <span class="keyword">if</span> (newHtml || oldHtml)</span><br><span class="line">        <span class="keyword">if</span> (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html)</span><br><span class="line">          dom.innerHTML = (newHtml &amp;&amp; newHtml.__html) || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️递归比对子元素</span></span><br><span class="line">      diffChildren(dom, newVNode, oldVNode, context, mounts, ancestorComponent, EMPTY_OBJ);</span><br><span class="line">      <span class="comment">// ⚛️递归比对DOM属性</span></span><br><span class="line">      diffProps(dom, newProps, oldProps, isSvg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><hr><p><br></p><h3 id="diffprops"><a href="#diffprops" class="headerlink" title="diffProps"></a>diffProps</h3><p>diffProps 用于更新 DOM 元素的属性</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">dom, newProps, oldProps, isSvg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(newProps).sort();</span><br><span class="line">  <span class="comment">// ⚛️比较并设置属性</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> k = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (k !== <span class="string">'children'</span> &amp;&amp; k !== <span class="string">'key'</span> &amp;&amp;</span><br><span class="line">      (!oldProps || (k === <span class="string">'value'</span> || k === <span class="string">'checked'</span> ? dom : oldProps)[k] !== newProps[k])) </span><br><span class="line">      setProperty(dom, k, newProps[k], oldProps[k], isSvg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️清空属性</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> oldProps)</span><br><span class="line">    <span class="keyword">if</span> (i !== <span class="string">'children'</span> &amp;&amp; i !== <span class="string">'key'</span> &amp;&amp; !(i <span class="keyword">in</span> newProps))</span><br><span class="line">      setProperty(dom, i, <span class="literal">null</span>, oldProps[i], isSvg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>diffProps 实现比较简单，就是遍历一下属性有没有变动，有变动则通过 setProperty 设置属性。对于失效的 props 也会通过 setProperty 置空。这里面稍微有点复杂的是 setProperty. 这里涉及到事件的处理, 命名的转换等等:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>(<span class="params">dom, name, value, oldValue, isSvg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'style'</span>) &#123;</span><br><span class="line">    <span class="comment">// ⚛️样式设置</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = assign(assign(&#123;&#125;, oldValue), value);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">      <span class="comment">// 样式属性没有变动</span></span><br><span class="line">      <span class="keyword">if</span> ((value || EMPTY_OBJ)[i] === (oldValue || EMPTY_OBJ)[i]) <span class="keyword">continue</span>;</span><br><span class="line">      dom.style.setProperty(</span><br><span class="line">        i[<span class="number">0</span>] === <span class="string">'-'</span> &amp;&amp; i[<span class="number">1</span>] === <span class="string">'-'</span> ? i : i.replace(CAMEL_REG, <span class="string">'-$&amp;'</span>),</span><br><span class="line">        value &amp;&amp; i <span class="keyword">in</span> value</span><br><span class="line">          ? <span class="keyword">typeof</span> <span class="keyword">set</span>[i] === 'number' &amp;&amp; IS_NON_DIMENSIONAL.test(i) === false</span><br><span class="line">            ? <span class="keyword">set</span>[i] + 'px'</span><br><span class="line">            : <span class="keyword">set</span>[i]</span><br><span class="line">          : '', // 清空</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (name[0] === 'o' &amp;&amp; name[1] === 'n') &#123;</span><br><span class="line">    <span class="comment">// ⚛️事件绑定</span></span><br><span class="line">    <span class="keyword">let</span> useCapture = name !== (name = name.replace(<span class="regexp">/Capture$/</span>, <span class="string">''</span>));</span><br><span class="line">    <span class="keyword">let</span> nameLower = name.toLowerCase();</span><br><span class="line">    name = (nameLower <span class="keyword">in</span> dom ? nameLower : name).slice(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      <span class="comment">// ⚛️首次添加事件, 注意这里是eventProxy为事件处理器</span></span><br><span class="line">      <span class="comment">// preact统一将所有事件处理器收集在dom._listeners对象中，统一进行分发</span></span><br><span class="line">      <span class="comment">// function eventProxy(e) &#123;</span></span><br><span class="line">      <span class="comment">//   return this._listeners[e.type](options.event ? options.event(e) : e);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">if</span> (!oldValue) dom.addEventListener(name, eventProxy, useCapture);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      dom.removeEventListener(name, eventProxy, useCapture);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存事件队列</span></span><br><span class="line">    (dom._listeners || (dom._listeners = &#123;&#125;))[name] = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name !== <span class="string">'list'</span> &amp;&amp; name !== <span class="string">'tagName'</span> &amp;&amp; name <span class="keyword">in</span> dom) &#123;</span><br><span class="line">    <span class="comment">// ⚛️DOM对象属性</span></span><br><span class="line">    dom[name] = value == <span class="literal">null</span> ? <span class="string">''</span> : value;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> value !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    name !== <span class="string">'dangerouslySetInnerHTML'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ⚛️DOM元素属性</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">      dom.removeAttribute(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dom.setAttribute(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>OK 至此 Diff 算法介绍完毕，其实这里面的逻辑并不是特别复杂, 当然 Preact 只是一个极度精简的框架，React 复杂度要高得多，尤其 React Fiber 重构之后。你也可以把 Preact 当做 React 的历史回顾，有兴趣再深入了解 React 的最新架构。</p><p><br></p><hr><p><br></p><h2 id="hooks-的实现"><a href="#hooks-的实现" class="headerlink" title="Hooks 的实现"></a>Hooks 的实现</h2><p>React16.8 正式引入的 hooks，这玩意带来了全新的 React 组件开发方式，让代码变得更加简洁。 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a>这篇文章已经揭示了 hooks 的基本实现原理, 它不过是基于数组实现的。preact 也实现了 hooks 机制，实现代码也就百来行，让我们来体会体会.</p><p>hooks 功能本身是没有集成在 Preact 代码库内部的，而是通过<code>preact/hooks</code>导入</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'preact'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'preact/hooks'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mounted'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello hooks<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>那 Preact 是如何扩展 diff 算法来实现 hooks 的呢？ 实际上 Preact 提供了<code>options</code>对象来对 Preact diff 进行扩展，options 类似于 Preact 生命周期钩子，在 diff 过程中被调用(为了行文简洁，上面的代码我忽略掉了)。例如:</p><!-- prettier-ignore-start --><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"><span class="regexp">/*...*/</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️开始diff</span></span><br><span class="line">  <span class="keyword">if</span> ((tmp = options.diff)) tmp(newVNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    outer: <span class="keyword">if</span> (oldVNode.type === Fragment || newType === Fragment) &#123;</span><br><span class="line">      <span class="comment">// Fragment diff</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newType === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 自定义组件diff</span></span><br><span class="line">      <span class="comment">// ⚛️开始渲染</span></span><br><span class="line">      <span class="keyword">if</span> ((tmp = options.render)) tmp(newVNode);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        c.render(c.props, c.state, c.context),</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// ⚛️捕获异常</span></span><br><span class="line">        <span class="keyword">if</span> ((tmp = options.catchRender) &amp;&amp; tmp(e, c)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// DOM element diff</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⚛️diff结束</span></span><br><span class="line">    <span class="keyword">if</span> ((tmp = options.diffed)) tmp(newVNode);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    catchErrorInComponent(e, ancestorComponent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newVNode._dom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><h3 id="usestate"><a href="#usestate" class="headerlink" title="useState"></a>useState</h3><p>先从最常用的 useState 开始:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️OK只是数组，没有Magic，每个hooks调用都会递增currenIndex, 从当前组件中取出状态</span></span><br><span class="line">  <span class="keyword">const</span> hookState = getHookState(currentIndex++);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!hookState._component) &#123;</span><br><span class="line">    hookState._component = currentComponent; <span class="comment">// 当前组件实例</span></span><br><span class="line">    hookState._value = [</span><br><span class="line">      <span class="comment">// ⚛️state, 初始化state</span></span><br><span class="line">      <span class="keyword">typeof</span> initialState === <span class="string">'function'</span> ? initialState() : initialState,</span><br><span class="line">      <span class="comment">// ⚛️dispatch</span></span><br><span class="line">      value =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> nextValue = <span class="keyword">typeof</span> value === <span class="string">'function'</span> ? value(hookState._value[<span class="number">0</span>]) : value;</span><br><span class="line">        <span class="keyword">if</span> (hookState._value[<span class="number">0</span>] !== nextValue) &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 保存状态并调用setState强制更新</span></span><br><span class="line">          hookState._value[<span class="number">0</span>] = nextValue;</span><br><span class="line">          hookState._component.setState(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hookState._value; <span class="comment">// [state, dispatch]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>从代码可以看到，关键在于<code>getHookState</code>的实现</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; options &#125; <span class="keyword">from</span> <span class="string">'preact'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentIndex; <span class="comment">// 保存当前hook的索引</span></span><br><span class="line"><span class="keyword">let</span> currentComponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️render 钩子, 在组件开始渲染之前调用</span></span><br><span class="line"><span class="comment">// 因为Preact是同步递归向下渲染的，而且Javascript是单线程的，所以可以安全地引用当前正在渲染的组件实例</span></span><br><span class="line">options.render = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  currentComponent = vnode._component; <span class="comment">// 保存当前正在渲染的组件</span></span><br><span class="line">  currentIndex = <span class="number">0</span>;                    <span class="comment">// 开始渲染时index重置为0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暂时忽略，下面讲到useEffect就能理解</span></span><br><span class="line">  <span class="comment">// 清空上次渲染未处理的Effect(useEffect)，只有在快速重新渲染时才会出现这种情况，一般在异步队列中被处理</span></span><br><span class="line">  <span class="keyword">if</span> (currentComponent.__hooks) &#123;</span><br><span class="line">    currentComponent.__hooks._pendingEffects = handleEffects(</span><br><span class="line">      currentComponent.__hooks._pendingEffects,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️no magic!, 只是一个数组, 状态保存在组件实例的_list数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHookState</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取或初始化列表</span></span><br><span class="line">  <span class="keyword">const</span> hooks = currentComponent.__hooks ||</span><br><span class="line">    (currentComponent.__hooks = &#123;</span><br><span class="line">      _list: [],                  <span class="comment">// 放置状态</span></span><br><span class="line">      _pendingEffects: [],        <span class="comment">// 放置待处理的effect，由useEffect保存</span></span><br><span class="line">      _pendingLayoutEffects: [],  <span class="comment">// 放置待处理的layoutEffect，有useLayoutEffect保存</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建状态</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= hooks._list.length) &#123;</span><br><span class="line">    hooks._list.push(&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hooks._list[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>大概的流程如下:</p><center><br>  <img src="/images/07/useState.png" width="800"><br></center><p><br></p><h3 id="useeffect"><a href="#useeffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>再看看 useEffect 和 useLayoutEffect. useEffect 和 useLayouteEffect 差不多, 只是触发 effect 的时机不一样，useEffect 在完成渲染后绘制触发，而 useLayoutEffect 在 diff 完成后触发:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123;</span><br><span class="line">    <span class="comment">// ⚛️状态变化</span></span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    currentComponent.__hooks._pendingEffects.push(state); <span class="comment">// ⚛️推进_pendingEffects队列</span></span><br><span class="line">    afterPaint(currentComponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLayoutEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123;</span><br><span class="line">    <span class="comment">// ⚛️状态变化</span></span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    currentComponent.__hooks._pendingLayoutEffects.push(state); <span class="comment">// ⚛️推进_pendingLayoutEffects队列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>看看如何触发 effect. useEffect 和上面看到的<code>enqueueRender</code>差不多，放进一个异步队列中，由<code>requestAnimationFrame</code>进行调度，批量处理:</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个类似于上面提到的异步队列</span></span><br><span class="line">afterPaint = <span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!component._afterPaintQueued &amp;&amp; <span class="comment">// 避免组件重复推入</span></span><br><span class="line">    (component._afterPaintQueued = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">    afterPaintEffects.push(component) === <span class="number">1</span> <span class="comment">// 开始调度</span></span><br><span class="line">  )</span><br><span class="line">    requestAnimationFrame(scheduleFlushAfterPaint);  <span class="comment">// 由requestAnimationFrame调度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleFlushAfterPaint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(flushAfterPaintEffects);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushAfterPaintEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  afterPaintEffects.some(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    component._afterPaintQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (component._parentDom)</span><br><span class="line">      <span class="comment">// 清空_pendingEffects队列</span></span><br><span class="line">      component.__hooks._pendingEffects = handleEffects(component.__hooks._pendingEffects);</span><br><span class="line">  &#125;);</span><br><span class="line">  afterPaintEffects = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEffects</span>(<span class="params">effects</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先清除后调用effect</span></span><br><span class="line">  effects.forEach(invokeCleanup); <span class="comment">// 请调用清理</span></span><br><span class="line">  effects.forEach(invokeEffect);  <span class="comment">// 再调用effect</span></span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCleanup</span>(<span class="params">hook</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hook._cleanup) hook._cleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeEffect</span>(<span class="params">hook</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = hook._value();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">'function'</span>) hook._cleanup = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p><br></p><p>再看看如何触发 LayoutEffect, 很简单，在 diff 完成后触发, 这个过程是同步的.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options.diffed = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c = vnode._component;</span><br><span class="line">  <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> hooks = c.__hooks;</span><br><span class="line">  <span class="keyword">if</span> (hooks) &#123;</span><br><span class="line">    hooks._pendingLayoutEffects = handleEffects(hooks._pendingLayoutEffects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>👌，hooks 基本原理基本了解完毕, 最后还是用一张图来总结一下吧。</p><center><br>  <img src="/images/07/hooks.png" width="800"><br></center><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><p>文章篇幅很长，主要是太多代码了, 我自己也不喜欢看这种文章，所以没期望读者会看到这里. 后面文章再想办法改善改善. 谢谢你阅读到这里。</p><p>本期的主角本身是一个小而美的视图框架，没有其他技术栈. 这里就安利一下 Preact 作者<a href="https://github.com/developit" target="_blank" rel="noopener">developit</a>的另外一些小而美的库吧.</p><ul><li><a href="https://github.com/developit/workerize" target="_blank" rel="noopener">Workerize</a> 优雅地在 webWorker 中执行和调用程序</li><li><a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> 零配置的库打包工具</li><li><a href="https://github.com/developit/greenlet" target="_blank" rel="noopener">greenlet</a> 和 workerize 差不多，这个将单个异步函数放到 webworker 中执行，而 workerize 是将一个模块</li><li><a href="https://github.com/developit/mitt" target="_blank" rel="noopener">mitt</a> 200byte 的 EventEmitter</li><li><a href="https://github.com/developit/dlv" target="_blank" rel="noopener">dlv</a> 安全地访问深嵌套的对象属性，类似于 lodash 的 get 方法</li><li><a href="https://github.com/developit/snarkdown" target="_blank" rel="noopener">snarkdown</a> 1kb 的 markdown parser</li><li><a href="https://github.com/developit/unistore" target="_blank" rel="noopener">unistore</a> 简洁类 Redux 状态容器，支持 React 和 Preact</li><li><a href="https://github.com/developit/stockroom" target="_blank" rel="noopener">stockroom</a> 在 webWorker 支持状态管理器</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://juejin.im/entry/59b9284a5188257e6571b9b4" target="_blank" rel="noopener">Preact：Into the void 0（译）</a></li><li><a href="https://auth0.com/blog/face-off-virtual-dom-vs-incremental-dom-vs-glimmer/" target="_blank" rel="noopener">React Virtual DOM vs Incremental DOM vs Ember’s Glimmer: Fight</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路).&lt;/p&gt;
&lt;p&gt;Preact 是 R
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] 💅styled-components 💅</title>
    <link href="https://bobi.ink/2019/05/29/styled-components-map/"/>
    <id>https://bobi.ink/2019/05/29/styled-components-map/</id>
    <published>2019-05-28T16:00:00.000Z</published>
    <updated>2019-06-01T09:18:28.099Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://juejin.im/post/5cdad9c7f265da039b08915d" target="_blank" rel="noopener">React 组件设计实践总结 03 - 样式的管理</a>一文中吹了一波 <a href="https://www.styled-components.com" target="_blank" rel="noopener">styled-components</a> 后，本文想深入来了解一下 styled-components 的原理. 如果你对 styled-components 还不了解，建议先阅读一下官方<a href="http://styled-components.com" target="_blank" rel="noopener">文档</a>或前面的文章.</p><blockquote><p>本文基于 styled-components v4.13 版本</p></blockquote><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#从-tagged-template-literals-说起">从 Tagged Template Literals 说起</a></li><li><a href="#源码导读">源码导读</a><ul><li><a href="#1-处理标签模板字面量">1. 处理标签模板字面量</a></li><li><a href="#2-react-组件的封装">2. React 组件的封装</a></li><li><a href="#3-样式和类名的生成">3. 样式和类名的生成</a></li><li><a href="#4-dom-层操作">4. DOM 层操作</a></li><li><a href="#5-总结">5. 总结</a></li></ul></li><li><a href="#技术地图">技术地图</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="从-tagged-template-literals-说起"><a href="#从-tagged-template-literals-说起" class="headerlink" title="从 Tagged Template Literals 说起"></a>从 Tagged Template Literals 说起</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener"><strong>标签模板字面量(Tagged Template Literals)</strong></a>是 ES6 新增的特性，它允许你<strong>自定义字符串的内插(interpolation)规则</strong>, styled-components 正是基于这个特性构建:</p><center><br>  <img src="/images/06/styled-sample.png" width="400"><br></center><p>它的原理非常简单，所有静态字符串会被拆分出来合并成为数组, 作为第一个参数传入到目标函数，而内插(interpolation)表达式的值则会作为 rest 参数传入:</p><center><br>  <img src="/images/06/tag-template.png" width="400"><br></center><p><strong>标签模板字面量相比普通的模板字面量更加灵活. 普通模板字符串会将所有内插值转换为字符串，而<code>标签模板字面量</code>则由你自己来控制</strong>:</p><center><br>  <img src="/images/06/tag-template-pros.png" width="600"><br></center><p>因为标签模板字符串简洁的语法和灵活性，它比较适用于作为<code>DSL</code>, 不需要在语言层面进行支持，比如前阵子<a href="https://github.com/preactjs/preact" target="_blank" rel="noopener">preact</a>作者开发的<a href="https://github.com/developit/htm" target="_blank" rel="noopener">htm</a>, 口号就是”取代 JSX，而且不需要编译器支持”, 通过这种方式是可以优雅地实现<a href="https://juejin.im/post/5ceacf09e51d454f73356cc4" target="_blank" rel="noopener">‘你的网站或许不需要前端构建’</a>.</p><center><br>  <img src="/images/06/htm.png" width="700"><br></center><p>另一个典型的例子就是 <code>jest</code> 的<a href="https://jestjs.io/docs/en/api#testeachtable-name-fn-timeout" target="_blank" rel="noopener"><code>表格测试</code></a>, 这样形式可读性更高:</p><center><br>  <img src="/images/06/jest.png" width="700"><br></center><p>标签模板字面量的脑洞还在继续，比如可以用来写 markdown，再生成 react 组件。限于篇幅就不啰嗦了</p><p>扩展:</p><ul><li><a href="https://mxstbr.blog/2016/11/styled-components-magic-explained/" target="_blank" rel="noopener">The magic behind 💅 styled-components</a></li></ul><p><br></p><hr><p><br></p><h2 id="源码导读"><a href="#源码导读" class="headerlink" title="源码导读"></a>源码导读</h2><p>现在来看一下 styled-components 的实现。为了行文简洁，我们只关心 styled-components 的核心逻辑，所以我对源代码进行了大量的简化，比如忽略掉服务端渲染、ReactNative 实现、babel 插件等等.</p><h3 id="1-处理标签模板字面量"><a href="#1-处理标签模板字面量" class="headerlink" title="1. 处理标签模板字面量"></a>1. 处理标签模板字面量</h3><p>先从 <code>styled</code> 构造函数看起:</p><center><br>  <img src="/images/06/styled-code.png" width="500"><br></center><p>styled 构造函数接收一个包装组件 target，而标签模板字面量则由<a href="https://www.styled-components.com/docs/api#css" target="_blank" rel="noopener"><code>css</code></a>函数进行处理的. 这个函数在 styled-components 中非常常用，类似于 <code>SCSS</code> 的 <code>mixin</code> 角色. <code>css</code> 函数会标签模板字面量规范化, 例如:</p><center><br>  <img src="/images/06/css.png" width="750"><br></center><p> css 实现也非常简单:</p><center><br>  <img src="/images/06/css-code.png" width="700"><br></center><p><code>interleave</code>函数将将静态字符串数组和内插值’拉链式‘交叉合并为单个数组, 比如[1, 2] + [a, b]会合并为[1, a, 2, b]</p><p>关键在于如何将数组进行扁平化, 这个由 <code>flatten</code> 函数实现. flatten 函数会将嵌套的 css(数组形式)递归 concat 在一起，将 StyledComponent 组件转换为类名引用、还有处理 keyframe 等等. 最终剩下静态字符串和函数, 输出结果如上所示。</p><p><strong>实际上 styled-components 会进行两次 flatten，第一次 flatten 将能够静态化的都转换成字符串，将嵌套的 css 结构打平, 只剩下一些函数，这些函数只能在运行时(比如在组件渲染时)执行；第二次是在运行时，拿到函数的运行上下文(props、theme 等等)后, 执行所有函数，将函数的执行结果进行递归合并，最终生成的是一个纯字符串数组</strong>. 对于标签模板字面量的处理大概都是这个过程. 看看 flatten 的实现:</p><center><br>  <img src="/images/06/flatten-code.png" width="700"><br></center><p>总结一下标签模板字面量的处理流程大概是这样子:</p><center><br><img src="/images/06/flatten.png" width="700"><br></center><p><br></p><hr><p><br></p><h3 id="2-react-组件的封装"><a href="#2-react-组件的封装" class="headerlink" title="2. React 组件的封装"></a>2. React 组件的封装</h3><p>现在看看如何构造出 React 组件。styled-components 通过 createStyledComponent 高阶组件将组件封装为 StyledComponent 组件:</p><center><br><img src="/images/06/create-component.png" width="800"><br></center><p>createStyledComponent 是一个典型的高阶组件，它在执行期间会生成一个唯一的组件 id 和创建<code>ComponentStyle</code>对象. ComponentStyle 对象用于维护 css 函数生成的 cssRules, 在运行时(组件渲染时)得到执行的上下文后生成最终的样式和类名。</p><p>再来看看 StyledComponent 的实现, StyledComponent 在组件渲染时，将当前的 props+theme 作为 context 传递给 ComponentStyle，生成类名.</p><center><br><img src="/images/06/StyledComponent.png" width="800"><br></center><p><br></p><hr><p><br></p><h3 id="3-样式和类名的生成"><a href="#3-样式和类名的生成" class="headerlink" title="3. 样式和类名的生成"></a>3. 样式和类名的生成</h3><p>上面看到 StyleComponent 通过 ComponentStyle 类来构造样式表并生成类名, ComponentStyle 拿到 context 后，再次调用 flatten 将 css rule 扁平化，得到一个纯字符串数组。通过使用 hash 算法生成类名, 并使用stylis 对样式进行预处理. 最后通过 StyleSheet 对象将样式规则插入到 DOM 中</p><center><br><img src="/images/06/ComponentStyle.png" width="800"><br></center><p><a href="https://github.com/thysultan/stylis.js/blob/master/README.md" target="_blank" rel="noopener">stylis</a>是一个 3kb 的轻量的 CSS 预处理器, styled-components 所有的 CSS 特性都依赖于它， 例如嵌套规则(<code>a {&amp;:hover{}}</code>)、厂商前缀、压缩等等.</p><p><br></p><hr><p><br></p><h3 id="4-dom-层操作"><a href="#4-dom-层操作" class="headerlink" title="4. DOM 层操作"></a>4. DOM 层操作</h3><p>现在来看一下 StyleSheet, StyleSheet 负责收集所有组件的样式规则，并插入到 DOM 中</p><center><br><img src="/images/06/StyleSheet.png" width="800"><br></center><p>看看简化版的 makeTag</p><center><br><img src="/images/06/makeTag.png" width="800"><br></center><p><br></p><hr><p><br></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>代码可能看晕了，通过流程图来梳理一下过程.</p><blockquote><p>上一篇文章<a href="https://juejin.im/post/5cedb26451882566477b7235" target="_blank" rel="noopener">技术地图 - vue-cli</a>一点代码也没有罗列，只有一个流程图, 读者可能一下子就傻眼了, 不知道在说些什么; 而且这个流程图太大，在移动端不好阅读. 这期稍微改进一下，新增’源码导读‘一节，代码表达能力毫无疑问是胜于流程图的，但是代码相对比较细节琐碎，所以第一是将代码进行简化，留下核心的逻辑，第二是使用流程图表示大概的程序流程，以及流程主体之间的关系.</p></blockquote><p><img src="/images/06/process.png" alt></p><p><br></p><p>如上图 styled-components 主要有四个核心对象:</p><ul><li><strong>WrappedComponent</strong>: 这是 createStyledComponent 创建的包装组件，这个组件保存的被包装的 target、并生成组件 id 和 ComponentStyle 对象</li><li><strong>StyledComponent</strong>: 这是样式组件，在它 render 时会将 props 作为 context 传递给 ComponentStyle，并生成类名</li><li><strong>ComponentStyle</strong>: 负责生成最终的样式表和唯一的类名，并调用 StyleSheet 将生成的样表注入到文档中</li><li><strong>StyleSheet</strong>: 负责管理已生成的样式表, 并注入到文档中</li></ul><p><br></p><p><strong>styled-components 性能优化建议</strong></p><p>styled-components 每次渲染都会重新计算 cssRule，并进行 hash 计算出 className，如果已经对应的 className 还没插入到样式表中，则使用 stylis 进行预处理，并插入到样式表中; </p><p>另外 styled-components 对静态 cssRule(没有任何内插函数)进行了优化，它们不会监听 ThemeContext 变化, 且在渲染时不会重新计算。</p><p>通过这些规则可以得出以下性能优化的建议:</p><ul><li><strong>静态化的 cssRule 性能是最好的</strong></li><li><p><strong>降低 StyledComponent 状态复杂度</strong>. styled-components 并不会对已有的不变的样式规则进行复用，一旦状态变化 styled-component 会生成一个全新的样式规则和类名. 这是最简单的一种实现, 避免了样式复用的复杂性，同时保持样式的隔离性, 问题就是会产生样式冗余。 例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo = styled.div&lt;&#123; active: boolean &#125;&gt;`</span><br><span class="line">  color: red;</span><br><span class="line">  background: $&#123;props =&gt; (props.active ? &apos;blue&apos; : &apos;red&apos;)&#125;;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>active 切换之间会生成两个类名:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cQAOKL</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.kklCtT</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把 StyledComponent 看做是一个状态机，那么 styled-components 可能会为每一个可能的状态生成独立的样式. 如果 StyledComponent 样式很多, 而且状态比较复杂，那么会生成很多冗余的样式.</p></li><li><p>❌ <strong>不要用于动画</strong>。上面了解到 styled-component 会为每个状态生成一个样式表. 动画一般会有很多中间值，在短时间内进行变化，如果动画值通过props传入该StyledComponent来应用样式，这样会生成很多样式，性能非常差:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Bar = styled.div&lt;&#123; width: boolean &#125;&gt;`</span><br><span class="line">  color: red;</span><br><span class="line">  // 千万别这么干</span><br><span class="line">  width: $&#123;props =&gt; props.width&#125;;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>这种动画场景最好使用 style 内联样式来做</p></li></ul><p><br></p><p>OK, 行文结束。styled-components 不过如此是吧？</p><p><br></p><hr><p><br></p><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><ul><li><strong>CSS 相关</strong><ul><li>@emotion/unitless 判断属性值是否需要单位</li><li>css-to-react-native 将 css 转换为 ReactNative style 属性</li><li>✨<a href="https://www.npmjs.com/package/bundlesize" target="_blank" rel="noopener">stylis</a> 轻量的 CSS 预处理器</li></ul></li><li><strong>React 相关</strong><ul><li>@emotion/is-prop-valid 判断是否是合法的 DOM 属性</li><li><a href="https://www.npmjs.com/package/hoist-non-react-statics" target="_blank" rel="noopener">hoist-non-react-statics</a> 提升React组件的静态属性，用于高阶组件场景</li><li>✨<a href="https://www.npmjs.com/package/react-is" target="_blank" rel="noopener">react-is</a>: 判断各种 React 组件类型</li><li><a href="https://github.com/lelandrichardson/react-primitives#readme" target="_blank" rel="noopener">react-primitives</a> 这是一个有意思的库，这个库试图围绕着构建 React 应用提出一套理想的原语，通俗的说就是通过它可以导入不同平台的组件。</li><li><a href="https://github.com/ryanseddon/react-frame-component" target="_blank" rel="noopener">react-frame-component</a> 将react渲染到iframe中。也是一个比较有意思的库</li><li><a href="https://www.npmjs.com/package/react-live" target="_blank" rel="noopener">react-live</a> react实时编辑器和展示，主要用于文档</li></ul></li><li><strong>构建相关</strong><ul><li><a href="https://github.com/siddharthkp/bundlesize#readme" target="_blank" rel="noopener">bundlesize</a> 检查包大小</li><li><a href="https://github.com/codemod-js/codemod/blob/master/packages/cli/README.md" target="_blank" rel="noopener">codemod</a> 使用babel-plugin来重写Javascript或Typescript代码， 一般用于制作升级脚本</li><li>✨<a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> 一个零配置的打包器，基于Rollup，可以用于库的打包和开发, preact作者开发必属精品</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://juejin.im/post/5cdad9c7f265da039b08915d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React 组件设计实践总结 03 - 样式的管理&lt;/a&gt;一文中吹了一波 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[技术地图] vue-cli</title>
    <link href="https://bobi.ink/2019/05/26/vue-cli-map/"/>
    <id>https://bobi.ink/2019/05/26/vue-cli-map/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2019-06-01T08:15:46.354Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个新开的’实验性’文章系列，如其名‘技术地图’，这个系列计划剖析一些前端开源项目，可能会探讨这些项目的<strong>设计和组织</strong>、整理他们使用到<strong>技术栈</strong>。 首先拿<code>vue-cli</code>小试牛刀，再决定后续要不要继续这个系列.</p><p><br></p><p>我一直在思考我们编程主要在做什么？我们有一大部分工作就是选择各种工具/库/框架，来黏合业务. 工具和场景越匹配、原理了解越多，运用越娴熟，我们效率可能就越高. 这种说法很有争议，就像<code>程序=算法+数据结构</code>不能完全表达现今的软件工程一样, 说我们的工作就是堆砌工具，黏合业务, 一定程度上有自贬的意思。 但这确实是大部分程序员的真实写照。</p><p>这系列文章其实有点类似于 github 上面的<code>Awesome</code>项目. 这些 Awesome 项目就是一个<strong>生态展览馆</strong>, 里面项目琳琅满目. 因为数量太多了，而且缺少评分机制，大部分情况我们不可能一个个去查看，很难从中选择符合需求的项目(当然你带着明确的目的，且目标范围非常小，可能比较有用)。</p><center><br><img src="/images/05/awesome.png" width="400"><br></center><p>是否可以尝试换个角度，<strong>选取一些有趣的开源项目，看看它是怎么应用这些工具的, 有序的罗列出来? 对于有相同场景的项目, 参考或者模仿价值可能会更大一些</strong>. 这些开源项目就是巨人，站在巨人肩膀上显然省事多了</p><p>只是技术栈罗列未免过于简单，笔者还希望从这些项目中学点东西，比如他的设计和项目组织. 我会尝试简化和通俗解释里面的关键知识或亮点, 但是不求甚解。为了避免陷入细节泥潭，我会尽量使用图形化方式展示他们程序流程，避免拘泥于细节。你也可以把这些文章作为深入阅读这些项目源码的引导</p><p>我也希望读者同我交流反馈，共同学习和进步。</p><p><br></p><hr><p><br></p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>说到 CLI, 不得不提<a href="https://ruby-china.github.io/rails-guides/getting_started.html" target="_blank" rel="noopener">Rails</a>框架，它可能是<em>框架提供 CLI 的先祖</em>(具体历史没有深入考究). Rails 有一个重要的指导思想，即<strong>约定大于配置</strong>, <strong>它为 Web 应用的大多数需求都提供了最好的解决方法，并且默认使用这些约定，而不是在长长的配置文件中设置每个细节</strong>。</p><p><strong>CLI 也是这个指导思想下的产物</strong>, 例如通过它提供的 CLI，可以在<a href="https://ruby-china.github.io/rails-guides/getting_started.html" target="_blank" rel="noopener">15 分钟内构建一个简易的博客</a>, 可以通过 CLI 启动服务器和 REPL、生成项目脚手架、生成代码文件、路由、数据库迁移等等:</p><center><br>  <img src="/images/05/rails-cli.png" width="500"><br></center><p>Rails 的很多设计在那个年代就是就是一个明星(闪瞎 PHP、JSP、 ASP…, 想想要配置各种服务器，各种 xml 文件)，它的很多设计模式深刻影响了后面的 web 框架，比如 Django、Laravel, 甚至很多模仿 Rails 命名的，如 Sails、Grails.</p><p>Rails 对于前端开发影响也很深远，比如在 Nodejs 出来之前，Rails 社区就开始使用 <code>coffeescript + sass</code>预编译语言进行前端开发了, <a href="https://ruby-china.github.io/rails-guides/asset_pipeline.html" target="_blank" rel="noopener">Asset Pipeline</a>可以说是最早的’前端工程化’, 配合<a href="https://github.com/turbolinks/turbolinks" target="_blank" rel="noopener">Turbolink</a>可以让传统后端渲染页面拥有不亚于单页应用的用户体验…</p><p>当初 Rails 给我带来的各种震撼还历历在目, <a href="https://ruby-china.org" target="_blank" rel="noopener">Ruby China 社区</a>也是国内最好社区之一. 但是目前 Rails 的关注度不如从前, 在前端社区像 Rails 这种集大成的框架也早已不吃香(参考 Ember, 某种程度上 Angular 也算吧?).</p><p>说实在话如果一生只学一门语言，我会选 Ruby，如果选一个 web 框架，那就是 Rails。</p><p>推荐大家阅读<a href="https://ruby-china.org/wiki/the-rails-doctrine" target="_blank" rel="noopener">The Rails Doctrine - Rails 信条</a> 这篇文章里面有一句话笔者非常喜欢: <strong>“只要放下了自负的个人喜好，便可以跳过无谓的世俗决定，专注在最重要的地方下更快的决定。”</strong>。为人写程序，而不是为了机器写程序.</p><p><strong>约定大于配置</strong>可以减少我们做决定的数量，减少无谓的争论和考虑，让我们可以专注于更重要的事情. 这个原则可以提高开发和团队协作效率, 甚至可以凝聚一个社区.</p><p>以 Webpack 为例，恶心复杂的配置被人诟病，所以才需要 vue-cli 或者 create-react-app 这些工具.</p><blockquote><p>没有用 Ruby/Rails 工作过, 默默写了个 Ruby China 小程序(微信搜<code>Ruby CN</code>)，算是感恩回馈社区吧</p></blockquote><p><br></p><p>Ok, 忍不住吹了一波 Rails, 回到正题.</p><p>笔者是使用 React 作为主力开发的，Vue 也是我非常喜欢的一个开源项目，不说别的，在开发者的’用户体验’方面 Vue 是我见过最好之一，主要体现在 API 的简洁性和易用性、文档还有项目构建工具(今天的主角).</p><p>vue-cli-ui 是我想写这系列文章的动机之一. 前阵子用了一下<code>vue-cli-ui</code>, 感觉很不错, 支持可视化配置和任务运行，比我在终端下一个项目一个项目跑 task 清爽多了. 很想在我们自家的构建工具上也搞一套，怎搞？ 学习它的源码, 我觉得可以作为博客记录下来.</p><p>现在前端工程师也有‘webpack 配置工程师’的戏称，这能说明 webpack 配置是费时费力的苦事(Angular 例外). 这不后来就有了<code>parcel</code>宣称零配置的轮子, 还有 React 社区的<code>create-react-app</code>, vue-cli 前期是基于模板的创建项目, 不算此列。</p><p>后来 vue-cli 汲取着前者的很多优点，把这块做大做优了(看来 vue 很擅长做这些事情). 我们可以来对比一下这些工具:</p><p><br></p><table><thead><tr><th></th><th>Vue CLI</th><th>create-react-app</th><th>parcel</th></tr></thead><tbody><tr><td>快速原型开发</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>全局模式</td><td>零配置原型开发就是全局的</td><td>-</td><td>支持</td></tr><tr><td>插件</td><td>支持</td><td>-</td><td>支持，扩展文件类型和文件输出</td></tr><tr><td>扩展性</td><td>强，通过插件扩展 wepack 配置</td><td>弱, 强约定, 无法配置 webpack，可以 eject, 然后手工配置；支持 babel-macro;(严格说可以通过<a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">react-app-rewired</a>进行扩展)</td><td>中(可以配置 babel，postcss，Typescript); 提供了 Node API; 支持插件扩展文件类型</td></tr><tr><td>多页面</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>适用范围</td><td>Vue 组件的第一公民。通过扩展可以支持任意前端框架</td><td>针对 React 开发，不支持其他框架</td><td>parcel 是一个通用的打包工具，它的竞争对手是 webpack</td></tr><tr><td>编译速度</td><td>cache-loader,thread-loader 来加速 JS 和 TS 编译</td><td>babel-loader 开启了 cache</td><td>编译速度号称是 webpack 的两倍</td></tr><tr><td>可升级性</td><td>支持升级 cli-service, 插件需要单独升级, 插件需要遵循语义化版本. 太多插件存在升级风险</td><td>支持升级 react-script, 官方维护，且强约定基本可以保障向下兼容</td><td>支持升级 parcel-bundler</td></tr><tr><td>UI</td><td>图形化管理是 CLI 的特色之一</td><td>-</td><td>-</td></tr></tbody></table><p><br></p><p>通过上面的对比，可以看出 <strong>vue-cli 是一个扩展性非常强的构建工具，以致于它不仅限于 Vue，也可以用来构建 React 甚至其他前端框架</strong>。</p><p>相比而言 <code>create-react-app</code> 就是一个非常 Opinionated(坚持己见) 的工具，强约定. 一个典型的例子就是它不内置开启 babel 装饰器转译，CRA 团队认为已经废弃(或者不成熟)的语言特性不应该带到 CRA 中; 后面为了给‘优雅’地给 babel 扩展插件，就捣鼓出来了<code>babel-macro</code>, 这是一种’免配置’的 babel 插件规范.</p><p>这种强约定也是有好处的，比如不需要管理配置; 而且 CRA 团队谨慎可靠地维护着 CRA，这使得开发者可以一般无痛地升级 CRA. 如果要扩展 webpack，一般只有 eject，这就走回了手动配置 webpack 的老路, 不可取.</p><p>vue-cli 也是一个’渐进式’的 cli，vue-cli 提供了默认的 preset，但不阻止你对其进行扩展. vue-cli 的扩展接口也非常简洁(合理, 不多不少), 还有 UI 管理界面，可视化管理项目的配置和插件，用户体验很棒，计划在下一篇文章介绍 vue ui. 唯一比较不舒服的是如果滥用这种扩展性，装 N 多插件，而且插件之间还存在依赖关系时，也会成为升级维护的负担.</p><p><br></p><hr><p><br></p><h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>注意，本文不是 vue-cli 的教程，最好的教程是<a href="https://cli.vuejs.org/zh/dev-guide/plugin-dev.html#prompts" target="_blank" rel="noopener">官方文档</a>.</p><p><br></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>下面是 vue-cli 的基本目录结构. 大部分大型的前端项目都使用 lerna 实现 mono-repo 模式, 然后统一分发到 npm. 这种模式有利于项目模块组织</p><center><br>  <img src="/images/05/vue-cli-struct.png" width="700"><br></center><p><br></p><h3 id="分离-cli-层和-service-层"><a href="#分离-cli-层和-service-层" class="headerlink" title="分离 CLI 层和 Service 层"></a><strong>分离 CLI 层和 Service 层</strong></h3><p>这个设计是借鉴<code>create-react-app</code>的, CLI 层只是一些基础的命令一般不需要频繁升级，而且是全局安装; 而 Service 层是多变的, 作为项目的局部依赖，不应该硬编码在 CLI 里面. CLI 和 Service 的职责划分如下:</p><p><br></p><ul><li><p>CLI: 用于项目创建和管理</p><ul><li>全局安装</li><li><code>vue create</code> 创建项目脚手架. 拉取最新的 Service，并选择配置需要的插件</li><li><code>vue ui</code>. 启动 UI 管理界面</li><li>快速原型开发: <code>vue serve</code> | <code>vue build</code>, 直接伺服和编译一个 Vue 文件</li><li>插件管理: <code>vue add</code> | <code>vue invoke</code> 安装插件和调用插件生成器</li></ul></li><li><p>Service: 负责项目的实际构建</p><ul><li>局部安装</li><li>集成 webpack 构建环境，<strong>Service 本身只有一个插件机制, 所有构建相关逻辑都由内置插件和外部插件提供</strong></li><li>内置插件(命令): serve, build, inspect</li></ul></li></ul><p><br><br><br></p><h3 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a><strong>插件系统</strong></h3><p>vue-cli 提供了类似 babel、eslint 的插件机制。</p><center><br>  <img src="/images/05/plugins.png" width="400"><br></center><p><br></p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a><strong>插件</strong></h4><p>插件机制是 vue-cli 的核心, 用于扩展 Service. Service 的<code>命令</code>和 webpack 配置都由插件提供.</p><p>其实插件机制本身并没有什么技术难度, 换句话说<strong>插件其实就是一个协议的设计</strong>. vue-cli 插件的协议如下:</p><ul><li><strong>命名</strong>: <code>@vue/cli-plugin-*</code>或<code>vue-cli-plugin-*</code>. package.json 中按着这个命名约定的依赖会被识别为 vue-cli 插件，另外命名约定也有利于在 github 或 npm 上筛选</li><li><strong>生命周期</strong>:<br>一个插件的生命周期可以分为<code>安装阶段</code>和<code>运行阶段</code>. <code>vue create</code>命令创建项目脚手架、<code>vue add</code>以及<code>vue invoke</code>插件安装命令都属于安装阶段; 而 cli-service 命令执行时属于运行阶段.</li><li><p><strong>基本结构</strong>: 区分了生命周期后，插件的结构就比较清晰了:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── generator.js  # generator (可选)</span><br><span class="line">├── prompts.js    # prompt 文件 (可选)</span><br><span class="line">├── index.js      # service 插件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><ul><li>安装阶段:<ul><li>prompts: 收集用户意见和配置</li><li>gernerator: 在安装阶段生成模板文件</li></ul></li><li>运行时: index.js<ul><li>注入 service 命令</li><li>扩展和修改 webpack 配置. vue-cli 通过<code>webpack-chain</code>和<code>webpack-merge</code>来实现 webpack 可配置化</li></ul></li></ul></li></ul><p><br></p><p>一个简单的插件结构是这样子的:</p><center><br>  <img src="/codes/vue-plugin.png" width="600"><br></center><p><br></p><h4 id="preset"><a href="#preset" class="headerlink" title="preset"></a><strong>preset</strong></h4><p>这个 preset 和 babel 的 preset 概念实际上是不一样的:</p><p><strong>vue-cli 的 preset 一个脚手架创建方案</strong>, 也就是说它只作用于<code>vue create</code>阶段。比如<code>vue create</code>时默认使用的就是 babel+eslint preset. preset 可以简化项目脚手架的创建。<strong>团队可以共享一个 preset 来创建脚手架</strong>。</p><p><strong>而 babel 中的 preset 是一个插件集合，他可以统一收纳和管理一组插件方案</strong>. 例如<code>babel-preset-react</code>、 <code>babel-preset-env</code>. 上文说到如果扩展性被滥用，装 N 多插件，而且插件之间还存在依赖关系时，也会成为升级维护的负担. 而 ‘babel 式’的 preset 可以让插件更方便维护和和<strong>一键式升级</strong>。</p><p>尽管目前 vue 也提供了<code>vue upgrade</code>对插件进行升级，这个是基于语义化版本约定的, 且当插件之间存在依赖关系时, 不排除升级存在风险. 尤其对于团队项目还是推荐有统一地管理这些插件, 实现傻瓜化的升级。 实际上这种 ‘babel 式’的 preset 是可以通过 vue-plugin 实现和转发的。</p><p><br></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h4><p>vue 支持在 package.json 的 <code>vue</code> 字段或<code>vue.config.js</code>中进行配置。这里可以对 Service 核心功能和插件进行配置, 也可以直接修改 webpack 配置. 另外部分构建行为是通过环境变量进行影响的，这些可以通过<code>.env.*</code>文件进行配置</p><p><br></p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a><strong>基本流程</strong></h3><p>现在来看看一个 vue-cli 内部的基本流程, Service 的插件实现是 vue-cli 比较有意思的点. 以<code>vue serve</code>为例:</p><center><br>  <img src="/images/05/vue-cli.png"><br></center><p>Service 对象是 vue-cli 的核心对象，负责管理和应用插件，所有命令和 webpack 配置都是以插件的形式存在:</p><center><br>  <img src="/images/05/vue-service-struct.png" width="700"><br></center><p><strong>首先划分为配置阶段和运行阶段</strong>。 配置阶段 vue-cli 会加载配置文件，并查找和应用所有插件。将 PluginAPI 实例和项目配置传递给插件运行时, 插件运行时通过 PluginAPI 注入命令(registerCommand)和 扩展 webpack 配置(chainWebpack, configureWebpack).</p><p>运行阶段则根据用户传入的命令名调用插件注入命令。在命令实现函数中，可以调用 resolveWebpackConfig()来生成最终的 webpack 配置。以 serve 命令为例，获取到 webpackConfig 后会创建一个 webpack 编译器，并开启 webpack-dev-server 开发服务器.</p><p><br></p><h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><ul><li><strong>组织</strong><ul><li><a href="http://lernajs.io" target="_blank" rel="noopener">lerna</a></li></ul></li><li><strong>cli 命令行相关工具</strong><ul><li><a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a>: 命令行字体颜色样式</li><li><a href="https://www.npmjs.com/package/cli-highlight" target="_blank" rel="noopener">cli-highlight</a>: 终端语法高亮输出, 类似于 Highlight.js</li><li><a href="https://www.npmjs.com/package/cliui" target="_blank" rel="noopener">cliui</a>: 在终端中进行多列输出</li><li><a href="https://github.com/dcporter/didyoumean.js" target="_blank" rel="noopener">didyoumean</a>: 根据单词相似度，来对用户输入纠正提示</li><li><a href="https://www.npmjs.com/package/semver" target="_blank" rel="noopener">semver</a>: 提供语义化版本号相关的工具函数。 例如比较，规范化</li><li><a href="https://github.com/tj/commander.js#readme" target="_blank" rel="noopener">commander</a> TJ 写的命令行选项和参数解析器，支持子命令，选项校验和类型转换，帮组信息生成等等. API 简单优雅</li><li><a href="https://www.npmjs.com/package/minimist" target="_blank" rel="noopener">minimist</a>: 一个极简的命令行参数解析器。如果只是简单的选项解析，可以用这个库</li><li><a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noopener">inquirer</a> 命令行询问</li><li><a href="https://github.com/sindresorhus/ora" target="_blank" rel="noopener">ora</a> 命令行 spinner</li><li><a href="https://github.com/yyx990803/launch-editor" target="_blank" rel="noopener">launch-editor</a> 打开编辑器. 通过 node 打开编辑器，前端可以 express 暴露接口调用打开</li><li><a href="https://www.npmjs.com/package/open" target="_blank" rel="noopener">open</a> 打开 URL、文件、可执行文件</li><li><a href="https://www.npmjs.com/package/execa" target="_blank" rel="noopener">execa</a> 更好的 child_process，修复了原生 exec 的一些问题</li><li>validate-npm-package-name: 验证 npm 包名称，比如创建的项目名是否合法</li><li><a href="https://www.npmjs.com/package/dotenv" target="_blank" rel="noopener">dotenv</a> &amp; <a href="https://www.npmjs.com/package/dotenv-expand" target="_blank" rel="noopener">dotenv-expand</a>: 从.env 文件中加载配置，环境变量</li></ul></li><li><strong>网络相关</strong><ul><li><a href="https://www.npmjs.com/package/portfinder" target="_blank" rel="noopener">portfinder</a>: 获取可用的端口</li><li><a href="https://www.npmjs.com/package/address" target="_blank" rel="noopener">address</a>: 获取当前主机的 ip，MAC 和 DNS 服务器</li></ul></li><li><strong>文件处理相关</strong><ul><li><a href="https://www.npmjs.com/package/slash" target="_blank" rel="noopener">slash</a> 一致化处理路径中的分隔符</li><li><a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="noopener">fs-extra</a> node fs 模块扩展</li><li>globby: glob 模式匹配</li><li>rimraf 跨平台文件删除命令</li><li><a href="https://www.npmjs.com/package/memfs" target="_blank" rel="noopener">memfs</a> 兼容 Node fs API 的内存文件系统</li></ul></li><li><strong>数据检验</strong><ul><li><a href="https://www.npmjs.com/package/@hapi/joi" target="_blank" rel="noopener">@hapi/joi</a> JSON schema 校验</li></ul></li><li><strong>调试</strong><ul><li><a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">debug</a>: 这是一个 debug 日志利器, 支持通过环境变量或动态设置来确定是否需要输出; 支持 printf 风格格式化</li></ul></li><li><strong>算法</strong><ul><li>hash-sum: 散列值计算</li><li>deepmerge 深合并</li></ul></li><li><strong>其他</strong><ul><li><a href="https://github.com/benjamn/recast" target="_blank" rel="noopener">recast</a> Javascript 语法树转换器，支持非破坏性的格式化输出. 常用于扩展 js 代码</li><li><a href="https://www.npmjs.com/package/javascript-stringify" target="_blank" rel="noopener">javascript-stringify</a>: 类似于 JSON.stringify, 将对象字符串化。</li></ul></li><li><strong>webpack</strong><ul><li>配置定义<ul><li>webpack-merge: 合并 webpack 配置对象</li><li>webpack-chain: 链式配置 webpack. 这两个库是 vue-cli 插件的重要成员</li></ul></li><li>webpack-dev-server: webpack 开发服务器，支持代码热重载，错误信息展示，接口代理等等</li><li>webpack-bundle-analyzer: webpack 包分析器</li></ul></li><li><strong>扩展(一些相关的技术栈)</strong><ul><li>http-server 快速伺服静态文件</li><li>plop 模板生成器</li><li>yeoman 项目脚手架工具</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个新开的’实验性’文章系列，如其名‘技术地图’，这个系列计划剖析一些前端开源项目，可能会探讨这些项目的&lt;strong&gt;设计和组织&lt;/strong&gt;、整理他们使用到&lt;strong&gt;技术栈&lt;/strong&gt;。 首先拿&lt;code&gt;vue-cli&lt;/code&gt;小试牛刀，再决定
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结05 - 状态管理</title>
    <link href="https://bobi.ink/2019/05/20/react-component-design-05/"/>
    <id>https://bobi.ink/2019/05/20/react-component-design-05/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-22T06:44:27.830Z</updated>
    
    <content type="html"><![CDATA[<p>今天是 520，这是本系列最后一篇文章，主要涵盖 React 状态管理的相关方案。</p><p>前几篇文章在<a href="https://juejin.im" target="_blank" rel="noopener">掘金</a>首发基本石沉大海, 没什么阅读量. 可能是文章篇幅太长了？掘金值太低了？ 还是错别字太多了? 后面静下心来想想，写作对我来说是一种学习和积累的过程, 让我学习更全面更系统性去描述一个事物. 但是写作确实是一件非常耗时的事情, 文章的每句话都要细细推敲, 还要避免主观性太强避免误导了别人.</p><p>所以模仿<a href="https://kernelpanic.fm" target="_blank" rel="noopener">&lt;&lt;内核恐慌&gt;&gt;</a>的口号: “想看的人看，不想看的人就别看”</p><p><br></p><p><strong>系列目录</strong></p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li><a href="/2019/05/20/react-component-design-05/">05 状态管理</a></li></ul><p><br></p><p><strong>文章目录</strong></p><!-- TOC --><ul><li><a href="#状态管理">状态管理</a></li><li><a href="#你不需要状态管理">你不需要状态管理</a></li><li><a href="#你不需要复杂的状态管理">你不需要复杂的状态管理</a></li><li><a href="#redux">Redux</a></li><li><a href="#mobx">Mobx</a></li><li><a href="#rxjs">RxJS</a></li><li><a href="#其他状态管理方案">其他状态管理方案</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>现在的前端框架，包括 React 的一个核心思想就是<strong>数据驱动视图</strong>, 即<code>UI = f(state)</code>. 这种开发方式的变化其实得益于 Virtual-DOM, 它使得我们不需要关心浏览器底层 DOM 的操作细节，只需关心‘状态(state)’和‘状态到 UI 的映射关系(f)’. <strong>所以如果你是初学者，不能理解什么是‘数据驱动’, 还是不推荐继续阅读文章下面的内容</strong>。</p><p>但是随着 <code>state</code> 的复杂化, 框架现有的组件化方式很难驾驭 <code>f</code>(视图的映射关系变得复杂, 难以被表达和维护); 或者相关类型的应用数据流本来就比较复杂, 组件之间的交互关系多样，本来难以使用<code>UI = f(state)</code>这种关系来表达; 或者应用的组件状态过于离散，需要统一的治理等等. 我们就有了状态管理的需求.</p><p>状态管理最基础的解决方式就是分层，也就是说和传统的 <code>MV*</code> 模式没有本质区别, 主流状态管理的主要结构基本都是这样的:</p><center><br> <img src="/images/04/mvc.png" width="500"><br></center><p>他们基本都包含这些特点:</p><ul><li><strong>分离视图和状态</strong>. 状态管理器擅长状态管理，所以他们一般会将应用状态聚合在一起管理，而视图退化为贫血视图(只关注展示)，这样就可以简化<code>f</code>映射关系, 让<code>UI = f(state)</code>这个表达式更彻底</li><li><strong>约束状态的变更</strong>。Redux 要求通过<code>dispatch+reducer</code>, mobx 要求数据变更函数使用<code>action</code>装饰或放在<a href="https://mobx.js.org/best/actions.html" target="_blank" rel="noopener"><code>flow</code></a>函数中，目的就是让状态的变更根据可预测性</li><li><strong>单向数据流</strong>。数据流总是按照 Store -&gt; View -&gt; Store 这样的方式流动, 简化数据流</li></ul><p><br></p><p>但是, React 的状态管理方案太多了，选择这些方案可能会让人抓狂，你需要权衡很多东西:</p><ul><li>面向对象还是函数式还是函数响应式?</li><li>单 Store 还是多 Store？</li><li>不可变数据还是可变数据？</li><li>写代码爽还是后期维护爽?</li><li>自由还是约束？</li><li>强类型还是弱类型？</li><li>范式化数据还是非范式化？</li><li>React 原生还是第三方?</li><li>…</li></ul><p><br></p><hr><p><br></p><h2 id="你不需要状态管理"><a href="#你不需要状态管理" class="headerlink" title="你不需要状态管理"></a>你不需要状态管理</h2><p>对于大部分简单的应用和中后台项目来说是不需要状态管理的。说实话这些应用和传统 web 页面没什么区别, 每个页面都各自独立，每次打开一个新页面时拉取最新数据，增删改查仅此而已. 对于这些场景 React 的组件状态就可以满足, 没有必要为了状态管理而状态管理. 这种各自独立的‘静态’页面，引入状态管理就是过度设计了。</p><p>在考虑引入状态管理之前考虑一下这些手段是否可以解决你的问题:</p><ul><li>是否可以通过抬升 State 来实现组件间通信?</li><li>如果跨越的层级太多，数据是否可以通过 Context API 来实现共享?</li><li>一些全局状态是否可以放在 localStorage 或 sessionStorage 中？</li><li>数据是否可以通过外置的事件订阅器进行共享?</li><li>…</li></ul><p><br></p><hr><p><br></p><h2 id="你不需要复杂的状态管理"><a href="#你不需要复杂的状态管理" class="headerlink" title="你不需要复杂的状态管理"></a>你不需要复杂的状态管理</h2><p>当你的应用有以下场景时，就要开始考虑状态管理:</p><ul><li>组件之间需要状态共享。同一份数据需要响应到多个视图，且被多个视图进行变更</li><li>需要维护全局状态，并在他们变动时响应到视图</li><li>数据流变得复杂，React 组件本身已经无法驾驭。例如跨页面的用户协作</li><li>需要统一管理应用的状态。比如实现持久化，可恢复，可撤销/重做</li><li>…</li></ul><p>首先确定是否需要 Redux、Mobx 这些复杂的状态管理工具? 在 2019 他们很多功能都可以被 React 本身提供的特性取代. 随着 React 16.3 发布了新的 Context API，我们可以方便地在它之上做简单的状态管理, 我们应该<strong>优先选择这些原生态的状态管理方式</strong>。</p><p>例如: 简单的使用 Context API 来做状态管理:</p><center><br>  <img src="/codes/context-api-vuex.png" width="600"><br></center><p>最近 hooks 用得比较爽(参考上一篇文章: <a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d" target="_blank" rel="noopener">组件的思维</a>)，我就想配合 Context API 做一个状态管理器, 后来发现早就有人这么干了： <a href="https://github.com/jamiebuilds/unstated-next" target="_blank" rel="noopener">unstated-next</a>, 代码只有 38 行(Hooks+Context)，接口非常简单:</p><center><br> <img src="/images/04/unstated.png" width="750"><br></center><p>依赖于 hooks 本身灵活的特性，我们可以用它来做很多东西, 仅限于想象力. 例如异步数据获取:</p><center><br> <img src="/codes/useTodoList.png" width="750"><br></center><p>抑或者实现 Redux 的核心功能:</p><iframe src="https://codesandbox.io/embed/w1plr?fontsize=14" title="redux hooks" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p><br></p><p>总结一下使用 hooks 作为状态管理器的优点:</p><ul><li><strong>极简</strong>。如上</li><li><strong>可组合性</strong>. hooks 只是普通函数, 可以组合其他 hooks，以及其他<code>Hooks Container</code>. 上一篇文章提到 hooks 写着写着很像组件，组件写着写着很像 hooks，在用法上组件可以认为是一种’特殊’的 hooks。相比组件, hooks 有更灵活的组合特性</li><li><strong>以 react 之名</strong>. 基于 Context 实现组件状态共享，基于 hooks 实现状态管理, 这个方式足够通用.</li><li>hooks 很多灵活的特性足以取代类似 Mobx 这些框架的大部分功能</li><li>只是普通的 React 组件，可以在 React inspector 上调试</li><li>强类型</li><li>基于Context API更容易实现模块化(或者分形)</li></ul><p><br></p><p>需要注意的地方</p><ul><li>没有外置的状态. 状态在组件内部，没有方法从外部触发状态变更</li><li>缺少约束. 是好处也是坏处, 对于团队和初学者来说没有约束会导致风格不统一，无法控制项目熵增。好处是可以自定义自己的约束</li><li>性能优化. 需要考虑 Context 变更带来的性能问题</li><li>调试体验不如 Redux</li><li>没有数据镜像, 不能实现诸如事件管理的需求</li><li>没有 Redux 丰富的生态</li></ul><p><strong>所以 Context+ Hooks 可以用于满足简单的状态管理需求, 对于复杂的状态管理需求还是需要用上 Redux、Mobx 这类专业的状态管理器.</strong></p><p><br></p><p>其他类似的方案</p><ul><li><a href="https://github.com/jamiebuilds/unstated" target="_blank" rel="noopener">unstated</a> unstated-next 的前身，使用 setState API</li><li><a href="https://github.com/dai-shi/react-hooks-global-state" target="_blank" rel="noopener">react-hooks-global-state</a></li></ul><p>扩展</p><ul><li><a href="https://blog.bitsrc.io/react-context-api-a-replacement-for-redux-6e20790492b3" target="_blank" rel="noopener">React Context API — A Replacement for Redux?</a></li><li><a href="https://zhuanlan.zhihu.com/p/48219978" target="_blank" rel="noopener">unstated: 可能是简单状态管理工具中最好的</a></li></ul><p><br></p><hr><r><h2 id="redux"><a href="#redux" class="headerlink" title="Redux"></a>Redux</h2><p><code>unstated</code> 是一个极简的状态管理方案，其作者也说了不要认为<strong>unstated 是一个 Redux killer</strong>, 不要在它之上构建复杂的工具，也就是不要重复造轮子。所以一般到了这个地步, 其实你就应该考虑 Redux、Mobx、Rxjs 这些复杂的状态管理框架了。</p><p>Redux 是学习 React 绕不过的一个框架. 尽管 Redux 的代码只有一百多行，概念却很多，学习曲线非常陡峭，看官方文档就知道了。即使它的实现很简洁，但是开发代码并不简洁(和 mobx 相反, 脏活留给开发者)，尤其遵循它的’最佳实践’，是从头开始构建一个项目是非常繁琐的. 还在现在有类似 dva 或 rematch 这样的二次封装库来简化它.</p><p>本文不打算深入介绍 Redux 的相关实践， 社区上面有非常多的教程，官方文档也非常详尽. 这里会介绍 Redux 的主要架构和核心思想，以及它的适用场景.</p><center><br>  <img src="/images/04/redux-design.png" width="700"><br></center><p>Redux 的主要结构如上，在此之前你先要搞清楚 Redux 的初衷是什么，才能明白它为什么要这么设计. 在我看来 Redux 主要为了解决以下两个问题:</p><ol><li><strong>可预测状态</strong></li><li><strong>简化应用数据流</strong></li></ol><p><br></p><p>其实这也是 <code>flux</code> 的初衷, 只是有些它有些东西没做好. 明白 Redux 的初衷，现在来看看它的设计就会清晰很多</p><ul><li><p><strong>单一数据源</strong> -&gt; 可预测，简化数据流：数据只能在一个地方被修改</p><ul><li><p>可以简化应用数据流. 解决传统多 model 模型数据流混乱问题(比如一个 model 可以修改其他 model，一个 view 受到多个 model 驱动)，让数据变动变得可预测可调试</p><center><br> <img src="/images/04/traditional-model.png" width="400"><br></center></li><li><p>同构化应用开发</p></li><li>方便调试</li><li>方便做数据镜像. 可以实现撤销/重做、时间旅行、热重载、状态持久化和恢复</li></ul></li><li><p><strong>单向数据流</strong> -&gt; 简化数据流, 可预测</p></li><li><strong>不能直接修改状态</strong> -&gt; 可预测<ul><li>只能通过 dispatch action 来触发状态变更. action 只是一个简单的对象， 携带事件的类型和 payload</li><li>reducer 接收 action 和旧的 state， 规约生成新的 state. reducer 只是一个纯函数，可以嵌套组合子 reducer 对复杂 state 树进行规约</li><li>不可变数据.</li><li>可测试.</li></ul></li><li><strong>范式化和反范式化</strong>. Store 只存储范式化的数据，减少数据冗余。视图需要的数据通过 reselect 等手段反范式化</li><li><strong>通过中间件隔离副作用</strong> -&gt; 可预测<br>可以说 Redux 的核心概念就是 reducer，然而这是一个纯函数。为了实现复杂的副作用，redux 提供了类似 Koa 的中间件机制，实现各种副作用. 比如异步请求. 除此之外，可以利用中间件机制，实现通用的业务模式， 减少代码重复。</li><li><strong>Devtool</strong> -&gt; 可预测。通过开发者工具可以可视化数据流</li></ul><p><br></p><p><strong>什么时候应该使用 Redux?</strong></p><p>首先还是警告一下： <a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" target="_blank" rel="noopener">You Might Not Need Redux</a>, Redux 不是你的第一选择。</p><p><strong>当我们需要处理复杂的应用状态，且 React 本身无法满足你时</strong>. 比如：</p><ul><li>你需要持久化应用状态, 这样你可以从本地存储或服务器返回数据中恢复应用</li><li>需要实现撤销重做这些功能</li><li>实现跨页面的用户协作</li><li>应用状态很复杂时</li><li>数据流比较复杂时</li><li>许多不相关的组件需要共享和更新状态</li><li>外置状态</li><li>…</li></ul><p><br></p><p><strong>最佳实践</strong></p><p>个人觉得<a href="https://github.com/react-boilerplate/react-boilerplate/blob/master/docs/general/introduction.md" target="_blank" rel="noopener">react-boilerplate</a>是最符合官方‘最佳实践’的项目模板. 它的应用工作流如下:</p><center><br> <img src="/images/04/redux-workflow.png " width="600"><br></center><p>特性:</p><ol><li>整合了 Redux 生态比较流行的方案: <code>immer</code>(不可变数据变更)，<code>redux-saga</code>(异步数据流处理)，<code>reselect</code>(选取和映射 state，支持 memo，可复合)，<code>connected-react-router</code>(绑定 react-router v4)</li><li>根据页面分割 saga 和 reducer。见下面 👇 和目录结构</li><li>按需加载 saga 和 reducer(通过 replaceReducer)</li><li>划分容器组件和展示组件</li></ol><p>再看看 react-boilerplate 目录结构. 这是我个人比较喜欢的项目组件方式，组织非常清晰，很有参考意义</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/src</span><br><span class="line">  /components        # 展示组件</span><br><span class="line">  /containers        # 🔴容器/页面组件</span><br><span class="line">    /App             # 根组件， 例如放置Provider和Router</span><br><span class="line">    /HomePage        # 页面组件</span><br><span class="line">      index.js       # 页面入口</span><br><span class="line">      constants.js   # 🔴 在这里定义各种常量。包括Action Type</span><br><span class="line">      actions.js     # 🔴 定义各种Action函数</span><br><span class="line">      saga.js        # 🔴 redux-saga 定义各种saga方法， 用于处理异步流程</span><br><span class="line">      reducer.js     # 🔴 reducer。 页面组件的reducer和saga都会按需注入到根store</span><br><span class="line">      selectors.js   # 🔴 redux state映射和计算</span><br><span class="line">      message.js</span><br><span class="line">      Form.js        # 各种局部组件</span><br><span class="line">      Input.js</span><br><span class="line">      ...</span><br><span class="line">    /FeaturePage     # 其他页面组件结构同上</span><br><span class="line">    ...</span><br><span class="line">  /translations      # i18n 翻译文件</span><br><span class="line">  /utils</span><br><span class="line">    reducerInjectors.js  # 🔴reducer 注入器, 实现和页面组件一起按需注入</span><br><span class="line">    sagaInjectors.js     # 🔴saga 注入器, 同上</span><br><span class="line">    lodable.js</span><br><span class="line">  app.js             # 应用入口</span><br><span class="line">  i18n.js            # i18n配置</span><br><span class="line">  configureStore.js  # 🔴 创建和配置Redux Store</span><br><span class="line">  reducers.js        # 🔴 根reducers, 合并所有'页面状态'和'全局状态'(如router， language， global(例如用户鉴权信息))</span><br></pre></td></tr></table></figure><p><br></p><p><strong>🤬 开始吐槽!</strong></p><p><br></p><ul><li><p><strong>一，Redux 核心库很小，只提供了 dispatch 和 reducer 机制，对于各种复杂的副作用处理 Redux 通过提供中间件机制外包出去</strong>。社区有很多解决方案，redux-promise, redux-saga, redux-observable… 查看 Redux 的<a href="https://redux.js.org/introduction/ecosystem#actions" target="_blank" rel="noopener">生态系统</a>.</p><p><strong>Redux 中间件的好处是扩展性非常好, 开发者可以利用中间件抽象重复的业务 e 中间件生态也百花齐放, 但是对于初学者则不友好</strong>.</p><p>TM 起码还得需要去了解各种各样的库，横向比较的一下才知道自己需要搭配哪个库吧? 那好吧，就选 redux-saga 吧，star 数比较多。后面又有牛人说不要面向 star 编程，选择适合自己团队的才是最好的… 所以挑选合适的方案之前还是得要了解各种方案本身吧?。</p><p>Vue 之所以学习曲线比较平缓也在于此吧。它帮助我们做了很多选择，提供简洁的解决方案，另外官方还提供了风格指南和最佳实践. 这些选择适合 80%以上的开发需求. 开发者减少了很多折腾的时间，可以专心写业务. <strong>这才是所谓的‘<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">渐进式</a>’框架吧, 对于不爱折腾的或初学者，我们帮你选择，但也不会阻碍你往高级的地方走</strong>。 这里可以感受到 React 社区和 Vue 社区的风格完全不同.</p><p>在出现选择困难症时，还是看看别人怎么选择，比如比较有影响力的团队或者流行的开源项目(如 dva，rematch)，选取一个折中方案, 后续有再慢慢深入研究. <strong>对于 Redux 目前比较流行的组合就是: <code>immer+saga+reselect</code></strong></p><p><br></p></li><li><p><strong>二，太多模板代码</strong>。比如上面的 react-boilerplate, 涉及五个文件, 需要定义各种 Action Type、Action、 Reducer、Saga、Select. 所以即便想进行一个小的状态变化也需要更改好几个地方:</p><p><img src="/images/04/redux-page.png" alt></p><p>笔者个人更喜欢类似 Vuex 这种<code>Ducks</code>风格的组织方式，将模块下的 action，saga，reducer 和 mapper 都组织在一个文件下面:</p><center><br> <img src="/codes/redux-ducks.png" width="600"><br></center><p>Redux 的二次封装框架基本采用类似的风格, 如<a href="https://github.com/rematch/rematch" target="_blank" rel="noopener"><code>rematch</code></a></p><center><br> <img src="/images/04/rematch.png" width="800"><br></center><p>这些二次封装框架一般做了以下优化(其实可以当做是 Vuex 的优点)，来提升 Redux 的开发体验:</p><ul><li><strong>使用 Ducks 风格组织代码</strong>.聚合分散的 reducer，saga，actions…</li><li><strong>更简化的 API</strong></li><li><strong>提供了简单易用的模块化(或者称为‘分形’)或者命名空间机制</strong>。模块本身支持‘状态隔离’，让模块的 reducer、saga 只专注于模块自己的状态. 另外模块还考虑<strong>动态加载</strong></li><li><strong>内置副作用处理机制</strong>。如使用 saga 或 redux-promise</li><li><strong>简化了不可变数据的操作方式</strong>。 如使用 immer</li><li><strong>简化 reducer</strong>。Redux 内置了 combineReducers 来复合多个 reducer，在 reducer 内部我们一般使用 switch 语句来接收 action 和处理数据变动, 其实写起来非常啰嗦. <strong>Vuex 和这些封装框架不约而同使用了 key/value 形式</strong>, 更为简洁明了</li><li><strong>简化 view 层的 connect 接口</strong>。如简化 mapProps，mapDispatch 这些代码写起来也比较繁琐</li></ul><p><br></p></li><li><p><strong>三，强制不可变数据</strong>。前面文章也提到过 setState 很啰嗦，为了保证状态的不可变性最简单的方式是使用对象展开或者数组展开操作符, 再复杂点可以上 Immutable.js, 这需要一点学习成本. 好在现在有 immer，可以按照 Javascript 的对象操作习惯来实现不可变数据</p><p><br></p></li><li><p><strong>四，状态设计</strong>。</p><p>数据类型一般分为<strong>领域数据(Domain data)</strong>和<strong>应用数据(或者称为 UI 数据)</strong>. 在使用 Redux 时经常需要考虑状态要放在组件局部，还是所有状态都抽取到 Redux Store？把这些数据放到 Redux Store 里面处理起来好像更麻烦？既然都使用 Redux 了，不把数据抽取到 Redux Store 是否不符合最佳实践？ 笔者也时常有这样的困惑, 你也是<a href="https://ruby-china.org/topics/38057" target="_blank" rel="noopener">最佳实践的受害者</a>?</p><p>我觉得可以从下面几个点进行考虑:</p><ul><li><strong>领域数据还是应用数据?</strong> 领域数据一般推荐放在 ReduxStore 中，我们通常会将 Redux 的 Store 看作一个数据库，存放范式化的数据。</li><li><strong>状态是否会被多个组件或者跨页面共享？</strong> Redux Store 是一个全局状态存储器，既然使用 Redux 了，有理由让 Redux 来管理跨越多组件的状态</li><li><strong>状态是否需要被镜像化?</strong> 如果你的应用要做‘时间旅行(撤销/重做)’或者应用持久化，这个状态需要被恢复，那么应该放到 Redux Store，集中化管理数据是 Redux 的强项</li><li><strong>状态是否需要跨越组件的生命周期？</strong> 将状态放在组件局部，就会跟着组件一起被销毁。如果希望状态跨越组件的生命周期，应该放到父组件或者 Redux Store 中. 比如一个模态框编辑的数据在关闭后是否需要保留</li></ul><p><strong>原则是能放在局部的就放在局部</strong>. 在局部状态和全局状态中取舍需要一点开发经验.</p><p>另外作为一个集中化的状态管理器，为了状态的可读性(更容易理解)和可操作性(更容易增删查改)，在状态结构上面的设计也需要花费一些精力的. 这个数据库结构的设计方法是一样的, <strong>在设计状态之前你需要理清各种领域对象之间的关系, 在数据获取和数据变更操作复杂度/性能之间取得平衡</strong>.</p><p>Redux 官方推荐<a href="https://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="noopener"><strong>范式化 State</strong></a>，扁平化结构树, 减少嵌套，减少数据冗余. <strong>也就是倾向于更方便被更新和存储，至于视图需要什么则交由 reselect 这些库进行计算映射和组合</strong>.</p><p>所以说 Redux 没那么简单, 当然 80%的 Web 应用也不需要这么复杂.</p><p><br></p></li><li><p><strong>五，不方便 Typescript 类型化</strong>。不管是 redux 还是二次封装框架都不是特别方便 Typescript 进行类型推导，尤其是在加入各种扩展后。你可能需要显式注解很多数据类型</p><p>扩展: <a href="https://github.com/piotrwitek/react-redux-typescript-guide#redux---typing-patterns" target="_blank" rel="noopener">react-redux-typescript-guide</a>, <a href="https://rematch.gitbooks.io/rematch/docs/recipes/typescript.html" target="_blank" rel="noopener">rematch &amp; Typescript</a><br><br></p></li><li><p><strong>六，不是分形(Fractal)</strong></p><p>在没有看到<a href="https://www.zhihu.com/people/yang-jian-feng/activities" target="_blank" rel="noopener">@杨剑锋</a>的这条<a href="https://www.zhihu.com/question/263928256/answer/275092256" target="_blank" rel="noopener">知乎回答</a>之前我也不知道什么叫分形, 我只能尝试解释一下我对分形的理解:</p><p>前面文章也提到过‘分离逻辑和视图’和‘分离容器组件和展示组件’，这两个规则都来自于 Redux 的最佳实践。<strong>Redux 就是一个’非分形的架构’，如下图，在这种简单的‘横向分层’下, 视图和逻辑(或状态)可以被单独复用，但在 Redux 中却很难将二者作为一个整体的组件来复用</strong>:</p><p>  <center><br>  <img src="/images/04/redux-and-dumb.png" width="400"><br>  </center><br>  <em>集中化的 Store，再通过 Connect 机制可以让状态在整个应用范围内被复用；Dumb 组件抽离的状态和行为，也容易被复用</em></p><p>现在假设你需要将单个 container 抽离成独立的应用，单个 container 是无法独立工作的。<strong>在分形的架构下，一个‘应用’有更小的‘应用’组成，‘应用’内部有自己的状态机制，单个应用可以独立工作，也可以作为子应用</strong>. 例如 Redux 的鼻祖 Elm 的架构:</p><p>  <center><br>  <img src="/images/04/elm.jpg" width="500"><br>  </center><br>  <em>Store的结构和应用的结构保持一致, 每个 Elm 组件也是一个 Elm 应用，包含完整的Action、Update、Model和View. 使得单独的应用可以被复用</em></p><p><strong>Redux 不是分形和 Redux 本身的定位有关，它是一个纯粹的状态管理器，不涉及组件的视图实现，所以无法像 elm 和 cyclejs 一样形成一个完整的应用闭环</strong>。 其实可以发现 react 组件本身就是分形的，组件原本就是状态和视图的集合.</p><p>分形的好处就是可以实现更灵活的复用和组合，减少胶水代码。显然现在支持纯分形架构的框架并不流行，原因可能是门槛比较高。个人认为不支持分形在工程上还不至于成为 Redux 的痛点，我们可以通过‘模块化’将 Redux 拆分为多个模块，在多个 Container 中进行独立维护，从某种程度上是否就是分形？另外这种横向隔离的 UI 和状态，也是有好处的，比如 UI 相比业务的状态变化的频度会更大.</p><p>个人感觉到页面这个级别的分化刚刚好，比如方便分工。比如最近笔者就有这样一个项目, 我们需要将一个原生 Windows 客户端转换成 electron 实现，限于资源问题，这个项目涉及到两个团队之间协作. 对于这个项目应用 Store 就是一个接口层，Windows 团队负责在这里维护状态和实现业务逻辑，而我们前端团队则负责展示层. 这样一来 Windows 不需要学习 React 和视图展示，我们也不需要关系他们复杂的业务逻辑(底层还是使用 C++, 暴露部分接口给 node)</p></li></ul><p><br></p><p><strong>七，可能还有性能问题</strong></p><ul><li><a href="https://cn.redux.js.org/docs/faq/Performance.html" target="_blank" rel="noopener">Redux 常见问题：性能</a></li><li><a href="https://www.zhihu.com/question/41904561/answer/93029393" target="_blank" rel="noopener">redux 中的 state 树太大会不会有性能问题？</a></li><li><a href="https://tech.youzan.com/mobx_vs_redux/" target="_blank" rel="noopener">我为什么从 Redux 迁移到了 Mobx</a></li><li><a href="https://zhuanlan.zhihu.com/p/52625410" target="_blank" rel="noopener">Mobx 与 Redux 的性能对比</a></li></ul><p><br></p><p>总结</p><p>本节主要介绍的 Redux 设计的动机，以及围绕着这个动机一系列设计, 再介绍了 Redux 的一些缺点和最佳实践。Redux 的生态非常繁荣，如果是初学者或不想折腾还是建议使用 Dva 或 rematch 这类二次封装框架，这些框架通常就是 Redux 一些最佳实践的沉淀, 减少折腾的时间。当然这只是个开始，组织一个大型项目你还有很多要学的。</p><p><br></p><p>扩展阅读</p><ul><li><a href="https://www.zhihu.com/question/263928256/answer/275092256" target="_blank" rel="noopener">Redux 有什么缺点</a> 知乎上的吐槽</li><li><a href="https://zhuanlan.zhihu.com/p/27093191" target="_blank" rel="noopener">Redux 状态管理之痛点、分析与改良</a></li><li><a href="https://www.zhihu.com/question/47995437/answer/108788493" target="_blank" rel="noopener">Redux 有哪些最佳实践?</a></li><li><a href="https://www.zhihu.com/question/38591713/answer/77634014" target="_blank" rel="noopener">如何评价数据流管理架构 Redux?</a></li><li><a href="https://www.zhihu.com/question/284931332/answer/441399919" target="_blank" rel="noopener">2018 年我们还有什么功能是 Redux 才适合做的吗？</a></li><li><a href="https://juejin.im/post/5c166d8fe51d45242973fdd3" target="_blank" rel="noopener">Cycle.js 状态管理模型</a></li><li><a href="https://dvajs.com/guide/develop-complex-spa.html#动态加载model" target="_blank" rel="noopener">使用 Dva 开发复杂 SPA</a></li><li><a href="https://hackernoon.com/redesigning-redux-b2baee8b8a38" target="_blank" rel="noopener">Redesigning Redux</a></li><li><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">Redux 官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/26485702" target="_blank" rel="noopener">redux 三重境</a></li></ul><p><br></p><hr><p><br></p><h2 id="mobx"><a href="#mobx" class="headerlink" title="Mobx"></a>Mobx</h2><p>Mobx 提供了一个类似 Vue 的响应式系统，相对 Redux 来说 Mobx 的架构更容易理解。 拿官方的图来看:</p><p><img src="/images/04/mobx-preview.png" alt></p><ul><li><p><strong>响应式数据</strong>. 首先使用<code>@observable</code> 将数据转换为‘响应式数据’，类似于 Vue 的 data。这些数据在一些上下文(例如 computed，observer 的包装的 React 组件，reaction)中被访问时可以被收集依赖，当这些数据变动时相关的依赖就会被通知.</p><p>响应式数据带来的两个优点是 ① 简化数据操作方式(相比 redux 和 setState); ② 精确的数据绑定，只有数据真正变动时，视图才需要渲染，组件依赖的粒度越小，视图就可以更精细地更新</p></li><li><p><strong>衍生</strong>.</p><ul><li>衍生数据。Mobx 也推荐不要在状态中放置冗余或可推导的数据，而是使用 <code>@computed</code> 计算衍生的状态. computed 的概念类似于 Redux 中的 reselect，对范式化的数据进行反范式化或者聚合计算</li><li>副作用衍生. 当数据变动时触发依赖该数据的副作用，其中包含‘视图’。视图是响应式数据的映射</li></ul></li><li><p><strong>数据变更</strong>. mobx 推荐在 <code>action/flow(异步操作)</code> 中对数据进行变更，action 可以认为是 Redux 中的 dispatch+reducer 的合体。在严格模式下 mobx 会限制只能在 action 函数中进行变更，这使得状态的变更可被追溯。<strong>推荐在 flow 函数中隔离副作用，这个东西和 Redux-saga 差不多，通过 generator 来进行异步操作和副作用隔离</strong></p></li></ul><p><br></p><p>上面就是 Mobx 的核心概念。举一个简单的例子：</p><center><br><img src="/codes/mobx-demo.png" width="650"><br></center><p>但是<strong>Mobx 不是一个框架</strong>，它不会像 Redux 一样告诉你如何去组织代码，在哪存储状态或者如何处理事件, 也没有最佳实践。好处是你可以按照自己的喜好组件项目，比如按照 Redux(Vuex)方式，也可以使用面向对象方式组织; 坏处是如果你没有相关经验, 会不知所措，不知道如何组织代码</p><p>Mobx 一般使用面向对象的方式对 Store 进行组织, 官方文档<a href="https://cn.mobx.js.org/best/store.html" target="_blank" rel="noopener">构建大型可扩展可维护项目的最佳实践</a>也介绍了这种方式, 这个其实就是经典的 MV* 模式:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/          # 展示组件</span><br><span class="line">  models/              # 🔴 放置一些领域对象</span><br><span class="line">    Order.ts</span><br><span class="line">    User.ts</span><br><span class="line">    Product.ts</span><br><span class="line">    ...</span><br><span class="line">  stores/              # store</span><br><span class="line">    AppStore.ts        # 应用Store，存放应用全局信息，如auth，language，theme</span><br><span class="line">    OrderStore.ts</span><br><span class="line">    RootStore.ts       # 根Store，组合所有下级Store</span><br><span class="line">    ...</span><br><span class="line">  containers/</span><br><span class="line">    App/               # 根组件</span><br><span class="line">    Orders/            # 页面组件</span><br><span class="line">    ...</span><br><span class="line">  utils/</span><br><span class="line">  store.ts             # store初始化</span><br><span class="line">  index.tsx</span><br></pre></td></tr></table></figure><p><br></p><p><strong>领域对象</strong></p><p>面向对象领域有太多的名词和概念，而且比较抽象，如果理解有误请纠正. 暂且不去理论领域对象是什么，尚且视作是现实世界中一个业务实体在 OOP 的抽象. 具体来说可以当做<code>MVC</code>模式中的 M, 或者是 ORM 中数据库中映射出来的对象.</p><p>对于复杂的领域对象，会抽取为单独的类，比如前面例子中的<code>Todo</code>类, 抽取为类的好处是它具有封装性，可以包含关联的行为、定义和其他对象的关联关系，相比纯对象表达能力更强. 缺点就是不好序列化</p><p>因为它们和页面的关联关系较弱，且可能在多个页面中被复用, 所以放在根目录的<code>models/</code>下. 在代码层面领域对象有以下特点：</p><ul><li>定义了一些字段(@observable)和一些领域对象的操作方法(@action), 可能还关联其他领域对象，比如订单会关联用户和产品</li><li>由 Store 来管理生命周期，或者说 Store 就 Model 的容器, 相当于数据库. Store 通常也是单例</li></ul><p>示例</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Order &#123;</span><br><span class="line">  <span class="keyword">public</span> id: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> createdDate: <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> product: Product;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> user: User;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Store</strong></p><p>Store 只是一个 Model 容器， 负责管理 model 对象的生命周期、定义衍生状态、封装副作用、和后端接口集成等等. Store 一般是单例. 在 Mobx 应用中一般会划分为多个 Store 绑定不同的页面。</p><p>示例</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, computed, reaction &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> OrderStore &#123;</span><br><span class="line">    <span class="comment">// 定义模型state</span></span><br><span class="line">  <span class="meta">@observable</span> orders: Order[] = [];</span><br><span class="line"></span><br><span class="line">  _unSubscribeOrderChange: <span class="built_in">Function</span></span><br><span class="line">  rootStore: RootStore</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义衍生数据</span></span><br><span class="line">  <span class="meta">@computed</span> <span class="keyword">get</span> finishedOrderCount() &#123;&#125;</span><br><span class="line">  <span class="meta">@computed</span> <span class="keyword">get</span> finishedOrders() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义副作用衍生</span></span><br><span class="line">  subscribeOrderChange() &#123;      <span class="keyword">this</span>._unSubscribeOrderChange = <span class="keyword">this</span>.orders.observe(<span class="function">(<span class="params">changeData</span>) =&gt;</span> &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义action</span></span><br><span class="line">  <span class="meta">@action</span>  addOrder (order) &#123;&#125;</span><br><span class="line">  <span class="meta">@action</span>  removeOrder (order) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者一些异步的action</span></span><br><span class="line">  <span class="keyword">async</span> fetchOrders () &#123;</span><br><span class="line">    <span class="keyword">const</span> orders = <span class="keyword">await</span> fetchOrders()</span><br><span class="line">    orders.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">this</span>.addOrder(<span class="keyword">new</span> OrderModel(<span class="keyword">this</span>, item)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化，初始化数据结构，初始化订阅等等</span></span><br><span class="line">  initialize () &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribeOrderChange()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一些清理工作</span></span><br><span class="line">  release () &#123;</span><br><span class="line">    <span class="keyword">this</span>._unSubscribeOrderChange()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">store: RootStore</span>) &#123;</span><br><span class="line">    <span class="comment">// 和rootStore进行通信</span></span><br><span class="line">    <span class="keyword">this</span>.rootStore = store</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根 Store</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> RootStore &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.appStore = <span class="keyword">new</span> AppStore(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.orderStore = <span class="keyword">new</span> OrderStore(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Provider rootStore=&#123;new RootStore()&#125;&gt;</span><br><span class="line">  &lt;App /&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure><p>看一个 <a href="https://github.com/gothinkster/react-mobx-realworld-example-app/blob/master/src/index.js" target="_blank" rel="noopener">真实世界的例子</a></p><p>这种传统 MVC 的组织方式主要有以下优点:</p><ul><li><strong>好理解, 容易入手</strong>. 经典的 MVC 模式、面向对象，我们再熟悉不过了. 尤其是熟悉 Java 这些传统面向对象编程范式的后端开发人员. 上文提到的跨团队的项目，我们选择的就是 mobx 作为状态管理器，对于他们来说这是最好理解的方式. 但是<strong>对于领域对象和领域 Store 的拆分和设计需要一点经验</strong></li><li><strong>强类型</strong></li><li><strong>代码简洁</strong>。相对 Redux 多余的模板代码而言</li><li><strong>数据封装性</strong>。使用类表达的数据结构可以封装相应的行为</li></ul><p>问题</p><ul><li><strong>在多个 Store 之间共享数据比较麻烦</strong>. 我们的做法是让所有 Store 都继承一个父类作为中间者，通过事件订阅模式在多个 Store 间进行数据通信</li><li><strong>缺乏组织</strong>。相对 Redux 而言, 状态过于零散，不加以约束，状态可以被随意修改。我们很多代码就是这样，懒得写 action，甚至直接在视图层给状态赋值. 所以一定要开始严格模式</li><li><strong>没有 Magic</strong>. 这是一把双刃剑, Redux 有中间件机制，可以扩展抽象许多重复的工作, 比如为异步方法添加 loading 状态, 但是对 Typescript 不友好; 基于类的方案，无处下手，代码会比较啰嗦， 但更直观</li><li><strong>无数据快照</strong>，无法实现时间回溯，这是 Redux 的强项，但大部分的应用不需要这个功能; 另外可以通过 mobx-state-tree 实现</li><li><strong>无法 hot-reload</strong></li></ul><p><br></p><p>还有一些 mobx 本身的问题, 这些问题在上一篇文章也提过, 另外可以看这篇文章(<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;mid=2697266952&amp;idx=2&amp;sn=a3389d1db237c2b23f523061da3b2359" target="_blank" rel="noopener">Mvvm 前端数据流框架精讲</a>):</p><ul><li><p><strong>组件侵入性</strong>. 需要改变 React 组件原本的结构, 例如所有需要响应数据变动的组件都需要使用 observer 装饰. 组件本地状态也需要 observable 装饰, 以及数据操作方式等等. 对 mobx 耦合较深, 日后切换框架或重构的成本很高</p></li><li><p><strong>兼容性</strong>. mobx v5 后使用 Proxy 进行重构, 但 Proxy 在 Chrome49 之后才支持. 如果要兼容旧版浏览器则只能使用 v4, v4 有一些<a href="https://cn.mobx.js.org/#mobx-4-vs-mobx-5" target="_blank" rel="noopener">坑</a>, 这些坑对于不了解 mobx 的新手很难发现:</p><ul><li>Observable 数组并非真正的数组. 比如 antd 的 Table 组件就不认 mobx 的数组, 需要传入到组件之间使用 slice 进行转换</li><li>向一个已存在的 observable 对象中添加属性不会被自动捕获</li></ul></li></ul><p><br></p><p><code>MV*</code> 只是 Mobx 的其中一种主流组织方式, 很多文章在讨论 Redux 和 mobx 时往往会沦为<strong>函数式和面向对象</strong>之争，然后就下结论说 Redux 更适合大型项目，<strong>下这种结论最主要的原因是 Redux 有更多约束(only one way to do it), 适合项目的演进和团队协作, 而不在于函数式和面向对象</strong>。当然函数式和面向对象范式都有自己擅长的领域，例如函数式适合数据处理和复杂数据流抽象，而面向对象适合业务模型的抽象, 所以不要一竿子打死.</p><p>换句话说适不适合大型项目是项目组织问题, Mobx 前期并没有提出任何解决方案和最佳实践。这不后来其作者也开发了<a href="https://github.com/mobxjs/mobx-state-tree" target="_blank" rel="noopener">mobx-state-tree</a>这个神器，作为 MobX 官方提供的状态模型构建库，MST 吸收了 Redux 等工具的优点，<strong>旨在结合不可变数据/函数式(transactionality, traceability and composition)和可变数据/面向对象(discoverability, co-location and encapsulation)两者的优点</strong>， 提供了很多诸如数据镜像(time travel)、hot reload、action middleware、集成 redux-devtools 以及强类型(Typescript + 运行时检查(争议点))等很有用的特性, 其实它更像是后端 ActiveRecord 这类 ORM 工具, 构建一个对象图。</p><center><br>  <img src="/images/04/immutable-vs-mutable.png" width="500"><br></center><p>典型的代码：</p><center><br>  <img src="/codes/mst.png" width="800"><br></center><p>限于笔者对 MST 实践不多，而且文章篇幅已经很长，所以就不展开了，后续有机会再分享分享。</p><p><br></p><p>还是得下一个结论, 选择 Mobx 还是 Redux? 这里还是引用来自<a href="https://zhuanlan.zhihu.com/p/25989654" target="_blank" rel="noopener">MobX vs Redux: Comparing the Opposing Paradigms - React Conf 2017 纪要</a>的结论:</p><ul><li>需要快速开发简单应用的小团队可以考虑使用 MobX，因为 MobX 需要开发的代码量小，学习成本低，上手快，适合于实时系统，仪表盘，文本编辑器，演示软件，但不适用于基于事件的系统</li><li>Redux 适用于大团队开发复杂应用，Redux 在可扩展性和可维护性方面可以 hold 住多人协作与业务需求多变，适合商业系统、基于事件的系统以及涉及复杂反应的游戏场景。</li></ul><p>上述结论的主要依据是 Redux 对 action / event 作出反应，而 MobX 对 state 变化作出反应。比如当一个数据变更涉及到 Mobx 的多个 Store，可以体现出 Redux 的方式更加优雅，数据流更加清晰. 前面都详尽阐述了 Mobx 和 Redux 的优缺点，mobx 还有 MST 加持， 相信读者心里早已有自己的喜好</p><p><br></p><p>扩展</p><ul><li><a href="https://zhuanlan.zhihu.com/p/33761397" target="_blank" rel="noopener">你需要 Mobx 还是 Redux？</a></li><li><a href="https://zhuanlan.zhihu.com/p/25585910" target="_blank" rel="noopener">Mobx 思想的实现原理，及与 Redux 对比</a></li><li><a href="https://zhuanlan.zhihu.com/p/25989654" target="_blank" rel="noopener">MobX vs Redux: Comparing the Opposing Paradigms - React Conf 2017 纪要</a></li><li><a href="https://github.com/dobjs/dob" target="_blank" rel="noopener">dob</a> 更轻量的类似 mobx 的轮子</li><li><a href="https://segmentfault.com/a/1190000018940757" target="_blank" rel="noopener">积梦前端采用的 React 状态管理方案: Rex</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;mid=2697266952&amp;idx=2&amp;sn=a3389d1db237c2b23f523061da3b2359" target="_blank" rel="noopener">干货 | Mvvm 前端数据流框架精讲</a></li></ul><h2 id="rxjs"><a href="#rxjs" class="headerlink" title="RxJS"></a>RxJS</h2><p>如果上文提到的状态管理工具都无法满足你的需要，你的项目复杂程度可能超过全国 99%的项目了. RxJS 可能可以助你一臂之力, <strong>RxJS 非常适合复杂异步事件流的应用</strong>，笔者在这方面实践也比较少，推荐看看<a href="https://www.zhihu.com/people/sharpmaster/posts" target="_blank" rel="noopener">徐飞的相关文章</a>, 另外 Redux(Redux-Observable)和 Mobx 实际上也可以配合 RxJS 使用</p><p><br></p><hr><p><br></p><h2 id="其他状态管理方案"><a href="#其他状态管理方案" class="headerlink" title="其他状态管理方案"></a>其他状态管理方案</h2><ul><li>Apollo+GraphQL</li><li><a href="https://github.com/FormidableLabs/freactal/" target="_blank" rel="noopener">freactal</a></li></ul><p>推荐这篇文章<a href="https://blog.bitsrc.io/state-of-react-state-management-in-2019-779647206bbc" target="_blank" rel="noopener">State of React State Management for 2019</a></p><p><br></p><hr><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/26426054" target="_blank" rel="noopener">单页应用的数据流方案探索</a></li><li><a href="https://zhuanlan.zhihu.com/p/24677176" target="_blank" rel="noopener">复杂单页应用的数据层设计</a></li><li><a href="https://blog.bitsrc.io/state-of-react-state-management-in-2019-779647206bbc" target="_blank" rel="noopener">State of React State Management for 2019</a></li><li><a href="https://zhuanlan.zhihu.com/p/32107541" target="_blank" rel="noopener">从时间旅行的乌托邦，看状态管理的设计误区</a></li></ul></r>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是 520，这是本系列最后一篇文章，主要涵盖 React 状态管理的相关方案。&lt;/p&gt;
&lt;p&gt;前几篇文章在&lt;a href=&quot;https://juejin.im&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金&lt;/a&gt;首发基本石沉大海, 没什么阅读量.
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结04 - 组件的思维</title>
    <link href="https://bobi.ink/2019/05/15/react-component-design-04/"/>
    <id>https://bobi.ink/2019/05/15/react-component-design-04/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-07-11T14:34:42.423Z</updated>
    
    <content type="html"><![CDATA[<p>在 React 的世界里”<strong>一切都是组件</strong>“， 组件可以映射作函数式编程中的函数，React 的组件和函数一样的灵活的特性不仅仅可以用于绘制 UI，还可以用于封装业务状态和逻辑，或者非展示相关的副作用, 再通过组合方式组成复杂的应用. 本文尝试解释用 React 组件的思维来处理常见的业务开发场景.</p><p><strong>系列目录</strong></p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li><a href="/2019/05/20/react-component-design-05/">05 状态管理</a></li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-高阶组件">1. 高阶组件</a></li><li><a href="#2-render-props">2. Render Props</a></li><li><a href="#3-使用组件的方式来抽象业务逻辑">3. 使用组件的方式来抽象业务逻辑</a></li><li><a href="#4-hooks-取代高阶组件">4. hooks 取代高阶组件</a></li><li><a href="#5-hooks-实现响应式编程">5. hooks 实现<code>响应式</code>编程</a></li><li><a href="#6-类继承也有用处">6. 类继承也有用处</a></li><li><a href="#7-模态框管理">7. 模态框管理</a></li><li><a href="#8-使用-context-进行依赖注入">8. 使用 Context 进行依赖注入</a></li><li><a href="#9-不可变的状态">9. 不可变的状态</a></li><li><a href="#10-react-router-url-即状态">10. React-router: URL 即状态</a></li><li><a href="#11-组件规范">11. 组件规范</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="1-高阶组件"><a href="#1-高阶组件" class="headerlink" title="1. 高阶组件"></a>1. 高阶组件</h2><p>在很长一段时期里，高阶组件都是增强和组合 React 组件的最流行的方式. 这个概念源自于函数式编程的高阶函数. 高阶组件可以定义为: <strong>高阶组件是函数，它接收原始组件并返回原始组件的增强/填充版本</strong>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function"><span class="params">Component</span> =&gt;</span> EnhancedComponent;</span><br></pre></td></tr></table></figure><p>首先要明白我们<strong>为什么需要高阶组件</strong>:</p><p>React 的<a href="https://react.docschina.org/docs/higher-order-components.html" target="_blank" rel="noopener">文档</a>说的非常清楚, <strong>高阶组件是一种用于复用组件逻辑模式</strong>. 最为常见的例子就是 redux 的<code>connect</code>和 react-router 的 <code>withRouter</code>. 高阶组件最初用于取代 mixin(了解<a href="https://zhuanlan.zhihu.com/p/20361937" target="_blank" rel="noopener">React Mixin 的前世今生</a>). 总结来说就是两点:</p><ul><li>逻辑复用. 把一些通用的代码逻辑提取出来放到高阶组件中, 让更多组件可以共享</li><li>分离关注点. 在之前的章节中提到”逻辑和视图分离”的原则. 高阶组件可以作为实现该原则的载体. 我们一般将行为层或者业务层抽取到高阶组件中来实现, 让展示组件只关注于 UI</li></ul><p>高阶组件的一些<strong>实现方法</strong>主要有两种:</p><ul><li><p><code>属性代理(Props Proxy)</code>: 代理传递给被包装组件的 props, 对 props 进行操作. 这种方式用得最多. 使用这种方式可以做到:</p><ul><li>操作 props</li><li>访问被包装组件实例</li><li>提取 state</li><li>用其他元素包裹被包装组件</li></ul></li><li><p><code>反向继承(Inheritance Inversion)</code>: 高阶组件继承被包装的组件. 例如:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myhoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> Enhancer <span class="keyword">extends</span> WrappedComponent &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现:</p><ul><li>渲染劫持: 即控制被包装组件的渲染输出.</li><li>操作 state: state 一般属于组件的内部细节, 通过继承的方式可以暴露给子类. 可以增删查改被包装组件的 state, 除非你知道你在干什么, 一般不建议这么做.</li></ul></li></ul><p>实际上高阶组件能做的不止上面列举的, 高阶组件非常灵活, 全凭你的想象力. 读者可以了解 <a href="https://github.com/acdlite/recompose/blob/master/docs/API.md" target="_blank" rel="noopener">recompose</a>这个库, 简直把高阶组件玩出花了.</p><p>总结一下高阶组件的<strong>应用场景</strong>:</p><ul><li>操作 props: 增删查改 props. 例如转换 props, 扩展 props, 固定 props, 重命名 props</li><li>依赖注入. 注入 context 或外部状态和逻辑, 例如 redux 的 connnect, react-router 的 withRouter. 旧 context 是实验性 API, 所以很多库都不会将 context 保留出来, 而是通过高阶组件形式进行注入</li><li>扩展 state: 例如给函数式组件注入状态</li><li>避免重复渲染: 例如 React.memo</li><li>分离逻辑, 让组件保持 dumb</li></ul><blockquote><p>高阶组件相关文档在网上有很多, 本文不打算展开描述. 深入了解<a href="https://zhuanlan.zhihu.com/p/24776678" target="_blank" rel="noopener">高阶组件</a></p></blockquote><p>高阶组件的一些<strong>规范</strong>:</p><ul><li><p>包装显示名字以便于调试</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">class</span> WithSubscription <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  WithSubscription.displayName = <span class="string">`WithSubscription(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">'Component'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 React.forwardRef 来转发 ref</p></li><li><p>使用’高阶函数’来配置’高阶组件’, 这样可以让高阶组件的组合性最大化. Redux 的 connect 就是典型的例子</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ConnectedComment = connect(</span><br><span class="line">  commentSelector,</span><br><span class="line">  commentActions,</span><br><span class="line">)(Comment);</span><br></pre></td></tr></table></figure><p>当使用 compose 进行组合时就能体会到它的好处:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 🙅 不推荐</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 使用compose方法进行组合</span></span><br><span class="line"><span class="comment">// compose(f, g, h) 和 (...args) =&gt; f(g(h(...args)))是一样的</span></span><br><span class="line"><span class="keyword">const</span> enhance = compose(</span><br><span class="line">  <span class="comment">// 这些都是单独一个参数的高阶组件</span></span><br><span class="line">  withRouter,</span><br><span class="line">  connect(commentSelector),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent);</span><br></pre></td></tr></table></figure></li><li><p>转发所有不相关 props 属性给被包装的组件</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp=&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命名: 一般以 with*命名, 如果携带参数, 则以 create*命名</p></li></ul><p><br></p><hr><p><br></p><h2 id="2-render-props"><a href="#2-render-props" class="headerlink" title="2. Render Props"></a>2. Render Props</h2><p>Render Props(Function as Child) 也是一种常见的 react 模式, 比如官方的 <a href="https://reactjs.org/docs/context.html" target="_blank" rel="noopener">Context API</a> 和 <a href="https://www.react-spring.io" target="_blank" rel="noopener">react-spring</a> 动画库. 目的高阶组件差不多: 都是为了分离关注点, 对组件的逻辑进行复用; 在使用和实现上比高阶组件要简单, 在某些场景可以取代高阶组件. 官方的定义是:</p><blockquote><p><strong>是指一种在 React 组件之间使用一个值为函数的 prop 在 React 组件间共享代码的简单技术</strong></p></blockquote><p>React 并没有限定任何 props 的类型, 所以 props 也可以是函数形式. 当 props 为函数时, 父组件可以通过函数参数给子组件传递一些数据进行动态渲染. 典型代码为:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;FunctionAsChild&gt;&#123;<span class="function"><span class="params">()</span> =&gt;</span> &lt;div&gt;Hello,World!&lt;<span class="regexp">/div&gt;&#125;&lt;/</span>FunctionAsChild&gt;</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;Spring <span class="keyword">from</span>=&#123;&#123; opacity: <span class="number">0</span> &#125;&#125; to=&#123;&#123; opacity: <span class="number">1</span> &#125;&#125;&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">props</span> =&gt;</span> &lt;div style=&#123;props&#125;&gt;hello&lt;<span class="regexp">/div&gt;&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Spring&gt;</span><br></pre></td></tr></table></figure><p>某种程度上, 这种模式相比高阶组件要简单很多, 不管是实现还是使用层次. 缺点也很明显:</p><ul><li>可读性差, 尤其是多层嵌套情况下</li><li>组合性差. 只能通过 JSX 一层一层嵌套, 一般不宜多于一层</li><li>适用于动态渲染. 因为局限在 JSX 节点中, 当前组件是很难获取到 render props 传递的数据. 如果要传递给当前组件还是得通过 props, 也就是通过高阶组件传递进来</li></ul><p>再开一下脑洞. 通过一个 Fetch 组件来进行接口请求:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;Fetch method=<span class="string">"user.getById"</span> id=&#123;userId&#125;&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">&#123; data, error, retry, loading &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &#123;loading ? (</span><br><span class="line">        &lt;Loader /&gt;</span><br><span class="line">      ) : error ? (</span><br><span class="line">        &lt;ErrorMessage error=&#123;error&#125; retry=&#123;retry&#125; /&gt;</span><br><span class="line">      ) : data ? (</span><br><span class="line">        &lt;Detail data=&#123;data&#125; /&gt;</span><br><span class="line">      ) : <span class="literal">null</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/Container&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Fetch&gt;</span><br></pre></td></tr></table></figure><p>在 React Hooks 出现之前, 为了给函数组件(或者说 dumb component)添加状态, 通常会使用这种模式. 比如 <a href="https://github.com/renatorib/react-powerplug" target="_blank" rel="noopener">react-powerplug</a></p><blockquote><p>官方<a href="https://react.docschina.org/docs/render-props.html" target="_blank" rel="noopener">文档</a></p></blockquote><p><br></p><hr><p><br></p><h2 id="3-使用组件的方式来抽象业务逻辑"><a href="#3-使用组件的方式来抽象业务逻辑" class="headerlink" title="3. 使用组件的方式来抽象业务逻辑"></a>3. 使用组件的方式来抽象业务逻辑</h2><p>大部分情况下, 组件表示是一个 UI 对象. 其实组件不单单可以表示 UI, 也可以用来抽象业务对象, 有时候抽象为组件可以巧妙地解决一些问题.</p><p>举一个例子: 当一个审批人在审批一个请求时, 请求发起者是不能重新编辑的; 反之发起者在编辑时, 审批人不能进行审批. 这是一个锁定机制, 后端一般使用类似心跳机制来维护这个’锁’, 这个锁可以显式释放，也可以在超过一定时间没有激活时自动释放，比如页面关闭. 所以前端通常会使用轮询机制来激活锁.</p><p>一般的实现:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MyPage <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 根据一些条件触发, 可能还要监听这些条件的变化，然后停止加锁轮询. 这个逻辑实现起来比较啰嗦</span></span><br><span class="line">    <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">      <span class="keyword">this</span>.timer = setInterval(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 轮询</span></span><br><span class="line">        tryLock();</span><br><span class="line">        <span class="comment">// 错误处理，可以加锁失败...</span></span><br><span class="line">      &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">    <span class="comment">// 页面卸载时显式释放</span></span><br><span class="line">    releaseLock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidUpdate() &#123;</span><br><span class="line">    <span class="comment">// 监听条件变化，开始或停止锁定</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着功能的迭代, MyPage 会变得越来越臃肿, 这时候你开始考虑将这些业务逻辑抽取出去. 一般情况下通过高阶组件或者 hook 来实现, 但都不够灵活, 比如<strong>条件锁定这个功能实现起来就比较别扭</strong>.</p><p>有时候考虑将业务抽象成为组件, 可能可以巧妙地解决我们的问题, 例如 Locker:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 锁定器</span><br><span class="line"> */</span><br><span class="line">const Locker: FC&lt;&#123; onError: err =&gt; boolean, id: string &#125;&gt; = props =&gt; &#123;</span><br><span class="line">  const &#123;id, onError&#125; = props</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let timer</span><br><span class="line">    const poll = () =&gt; &#123;</span><br><span class="line">      timer = setTimeout(async () =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">        // 轮询，处理异常等情况</span><br><span class="line">      &#125;, 5000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    poll()</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      releaseLock()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [id])</span><br><span class="line"></span><br><span class="line">  return null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 Locker</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">    &#123;someCondition &amp;&amp; &lt;Locker id=&#123;<span class="keyword">this</span>.id&#125; onError=&#123;<span class="keyword">this</span>.handleError&#125;&gt;&lt;<span class="regexp">/Locker&gt;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有一个要点：我们将一个业务抽象为了一个组件后，业务逻辑有了和组件一样的生命周期。<strong>现在组件内部只需关心自身的逻辑，比如只关心资源请求和释放(即 How)，而何时进行，什么条件进行(即 When)则由父级来决定</strong>, 这样就符合了单一职责原则。 上面的例子父级通过 JSX 的条件渲染就可以动态控制锁定, 比之前的实现简单了很多</p><p><br></p><hr><p><br></p><h2 id="4-hooks-取代高阶组件"><a href="#4-hooks-取代高阶组件" class="headerlink" title="4. hooks 取代高阶组件"></a>4. hooks 取代高阶组件</h2><p>个人觉得 hooks 对于 React 开发来说是一个革命性的特性, 它改变了开发的思维和模式. 首先要问一下, “它解决了什么问题? 带来了什么新的东西?”</p><p>hooks 首先是要解决高阶组件或者 Render Props 的痛点的. 官方在’<strong>动机</strong>‘上就说了:</p><ul><li><ol><li><strong>很难在组件之间复用状态逻辑</strong>:</li></ol><ul><li>问题: React 框架本身并没有提供一种将可复用的逻辑注入到组件上的方式/原语. RenderProps 和高阶组件只是’模式层面(或者说语言层面)’的东西:</li><li>此前的方案: 高阶组件和 Render Props。<strong>这些方案都是基于组件本身的机制</strong><ul><li>高阶组件和 Render Props 会造成多余的节点嵌套. 即 Wrapper hell</li><li>需要调整你的组件结构, 会让代码变得笨重, 且难以理解</li><li>高阶组件复杂, 难以理解</li><li>此前高阶组件也要 ref 转发问题等等</li></ul></li><li><p>hooks 如何解决:</p><ul><li>将状态逻辑从组件中脱离, 让他可以被单独的测试和复用.</li><li>hooks 可以在组件之间共享, 不会影响组件的结构</li></ul><p><br></p></li></ul></li><li><ol start="2"><li><strong>复杂的组件难以理解</strong>: 复杂组件的特点是有一大堆分散的状态逻辑和副作用. 例如每个生命周期函数常常包含一些互不相关的逻辑, 这些互不相关的逻辑会慢慢变成面条式的代码, 但是你发现很难再对它们进行拆解, 更别说测试它们</li></ol><ul><li>问题:<ul><li>实际情况，我们很难将这些组件分解成更小的组件，因为状态到处都是。测试它们也很困难。</li><li>经常导致过分抽象, 比如 redux, 需要在多个文件中跳转, 需要很多模板文件和模板代码</li></ul></li><li>此前的解决方法: 高阶组件和 Render Props 或者状态管理器. 分割抽离逻辑和 UI, 切割成更小粒度的组件</li><li><p>hooks 如何解决: Hooks 允许您根据相关部分(例如设置订阅或获取数据)将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。你还可以选择使用一个 reducer 来管理组件的本地状态，以使其更加可预测</p><p><br></p></li></ul></li><li><ol start="3"><li>基于 class 的组件对机器和用户都不友好:</li></ol><ul><li>问题:<ul><li>对于人: 需要理解 this, 代码冗长</li><li>对于机器: 不好优化</li></ul></li><li>hooks 如何解决: 函数式组件</li><li>新的问题: 你要了解闭包</li></ul></li></ul><p><br></p><p>Hooks 带来的<strong>新东西</strong>: <strong>hook 旨在让组件的内部逻辑组织成可复用的更小单元，这些单元各自维护一部分组件‘状态和逻辑’</strong>。</p><p><img alt="migrate to hooks" src="/images/04/hooks-transform.png" width="800"><br>图片来源于twitter(<a href="https://twitter.com/threepointone/status/1056594421079261185/photo/1?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1056594421079261185&amp;ref_url=https%3A%2F%2Fmedium.com%2Fmedia%2Fe55e7bcbf2d4912af7e539a2646388e2%3FpostId%3Dfdbde8803889" target="_blank" rel="noopener">@sunil Pai</a>)</p><ul><li><strong>一种新的组件编写方式</strong>. 和此前基于 class 或纯函数组件的开发方式不太一样, hook 提供了更简洁的 API 和代码复用机制, 这使得组件代码变得更简短. 例如 👆 上图就是迁移到 hooks 的代码结构对比, 读者也可以看这个演讲(<a href="https://www.youtube.com/watch?v=wXLf18DsV-I" target="_blank" rel="noopener">90% Cleaner React</a>).<br><br></li><li><strong>更细粒度的状态控制(useState)</strong>. 以前一个组件只有一个 setState 集中式管理组件状态, <strong>现在 hooks 像组件一样, 是一个逻辑和状态的聚合单元. 这意味着不同的 hook 可以维护自己的状态</strong>.<br><br></li><li><p><strong>不管是 hook 还是组件，都是普通函数</strong>.</p><ul><li><strong>从某种程度上看组件和 hooks 是同质的(都包含状态和逻辑)</strong>. 统一使用函数形式开发, 这使得你不需要在类、高阶组件或者 renderProps 上下文之间切换, 降低项目的复杂度. 对于 React 的新手来说，各种高阶组件、render props 各种概念拉高了学习曲线</li><li><strong>函数是一种最简单的代码复用单元, 最简单也意味着更灵活</strong>。相比组件的 props，函数的传参更加灵活； 函数也更容易进行组合, hooks 组合其他 hook 或普通函数来实现复杂逻辑.</li><li><strong>本质上讲，hooks 就是给函数带来了状态的概念</strong><br><br></li></ul></li><li><p><strong>高阶组件之间只能简单嵌套复合(compose), 而多个 hooks 之间是平铺的, 可以定义更复杂的关系(依赖)</strong>.<br><br></p></li><li><strong>更容易进行逻辑和视图分离</strong>. hooks 天然隔离 JSX, 视图和逻辑之间的界限比较清晰, 这使得 hooks 可以更专注组件的行为.<br><br></li><li><strong>淡化组件生命周期概念, 将本来分散在多个生命周期的相关逻辑聚合起来</strong><br><br></li><li><strong>一点点’响应式编程’的味道</strong>, 每个 hooks 都包含一些状态和副作用，这些数据可以在 hooks 之间传递流动和响应， 见下文<br><br></li><li><strong>跨平台的逻辑复用</strong>. 这是我自己开的脑洞, React hooks 出来之后<a href="https://github.com/yyx990803" target="_blank" rel="noopener">尤雨溪</a>就推了一个<a href="https://github.com/yyx990803/vue-hooks" target="_blank" rel="noopener">vue-hooks</a>试验项目, 如果后面发展顺利, hooks 是可能被用于跨框架复用?</li></ul><p><br></p><p>一个<strong>示例</strong>: 无限加载列表</p><iframe src="https://codesandbox.io/embed/rwq4opm70n?codemirror=1&fontsize=14&view=editor" title="useList" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p><br></p><p>一般 hooks 的基本代码结构为:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useHook</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️states</span></span><br><span class="line">  <span class="keyword">const</span> [someState, setSomeState] = useState(initialValue);</span><br><span class="line">  <span class="comment">// ⚛️derived state</span></span><br><span class="line">  <span class="keyword">const</span> computedState = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computed, [dependencies]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️refs</span></span><br><span class="line">  <span class="keyword">const</span> refSomething = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️side effect</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, []);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, [dependencies]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️state operations</span></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setSomeState(newState)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️output</span></span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;&#123;...&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>自定义 hook 和函数组件的代码结构基本一致, 所以有时候<strong>hooks 写着写着原来越像组件, 组件写着写着越像 hooks. 我觉得可以认为组件就是一种特殊的 hook, 只不过它输出 Virtual DOM</strong>.</p><p><br></p><p>一些<strong>注意事项</strong>:</p><ul><li>只能在组件顶层调用 hooks。不要在循环，控制流和嵌套的函数中调用 hooks</li><li>只能从 React 的函数组件中调用 hooks</li><li>自定义 hooks 使用 use*命名</li></ul><p><br></p><p>总结 hooks 的<strong>常用场景</strong>:</p><ul><li><strong>副作用封装和监听</strong>: 例如 useWindowSize(监听窗口大小)，useOnlineStatus(在线状态)</li><li><strong>副作用衍生</strong>: useEffect, useDebounce, useThrottle, useTitle, useSetTimeout</li><li><strong>DOM 事件封装</strong>：useActive，useFocus, useDraggable, useTouch</li><li><strong>获取 context</strong></li><li><strong>封装可复用逻辑和状态</strong>: useInput, usePromise(异步请求), useList(列表加载)<ul><li>取代高阶组件和 render Props. 例如使用 useRouter 取代 withRouter, useSpring 取代旧的 Spring Render Props 组件</li><li>取代容器组件</li><li>状态管理器: use-global-hook, unstated</li></ul></li><li><strong>扩展状态操作</strong>: 原始的 useState 很简单，所以有很大的扩展空间，例如 useSetState(模拟旧的 setState), useToggle(boolean 值切换)，useArray, useLocalStorage(同步持久化到本地存储)</li><li>继续开脑洞…: hooks 的探索还在<a href="https://usehooks.com/" target="_blank" rel="noopener">继续</a></li></ul><p>学习 hooks:</p><ul><li><a href="https://react.docschina.org/docs/hooks-overview.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/50597236" target="_blank" rel="noopener">一篇看懂 React Hooks</a></li><li><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM" target="_blank" rel="noopener">React Today and Tomorrow and 90% Cleaner React With Hooks</a></li><li><a href="https://www.hooks.guide/" target="_blank" rel="noopener">hook-guide</a></li><li><a href="https://zhuanlan.zhihu.com/p/50274018" target="_blank" rel="noopener">精读《怎么用 React Hooks 造轮子》</a></li><li><a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" target="_blank" rel="noopener">Making Sense of React Hooks</a></li><li><a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a></li></ul><p><br></p><hr><p><br></p><h2 id="5-hooks-实现响应式编程"><a href="#5-hooks-实现响应式编程" class="headerlink" title="5. hooks 实现响应式编程"></a>5. hooks 实现<code>响应式</code>编程</h2><p><code>Vue</code>的非侵入性<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">响应式系统</a>是其最独特的特性之一, 可以按照 Javascript 的数据操作习惯来操作组件状态， 然后自动响应到页面中. 而 React 这边则提供了 setState, 对于复杂的组件状态, setState 会让代码变得的又臭又长. 例如:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  pagination: &#123;</span><br><span class="line">    ...this.state.pagination,</span><br><span class="line">    current: defaultPagination.current || <span class="number">1</span>,</span><br><span class="line">    pageSize: defaultPagination.pageSize || <span class="number">15</span>,</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后来有了<a href="https://cn.mobx.js.org" target="_blank" rel="noopener">mobx</a>, 基本接近了 Vue 开发体验:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@observer</span></span><br><span class="line"><span class="keyword">class</span> TodoView <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@observable</span> loading: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@observable</span> error?: <span class="built_in">Error</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@observable</span> list: Item[] = [];</span><br><span class="line">  <span class="comment">// 衍生状态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@computed</span> <span class="keyword">get</span> completed() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list.filter(<span class="function"><span class="params">i</span> =&gt;</span> i.completed)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.load();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> load() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.error = <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">await</span> fetchList()</span><br><span class="line">      <span class="keyword">this</span>.list = list</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.error = err</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 mobx 也有挺多缺点:</p><ul><li>代码侵入性. 所有需要响应数据变动的组件都需要使用 observer 装饰, 属性需要使用 observable 装饰, 以及数据操作方式. 对 mobx 耦合较深, 日后切换框架或重构的成本很高</li><li><p>兼容性. mobx v5 后使用 Proxy 进行重构, Proxy 在 Chrome49 之后才支持. 如果要兼容旧版浏览器则只能使用 v4, v4 有一些<a href="https://cn.mobx.js.org/#mobx-4-vs-mobx-5" target="_blank" rel="noopener">坑</a>, 这些坑对于不了解 mobx 的新手很难发现:</p><ul><li>Observable 数组并非真正的数组. 比如 antd 的 Table 组件就不认 mobx 的数组, 需要传入到组件之间使用 slice 进行转换</li><li>向一个已存在的 observable 对象中添加属性不会被自动捕获</li></ul></li></ul><p><br></p><p>于是 hooks 出现了, 它让组件的状态管理变得更简单直接, 而且它的思想也很接近 mobx 响应式编程哲学:</p><p><img src="/images/04/mobx.png" alt="mobx"></p><p><br></p><ol><li>简洁地声明状态</li></ol><p><strong>状态</strong> 是驱动应用的数据. 例如 UI 状态或者业务领域状态</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;Item[]&gt;([]);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>衍生</li></ol><p>任何 源自状态并且不会再有任何进一步的相互作用的东西就是衍生。包括用户视图, 衍生状态, 其他副作用</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props: &#123; id: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = props;</span><br><span class="line">  <span class="comment">// 取代mobx的observable: 获取列表, 在挂载或id变动时请求</span></span><br><span class="line">  <span class="keyword">const</span> [value, setValue, loading, error, retry] = usePromise(</span><br><span class="line">    <span class="keyword">async</span> id =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> getList(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    [id],</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 衍生状态: 取代mobx的computed</span></span><br><span class="line">  <span class="keyword">const</span> unreads = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> value.filter(<span class="function"><span class="params">i</span> =&gt;</span> !i.readed), [value]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 衍生副作用: value变动后自动持久化</span></span><br><span class="line">  useDebounce(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      saveList(id, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    [value],</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 衍生视图</span></span><br><span class="line">  <span class="keyword">return</span> &lt;List data=&#123;value&#125; onChange=&#123;setValue&#125; error=&#123;error&#125; loading=&#123;loading&#125; retry=&#123;retry&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/04/hook-stream.png" width="400"></p><p>所以说 hook 是一个革命性的东西, 它可以让组件的状态数据流更加清晰. 换做 class 组件, 我们通常的做法可能是在 <code>componentDidUpdate</code>生命周期方法中进行数据比较, 然后命令式地触发一些方法. 比如 id 变化时触发 getList, list 变化时进行 saveList.</p><p><strong>hook 似乎在淡化组件生命周期的概念, 让开发者更专注于状态的关系, 以数据流的方式来思考组件的开发</strong>. <a href="https://mobile.twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a>在<a href="https://overreacted.io/zh-hans/writing-resilient-components/" target="_blank" rel="noopener">编写有弹性的组件</a>也提到了一个原则”不要阻断数据流”, 证实了笔者的想法:</p><blockquote><p>无论何时使用 props 和 state，请考虑如果它们发生变化会发生什么。在大多数情况下，组件不应以不同方式处理初始渲染和更新流程。这使它能够适应逻辑上的变化。</p></blockquote><p>读者可以看一下<a href="https://github.com/rehooks/awesome-react-hooks" target="_blank" rel="noopener">awesome-react-hooks</a>, 这些开源的 hook 方案都挺有意思. 例如<a href="https://github.com/LeetCode-OpenSource/rxjs-hooks" target="_blank" rel="noopener">rxjs-hooks</a>, 巧妙地将 react hooks 和 rxjs 结合的起来:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props: &#123; foo: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 响应props的变动</span></span><br><span class="line">  <span class="keyword">const</span> value = useObservable(inputs$ =&gt; inputs$.pipe(map(<span class="function">(<span class="params">[val]</span>) =&gt;</span> val + <span class="number">1</span>)), <span class="number">200</span>, [props.foo]);</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123;value&#125;&lt;<span class="regexp">/h1&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="6-类继承也有用处"><a href="#6-类继承也有用处" class="headerlink" title="6. 类继承也有用处"></a>6. 类继承也有用处</h2><p>就如 react 官方文档说的: “我们的 React 使用了数以千计的组件，然而却还未发现任何需要推荐你使用继承的情况。”, React 偏向于函数式编程的组合模式, 面向对象的继承实际的应用场景很少.</p><p>当我们需要将一些传统的第三方库转换成 React 组件库时, 继承就可能派上用场. 因为这些库大部分是使用面向对象的范式来组织的, 比较典型的就是地图 SDK. 以<a href="http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference_3_0.html" target="_blank" rel="noopener">百度地图</a>为例:</p><p><img src="/images/04/overlay.png" alt="baidu overlay"></p><p>百度地图有各种组件类型: controls, overlays, tileLayers. 这些类型都有多个子类, 如上图, overlay 有 Label, Marker, Polyline 等这些子类, 且这些子类有相同的生命周期, 都是通过 addOverlay 方法来渲染到地图画布上. 我们可以通过继承的方式将他们生命周期管理抽取到父类上, 例如:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overlay抽象类, 负责管理Overlay的生命周期</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Overlay&lt;P&gt; <span class="keyword">extends</span> React.PureComponent&lt;OverlayProps &amp; P&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> initialize?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 子类在constructor或initialize方法中进行实例化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.initialize) &#123;</span><br><span class="line">      <span class="keyword">this</span>.initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.instance &amp;&amp; <span class="keyword">this</span>.context) &#123;</span><br><span class="line">      <span class="comment">// 渲染到Map画布中</span></span><br><span class="line">      <span class="keyword">this</span>.context.nativeInstance!.addOverlay(<span class="keyword">this</span>.instance);</span><br><span class="line">      <span class="comment">// 初始化参数</span></span><br><span class="line">      <span class="keyword">this</span>.initialProperties();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidUpdate(prevProps: P &amp; OverlayProps) &#123;</span><br><span class="line">    <span class="comment">// 属性更新</span></span><br><span class="line">    <span class="keyword">this</span>.updateProperties(prevProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">// 组件卸载</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.instance &amp;&amp; <span class="keyword">this</span>.context) &#123;</span><br><span class="line">      <span class="keyword">this</span>.context.nativeInstance!.removeOverlay(<span class="keyword">this</span>.instance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 其他通用方法</span></span><br><span class="line">  <span class="keyword">private</span> forceReloadIfNeed(props: P, prevProps: P) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的工作就变得简单很多, 声明自己的属性/事件和实例化具体类:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Label <span class="keyword">extends</span> Overlay&lt;LabelProps&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    enableMassClear: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">props: LabelProps</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">const</span> &#123; position, content &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="comment">// 声明支持的属性和回调</span></span><br><span class="line">    <span class="keyword">this</span>.extendedProperties = PROPERTIES;</span><br><span class="line">    <span class="keyword">this</span>.extendedEnableableProperties = ENABLEABLE_PROPERTIES;</span><br><span class="line">    <span class="keyword">this</span>.extendedEvents = EVENTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化具体类</span></span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="keyword">new</span> BMap.Label(content, &#123;</span><br><span class="line">      position,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码来源于 <a href="https://github.com/ivan-94/react-bdmap" target="_blank" rel="noopener">react-bdmap</a></p></blockquote><p>当然这个不是唯一的解决方法, 使用高阶组件和 hooks 同样能够实现. 只不过对于原本就采用面向对象范式组织的库, 使用继承方式会更加好理解</p><p><br></p><hr><p><br></p><h2 id="7-模态框管理"><a href="#7-模态框管理" class="headerlink" title="7. 模态框管理"></a>7. 模态框管理</h2><p><img src="/images/04/modal-demo.png" alt="modal demo"></p><p>模态框是应用开发中使用频率非常高组件，尤其在中后台管理系统中. 但是在 React 中用着并不是特别爽, 典型的代码如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Demo: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const [visible, setVisible] = useState(false);</span><br><span class="line">  const [editing, setEditing] = useState();</span><br><span class="line">  const handleCancel = () =&gt; &#123;</span><br><span class="line">    setVisible(false);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const prepareEdit = async (item: Item) =&gt; &#123;</span><br><span class="line">    // 加载详情</span><br><span class="line">    const detail = await loadingDeatil(item.id);</span><br><span class="line">    setEditing(detail);</span><br><span class="line">    setVisible(true);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const handleOk = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const values = await form.validate();</span><br><span class="line">      // 保存</span><br><span class="line">      await save(editing.id, values);</span><br><span class="line">      // 隐藏</span><br><span class="line">      setVisible(false);</span><br><span class="line">    &#125; catch &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;Table</span><br><span class="line">      dataSource=&#123;list&#125;</span><br><span class="line">      columns=&#123;[</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;操作&apos;,</span><br><span class="line">          render: item =&gt; &#123;</span><br><span class="line">            return &lt;a onClick=&#123;() =&gt; prepareEdit(item)&#125;&gt;编辑&lt;/a&gt;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ]&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;Modal visible=&#123;visible&#125; onOk=&#123;handleOk&#125; onCancel=&#123;handleHide&#125;&gt;</span><br><span class="line">      &#123;/* 表单渲染 */&#125;</span><br><span class="line">    &lt;/Modal&gt;</span><br><span class="line">  &lt;/&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码太丑了， 不相关逻辑堆积在一个组件下 ，不符合单一职责. 所以我们要将模态框相关代码抽取出去, 放到 EditModal 中:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EditModal: FC&lt;&#123; id?: string; visible: boolean; onCancel: () =&gt; void; onOk: () =&gt; void &#125;&gt; = props =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const &#123; visible, id, onHide, onOk &#125; = props;</span><br><span class="line">  const detail = usePromise(async (id: string) =&gt; &#123;</span><br><span class="line">    return loadDetail(id);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    if (id != null) &#123;</span><br><span class="line">      detail.call(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [id]);</span><br><span class="line"></span><br><span class="line">  const handleOk = () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const values = await form.validate();</span><br><span class="line">      // 保存</span><br><span class="line">      await save(editing.id, values);</span><br><span class="line">      onOk();</span><br><span class="line">    &#125; catch &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Modal visible=&#123;visible&#125; onOk=&#123;onOk&#125; onCancel=&#123;onCancel&#125;&gt;</span><br><span class="line">      &#123;detail.value &amp;&amp;</span><br><span class="line">        &#123;</span><br><span class="line">          /* 表单渲染 */</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &lt;/Modal&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用</span><br><span class="line"> */</span><br><span class="line">const Demo: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const [visible, setVisible] = useState(false);</span><br><span class="line">  const [editing, setEditing] = useState&lt;string | undefined&gt;(undefined);</span><br><span class="line">  const handleHide = () =&gt; &#123;</span><br><span class="line">    setVisible(false);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const prepareEdit = async (item: Item) =&gt; &#123;</span><br><span class="line">    setEditing(item.id);</span><br><span class="line">    setVisible(true);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;Table</span><br><span class="line">      dataSource=&#123;list&#125;</span><br><span class="line">      columns=&#123;[</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;操作&apos;,</span><br><span class="line">          render: item =&gt; &#123;</span><br><span class="line">            return &lt;a onClick=&#123;() =&gt; prepareEdit(item)&#125;&gt;编辑&lt;/a&gt;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ]&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;EditModal id=&#123;editing&#125; visible=&#123;visible&#125; onOk=&#123;handleHide&#125; onCancel=&#123;handleHide&#125;&gt;</span><br><span class="line">      &#123;&apos; &apos;&#125;</span><br><span class="line">    &lt;/EditModal&gt;</span><br><span class="line">  &lt;/&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在编辑相关的逻辑抽取到了 EditModal 上，但是 Demo 组件还要维护模态框的打开状态和一些数据状态。一个复杂的页面可能会有很多模态框，这样的代码会变得越来越恶心， 各种 xxxVisible 状态满天飞. 从实际开发角度上将，模态框控制的最简单的方式应该是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const handleEdit = item =&gt; &#123;</span><br><span class="line">  EditModal.show(&#123;</span><br><span class="line">    // 🔴 通过函数调用的方式出发弹窗. 这符合对模态框的习惯用法, 不关心模态框的可见状态. 例如window.confirm, wx.showModal().</span><br><span class="line">    id: item.id, // 🔴 传递数据给模态框</span><br><span class="line">    onOk: saved =&gt; &#123;</span><br><span class="line">      // 🔴 事件回调</span><br><span class="line">      refreshList(saved);</span><br><span class="line">    &#125;,</span><br><span class="line">    onCancel: async () =&gt; &#123;</span><br><span class="line">      return confirm(&apos;确认取消&apos;); // 控制模态框是否隐藏</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式在社区上也是有争议的，有些人认为这是 React 的反模式，<a href="https://www.zhihu.com/people/yu-san-geng" target="_blank" rel="noopener">@欲三更</a>在<a href="https://zhuanlan.zhihu.com/p/54492049" target="_blank" rel="noopener">Modal.confirm 违反了 React 的模式吗？</a>就探讨了这个问题。 以图为例：</p><p><img src="/images/04/modal-confirm.jpg" alt="modal confirm"></p><p>红线表示时间驱动(或者说时机驱动), 蓝线表示数据驱动。欲三更认为“哪怕一个带有明显数据驱动特色的 React 项目，也存在很多部分不是数据驱动而是事件驱动的. 数据只能驱动出状态，只有时机才能驱动出行为, 对于一个时机驱动的行为，你非得把它硬坳成一个数据驱动的状态，你不觉得很奇怪吗?”. 他的观点正不正确笔者不做评判, 但是某些场景严格要求‘数据驱动’，可能会有很多模板代码，写着会很难受.</p><p>So 怎么实现?</p><p>可以参考 antd <a href="https://github.com/ant-design/ant-design/blob/master/components/modal/confirm.tsx" target="_blank" rel="noopener">Modal.confirm</a>的实现, 它使用<code>ReactDOM.render</code>来进行外挂渲染，也有人使用<a href="https://medium.com/@BogdanSoare/how-to-use-reacts-new-context-api-to-easily-manage-modals-2ae45c7def81" target="_blank" rel="noopener">Context API</a>来实现的. 笔者认为比较接近理想的(至少 API 上看)是<a href="https://github.com/haradakunihiko/react-confirm" target="_blank" rel="noopener">react-comfirm</a>这样的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EditModal.tsx</span><br><span class="line"> */</span><br><span class="line">import &#123; confirmable &#125; from &apos;react-confirm&apos;;</span><br><span class="line">const EditModal = props =&gt; &#123;</span><br><span class="line">  /*...*/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default confirmable(EditModal);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Demo.tsx</span><br><span class="line"> */</span><br><span class="line">import EditModal from &apos;./EditModal&apos;;</span><br><span class="line"></span><br><span class="line">const showEditModal = createConfirmation(EditModal);</span><br><span class="line"></span><br><span class="line">const Demo: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span><br><span class="line">  const prepareEdit = async (item: Item) =&gt; &#123;</span><br><span class="line">    showEditModal(&#123;</span><br><span class="line">      id: item.id, // 🔴 传递数据给模态框</span><br><span class="line">      onOk: saved =&gt; &#123;</span><br><span class="line">        // 🔴 事件回调</span><br><span class="line">        refreshList(saved);</span><br><span class="line">      &#125;,</span><br><span class="line">      onCancel: async someValues =&gt; &#123;</span><br><span class="line">        return confirm(&apos;确认取消&apos;); // 控制模态框是否隐藏</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>ReactDOM.render</code>外挂渲染形式的缺点就是无法访问 Context，所以还是要妥协一下，结合 Context API 来实现示例：</p><iframe src="https://codesandbox.io/embed/lryom9617l?autoresize=1&fontsize=14" title="useModal" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>扩展</p><ul><li><a href="https://github.com/ant-design/ant-design/blob/master/components/modal/confirm.tsx" target="_blank" rel="noopener">Modal.confirm</a></li><li><a href="https://zhuanlan.zhihu.com/p/54492049" target="_blank" rel="noopener">Modal.confirm 违反了 React 的模式吗？</a></li><li><a href="https://www.zhihu.com/search?type=content&amp;q=react%20modal" target="_blank" rel="noopener">使用 render props 抽象 Modal 组件的状态</a></li><li><a href="https://github.com/haradakunihiko/react-confirm" target="_blank" rel="noopener">react-confirm</a></li><li><a href="https://medium.com/@BogdanSoare/how-to-use-reacts-new-context-api-to-easily-manage-modals-2ae45c7def81" target="_blank" rel="noopener">How to use React’s new Context API to easily manage modals</a> 基于 Context 的方案</li></ul><p><br></p><hr><p><br></p><h2 id="8-使用-context-进行依赖注入"><a href="#8-使用-context-进行依赖注入" class="headerlink" title="8. 使用 Context 进行依赖注入"></a>8. 使用 Context 进行依赖注入</h2><p>Context 为组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性.</p><p>Context 在 React 应用中使用非常频繁, 新的<a href="https://react.docschina.org/docs/context.html#when-to-use-context" target="_blank" rel="noopener">Context API</a>也非常易用. Context 常用于以下场景:</p><ul><li><strong>共享那些被认为对于一个’组件树’而言是“全局”的数据</strong>. 如当前认证的用户, 主题, i18n 配置, 表单状态</li><li><strong>组件配置</strong>. 配置组件的行为, 如 antd 的 ConfigProvider</li><li><strong>跨组件通信</strong>. 不推荐通过’事件’进行通信, 而是通过’状态’进行通信</li><li><strong>依赖注入</strong></li><li><strong>状态管理器</strong>. Context 经过一些封装可以基本取代 Redux 和 Mobx 这些状态管理方案. 后续有专门文章介绍</li></ul><p>Context 的作用域是子树, 也就是说一个 Context Provider 可以应用于多个子树, 子树的 Provider 也可以覆盖父级的 Provider 的 value. 基本结构:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useContext&#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export inteface MyContextValue &#123;</span><br><span class="line">  state: number</span><br><span class="line">  setState: (state: number) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const MyContext = React.createContext&lt;MyContextValue&gt;(</span><br><span class="line">  &#123;</span><br><span class="line">    state: 1,</span><br><span class="line">    // 设置默认值, 抛出错误, 必须配合Provider使用</span><br><span class="line">    setState: () =&gt; throw new Error(&apos;请求MyContextProvider组件下级调用&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export const MyContextProvider: FC&lt;&#123;&#125;&gt; = props =&gt; &#123;</span><br><span class="line">  const [state, setState] = useState(1)</span><br><span class="line">  return &lt;MyContext.Provider value=&#123;&#123;state, setState&#125;&#125;&gt;&#123;props.children&#125;&lt;/MyContext.Provider&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useMyContext() &#123;</span><br><span class="line">  return useContext(MyContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default MyContextProvider</span><br></pre></td></tr></table></figure><blockquote><p>Context 默认值中的方法应该抛出错误, 警告不规范的使用</p></blockquote><p>扩展：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/50336226" target="_blank" rel="noopener">避免 React Context 导致的重复渲染</a></li></ul><p><br></p><hr><p><br></p><h2 id="9-不可变的状态"><a href="#9-不可变的状态" class="headerlink" title="9. 不可变的状态"></a>9. 不可变的状态</h2><p>对于函数式编程范式的 React 来说，不可变状态有重要的意义.</p><ul><li><p>不可变数据具有可预测性。 可不变数据可以让应用更好调试，对象的变更更容易被跟踪和推导.<br>就比如 Redux, 它要求只能通过 dispatch+reducer 进行状态变更，配合它的 Devtool 可以很好的跟踪状态是如何被变更的. 这个特性对于大型应用来说意义重大，因为它的状态非常复杂，如果不加以组织和约束，你不知道是哪个地方修改了状态， 出现 bug 时很难跟踪.</p><p>所以说对于严格要求单向数据流的状态管理器(Redux)来说，不可变数据是基本要求，它要求整个应用由一个单一的状态进行映射，不可变数据可以让整个应用变得可被预测.</p></li><li><p>不可变数据还使一些复杂的功能更容易实现。避免数据改变，使我们能够安全保留对旧数据的引用，可以方便地实现撤销重做，或者时间旅行这些功能</p></li><li>可以精确地进行重新渲染判断。可以简化 shouldComponentUpdate 比较。</li></ul><p>实现不可变数据的流行方法:</p><ul><li><a href="https://github.com/immerjs/immer" target="_blank" rel="noopener">immer</a></li><li><a href="https://github.com/immutable-js/immutable-js" target="_blank" rel="noopener">Immutable.js</a></li></ul><p>笔者比较喜欢 immer，没有什么心智负担, 按照 JS 习惯的对象操作方式就可以实现不可变数据。</p><p><br></p><hr><p><br></p><h2 id="10-react-router-url-即状态"><a href="#10-react-router-url-即状态" class="headerlink" title="10. React-router: URL 即状态"></a>10. React-router: URL 即状态</h2><center><br> <img src="/images/04/static-router.png" width="300"><br></center><p>传统的路由主要用于区分页面, 所以一开始前端路由设计也像后端路由(也称为<strong>静态路由</strong>)一样, 使用对象配置方式, 给不同的 url 分配不同的页面组件, 当应用启动时, 在路由配置表中查找匹配 URL 的组件并渲染出来.</p><p>React-Router v4 算是一个真正意义上符合<em>组件化</em>思维的路由库, React-Router 官方称之为‘动态路由’, 官方的解释是”指的是在应用程序渲染时发生的路由，而不是在运行应用程序之外的配置或约定中发生的路由”, 具体说, <code>&lt;Route/&gt;</code>变成了一个普通 React 组件, 它在渲染时判断是否匹配 URL, 如果匹配就渲染指定的组件, 不匹配就返回 null.</p><p>这时候 URL 意义已经不一样了, <strong>URL 不再是简单的页面标志, 而是应用的状态</strong>; <strong>应用构成也不再局限于扁平页面, 而是多个可以响应 URL 状态的区域(可嵌套)</strong>. 因为思维转变很大, 所以它刚出来时并不受青睐. 这种方式更加灵活， 所以选择 v4 不代表放弃旧的路由方式, 你完全可以按照<a href="https://react-router.docschina.org/core/guides/static-routes" target="_blank" rel="noopener">旧的方式</a>来实现页面路由.</p><p>举个应用实例: 一个应用由三个区域组成: 侧边栏放置多个入口, 点击这些入口会加载对应类型的列表, 点击列表项需要加载详情. 三个区域存在级联关系</p><p><img src="/images/04/router-demo.png" alt="router demo"></p><p>首先设计能够表达这种级联关系的 URL, 比如<code>/{group}/{id}</code>, URL 设计一般遵循<a href="https://ruby-china.github.io/rails-guides/v5.0/routing.html#嵌套资源" target="_blank" rel="noopener">REST 风格</a>, 那么应用的大概结构是这样子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// App</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  &lt;div className=&quot;app&quot;&gt;</span><br><span class="line">    &lt;SideBar /&gt;</span><br><span class="line">    &lt;Route path=&quot;/:group&quot; component=&#123;ListPage&#125; /&gt;</span><br><span class="line">    &lt;Route path=&quot;/:group/:id&quot; component=&#123;Detail&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// SideBar</span><br><span class="line">const Sidebar = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;sidebar&quot;&gt;</span><br><span class="line">      &#123;/* 使用NavLink 在匹配时显示激活状态 */&#125;</span><br><span class="line">      &lt;NavLink to=&quot;/message&quot;&gt;消息&lt;/NavLink&gt;</span><br><span class="line">      &lt;NavLink to=&quot;/task&quot;&gt;任务&lt;/NavLink&gt;</span><br><span class="line">      &lt;NavLink to=&quot;/location&quot;&gt;定位&lt;/NavLink&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ListPage</span><br><span class="line">const ListPage = props =&gt; &#123;</span><br><span class="line">  const &#123; group &#125; = props.match.params;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 响应group变化, 并加载指定类型列表</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    load(group);</span><br><span class="line">  &#125;, [group]);</span><br><span class="line"></span><br><span class="line">  // 列表项也会使用NavLink, 用于匹配当前展示的详情, 激活显示</span><br><span class="line">  return &lt;div className=&quot;list&quot;&gt;&#123;renderList()&#125;&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// DetailPage</span><br><span class="line">const DetailPage = props =&gt; &#123;</span><br><span class="line">  const &#123; group, id &#125; = props.match.params;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 响应group和id, 并加载详情</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    loadDetail(group, id);</span><br><span class="line">  &#125;, [group, id]);</span><br><span class="line"></span><br><span class="line">  return &lt;div className=&quot;detail&quot;&gt;&#123;renderDetail()&#125;&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>扩展</p><ul><li><a href="https://react-router.docschina.org/core/guides/philosophy" target="_blank" rel="noopener">React Router 哲学</a></li><li><a href="https://juejin.im/post/5986d1456fb9a03c3f405bd2" target="_blank" rel="noopener">聊聊 React Router v4 的设计思想</a></li></ul><p><br></p><hr><p><br></p><h2 id="11-组件规范"><a href="#11-组件规范" class="headerlink" title="11. 组件规范"></a>11. 组件规范</h2><ul><li>开启严格模式: 开启 StrictMode，尽早发现潜在问题和不规范用法</li><li>第三方开发规范:<ul><li><a href="https://github.com/airbnb/javascript/tree/master/react#ordering" target="_blank" rel="noopener">Airbnb React/JSX Style Guide</a></li><li><a href="https://vasanthk.gitbooks.io/react-bits/patterns/30.component-switch.html" target="_blank" rel="noopener">React bits</a></li><li><a href="https://github.com/krasimir/react-in-patterns" target="_blank" rel="noopener">react-in-patterns</a></li></ul></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://github.com/acdlite/recompose/blob/master/docs/API.md" target="_blank" rel="noopener">recompose</a></li><li><a href="https://overreacted.io/zh-hans/writing-resilient-components/" target="_blank" rel="noopener">编写有弹性的组件</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 React 的世界里”&lt;strong&gt;一切都是组件&lt;/strong&gt;“， 组件可以映射作函数式编程中的函数，React 的组件和函数一样的灵活的特性不仅仅可以用于绘制 UI，还可以用于封装业务状态和逻辑，或者非展示相关的副作用, 再通过组合方式组成复杂的应用. 本文尝试
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结03 - 样式的管理</title>
    <link href="https://bobi.ink/2019/05/14/react-component-design-03/"/>
    <id>https://bobi.ink/2019/05/14/react-component-design-03/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-07-11T14:34:55.041Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 是前端开发的重要组成部分，但是它并不完美，本文主要探讨 React 样式管理方面的一些解决方案，目的是实现样式的高度可定制化, 让大型项目的样式代码更容易维护.</p><p><strong>系列目录</strong></p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li><a href="/2019/05/20/react-component-design-05/">05 状态管理</a></li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-认识-css-的局限性">1. 认识 CSS 的局限性</a><ul><li><a href="#1️⃣-全局性">1️⃣ 全局性</a></li><li><a href="#2️⃣-依赖">2️⃣ 依赖</a></li><li><a href="#3️⃣-无用代码的移除">3️⃣ 无用代码的移除</a></li><li><a href="#4️⃣-压缩">4️⃣ 压缩</a></li><li><a href="#5️⃣-常量共享">5️⃣ 常量共享</a></li><li><a href="#6️⃣-css-解析方式的不确定性">6️⃣ CSS 解析方式的不确定性</a></li></ul></li><li><a href="#2-组件的样式管理">2. 组件的样式管理</a><ul><li><a href="#1️⃣-组件的样式应该高度可定制化">1️⃣ 组件的样式应该高度可定制化</a></li><li><a href="#2️⃣-避免使用内联-css">2️⃣ 避免使用内联 CSS</a></li><li><a href="#3️⃣-使用-css-in-js">3️⃣ 使用 CSS-in-js</a><ul><li><a href="#0-基本用法">0. 基本用法</a></li><li><a href="#1-样式扩展">1. 样式扩展</a></li><li><a href="#2-mixin-机制">2. mixin 机制</a></li><li><a href="#3-类-scss-的语法">3. 类 SCSS 的语法</a></li><li><a href="#5-js-带来的动态性">5. JS 带来的动态性</a></li><li><a href="#6-绑定组件的全局样式">6. 绑定组件的<code>全局样式</code></a></li><li><a href="#7-theme-机制及-theme-对象的设计">7. Theme 机制及 Theme 对象的设计</a></li><li><a href="#8-提升开发体验">8. 提升开发体验</a></li><li><a href="#9-了解-styled-components-的局限性">9. 了解 styled-components 的局限性</a></li><li><a href="#10-一些开发规范">10. 一些开发规范</a></li><li><a href="#11-其他-css-in-js-方案">11. 其他 CSS-in-js 方案</a></li></ul></li><li><a href="#4️⃣-通用的组件库不应该耦合-css-in-jscss-module-的方案">4️⃣ 通用的组件库不应该耦合 CSS-in-js/CSS-module 的方案</a></li><li><a href="#5️⃣-优先使用原生-css">5️⃣ 优先使用原生 CSS</a></li><li><a href="#6️⃣-选择合适自己团队的技术栈">6️⃣ 选择合适自己团队的技术栈</a></li><li><a href="#7️⃣-使用-svgr-转换-svg-图标">7️⃣ 使用 svgr 转换 svg 图标</a></li><li><a href="#8️⃣-结合使用-rem-和-em-等相对单位-创建更有弹性的组件">8️⃣ 结合使用 rem 和 em 等相对单位, 创建更有弹性的组件</a></li></ul></li><li><a href="#3-规范">3. 规范</a><ul><li><a href="#1️⃣-促进建立统一的-ui-设计规范">1️⃣ 促进建立统一的 UI 设计规范</a></li><li><a href="#2️⃣-css-编写规范">2️⃣ CSS 编写规范</a></li><li><a href="#3️⃣-使用stylelint进行样式规范检查">3️⃣ 使用stylelint进行样式规范检查</a></li></ul></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="1-认识-css-的局限性"><a href="#1-认识-css-的局限性" class="headerlink" title="1. 认识 CSS 的局限性"></a>1. 认识 CSS 的局限性</h2><center><br> <img src="/images/04/vjeux-speak.png" alt="vjeux-speak" width="500"><br></center><p>2014 年<a href="https://github.com/vjeux" target="_blank" rel="noopener">vjeux</a>一个 <a href="https://speakerd.s3.amazonaws.com/presentations/2e15908049bb013230960224c1b4b8bd/css-in-javascript.pdf" target="_blank" rel="noopener">speak</a> 深刻揭示的原生 CSS 的一些局限性. 虽然它有些争议, 对于开发者来说更多的是启发. 至从那之后出现了很多 <code>CSS-in-js</code> 解决方案.</p><h3 id="1️⃣-全局性"><a href="#1️⃣-全局性" class="headerlink" title="1️⃣ 全局性"></a>1️⃣ 全局性</h3><p>CSS 的选择器是没有隔离性的, 不管是使用命名空间还是 BEM 模式组织, 最终都会污染全局命名空间. 尤其是大型团队合作的项目, 很难确定某个特定的类或者元素是否已经赋过样式. 所以在大部分情况下我们都会绞尽脑汁新创建一个类名, 而不是复用已有的类型.</p><p>解决的方向: 生成唯一的类名; shadow dom; 内联样式; Vue-scoped 方案</p><p><br></p><h3 id="2️⃣-依赖"><a href="#2️⃣-依赖" class="headerlink" title="2️⃣ 依赖"></a>2️⃣ 依赖</h3><p>由于 CSS 的’全局性’, 所以就产生了依赖问题:</p><p>一方面我们需要在组件渲染前就需要先将 CSS 加载完毕, 但是<strong>很难清晰地定义某个特定组件依赖于某段特定的 CSS 代码</strong>; 另一方面, <strong>全局性导致你的样式可能被别的组件依赖(某种程度的细节耦合)</strong>, 你不能随便修改你的样式, 以免破坏其他页面或组件的样式. 如果团队没有制定合适的 CSS 规范(例如 BEM, 不直接使用标签选择器, 减少选择器嵌套等等), 代码很快就会失控</p><p>解决的方向: 之前文章提到组件是一个内聚单元, 样式应该是和组件绑定的. 最基本的解决办法是使用类似 BEM 命名规范来避免组件之间的命名冲突, 再通过创建优于复用, 组合优于继承的原则, 来避免组件间样式耦合;</p><p><br></p><h3 id="3️⃣-无用代码的移除"><a href="#3️⃣-无用代码的移除" class="headerlink" title="3️⃣ 无用代码的移除"></a>3️⃣ 无用代码的移除</h3><p>由于上述’依赖’问题, 组件样式之间并没有明确的边界, 很难判断哪些样式属于那个组件; 在加上 CSS 的’叠层特性’, 更无法确定删除样式会带来什么影响.</p><blockquote><p>现代浏览器已支持 CSS 无用代码检查. 但对于无组织的 CSS 效果不会太大</p></blockquote><p>解决的方向: 如果样式的依赖比较明确，则可以安全地移除无用代码</p><p><br></p><h3 id="4️⃣-压缩"><a href="#4️⃣-压缩" class="headerlink" title="4️⃣ 压缩"></a>4️⃣ 压缩</h3><p>选择器和类名的压缩可以减少文件的体积, 提高加载的性能. 因为原生 CSS 一般有开发者由配置类名(在 html 或 js 动态指定), 所以工具很难对类名进行控制.</p><blockquote><p>压缩类名也会降低代码的可读性, 变得难以调试.</p></blockquote><p>解决的方向: 由工具来转换或创建类名</p><p><br></p><h3 id="5️⃣-常量共享"><a href="#5️⃣-常量共享" class="headerlink" title="5️⃣ 常量共享"></a>5️⃣ 常量共享</h3><p>常规的 CSS 很难做到在样式和 JS 之间共享变量, 例如自定义主题色, 通常通过内联样式来部分实现这种需求</p><p>解决的方向: CSS-in-js</p><p><br></p><h3 id="6️⃣-css-解析方式的不确定性"><a href="#6️⃣-css-解析方式的不确定性" class="headerlink" title="6️⃣ CSS 解析方式的不确定性"></a>6️⃣ CSS 解析方式的不确定性</h3><p>CSS 规则的加载顺序是很重要的, 他会影响属性应用的优先级, 如果按需加载 CSS, 则无法确保他们的解析顺序, 进而导致错误的样式应用到元素上. 有些开发者为了解决这个问题, 使用!important 声明属性, 这无疑是进入了另一个坑.</p><p>解决方向：避免使用全局样式，组件样式隔离；样式加载和组件生命周期绑定</p><p><br></p><hr><p><br></p><h2 id="2-组件的样式管理"><a href="#2-组件的样式管理" class="headerlink" title="2. 组件的样式管理"></a>2. 组件的样式管理</h2><h3 id="1️⃣-组件的样式应该高度可定制化"><a href="#1️⃣-组件的样式应该高度可定制化" class="headerlink" title="1️⃣ 组件的样式应该高度可定制化"></a>1️⃣ 组件的样式应该高度可定制化</h3><p>组件的样式应该是可以自由定制的, 开发者应该考虑组件的各种使用场景. 所以一个好的组件必须暴露相关的样式定制接口. 至少需要支持为顶层元素配置<code>className</code>和<code>style</code>属性:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ButtonProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性应该是每个展示型组件应该暴露的 props, 其他嵌套元素也要考虑支持配置样式, 例如 footerClassName, footerStyle.</p><p><br></p><hr><p><br></p><h3 id="2️⃣-避免使用内联-css"><a href="#2️⃣-避免使用内联-css" class="headerlink" title="2️⃣ 避免使用内联 CSS"></a>2️⃣ 避免使用内联 CSS</h3><ol><li>style props 添加的属性不能自动增加厂商前缀, 这可能会导致兼容性问题. 如果添加厂商前缀又会让代码变得啰嗦.</li><li>内联 CSS 不支持复杂的样式配置, 例如伪元素, 伪类, 动画定义, 媒体查询和媒体回退(对象不允许同名属性, 例如<code>display: -webkit-flex; display: flex;</code>)</li><li>内联样式通过 object 传入组件, 内联的 object 每次渲染会重新生成, 会导致组件重新渲染. 当然通过某些工具可以将静态的 object 提取出去</li><li>不方便调试和阅读<br>…</li></ol><p>所以 内联 CSS 适合用于设置动态且比较简单的样式属性</p><blockquote><p>社区上有许多 CSS-in-js 方案是基于内联 CSS 的, 例如 Radium, 它使用 JS 添加事件处理器来模拟伪类, 另外也媒体查询和动画. 不过不是所有东西都可以通过 JS 模拟, 比如伪元素. 所以这类解决方案用得比较少</p></blockquote><p><br></p><hr><p><br></p><h3 id="3️⃣-使用-css-in-js"><a href="#3️⃣-使用-css-in-js" class="headerlink" title="3️⃣ 使用 CSS-in-js"></a>3️⃣ 使用 CSS-in-js</h3><p>社区有很多 CSS 解决方案, 有个<a href="https://github.com/MicheleBertoli/css-in-js" target="_blank" rel="noopener">项目(MicheleBertoli/css-in-js)</a>专门罗列和对比了这些方案. 读者也可以读这篇文章(<a href="https://www.javascriptstuff.com/how-to-style-react/" target="_blank" rel="noopener">What to use for React styling?</a>)学习对 CSS 相关技术进行选型决策</p><p>社区上最流行的, 也是笔者觉得使用起来最舒服的是<a href="https://www.styled-components.com" target="_blank" rel="noopener"><code>styled-components</code></a>, styled-components 有下列特性:</p><ul><li>自动生成类名, 解决 CSS 的全局性和样式冲突. 通过组件名来标志样式, 自动生成唯一的类名, 开发者不需要为元素定义类名.</li><li>绑定组件. 隔离了 CSS 的依赖问题, 让组件 JSX 更加简洁, 反过来开发者需要考虑更多组件的语义</li><li>天生支持’关键 CSS’. 样式和组件绑定, 可以和组件一起进行代码分割和异步加载</li><li>自动添加厂商前缀</li><li>灵活的动态样式. 通过 props 和全局 theme 来动态控制样式</li><li>提供了一些 CSS 预处理器的语法</li><li>主题机制</li><li>支持 react-native. 这个用起来比较爽</li><li>支持 <a href="https://github.com/stylelint/stylelint" target="_blank" rel="noopener">stylelint</a>, 编辑器高亮和智能提示</li><li>支持服务端渲染</li><li>符合分离展示组件和行为组件原则</li></ul><blockquote><p>推荐这篇文章: <a href="https://medium.com/@gajus/stop-using-css-in-javascript-for-web-development-fa32fb873dcc" target="_blank" rel="noopener">Stop using css-in-javascript for web development</a>, styled-components 可以基本覆盖所有 CSS 的使用场景:</p></blockquote><p><br></p><h4 id="0-基本用法"><a href="#0-基本用法" class="headerlink" title="0. 基本用法"></a>0. 基本用法</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义组件props</span></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1&lt;&#123; active?: <span class="built_in">boolean</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; (props.active ? 'red' : 'gray')&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定或计算组件props</span></span><br><span class="line"><span class="keyword">const</span> Input = styled.input.attrs(&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'text'</span>,</span><br><span class="line">  size: <span class="function"><span class="params">props</span> =&gt;</span> (props.small ? <span class="number">5</span> : <span class="literal">undefined</span>),</span><br><span class="line">&#125;)<span class="string">``</span>;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-样式扩展"><a href="#1-样式扩展" class="headerlink" title="1. 样式扩展"></a>1. 样式扩展</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  color: palevioletred;</span></span><br><span class="line"><span class="string">  font-size: 1em;</span></span><br><span class="line"><span class="string">  margin: 1em;</span></span><br><span class="line"><span class="string">  padding: 0.25em 1em;</span></span><br><span class="line"><span class="string">  border: 2px solid palevioletred;</span></span><br><span class="line"><span class="string">  border-radius: 3px;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖和扩展已有的组件, 包含styled生成的组件还是自定义组件(通过className传入)</span></span><br><span class="line"><span class="keyword">const</span> TomatoButton = styled(Button)<span class="string">`</span></span><br><span class="line"><span class="string">  color: tomato;</span></span><br><span class="line"><span class="string">  border-color: tomato;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-mixin-机制"><a href="#2-mixin-机制" class="headerlink" title="2. mixin 机制"></a>2. mixin 机制</h4><p>在 SCSS 中, mixin 是重要的 CSS 复用机制, styled-components 也可以实现:</p><p>定义:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; css &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utils/styled-mixins.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> css<span class="string">`</span></span><br><span class="line"><span class="string">    width: <span class="subst">$&#123;width&#125;</span>;</span></span><br><span class="line"><span class="string">    white-space: nowrap;</span></span><br><span class="line"><span class="string">    overflow: hidden;</span></span><br><span class="line"><span class="string">    text-overflow: ellipsis;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; truncate &#125; <span class="keyword">from</span> <span class="string">'~/utils/styled-mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Box = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  // 混入</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;truncate('250px')&#125;</span></span></span><br><span class="line"><span class="string">  background: papayawhip;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-类-scss-的语法"><a href="#3-类-scss-的语法" class="headerlink" title="3. 类 SCSS 的语法"></a>3. 类 SCSS 的语法</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = styled(Component)<span class="string">`</span></span><br><span class="line"><span class="string">  // 自动厂商前缀</span></span><br><span class="line"><span class="string">  padding: 2em 1em;</span></span><br><span class="line"><span class="string">  background: papayawhip;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 伪类</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background: palevioletred;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 提供样式优先级技巧</span></span><br><span class="line"><span class="string">  &amp;&amp;&amp; &#123;</span></span><br><span class="line"><span class="string">    color: palevioletred;</span></span><br><span class="line"><span class="string">    font-weight: bold;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 覆盖内联css样式</span></span><br><span class="line"><span class="string">  &amp;[style] &#123;</span></span><br><span class="line"><span class="string">    font-size: 12px !important;</span></span><br><span class="line"><span class="string">    color: blue !important;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 支持媒体查询</span></span><br><span class="line"><span class="string">  @media (max-width: 600px) &#123;</span></span><br><span class="line"><span class="string">    background: tomato;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 嵌套规则</span></span><br><span class="line"><span class="string">    &amp;:hover &#123;</span></span><br><span class="line"><span class="string">      background: yellow;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &gt; p &#123;</span></span><br><span class="line"><span class="string">    /* descendant-selectors work as well, but are more of an escape hatch */</span></span><br><span class="line"><span class="string">    text-decoration: underline;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /* Contextual selectors work as well */</span></span><br><span class="line"><span class="string">  html.test &amp; &#123;</span></span><br><span class="line"><span class="string">    display: none;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><strong>引用其他组件</strong><br></p><p>由于 styled-components 的类名是自动生成的, 所以不能直接在选择器中声明他们, 但可以在模板字符串中引用其他组件:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Icon = styled.svg<span class="string">`</span></span><br><span class="line"><span class="string">  flex: none;</span></span><br><span class="line"><span class="string">  transition: fill 0.25s;</span></span><br><span class="line"><span class="string">  width: 48px;</span></span><br><span class="line"><span class="string">  height: 48px;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 引用其他组件的类名. 这个组件必须是styled-components生成或者包装的组件</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;Link&#125;</span>:hover &amp; &#123;</span></span><br><span class="line"><span class="string">    fill: rebeccapurple;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-js-带来的动态性"><a href="#5-js-带来的动态性" class="headerlink" title="5. JS 带来的动态性"></a>5. JS 带来的动态性</h4><p>媒体查询帮助方法:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils/styled.ts</span></span><br><span class="line"><span class="keyword">const</span> sizes = &#123;</span><br><span class="line">  giant: <span class="number">1170</span>,</span><br><span class="line">  desktop: <span class="number">992</span>,</span><br><span class="line">  tablet: <span class="number">768</span>,</span><br><span class="line">  phone: <span class="number">376</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> media = <span class="built_in">Object</span>.keys(sizes).reduce(<span class="function">(<span class="params">accumulator, label</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> emSize = sizes[label] / <span class="number">16</span>;</span><br><span class="line">  accumulator[label] = <span class="function">(<span class="params">...args</span>) =&gt;</span> css<span class="string">`</span></span><br><span class="line"><span class="string">    @media (max-width: <span class="subst">$&#123;emSize&#125;</span>em) &#123;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;css(...args)&#125;</span></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Container = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  color: #333;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;media.desktop`padding: 0 20px;`&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;media.tablet`padding: 0 10px;`&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;media.phone`padding: 0 5px;`&#125;</span></span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><blockquote><p>SCSS 也提供了很多内置工具方法, 比如颜色的处理, 尺寸的计算. styled-components 提供了一个类似的 js 库: <a href="https://github.com/styled-components/polished" target="_blank" rel="noopener">polished</a>来满足这部分需求, 另外还集成了常用的 mixin, 如 clearfix. 通过 babel 插件可以在编译时转换为静态代码, 不需要运行时.</p></blockquote><p><br></p><h4 id="6-绑定组件的全局样式"><a href="#6-绑定组件的全局样式" class="headerlink" title="6. 绑定组件的全局样式"></a>6. 绑定组件的<code>全局样式</code></h4><p>全局样式和组件生命周期绑定, 当组件卸载时也会删除全局样式. 全局样式通常用于覆盖一些第三方组件样式</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> GlobalStyle = createGlobalStyle<span class="string">`</span></span><br><span class="line"><span class="string">  body &#123;</span></span><br><span class="line"><span class="string">    color: <span class="subst">$&#123;props =&gt; (props.whiteColor ? 'white' : 'black')&#125;</span>;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line">&lt;React.Fragment&gt;</span><br><span class="line">  &lt;GlobalStyle whiteColor /&gt;</span><br><span class="line">  &lt;Navigation /&gt; &#123;<span class="comment">/* example of other top-level stuff */</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/React.Fragment&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="7-theme-机制及-theme-对象的设计"><a href="#7-theme-机制及-theme-对象的设计" class="headerlink" title="7. Theme 机制及 Theme 对象的设计"></a>7. Theme 机制及 Theme 对象的设计</h4><p>styled-components 的 <a href="https://www.styled-components.com/docs/advanced#theming" target="_blank" rel="noopener">ThemeProvider</a> 可以用于取代 SCSS 的变量机制, 只不过它更加灵活, 可以被所有下级组件共享, 并动态变化.</p><p>关于 Theme 对象的设计我觉得可以参考传统的 UI 框架, 例如<a href="https://github.com/zurb/foundation-sites/tree/develop/scss" target="_blank" rel="noopener">Foundation</a>或者<a href="https://github.com/twbs/bootstrap/tree/master/scss" target="_blank" rel="noopener">Bootstrap</a>, 经过多年的迭代它们代码组织非常好, 非常值得学习. 以 Bootstrap 的项目结构为例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _alert.scss</span><br><span class="line">├── ...                # 定义各种组件的样式</span><br><span class="line">├── _print.scss        # 打印样式适配</span><br><span class="line">├── _root.scss         # 🔴根样式, 即全局样式</span><br><span class="line">├── _transitions.scss  # 过渡效果</span><br><span class="line">├── _type.scss         # 🔴基本排版样式</span><br><span class="line">├── _reboot.scss       # 🔴浏览器重置样式, 类似于normalize.css</span><br><span class="line">├── _functions.scss</span><br><span class="line">├── _mixins.scss</span><br><span class="line">├── _utilities.scss</span><br><span class="line">├── _variables.scss    # 🔴变量配置, 包含全局配置和所有组件配置</span><br><span class="line">├── bootstrap-grid.scss</span><br><span class="line">├── bootstrap-reboot.scss</span><br><span class="line">├── bootstrap.scss</span><br><span class="line">├── mixins             # 各种mixin, 可复用的css代码</span><br><span class="line">├── utilities          # 各种工具方法</span><br><span class="line">└── vendor</span><br><span class="line">    └── _rfs.scss</span><br></pre></td></tr></table></figure><p><a href="https://github.com/twbs/bootstrap/blob/master/scss/_variables.scss" target="_blank" rel="noopener"><code>_variables.scss</code></a>包含了以下配置:</p><ul><li>颜色系统: 调色盘配置<ul><li>灰阶颜色: 提供白色到黑色之间多个级别的灰阶颜色. 例如<br><img src="/images/04/gray-scale.png" width="300"></li><li>语义颜色: 根据 UI 上面的语义, 定义各种颜色. 这个也是 CSS 开发的常见模式<br><img src="/images/04/sem-color.png" width="300"></li></ul></li><li>尺寸系统: 多个级别的间距, 尺寸大小配置</li><li>配置开关: 全局性的配置开关, 例如是否支持圆角, 阴影</li><li>链接样式配置: 如颜色, 激活状态, decoration</li><li>排版: 字体, 字体大小, font-weight, 行高, 边框, 标题等基本排版配置</li><li>网格系统断点配置</li></ul><p>bootstrap 将这些配置项有很高的参考意义. 组件可以认为是 UI 设计师 的产出, 如果你的应用有统一和规范的设计语言(参考<a href="https://ant.design/docs/spec/values-cn" target="_blank" rel="noopener">antd</a>), 这些配置会很有意义。样式可配置化可以让你的代码更灵活, 更稳定, 可复用性和可维护性更高. 不管对于 UI 设计还是客户端开发, 设计规范可以提高团队工作效率, 减少沟通成本.</p><p>styled-components 的 Theme 使用的是<code>React Context</code> API, 官方文档有详尽的描述, 这里就不展开了. 点击这里<a href="https://www.styled-components.com/docs/advanced#theming" target="_blank" rel="noopener">了解更多</a>, 另外在<a href="https://www.styled-components.com/docs/api#typescript" target="_blank" rel="noopener">这里</a>了解如何在 Typescript 中声明 theme 类型</p><p><br></p><h4 id="8-提升开发体验"><a href="#8-提升开发体验" class="headerlink" title="8. 提升开发体验"></a>8. 提升开发体验</h4><p>可以使用<code>babel-plugin-styled-components</code>或<a href="https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros" target="_blank" rel="noopener"><code>babel macro</code></a>来支持服务端渲染、 样式压缩和提升 debug 体验. 推荐使用 macro 形式, 无需安装和配置 babel 插件. 在 create-react-app 中已内置支持:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled, &#123; createGlobalStyle &#125; <span class="keyword">from</span> <span class="string">'styled-components/macro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Thing = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  color: red;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>详见<a href="https://www.styled-components.com/docs/tooling#babel-macro" target="_blank" rel="noopener">Tooling</a></p><p><br></p><h4 id="9-了解-styled-components-的局限性"><a href="#9-了解-styled-components-的局限性" class="headerlink" title="9. 了解 styled-components 的局限性"></a>9. 了解 styled-components 的局限性</h4><p>比较能想到的局限性是性能问题:</p><ol><li>css-in-js: 需要一个 JS 运行时, 会增加 js 包体积(大约 15KB)</li><li>相比原生 CSS 会有更多节点嵌套(例如 ThemeConsumer)和计算消耗. 这个对于复杂的组件树的渲染影响尤为明显</li><li>不能抽取为 CSS 文件, 这通常不算问题</li></ol><blockquote><p>官方<a href="https://github.com/styled-components/styled-components/tree/master/packages/styled-components/benchmarks" target="_blank" rel="noopener">benchmark</a></p></blockquote><p>下面是基于 v4.0 基准测试对比图, 在众多 CSS-in-js 方案中, styled-components 处于中上水平:</p><p><img src="/images/04/styled-benchmark.png" alt="styled-components benchmark"></p><p><br></p><h4 id="10-一些开发规范"><a href="#10-一些开发规范" class="headerlink" title="10. 一些开发规范"></a>10. 一些开发规范</h4><ul><li>避免无意义的组件名. 避免类似<code>Div</code>, <code>Span</code>这类直接照搬元素名的无意义的组件命名</li></ul><p><br></p><ul><li><p>在一个文件中定义 styled-components 组件. 对于比较简单的组件, 一般会在同一个文件中定义 styled-components 组件就行了. 下面是典型组件的文件结构:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components/macro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在顶部定义所有styled-components组件</span></span><br><span class="line"><span class="keyword">const</span> Header = styled.header<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> Title = styled.div<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> StepName = styled.div<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> StepBars = styled.div<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> StepBar = styled.div&lt;&#123; active?: <span class="built_in">boolean</span> &#125;&gt;<span class="string">``</span>;</span><br><span class="line"><span class="keyword">const</span> FormContainer = styled.div<span class="string">``</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Steps: FC&lt;StepsProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;&gt;...&lt;<span class="regexp">/&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Steps;</span></span><br></pre></td></tr></table></figure><p>然而对于比较复杂的页面组件来说, 会让文件变得很臃肿, 扰乱组件的主体, 所以笔者一般会像抽取到单独的<code>styled.tsx</code>文件中:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Header, Title, StepName, StepBars, StepBar, FormContainer &#125; <span class="keyword">from</span> <span class="string">'./styled'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Steps: FC&lt;StepsProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;&gt;...&lt;<span class="regexp">/&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Steps;</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p>考虑导出 styled-components 组件, 方便上级组件设置样式</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ---Foo/index.ts---</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Styled <span class="keyword">from</span> <span class="string">'./styled'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; Styled &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Bar/index.ts----</span></span><br><span class="line"><span class="keyword">import</span> &#123; Styled &#125; <span class="keyword">from</span> <span class="string">'../Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  &amp; <span class="subst">$&#123;Styled.SomeComponent&#125;</span> &#123;</span></span><br><span class="line"><span class="string">    color: red;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="11-其他-css-in-js-方案"><a href="#11-其他-css-in-js-方案" class="headerlink" title="11. 其他 CSS-in-js 方案"></a>11. 其他 CSS-in-js 方案</h4><ul><li>CSS-module</li><li>JSS</li><li>emotion</li><li>glamorous</li></ul><p>这里值得一提的是<a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener">CSS-module</a>, 这也是社区比较流行的解决方案. 严格来说, 这不是 CSS-in-js. 有兴趣的读者可以看这篇文章<a href="https://zhuanlan.zhihu.com/p/20495964" target="_blank" rel="noopener">CSS Modules 详解及 React 中实践</a>.</p><p>特性:</p><ul><li>比较轻量, 不需要 JS 运行时, 因为他在编译阶段进行计算</li><li>所有样式默认都是 local, 通过导入模块方式可以导入这些生成的类名</li><li>可以和 CSS proprocessor 配合</li><li>采用非标准的语法, 例如:global, :local, :export, compose:</li></ul><p>CSS module 同样也有外部样式覆盖问题, 所以需要通过其他手段对关键节点添加其他属性(如 data-name).</p><blockquote><p>如果使用 css-module, 建议使用<code>*.module.css</code>来命名 css 文件, 和普通 CSS 区分开来.</p></blockquote><p>扩展:</p><ul><li><a href="https://github.com/stereobooster/css-in-js-101" target="_blank" rel="noopener">CSS-in-JS 101: All you need to know</a></li></ul><p><br></p><hr><p><br></p><h3 id="4️⃣-通用的组件库不应该耦合-css-in-js-css-module-的方案"><a href="#4️⃣-通用的组件库不应该耦合-css-in-js-css-module-的方案" class="headerlink" title="4️⃣ 通用的组件库不应该耦合 CSS-in-js/CSS-module 的方案"></a>4️⃣ 通用的组件库不应该耦合 CSS-in-js/CSS-module 的方案</h3><p>如果是作为第三方组件库形式开发, 个人觉得不应该耦合各种 CSS-in-js/CSS-module. 不能强求你的组件库使用者耦合这些技术栈, 而且部分技术是需要构建工具支持的. 建议使用原生 CSS 或者将 SCSS/Less 这些预处理工具作为增强方案</p><p><br></p><hr><p><br></p><h3 id="5️⃣-优先使用原生-css"><a href="#5️⃣-优先使用原生-css" class="headerlink" title="5️⃣ 优先使用原生 CSS"></a>5️⃣ 优先使用原生 CSS</h3><p>笔者的项目大部分都是使用<code>styled-components</code>, 但对于部分极致要求性能的组件, 一般我会回退使用原生 CSS, 再配合 BEM 命名规范. 这种最简单方式, 能够满足大部分需求.</p><p><br></p><hr><p><br></p><h3 id="6️⃣-选择合适自己团队的技术栈"><a href="#6️⃣-选择合适自己团队的技术栈" class="headerlink" title="6️⃣ 选择合适自己团队的技术栈"></a>6️⃣ 选择合适自己团队的技术栈</h3><p>每个团队的情况和偏好不一样, 选择合适自己的才是最好的. 关于 CSS 方面的技术栈搭配也非常多样:</p><p><img src="/images/04/css-determination.png" alt="css determination"></p><ul><li><strong>选择 CSS-in-js 方案</strong>:<br>优点: 这个方案解决了大部分 CSS 的缺陷, 灵活, 动态性强, 学习成本比较低, 非常适合组件化的场景.<br>缺点: 性能相比静态 CSS 要弱, 不过这点已经慢慢在改善. 可以考虑在部分组件使用原生 CSS</li><li><strong>选择 CSS 方案</strong>:<ul><li><strong>选择原生 CSS 方案</strong>: 这种方案最简单</li><li><strong>选择 Preprocessor</strong>: 添加 CSS 预处理器, 可以增强 CSS 的可编程性: 例如模块化, 变量, 函数, mixin.<br>优点: 预处理器可以减少代码重复, 让 CSS 更好维护. 适合组织性要求很高的大型项目.<br>缺点: 就是需要学习成本, 所以这里笔者建议使用标准的 cssnext 来代替 SCSS/Less 这些方案</li><li><strong>方法论</strong>: CSS 的各种方法论旨在提高 CSS 的组织性, 提供一些架构建议, 让 CSS 更好维护.</li><li><strong>postcss</strong>: 对 CSS 进行优化增强, 例如添加厂商前缀</li><li><strong>css-module</strong>: 隔离 CSS, 支持暴露变量给 JS, 解决 CSS 的一些缺陷, 让 CSS 适合组件化场景.<br>可选, 通过合适的命名和组织其实是可以规避 CSS 的缺陷</li></ul></li></ul><p>综上所述, CSS-in-js 和 CSS 方案各有适用场景. 比如对于组件库, 如 antd 则选择了 Preprocessor 方案; 对于一般应用笔者建议使用 CSS-in-js 方案, 它学习成本很低, 并且<code>There&#39;s Only One Way To Do It</code> 没有太多心智负担, 不需要学习冗杂的方法论, 代码相对比较可控; 另外它还支持跨平台, 在 ReactNative 下, styled-components 是更好的选择. 而 CSS 方案, 对于大型应用要做到有组织有纪律和规划化, 需要花费较大的精力, 尤其是团队成员能力不均情况下, 很容易失控</p><p><br></p><hr><p><br></p><h3 id="7️⃣-使用-svgr-转换-svg-图标"><a href="#7️⃣-使用-svgr-转换-svg-图标" class="headerlink" title="7️⃣ 使用 svgr 转换 svg 图标"></a>7️⃣ 使用 svgr 转换 svg 图标</h3><p>如今 CSS-Image-Sprite 早已被 <a href="https://github.com/jkphl/svg-sprite" target="_blank" rel="noopener">SVG-Sprite</a> 取代. 而在 React 生态中使用<a href="https://github.com/smooth-code/svgr#webpack-usage" target="_blank" rel="noopener"><code>svgr</code></a>更加方便, 它可以将 svg 文件转换为 React 组件, 也就是一个普通的 JS 模块, 它有以下优势:</p><ul><li>转换为普通 JS 文件, 方便代码分割和异步加载</li><li>相比 svg-sprite 和 iconfont 方案更容易管理</li><li>svg 可以通过 CSS/JS 配置, 可操作性更强; 相比 iconfont 支持多色</li><li>支持 svgo 压缩</li></ul><p>基本用法:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> starUrl, &#123; ReactComponent <span class="keyword">as</span> Star &#125; <span class="keyword">from</span> <span class="string">'./star.svg'</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;img src=&#123;starUrl&#125; alt=<span class="string">"star"</span> /&gt;</span><br><span class="line">    &lt;Star /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>了解<a href="https://www.smooth-code.com/open-source/svgr/docs/webpack/" target="_blank" rel="noopener">更多</a></p><blockquote><p>antd 3.9 之后使用 svg 图标<a href="https://ant.design/components/icon-cn/#SVG-图标" target="_blank" rel="noopener">代替了 font 图标</a> <br><br>对比<a href="https://aotu.io/notes/2018/11/23/SVG_vs_Image_vs_iconfont/index.html" target="_blank" rel="noopener">SVG vs Image, SVG vs Iconfont</a></p></blockquote><p><br></p><hr><p><br></p><h3 id="8️⃣-结合使用-rem-和-em-等相对单位-创建更有弹性的组件"><a href="#8️⃣-结合使用-rem-和-em-等相对单位-创建更有弹性的组件" class="headerlink" title="8️⃣ 结合使用 rem 和 em 等相对单位, 创建更有弹性的组件"></a>8️⃣ 结合使用 rem 和 em 等相对单位, 创建更有弹性的组件</h3><p>Bootstrap v4 全面使用 rem 作为基本单位, 这使得所有组件都可以响应浏览器字体的调整:</p><p><img src="/images/04/bootstrap-rem.gif" alt></p><p>rem 可以让整个文档可以响应 html 字体的变化, 经常用于移动端等比例还原设计稿, 详见<a href="https://www.zhihu.com/column/p/30413803" target="_blank" rel="noopener">Rem 布局的原理解析</a>. 我个人对于觉得弹性组件来说更重要的是 em 单位, 尤其是那些比例固定组件, 例如 Button, Switch, Icon. 比如我会这样定义 svg Icon 的样式:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.svg-icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">fill</span>: currentColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像 iconfont 一样, 外部只需要设置<code>font-size</code>就可以配置 icon 到合适的尺寸, 默认则继承当前上下文的字体大小:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyIcon style=&#123;&#123; fontSize: 17 &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>em 可以让<code>Switch</code>这类固定比例的组件的样式可以更容易的被配置, 可以配合函数将px转换为em:</p><iframe src="https://codesandbox.io/embed/z67r8rpnr4?fontsize=14" title="Switch" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>扩展:</p><ul><li><a href="https://www.sitepoint.com/understanding-and-using-rem-units-in-css/" target="_blank" rel="noopener">Understanding and Using rem Units in CSS</a></li><li><a href="https://www.zhihu.com/column/p/30413803" target="_blank" rel="noopener">Rem 布局的原理解析</a></li></ul><p><br></p><hr><p><br></p><h2 id="3-规范"><a href="#3-规范" class="headerlink" title="3. 规范"></a>3. 规范</h2><h3 id="1️⃣-促进建立统一的-ui-设计规范"><a href="#1️⃣-促进建立统一的-ui-设计规范" class="headerlink" title="1️⃣ 促进建立统一的 UI 设计规范"></a>1️⃣ 促进建立统一的 UI 设计规范</h3><p>上文已经阐述了 UI 设计规范的重要性, 有兴趣的读者可以看看这篇文章<a href="https://juejin.im/post/5b766ac56fb9a009aa154c27" target="_blank" rel="noopener">开发和设计沟通有多难？ - 你只差一个设计规范</a>. 简单总结一下:</p><ul><li>提供团队协作效率</li><li>提高组件的复用率. 统一的组件规范可以让组件更好管理</li><li>保持产品迭代过程中品牌一致性</li></ul><h3 id="2️⃣-css-编写规范"><a href="#2️⃣-css-编写规范" class="headerlink" title="2️⃣ CSS 编写规范"></a>2️⃣ CSS 编写规范</h3><p>可以参考以下规范:</p><ul><li><a href="https://codeguide.bootcss.com" target="_blank" rel="noopener">编码规范 by @mdo</a> bootstrap 使用的规范</li><li><a href="https://github.com/airbnb/css" target="_blank" rel="noopener">Airbnb CSS/Sass styleguide</a></li><li><a href="https://guide.aotu.io/docs/css/code.html#CSS3浏览器私有前缀写法" target="_blank" rel="noopener">Aotu 实验室代码规范</a></li><li><a href="https://github.com/fex-team/styleguide/blob/master/css.md" target="_blank" rel="noopener">FEX-Team 编码规范</a></li></ul><h3 id="3️⃣-使用stylelint进行样式规范检查"><a href="#3️⃣-使用stylelint进行样式规范检查" class="headerlink" title="3️⃣ 使用stylelint进行样式规范检查"></a>3️⃣ 使用stylelint进行样式规范检查</h3><p><br></p><hr><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://reactjs.org/docs/faq-styling.html" target="_blank" rel="noopener">Styling and CSS</a></li><li><a href="https://medium.com/@gajus/stop-using-css-in-javascript-for-web-development-fa32fb873dcc" target="_blank" rel="noopener">Stop using CSS in JavaScript for web development</a></li><li><a href="https://zhuanlan.zhihu.com/p/26878157" target="_blank" rel="noopener">精读《请停止 css-in-js 的行为》</a></li><li><a href="https://github.com/MicheleBertoli/css-in-js" target="_blank" rel="noopener">MicheleBertoli/css-in-js</a></li><li><a href="https://www.javascriptstuff.com/how-to-style-react/" target="_blank" rel="noopener">What to use for React styling?</a></li><li><a href="https://www.styled-components.com/docs/faqs" target="_blank" rel="noopener">styled-components FAQ</a></li><li><a href="https://medium.com/ansarada-thinking/styled-components-v4-the-good-the-bad-and-something-completely-different-e891139e0138" target="_blank" rel="noopener">Styled components V4: the good, the bad, and something completely different</a></li><li><a href="https://reactarmory.com/answers/should-i-use-css-in-js" target="_blank" rel="noopener">Should I use CSS-in-JS?</a></li><li><a href="http://qinsman.com/1606_uispec/" target="_blank" rel="noopener">聊聊 UI 设计规范：移动端、H5 与 Web 端</a></li><li><a href="https://juejin.im/post/5b768e18e51d45565d23e52c" target="_blank" rel="noopener">开发也能构建 UI 组件设计规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS 是前端开发的重要组成部分，但是它并不完美，本文主要探讨 React 样式管理方面的一些解决方案，目的是实现样式的高度可定制化, 让大型项目的样式代码更容易维护.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系列目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结02 - 组件的组织</title>
    <link href="https://bobi.ink/2019/05/11/react-component-design-02/"/>
    <id>https://bobi.ink/2019/05/11/react-component-design-02/</id>
    <published>2019-05-10T16:00:00.000Z</published>
    <updated>2019-07-15T00:47:30.837Z</updated>
    
    <content type="html"><![CDATA[<p>一个复杂的应用都是由简单的应用发展而来的, 随着越来越多的功能加入项目, 代码就会变得越来越难以控制. 本文章主要探讨在大型项目中如何对组件进行组织, 让项目具备可维护性.</p><p><strong>系列目录</strong></p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li><a href="/2019/05/20/react-component-design-05/">05 状态管理</a></li></ul><p><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-组件设计的基本原则">1. 组件设计的基本原则</a><ul><li><a href="#基本原则"><strong>基本原则</strong></a></li><li><a href="#高质量组件的特征"><strong>高质量组件的特征</strong></a></li></ul></li><li><a href="#2-基本技巧">2. 基本技巧</a></li><li><a href="#3-组件的分类">3. 组件的分类</a><ul><li><a href="#1️⃣-容器组件和展示组件分离">1️⃣ <strong>容器组件</strong>和<strong>展示组件</strong>分离</a></li><li><a href="#2️⃣-分离逻辑和视图">2️⃣ 分离逻辑和视图</a></li><li><a href="#3️⃣-有状态组件和无状态组件">3️⃣ 有状态组件和无状态组件</a></li><li><a href="#4️⃣-纯组件和非纯组件">4️⃣ 纯组件和非纯组件</a></li><li><a href="#5️⃣-按照-ui-划分为布局组件和内容组件">5️⃣ 按照 UI 划分为<code>布局组件</code>和<code>内容组件</code></a></li><li><a href="#6️⃣-接口一致的数据录入组件">6️⃣ 接口一致的数据录入组件</a></li></ul></li><li><a href="#4-目录划分">4. 目录划分</a><ul><li><a href="#1️⃣-基本目录结构">1️⃣ 基本目录结构</a></li><li><a href="#2️⃣-多页应用的目录划分">2️⃣ 多页应用的目录划分</a></li><li><a href="#3️⃣-多页应用的目录划分-monorepo-模式">3️⃣ 多页应用的目录划分: monorepo 模式</a></li><li><a href="#4️⃣-跨平台应用">4️⃣ 跨平台应用</a></li><li><a href="#5️⃣-跨平台的另外一种方式-taro">5️⃣ 跨平台的另外一种方式: taro</a></li></ul></li><li><a href="#5-模块">5. 模块</a><ul><li><a href="#1️⃣-创建严格的模块边界">1️⃣ 创建严格的模块边界</a></li><li><a href="#2️⃣-named-export-vs-default-export">2️⃣ <code>Named export</code> vs <code>default export</code></a></li><li><a href="#3️⃣-避免循环依赖">3️⃣ 避免循环依赖</a></li><li><a href="#4️⃣-相对路径不要超过两级">4️⃣ 相对路径不要超过两级</a></li></ul></li><li><a href="#6-拆分">6. 拆分</a><ul><li><a href="#1️⃣-拆分-render-方法">1️⃣ 拆分 render 方法</a></li><li><a href="#2️⃣-拆分为组件">2️⃣ 拆分为组件</a></li></ul></li><li><a href="#7-组件划分示例">7. 组件划分示例</a><ul><li><a href="#1️⃣-划分页面">1️⃣ 划分页面</a></li><li><a href="#2️⃣-划分基础-ui-组件">2️⃣ 划分基础 UI 组件</a></li><li><a href="#3️⃣-设计组件的状态">3️⃣ 设计组件的状态</a></li></ul></li><li><a href="#8-文档">8. 文档</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h2 id="1-组件设计的基本原则"><a href="#1-组件设计的基本原则" class="headerlink" title="1. 组件设计的基本原则"></a>1. 组件设计的基本原则</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a><strong>基本原则</strong></h3><p><strong>单一职责(Single Responsibility Principle)</strong>. 这原本来源于面向对象编程, 规范定义是”一个类应该只有一个发生变化的原因”, 白话说”一个类只负责一件事情”. 不管是什么编程范式, 只要是模块化的程序设计都适用单一职责原则. 在 React 中, 组件就是模块.</p><p>单一职责要求将组件限制在一个’合适’的粒度. 这个粒度是比较主观的概念, 换句话说’单一’是一个相对的概念. 我个人觉得单一职责并不是追求职责粒度的’最小’化, 粒度最小化是一个极端, 可能会导致大量模块, 模块离散化也会让项目变得难以管理. <strong>单一职责要求的是一个适合被复用的粒度</strong>.</p><p>往往一开始我们设计的组件都可能复合多个职责, 后来出现了代码重复或者模块边界被打破(比如一个模块依赖另一个模块的’细节’), 我们才会惰性将可复用的代码抽离. 随着越来越多的重构和迭代, 模块职责可能会越来越趋于’单一’(😂 看谁, 也可能变成面条).</p><p>当然有经验的开发者可以一开始就能考虑组件的各种应用场景, 可以观察到模块的重合边界. <strong>对于入门者来说<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener"><code>Don&#39;t repeat yourself</code></a>原则更有用, 不要偷懒/多思考/重构/消除重复代码, 你的能力就会慢慢提升</strong></p><p>单一职责的收益:</p><ul><li>降低组件的复杂度. 职责单一组件代码量少, 容易被理解, 可读性高</li><li>降低对其他组件的耦合. 当变更到来时可以降低对其他功能的影响, 不至于牵一发而动全身</li><li>提高可复用性. 功能越单一可复用性越高, 就比如一些基础组件</li></ul><p><br></p><h3 id="高质量组件的特征"><a href="#高质量组件的特征" class="headerlink" title="高质量组件的特征"></a><strong>高质量组件的特征</strong></h3><p><strong>一个高质量的组件一定是<code>高内聚, 低耦合</code>的</strong>, 这两个原则或者特征是组件独立性的一个判断标准.</p><p><strong>高内聚</strong>, 要求一个组件有一个明确的组件边界, 将紧密相关的内容聚集在一个组件下, 实现”专一”的功能. 和传统的前端编程不一样, 一个组件是一个<strong>自包含</strong>的单元, 它包含了逻辑/样式/结构, 甚至是依赖的静态资源. 这也使得组件天然就是一个比较独立的个体. 当然这种独立性是相对的, 为了最大化这种独立性, 需要根据<strong>单一职责</strong>将组件拆分为更小粒度的组件, 这样可以被更灵活的组合和复用.</p><p>虽然组件是独立的, 但是他需要和其他组件进行组合才能实现应用, 这就有了’关联’. <strong>低耦合</strong>要求最小化这种关联性, 比如明确模块边界不应该访问其他组件的内部细节, 组件的接口最小化, 单向数据流等等</p><p>文章后续内容主要讨论实现<em>高内聚/低耦合</em>主要措施</p><p><br></p><hr><p><br></p><h2 id="2-基本技巧"><a href="#2-基本技巧" class="headerlink" title="2. 基本技巧"></a>2. 基本技巧</h2><p>这些技巧来源于<a href="https://vasanthk.gitbooks.io/react-bits/ux-variations/" target="_blank" rel="noopener">react-bits</a>:</p><ul><li>如果组件不需要状态, 则使用<strong>无状态组件</strong></li><li>性能上比较: <strong>无状态函数 &gt; 有状态函数 &gt; class 组件</strong></li><li>最小化 props(接口). 不要传递超过要求的 props</li><li>如果组件内部存在较多条件控制流, 这通常意味着需要对组件进行抽取</li><li>不要过早优化. 只要求组件在当前需求下可被复用, 然后’随机应变’</li></ul><p><br></p><hr><p><br></p><h2 id="3-组件的分类"><a href="#3-组件的分类" class="headerlink" title="3. 组件的分类"></a>3. 组件的分类</h2><h3 id="1️⃣-容器组件和展示组件分离"><a href="#1️⃣-容器组件和展示组件分离" class="headerlink" title="1️⃣ 容器组件和展示组件分离"></a>1️⃣ <strong>容器组件</strong>和<strong>展示组件</strong>分离</h3><p><em>容器组件和展示组件分离</em>是 React 开发的重要思想, 它影响的 React 应用项目的组织和架构. 下面总结一下两者的区别:</p><p><br></p><table><thead><tr><th></th><th>容器组件</th><th>展示组件</th></tr></thead><tbody><tr><td>关注点</td><td>业务</td><td>UI</td></tr><tr><td>数据源</td><td>状态管理器/后端</td><td>props</td></tr><tr><td>组件形式</td><td>高阶组件</td><td>普通组件</td></tr></tbody></table><p><br></p><ul><li><p><strong>展示组件</strong>是一个只关注展示的’元件’, 为了可以在多个地方被复用, 它不应该耦合’业务/功能’, 或者说不应该过渡耦合. 像<code>antd</code>这类组件库提供通用组件显然就是’展示组件’</p><p>下面是一个典型的应用目录结构, 我们可以看到<strong>展示组件与业务/功能是可能有不同的耦合程度的, 和业务的耦合程度越低, 通用性/可复用性越强</strong>:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node_modules/antd/     🔴 通用的组件库, 不能和任何项目的业务耦合</span><br><span class="line">src/</span><br><span class="line">  components/          🔴 项目通用的组件库, 可以被多个容器/页面组件共享</span><br><span class="line">  containers/</span><br><span class="line">    Foo/</span><br><span class="line">      components/      🔴 容器/页面组件特有的组件库, 和一个业务/功能深度耦合. 以致于不能被其他容器组件共享</span><br><span class="line">      index.tsx</span><br><span class="line">    Bar/</span><br><span class="line">      components/</span><br><span class="line">      index.tsx</span><br></pre></td></tr></table></figure><p>对于展示组件，我们要以一种’第三方组件库’的标准来考虑组件的设计, 减少与业务的耦合度, 考虑各种应用的场景, 设计好公开的接口.</p><p><br></p></li><li><p><strong>容器组件</strong>主要关注业务处理. 容器组件一般以’高阶组件’形式存在, 它一般 ① 从外部数据源(redux 这些状态管理器或者直接请求服务端数据)获取数据, 然后 ② 组合<em>展示组件</em>来构建完整的视图.</p><center><br>  <img src="/images/04/container.png" width="400"><br></center><p><em>容器组件</em>通过组合<em>展示组件</em>来构建完整视图, 但两者未必是简单的包含与被包含的关系.</p><p><br></p></li></ul><p><code>容器组件和展示组件的分离</code>可以带来好处主要是<strong>可复用性</strong>和<strong>可维护性</strong>:</p><ul><li>可复用性: 展示组件可以用于多个不同的数据源(容器组件). 容器组件(业务逻辑)也可以被复用于不同’平台’的展示组件</li><li>展示和容器组件更好的分离，有助于更好的理解应用和 UI, 两者可以被独立地维护</li><li>展示组件变得轻量(无状态/或局部状态), 更容易被测试</li></ul><p><br></p><p>了解更多<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">Presentational and Container Components</a></p><p><br></p><hr><p><br></p><h3 id="2️⃣-分离逻辑和视图"><a href="#2️⃣-分离逻辑和视图" class="headerlink" title="2️⃣ 分离逻辑和视图"></a>2️⃣ 分离逻辑和视图</h3><p><code>容器组件和展示组件</code>的分离本质上是<code>逻辑和视图</code>的分离. 在<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener"><code>React Hooks</code></a>出现后, 容器组件可以被 Hooks 形式取代, Hooks 可以和视图层更自然的分离, 为视图层提供纯粹的数据来源.</p><p>抽离的后业务逻辑可以复用于不同的’展示平台’, 例如 web 版和 native 版:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Login/</span><br><span class="line">  useLogin.ts   // 可复用的业务逻辑</span><br><span class="line">  index.web.tsx</span><br><span class="line">  index.tsx</span><br></pre></td></tr></table></figure><p>上面使用了<code>useLogin.tsx</code>来单独维护业务逻辑. 可以被 web 平台和 native 平台的代码复用.</p><p><br></p><center><br>  <img src="/images/04/demo.png" width="300"><br></center><p>不仅仅是<strong>业务逻辑</strong>, 展示<strong>组件逻辑</strong>也可以分离. 例如上图, <code>FilePicker</code>和<code>ImagePicker</code>两个组件的’文件上传’逻辑是共享的, 这部分逻辑可以抽取到高阶组件或者 hooks, 甚至是 Context 中(可以统一配置文件上传行为)</p><p>分离逻辑和视图的主要方式有:</p><ul><li>hooks</li><li>高阶组件</li><li>Render Props</li><li>Context</li></ul><p><br></p><hr><p><br></p><h3 id="3️⃣-有状态组件和无状态组件"><a href="#3️⃣-有状态组件和无状态组件" class="headerlink" title="3️⃣ 有状态组件和无状态组件"></a>3️⃣ 有状态组件和无状态组件</h3><p><strong>无状态组件内部不存储状态, 完全由外部的 props 来映射</strong>. 这类组件以函数组件形式存在, 作为低级/高复用的底层展示型组件.<br>无状态组件天然就是’纯组件’, 如果无状态组件的映射需要一点成本, 可以使用 React.memo 包裹避免重复渲染</p><p><br></p><hr><p><br></p><h3 id="4️⃣-纯组件和非纯组件"><a href="#4️⃣-纯组件和非纯组件" class="headerlink" title="4️⃣ 纯组件和非纯组件"></a>4️⃣ 纯组件和非纯组件</h3><p>纯组件的’纯’来源于函数式编程. 指的是<strong>对于一个函数而言, 给定相同的输入, 它总是返回相同的输出, 过程没有副作用, 没有额外的状态依赖</strong>. 对应到 React 中, 纯组件指的是 props(严格上说还有 state 和 context, 它们也是组件的输入)没有变化, 组件的输出就不会变动.</p><center><br>  <img src="/images/04/input-output.png" width="450"><br></center><p>和 React 组件的输出输出模型相比, <a href="http://cyclejs.cn" target="_blank" rel="noopener">Cyclejs</a>对组件输入/输出的抽象则做的更加彻底，更加‘函数式’👇。它的组件就是一个普通的函数，只有’单向’的输入和输出:</p><center><br>  <img src="/images/04/cyclejs.png" width="400"><br></center><p>函数式编程和组件式编程思想某种意义上是一致的, 它们都是’组合’的艺术. 一个大的函数可以有多个职责单一函数组合而成. 组件也是如此. <strong>我们将一个大的组件拆分为子组件, 对组件做更细粒度的控制, 保持它们的纯净性, 让它们的职责更单一, 更独立. 这带来的好处就是可复用性, 可测试性和可预测性.</strong></p><p><strong>纯组件对 React 的性能优化也有重要意义</strong>. 如果一个组件是一个纯组件, 如果’输入’没有变动, 那么这个组件就不需要重新渲染. 组件树越大, 纯组件带来的性能优化收益就越高.</p><p>我们可以很容易地保证一个底层组件的纯净性, 因为它本来就很简单. 但是对于一个复杂的组件树, 则需要花点心思进行构建, 所以就有了’状态管理’的需求. <strong>这些状态管理器通常都在组件树的<em>外部</em>维护一个或多个状态库, 然后通过依赖注入形式, 将局部的状态注入到子树中. 通过视图和逻辑分离的原则, 来维持组件树的纯净性</strong>.</p><p>Redux 就是一个典型的解决方案, 在 Redux 的世界里可以认为<strong>一个复杂的组件树就是一颗状态树的映射</strong>, 只要状态树(需要依靠不可变数据来保证状态的可预测性)不变, 组件树就不变. Redux 建议保持组件的纯净性, 将组件状态交给 Redux 和配套的异步处理工具来维护, 这样就将整个应用抽象成了一个”单向的数据流”, 这是一种简单的”输入/输出”关系</p><center><br>  <img src="/images/04/redux.png" width="400"><br></center><p>不管是 Cyclejs 还是 Redux，抽象是需要付出一点代价的，就比如 redux 代码可能会很罗嗦; 一个复杂的状态树, 如果缺乏良好的组织，整个应用会变得很难理解。实际上, 并不是所有场景都能够顺利/优雅通过’数据驱动’进行表达(可以看一下这篇文章<a href="https://zhuanlan.zhihu.com/p/54492049" target="_blank" rel="noopener">Modal.confirm 违反了 React 的模式吗？</a>), 例如文本框焦点, 或者模态框. 所以不必极端追求无副作用或者数据驱动</p><p>后续会专门写篇文章来回顾总结状态管理.</p><p>扩展:</p><ul><li><a href="https://hackernoon.com/redesigning-redux-b2baee8b8a38" target="_blank" rel="noopener">Redesigning Redux</a></li><li><a href="http://cyclejs.cn/#-组件化" target="_blank" rel="noopener">Cyclejs</a></li></ul><p><br></p><hr><p><br></p><h3 id="5️⃣-按照-ui-划分为布局组件和内容组件"><a href="#5️⃣-按照-ui-划分为布局组件和内容组件" class="headerlink" title="5️⃣ 按照 UI 划分为布局组件和内容组件"></a>5️⃣ 按照 UI 划分为<code>布局组件</code>和<code>内容组件</code></h3><ul><li>布局组件用于控制页面的布局，为内容组件提供占位。通过 props 传入组件来进行填充. 比如<code>Grid</code>, <code>Layout</code>, <code>HorizontalSplit</code></li><li>内容组件会包含一些内容，而不仅有布局。内容组件通常被布局组件约束在占位内. 比如<code>Button</code>, <code>Label</code>, <code>Input</code></li></ul><p>例如下图, List/List.Item 就是布局组件，而 Input，Address 则是内容组件</p><center><br>  <img src="/images/04/layout-vs-content.png" lazyload width="500"><br></center><p>将布局从内容组件中抽取出来，分离布局和内容，可以让两者更好维护，比如布局变动不会影响内容，内容组件可以被应用不同的布局; 另一方面组件是一个自包含内聚的隔离单元, 不应该影响其外部的状态, 例如一个按钮不应该修改外部的布局, 另外也要避免影响全局的样式</p><p><br></p><hr><p><br></p><h3 id="6️⃣-接口一致的数据录入组件"><a href="#6️⃣-接口一致的数据录入组件" class="headerlink" title="6️⃣ 接口一致的数据录入组件"></a>6️⃣ 接口一致的数据录入组件</h3><p>数据录入组件, 或者称为表单, 是客户端开发必不可少的元素. 对于自定义表单组件, 我认为应该保持一致的 API:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props&lt;T&gt; &#123;</span><br><span class="line">  value?: T;</span><br><span class="line">  onChange: <span class="function">(<span class="params">value?: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处:</p><ul><li>接近原生表单元素原语. 自定义表单组件一般不需要封装到 event 对象中</li><li>几乎所有组件库的自定义表单都使用这种 API. 这使得我们的自定义组件可以和第三方库兼容, 比如<a href="https://ant.design/components/form-cn/#components-form-demo-validate-other" target="_blank" rel="noopener">antd 的表单验证机制</a></li><li>更容易被动态渲染. 因为接口一致, 可以方便地进行动态渲染或集中化处理, 减少代码重复</li><li><p>回显问题. 状态回显是表单组件的功能之一, 我个人的最佳实践是<code>value</code>应该是自包含的:</p><p>比如一个支持搜索的用户选择器, option 都是异步从后端加载, 如果 value 只保存用户 id, 那么回显的时候就无法显示用户名, 按照我的实践的 value 的结构应该为: <code>{id: string, name: string}</code>, 这样就解决了回显问题. 回显需要的数据都是由父节点传递进来, 而不是组件自己维护</p></li><li><p>组件都是受控的. 在实际的 React 开发中, 非受控组件的场景非常少, 我认为自定义组件都可以忽略这种需求, 只提供完全受控表单组件, 避免组件自己维护缓存状态</p></li></ul><p><br></p><hr><p><br></p><h2 id="4-目录划分"><a href="#4-目录划分" class="headerlink" title="4. 目录划分"></a>4. 目录划分</h2><h3 id="1️⃣-基本目录结构"><a href="#1️⃣-基本目录结构" class="headerlink" title="1️⃣ 基本目录结构"></a>1️⃣ 基本目录结构</h3><p>关于项目目录结构的划分有两种流行的模式:</p><ul><li><strong><a href="https://ruby-china.github.io/rails-guides/getting_started.html#say-hello-rails" target="_blank" rel="noopener">Rails-style</a>/by-type</strong>: 按照文件的类型划分为不同的目录，例如<code>components</code>、<code>constants</code>、 <code>typings</code>、<code>views</code></li><li><strong>Domain-style/by-feature</strong>: 按照一个功能特性或业务创建单独的文件夹，包含多种类型的文件或目录</li></ul><p>实际的项目环境我们一般使用的是<strong>混合模式</strong>，下面是一个典型的 React 项目结构:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/      # 🔴 项目通用的‘展示组件’</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx    # 组件的入口, 导出组件</span><br><span class="line">      Groups.tsx   # 子组件</span><br><span class="line">      loading.svg  # 静态资源</span><br><span class="line">      style.css    # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts       # 到处所有组件</span><br><span class="line">  containers/      # 🔴 包含'容器组件'和'页面组件'</span><br><span class="line">    LoginPage/     # 页面组件, 例如登录</span><br><span class="line">      components/  # 页面级别展示组件，这些组件不能复用与其他页面组件。</span><br><span class="line">        Button.tsx # 组件未必是一个目录形式，对于一个简单组件可以是一个单文件形式. 但还是推荐使用目录，方便扩展</span><br><span class="line">        Panel.tsx</span><br><span class="line">      reducer.ts   # redux reduces</span><br><span class="line">      useLogin.ts  # (可选)放置'逻辑', 按照👆分离逻辑和视图的原则，将逻辑、状态处理抽取到hook文件</span><br><span class="line">      types.ts     # typescript 类型声明</span><br><span class="line">      style.css</span><br><span class="line">      logo.png</span><br><span class="line">      message.ts</span><br><span class="line">      constants.ts</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx      # 🔴应用根组件</span><br><span class="line">  hooks/           # 🔴可复用的hook</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.tsx        # 应用入口, 在这里使用ReactDOM对跟组件进行渲染</span><br><span class="line">  stores.ts        # redux stores</span><br><span class="line">  contants.ts      # 全局常量</span><br></pre></td></tr></table></figure><p>上面使用<code>Domain-style</code>风格划分了<code>LoginPage</code>和<code>HomePage</code>目录, 将所有该业务或者页面相关的文件聚合在一起; 这里也使用<code>Rails-style</code>模式根据文件<strong>类型/职责</strong>划分不同的目录, 比如<code>components</code>, <code>hooks</code>, <code>containers</code>; 你会发现在<code>LoginPage</code>内部也有类似<code>Rails-Style</code>的结构, 如<code>components</code>, 只不过它的<strong>作用域</strong>不同, 它只归属于<code>LoginPage</code>, 不能被其他 Page 共享</p><p>前端项目一般按照页面路由来拆分组件, 这些组件我们暂且称为‘页面组件’, 这些组件是和业务功能耦合的，而且每个页面之间具有一定的独立性.</p><p>这里将页面组件放置在<code>containers</code>, 如其名，这个目录原本是用来放置容器组件的, 实际项目中通常是将‘容器组件’和‘页面组件’混合在了一起, 现阶段如果要实现纯粹的逻辑分离，我个人觉得还是应该抽取到 hook 中. 这个目录也可以命名为 views, pages…(whatever), 命名为 containers 只是一种习惯(来源于 Redux).</p><p>扩展:</p><ul><li><a href="https://github.com/react-boilerplate/react-boilerplate" target="_blank" rel="noopener">react-boilerplate</a></li></ul><p><br></p><hr><p><br></p><h3 id="2️⃣-多页应用的目录划分"><a href="#2️⃣-多页应用的目录划分" class="headerlink" title="2️⃣ 多页应用的目录划分"></a>2️⃣ 多页应用的目录划分</h3><p>对于大型应用可能有多个应用入口, 例如很多 electron 应用有多个 windows; 再比如很多应用除了 App 还有后台管理界面. 我一般会这样组织多页应用:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/       # 共享组件</span><br><span class="line">  containers/</span><br><span class="line">    Admin/          # 后台管理页面</span><br><span class="line">      components/   # 后台特定的组件库</span><br><span class="line">      LoginPage/</span><br><span class="line">      index.tsx</span><br><span class="line">      ...</span><br><span class="line">    App/</span><br><span class="line">      components/  # App特定的组件库</span><br><span class="line">      LoginPage/   # App页面</span><br><span class="line">      index.tsx</span><br><span class="line">      stores.ts    # redux stores</span><br><span class="line">    AnotherApp/    # 另外一个App页面</span><br><span class="line">  hooks/</span><br><span class="line">  ...</span><br><span class="line">  app.tsx          # 应用入口</span><br><span class="line">  anotherApp.tsx   # 应用入口</span><br><span class="line">  admin.tsx        # 后台入口</span><br></pre></td></tr></table></figure><p>webpack 支持多页应用的构建, 我一般会将应用入口文件命名为<code>*.page.tsx</code>, 然后在 src 自动扫描匹配的文件作为入口.</p><p>利用 webpack 的<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener"><code>SplitChunksPlugin</code></a>可以自动为多页应用抽取共享的模块, 这个对于功能差不多和有较多共享代码的多页应用很有意义. 意味着资源被一起优化, 抽取共享模块, 有利于减少编译文件体积, 也便于共享浏览器缓存.</p><blockquote><p><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener"><code>html-webpack-plugin</code></a>4.0 开始支持注入共享 chunk. 在此之前需要通过 SplitChunksPlugin 显式定义共享的 chunk, 然后也要 html-webpack-plugin 显式注入该 chunk, 比较挫.</p></blockquote><p><br></p><hr><p><br></p><h3 id="3️⃣-多页应用的目录划分-monorepo-模式"><a href="#3️⃣-多页应用的目录划分-monorepo-模式" class="headerlink" title="3️⃣ 多页应用的目录划分: monorepo 模式"></a>3️⃣ 多页应用的目录划分: monorepo 模式</h3><p>上面的方式, 所有页面都聚集在一个项目下面, 共享一样的依赖和 npm 模块. 这可能会带了一些问题:</p><ol><li>不能允许不同页面有不同版本的依赖</li><li>对于毫无相关的应用, 这种组织方式会让代码变得混乱, 例如 App 和后台, 他们使用的技术栈/组件库/交互体验都可能相差较大, 而且容易造成命名冲突.</li><li>构建性能. 你希望单独对某个页面进行构建和维护, 而不是所有页面混合在一起构建</li></ol><p>这种场景可以利用<a href="https://lernajs.io" target="_blank" rel="noopener">lerna</a>或者 <a href="https://yarnpkg.com/zh-Hans/docs/workspaces" target="_blank" rel="noopener">yarn workspace</a> 这里 monorepo 机制, 将多页应用隔离在不同的 npm 模块下, 以 yarn workspace 为例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">yarn.lock</span><br><span class="line">node_modules/      # 所有依赖都会安装在这里, 方便yarn对依赖进行优化</span><br><span class="line">share/             # 🔴 共享模块</span><br><span class="line">  hooks/</span><br><span class="line">  utils/</span><br><span class="line">admin/             # 🔴 后台管理应用</span><br><span class="line">  components/</span><br><span class="line">  containers/</span><br><span class="line">  index.tsx</span><br><span class="line">  package.json     # 声明自己的模块以及share模块的依赖</span><br><span class="line">app/               # 🔴 后台管理应用</span><br><span class="line">  components/</span><br><span class="line">  containers/</span><br><span class="line">  index.tsx</span><br><span class="line">  package.json     # 声明自己的模块以及share模块的依赖</span><br></pre></td></tr></table></figure><p>扩展:</p><ul><li><a href="https://juejin.im/post/5cd8c1d6e51d456e55623bf2" target="_blank" rel="noopener">精读《Monorepo 的优势》</a></li></ul><p><br></p><hr><p><br></p><h3 id="4️⃣-跨平台应用"><a href="#4️⃣-跨平台应用" class="headerlink" title="4️⃣ 跨平台应用"></a>4️⃣ 跨平台应用</h3><p>使用 ReactNative 可以将 React 衍生到原生应用的开发领域. 尽管也有<a href="https://github.com/necolas/react-native-web" target="_blank" rel="noopener"><code>react-native-web</code></a>这样的解决方案, Web 和 Native 的 API/功能/开发方式, 甚至产品需求上可能会相差很大, 久而久之就可能出现大量无法控制的适配代码; 另外 react-native-web 本身也可能成为风险点。 所以一些团队需要针对不同平台进行开发, 一般按照下面风格来组织跨平台应用:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx     # 🔴 ReactNative 组件</span><br><span class="line">      index.web.tsx # 🔴 web组件, 以web.tsx为后缀</span><br><span class="line">      loading.svg   # 静态资源</span><br><span class="line">      style.css     # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts</span><br><span class="line">    index.web.ts</span><br><span class="line">  containers/</span><br><span class="line">    LoginPage/</span><br><span class="line">      components/</span><br><span class="line">      ....</span><br><span class="line">      useLogin.ts   # 🔴 存放分离的逻辑，可以在React Native和Web组件中共享</span><br><span class="line">      index.web.tsx</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx</span><br><span class="line">  hooks/</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.web.tsx        # web应用入口</span><br><span class="line">  index.tsx            # React Native 应用入口</span><br></pre></td></tr></table></figure><p>可以通过 webpack 的<code>resolve.extensions</code>来配置扩展名补全的优先级. 早期的<a href="https://github.com/ant-design/ant-design-mobile" target="_blank" rel="noopener">antd-mobile</a>就是这样组织的.</p><p><br></p><hr><p><br></p><h3 id="5️⃣-跨平台的另外一种方式-taro"><a href="#5️⃣-跨平台的另外一种方式-taro" class="headerlink" title="5️⃣ 跨平台的另外一种方式: taro"></a>5️⃣ 跨平台的另外一种方式: taro</h3><p>对于国内的开发者来说，跨平台可不只 Native 那么简单，我们还有各种各样的小程序、小应用。终端的<strong>碎片化</strong>让前端的开发工作越来越有挑战性.</p><p>Taro 就这样诞生了, Taro 基于 React 的标准语法(DSL), 结合编译原理的思想, 将一套代码转换为多种终端的目标代码, 并提供一套统一的内置组件库和 SDK 来抹平多端的差异</p><center><br>  <img src="/images/04/taro.png" width="500"><br></center><p>因为 Taro 使用 React 的标准语法和 API，这使得我们按照原有的 React 开发约定和习惯来开发多端应用，且只保持一套代码. 但是不要忘了抽象都是有代价的</p><blockquote><p>可以查看 Taro 官方文档<a href="https://github.com/NervJS/taro" target="_blank" rel="noopener">了解更多</a> <br></p></blockquote><blockquote><p><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter</a>是近期比较或的跨平台方案，但是跟本文主题无关</p></blockquote><p><br></p><hr><p><br></p><h2 id="5-模块"><a href="#5-模块" class="headerlink" title="5. 模块"></a>5. 模块</h2><h3 id="1️⃣-创建严格的模块边界"><a href="#1️⃣-创建严格的模块边界" class="headerlink" title="1️⃣ 创建严格的模块边界"></a>1️⃣ 创建严格的模块边界</h3><p>下图是一个某页面的模块导入，相当混乱，这还算可以接受，笔者还见过上千行的组件，其中模块导入语句就占一百多行. 这有一部分原因可能是 VsCode 自动导入功能导致(可以使用 tslint 规则对导入语句进行排序和分组规范)，更大的原因是这些模块缺乏组织。</p><center><br>  <img src="/images/04/imports.png" width="600"><br></center><p>我觉得应该创建严格的模块边界，<strong>一个模块只有一个统一的’出口’</strong>。例如一个复杂的组件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ComplexPage/</span><br><span class="line">  components/</span><br><span class="line">    Foo.tsx</span><br><span class="line">    Bar.tsx</span><br><span class="line">  constants.ts</span><br><span class="line">  reducers.ts</span><br><span class="line">  style.css</span><br><span class="line">  types.ts</span><br><span class="line">  index.tsx # 出口</span><br></pre></td></tr></table></figure><p>可以认为<strong>一个‘目录’就是一个模块边界</strong>. 你<em>不应该</em>这样子导入模块:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComplexPage <span class="keyword">from</span> <span class="string">'../ComplexPage'</span>;</span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../ComplexPage/components/Foo'</span>;</span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../ComplexPage/components/Bar'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; XXX &#125; <span class="keyword">from</span> <span class="string">'../ComplexPage/components/constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User, ComplexPageProps &#125; <span class="keyword">from</span> <span class="string">'../ComplexPage/components/type'</span>;</span><br></pre></td></tr></table></figure><p><strong>一个模块/目录应该由一个‘出口’文件来统一管理模块的导出，限定模块的可见性</strong>. 比如上面的模块，<code>components/Foo</code>、 <code>components/Bar</code>和<code>constants.ts</code>这些文件其实是 <code>ComplexPage</code> 组件的’实现细节’. 这些是外部模块不应该去耦合实现细节，但这个在语言层面并没有一个限定机制，只能依靠规范约定.</p><blockquote><p>当其他模块依赖某个模块的’细节’时, 可能是一种重构的信号: 比如依赖一个模块的一个工具函数或者是一个对象类型声明, 这时候可能应该将其抬升到父级模块, 让兄弟模块共享它.</p></blockquote><p>在前端项目中 <code>index</code> 文件最适合作为一个’出口’文件, 当导入一个目录时，模块查找器会查找该目录下是否存在的 index 文件. 开发者设计一个模块的 API 时, 需要考虑模块各种使用方式, 并使用 index 文件控制模块可见性:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入外部模块需要使用的类型</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./type'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不暴露外部不需要关心的实现细节</span></span><br><span class="line"><span class="comment">// export * from './components/Foo'</span></span><br><span class="line"><span class="comment">// export * from './components/Bar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块的默认导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; ComplexPage <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./ComplexPage'</span>;</span><br></pre></td></tr></table></figure><p>现在导入语句可以更加简洁:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComplexPage, &#123; ComplexPageProps, User, XXX &#125; <span class="keyword">from</span> <span class="string">'../ComplexPage'</span>;</span><br></pre></td></tr></table></figure><p><br></p><p>这条规则也可以用于组件库. 在 webpack 的 Tree-shaking 特性还不成熟之前， 我们都使用了各种各样的技巧来实现<code>按需导入</code>. 例如<a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener"><code>babel-plugin-import</code></a>或直接子路径导入:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> TextField <span class="keyword">from</span> <span class="string">'~/components/TextField'</span>;</span><br><span class="line"><span class="keyword">import</span> SelectField <span class="keyword">from</span> <span class="string">'~/components/SelectField'</span>;</span><br><span class="line"><span class="keyword">import</span> RaisedButton <span class="keyword">from</span> <span class="string">'~/components/RaisedButton'</span>;</span><br></pre></td></tr></table></figure><p>现在可以使用<code>Named import</code>直接导入，让 webpack 来帮你优化:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TextField, SelectField, RaisedButton &#125; <span class="keyword">from</span> <span class="string">'~/components'</span>;</span><br></pre></td></tr></table></figure><p><strong>但不是所有目录都有出口文件, 这时候目录就不是模块的边界了</strong>. 典型的有<code>utils/</code>, <code>utils</code> 只是一个模块命名空间, <code>utils</code> 下面的文件都是一些互不相关或者不同类型的文件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">utils/</span><br><span class="line">  common.ts</span><br><span class="line">  dom.ts</span><br><span class="line">  sdk.ts</span><br></pre></td></tr></table></figure><p>我们习惯直接引用这些文件, 而不是通过一个入口文件, 这样可以更明确导入的是什么类型的:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'./utils/dom'</span>; <span class="comment">// 通过文件名可以知道, 这可能是隐藏某个DOM元素</span></span><br><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'./utils/sdk'</span>; <span class="comment">// webview sdk 提供的的某个方法</span></span><br></pre></td></tr></table></figure><p>最后再总结一下:</p>  <center><br>    <img src="/images/04/module-boundary.png" width="600"><br>  </center><p>根据模块边界原则(如上图): <strong>一个模块可以访问兄弟(同个作用域下)、 祖先及祖先的兄弟模块</strong>. 例如:</p><ul><li>Bar 可以访问 Foo, 但不能再向下访问它的细节, 即不能访问<code>../Foo/types.ts</code>, 但可以访问它的出口文件<code>../Foo</code></li><li>src/types.ts 不能访问 containers/HomePage</li><li>LoginPage 和访问 HomePage</li><li>LoginPage 可以访问 utils/sdk</li></ul><p><br></p><hr><p><br></p><h3 id="2️⃣-named-export-vs-default-export"><a href="#2️⃣-named-export-vs-default-export" class="headerlink" title="2️⃣ Named export vs default export"></a>2️⃣ <code>Named export</code> vs <code>default export</code></h3><p>这两种导出方式都有各自的适用场景，这里不应该一棒子打死就不使用某种导出方式. 首先看一下<strong>named export 有什么优点</strong>:</p><ul><li><p>命名确定</p><ul><li>方便 Typescript 进行重构</li><li>方便智能提醒和自动导入(auto-import)识别</li><li><p>方便 reexport</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// named</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./named-export'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Foo &#125; <span class="keyword">from</span> <span class="string">'./default-export'</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一个模块支持多个<code>named export</code></p></li></ul><p><br></p><p><strong>再看一下<code>default export</code>有什么优点?</strong>:</p><ul><li><p><code>default export</code>一般代表‘模块本身’, 当我们使用‘默认导入’导入一个模块时, 开发者是自然而然知道这个默认导入的是一个什么对象。</p><p>例如 react 导出的是一个 React 对象; LoginPage 导出的是一个登录页面; somg.png 导入的是一张图片. 这类模块总有一个确定的’主体对象’. 所以默认导入的名称和模块的名称一般是保持一致的(Typescript 的 auto-import 就是基于文件名).</p><p>当然’主体对象’是一种隐式的概念, 你只能通过规范去约束它</p></li><li><p><code>default export</code>的导入语句更加简洁。例如<code>lazy(import(&#39;./MyPage&#39;))</code></p></li></ul><p><code>default export</code>也有一些缺点:</p><ul><li>和其他模块机制(commonjs)互操作时比较难以理解. 例如我们会这样子导入<code>default export</code>: <code>require(&#39;./xx&#39;).default</code></li><li><code>named import</code> 优点就是<code>default export</code>的缺点</li></ul><p>所以总结一下:</p><ol><li>对于’主体对象’明确的模块需要有默认导出, 例如页面组件，类</li><li>对于’主体对象’不明确的模块不应该使用默认导出，例如组件库、utils(放置各种工具方法)、contants 常量</li></ol><p>按照这个规则可以这样子组织 components 目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">  Foo/</span><br><span class="line">    Foo.tsx</span><br><span class="line">    types.ts</span><br><span class="line">    constants.ts</span><br><span class="line">    index.ts         # 导出Foo组件</span><br><span class="line">  Bar/</span><br><span class="line">    Bar.tsx</span><br><span class="line">    index.tsx</span><br><span class="line">  index.ts           # 导出所有组件</span><br></pre></td></tr></table></figure><p>对于 Foo 模块来说， 存在一个主体对象即 Foo 组件, 所以这里使用<code>default export</code>导出的 Foo 组件， 代码为:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="comment">// 这三个文件全部使用named export导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./contants'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./types'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入主体对象</span></span><br><span class="line"><span class="keyword">export</span> &#123; Foo <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br></pre></td></tr></table></figure><p>现在假设 Bar 组件依赖于 Foo:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/Bar/Bar.tsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入Foo组件, 根据模块边界规则, 不能直接引用../Foo/Foo.tsx</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Bar;</span></span><br></pre></td></tr></table></figure><p>对于<code>components</code>模块来说，它的所有子模块都是平等的，所以不存在一个主体对象，<code>default export</code>在这里不适用。 <code>components/index.ts</code>代码:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/index.ts</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./Bar'</span>;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="3️⃣-避免循环依赖"><a href="#3️⃣-避免循环依赖" class="headerlink" title="3️⃣ 避免循环依赖"></a>3️⃣ 避免循环依赖</h3><p><strong>循环依赖是模块糟糕设计的一个表现</strong>, 这时候你需要考虑拆分和设计模块文件, 例如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- Foo.tsx ---</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./Bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">Foo.Bar = Bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Bar.tsx ----</span></span><br><span class="line"><span class="keyword">import</span> &#123; SomeType &#125; <span class="keyword">from</span> <span class="string">'./Foo'</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面 Foo 和 Bar 组件就形成了一个简单循环依赖, 尽管它不会造成什么运行时问题. 解决方案就是将 SomeType 抽取到单独的文件:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- types.ts ---</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Foo.tsx ---</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./Bar'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;SomeType&#125; <span class="keyword">from</span> <span class="string">'./types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">...</span><br><span class="line">Foo.Bar = Bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Bar.tsx ----</span></span><br><span class="line"><span class="keyword">import</span> &#123;SomeType&#125; <span class="keyword">from</span> <span class="string">'./types'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="4️⃣-相对路径不要超过两级"><a href="#4️⃣-相对路径不要超过两级" class="headerlink" title="4️⃣ 相对路径不要超过两级"></a>4️⃣ 相对路径不要超过两级</h3><p>当项目越来越复杂, 目录可能会越来越深, 这时候会出现这样的导入路径:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'../../../utils/dom'</span>;</span><br></pre></td></tr></table></figure><p>首先这种导入语句非常不优雅, 而且可读性很差. 当你在不清楚当前文件的目录上下文时, 你不知道具体模块在哪; 即使你知道当前文件的位置, 你也需要跟随导入路径在目录树中向上追溯在能定位到具体模块. 所以这种相对路径是比较反人类的.</p><p>另外这种导入路径不方便模块迁移(尽管 Vscode 支持移动文件时重构导入路径), 文件迁移需要重写这些相对导入路径.</p><p><strong>所以一般推荐相对路径导入不应该超过两级, 即只能是<code>../</code>和<code>./</code></strong>. 可以尝试将<strong>相对路径转换成绝对路径形式</strong>, 例如<code>webpack</code>中可以配置<code>resolve.alias</code>属性来实现:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">resolve: &#123;</span><br><span class="line">  ...</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="comment">// 可以直接使用~访问相对于src目录的模块</span></span><br><span class="line">    <span class="comment">// 如 ~/components/Button</span></span><br><span class="line">    <span class="string">'~'</span>: context,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以这样子导入相对于<code>src</code>的模块:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hide &#125; <span class="keyword">from</span> <span class="string">'~/utils/dom'</span>;</span><br></pre></td></tr></table></figure><p>扩展</p><ul><li>对于 Typescript 可以配置<a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping" target="_blank" rel="noopener">paths</a>选项;</li><li>对于 babel 可以使用<a href="https://www.npmjs.com/package/babel-plugin-module-resolver" target="_blank" rel="noopener"><code>babel-plugin-module-resolver</code></a>插件来转换为相对路径</li></ul><p><br></p><hr><p><br></p><h2 id="6-拆分"><a href="#6-拆分" class="headerlink" title="6. 拆分"></a>6. 拆分</h2><h3 id="1️⃣-拆分-render-方法"><a href="#1️⃣-拆分-render-方法" class="headerlink" title="1️⃣ 拆分 render 方法"></a>1️⃣ 拆分 render 方法</h3><p>当 render 方法的 JSX 结构非常复杂的时候, 首先应该尝试分离这些 JSX, 最简单的做法的就是拆分为多个子 render 方法:</p>  <center><br>    <img src="/images/04/sub-render.png" width="600"><br>  </center><p>当然这种方式只是暂时让 render 方法看起来没有那么复杂, 它并没有拆分组件本身, 所有输入和状态依然聚集在一个组件下面. 所以通常拆分 render 方法只是重构的第一步: 随着组件越来越复杂, 表现为文件越来越长, 笔者一般将 300 行作为一个阈值, <strong>超过 300 行则说明需要对这个组件进进一步拆分</strong></p><p><br></p><hr><p><br></p><h3 id="2️⃣-拆分为组件"><a href="#2️⃣-拆分为组件" class="headerlink" title="2️⃣ 拆分为组件"></a>2️⃣ 拆分为组件</h3><p>如果已经按照 👆 上述方法对组件的 render 拆分为多个子 render, 当一个组件变得臃肿时, 就可以方便地将这些子 render 方法拆分为组件. 一般组件抽离有以下几种方式:</p><ol><li>纯渲染拆分: 子 render 方法一般是纯渲染的, 他们可以很直接地抽离为<em>无状态组件</em></li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; visible &#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Modal</span><br><span class="line">      visible=&#123;visible&#125;</span><br><span class="line">      title=&#123;<span class="keyword">this</span>.getLocale(<span class="string">'title'</span>)&#125;</span><br><span class="line">      width=&#123;<span class="keyword">this</span>.width&#125;</span><br><span class="line">      maskClosable=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">      onOk=&#123;<span class="keyword">this</span>.handleOk&#125;</span><br><span class="line">      onCancel=&#123;<span class="keyword">this</span>.handleCancel&#125;</span><br><span class="line">      footer=&#123;&lt;Footer &#123;...&#125;&gt;&lt;<span class="regexp">/Footer&gt;&#125;</span></span><br><span class="line"><span class="regexp">    &gt;</span></span><br><span class="line"><span class="regexp">    &lt;Body &#123;...&#125;&gt;&lt;/</span>Body&gt;</span><br><span class="line">  &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>纯逻辑拆分: 按照<code>逻辑和视图分离</code>的原则, 将逻辑控制部分抽离到 hooks 或高阶组件中</li><li>逻辑和渲染拆分: 将相关的视图和逻辑抽取出去形成一个独立的组件, 这是更为彻底的拆分方式, 贯彻单一职责原则.</li></ol><p><br></p><hr><p><br></p><h2 id="7-组件划分示例"><a href="#7-组件划分示例" class="headerlink" title="7. 组件划分示例"></a>7. 组件划分示例</h2><p>我们一般会从 UI 原型图中分析和划分组件, 在 React 官方的<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">Thinking in react</a>也提到通过 UI 来划分组件层级: “<em>这是因为 UI 和数据模型往往遵循着相同的信息架构，这意味着将 UI 划分成组件的工作往往是很容易的。只要把它划分成能准确表示你数据模型的一部分的组件就可以</em>“. 组件划分除了需要遵循上文 👆 提到的一些原则, 他还依赖于你的开发经验.</p><p>本节通过一个简单的应用讲述划分组件的过程. 这是某政府部门的服务申报系统, 一共由四个页面组成:</p><center><br>  <img src="/images/04/demo-all.png" width="800"><br></center><h3 id="1️⃣-划分页面"><a href="#1️⃣-划分页面" class="headerlink" title="1️⃣ 划分页面"></a>1️⃣ 划分页面</h3><p>页面通常是最顶层的组件单元, 划分页面非常简单, 我们根据原型图就可以划分四个页面: <code>ListPage</code>, <code>CreatePage</code>, <code>PreviewPage</code>, <code>DetailPage</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  containers/</span><br><span class="line">    ListPage/</span><br><span class="line">    CreatePage/</span><br><span class="line">    PreviewPage/</span><br><span class="line">    DetailPage/</span><br><span class="line">    index.tsx     # 根组件, 一般在这里定义路由</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="2️⃣-划分基础-ui-组件"><a href="#2️⃣-划分基础-ui-组件" class="headerlink" title="2️⃣ 划分基础 UI 组件"></a>2️⃣ 划分基础 UI 组件</h3><p>首先看<code>ListPage</code></p>  <center><br>    <img src="/images/04/ListPage.png" width="400"><br>  </center><p>ListPage 根据 UI 可以划分为下面这些组件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ScrollView        # 滚动视图, 提供下拉刷新, 无限加载等功能</span><br><span class="line">  List            # 列表容器, 布局组件</span><br><span class="line">    Item          # 列表项, 布局组件, 提供header, body等占位符</span><br><span class="line">      props - header</span><br><span class="line">         Title       # 渲染标题</span><br><span class="line">      props - after</span><br><span class="line">         Time        # 渲染时间</span><br><span class="line">      props - body</span><br><span class="line">         Status      # 渲染列表项的状态</span><br></pre></td></tr></table></figure><p>再看看<code>CreatePage</code></p>  <center><br>    <img src="/images/04/CreatePage.png" width="400"><br>  </center><p>这是一个表单填写页面, 为了提高表单填写体验, 这里划分为多个步骤; 每个步骤里有还有多个表单分组; 每个表单的结构都差不多, 左边是 label 展示, 右边是实际表单组件, 所以根据 UI 可以对组件进行这样的划分:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CreatePage</span><br><span class="line">  Steps            # 步骤容器, 提供了步骤布局和步骤切换等功能</span><br><span class="line">    Step           # 单一步骤容器</span><br><span class="line">      List         # 表单分组</span><br><span class="line">        List.Item  # 表单容器, 支持设置label</span><br><span class="line">          Input    # 具体表单类型</span><br><span class="line">          Address</span><br><span class="line">          NumberInput</span><br><span class="line">          Select</span><br><span class="line">          FileUpload</span><br></pre></td></tr></table></figure><blockquote><p>组件命名的建议: 对于集合型组件, 一般会使用单复数命名, 例如上面的 Steps/Step; List/Item 这种形式也比较常见, 例如 Form/Form.Item, 这种形式比较适合作为子组件形式. 可以学习一下第三方组件库是怎么给组件命名的.</p></blockquote><p>再看一下<code>PreviewPage</code>, PreviewPage 是创建后的数据预览页面, 数据结构和页面结构和 CreatePage 差不多. 将 Steps 对应到 Preview 组件, Step 对应到 Preview.Item. Input 对应到 Input.Preview:</p>  <center><br>    <img src="/images/04/PreviewPage.png" width="400"><br>  </center><p><br></p><hr><p><br></p><h3 id="3️⃣-设计组件的状态"><a href="#3️⃣-设计组件的状态" class="headerlink" title="3️⃣ 设计组件的状态"></a>3️⃣ 设计组件的状态</h3><p>对于 ListPage 来说状态比较简单, 这里主要讨论 CreatePage 的状态. CreatePage 的特点:</p><ul><li>表单组件使用受控模式, 本身不会存储表单的状态. 另外表单之间的状态可能是联动的</li><li>状态需要在 CreatePage 和 PreviewPage 之间共享</li><li>需要对表单进行统一校验</li><li>草稿保存</li></ul><p>由于需要在 CreatePage 和 PreviewPage 中共享数据, 表单的状态应该抽取和提升到父级. 在这个项目的实际开发中, 我的做法是创建一个 FormStore 的 Context 组件, 下级组件通过这个 context 来统一存储数据. 另外我决定使用配置的方式, 来渲染动态这些表单. 大概的结构如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// CreatePage/index.tsx</span><br><span class="line">&lt;FormStore defaultValue=&#123;draft&#125; onChange=&#123;saveDraft&#125;&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&quot;/create/preview&quot; component=&#123;Preview&#125; /&gt;</span><br><span class="line">    &lt;Route path=&quot;/create&quot; component=&#123;Create&#125; /&gt;</span><br><span class="line">  &lt;/Switch&gt;</span><br><span class="line">&lt;/FormStore&gt;</span><br><span class="line"></span><br><span class="line">// CreatePage/Create.tsx</span><br><span class="line">&lt;Steps&gt;</span><br><span class="line">  &#123;steps.map(i =&gt;</span><br><span class="line">    &lt;Step key=&#123;i.name&#125;&gt;</span><br><span class="line">      &lt;FormRenderer forms=&#123;i.forms&#125;  /&gt; &#123;/* forms为表单配置, 根据配置的表单类型渲染表单组件, 从FormStore的获取和存储值 */&#125;</span><br><span class="line">    &lt;/Step&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/Steps&gt;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="8-文档"><a href="#8-文档" class="headerlink" title="8. 文档"></a>8. 文档</h2><p>组件的文档化推荐使用<a href="https://storybook.js.org" target="_blank" rel="noopener">Storybook</a>, 这是一个组件 <code>Playground</code>, 有以下特性</p><ul><li>可交互的组件示例</li><li>可以用于展示组件的文档. 支持 props 生成和 markdown</li><li>可以用于组件测试. 支持组件结构测试, 交互测试, 可视化测试, 可访问性或者手动测试</li><li>丰富的插件生态</li></ul><p><a href="https://storybooks-official.netlify.com" target="_blank" rel="noopener">React 示例</a>. 由于篇幅原因, Storybook 就不展开细节, 有兴趣的读者可以参考官方文档.</p><p><br></p><hr><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://jaysoo.ca/2016/02/28/organizing-redux-application/#rule-2-create-strict-module-boundaries" target="_blank" rel="noopener">Three Rules For Structuring (Redux) Applications</a></li><li><a href="https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/" target="_blank" rel="noopener">How To Scale React Applications</a></li><li><a href="http://cn.redux.js.org/docs/faq/CodeStructure.html" target="_blank" rel="noopener">Redux 常见问题：代码结构</a></li><li><a href="https://basarat.gitbooks.io/typescript/docs/tips/defaultIsBad.html" target="_blank" rel="noopener">export default considered harmful</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html" target="_blank" rel="noopener">JavaScript 模块的循环加载</a></li><li><a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">thinking-in-react</a></li><li><a href="https://speakerdeck.com/vasa/building-multitenant-ui-with-react-dot-js?slide=16" target="_blank" rel="noopener">Building Multitenant UI with React.js</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个复杂的应用都是由简单的应用发展而来的, 随着越来越多的功能加入项目, 代码就会变得越来越难以控制. 本文章主要探讨在大型项目中如何对组件进行组织, 让项目具备可维护性.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系列目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React组件设计实践总结01 - 类型检查</title>
    <link href="https://bobi.ink/2019/05/10/react-component-design-01/"/>
    <id>https://bobi.ink/2019/05/10/react-component-design-01/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-07-11T14:59:37.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系列引言"><a href="#系列引言" class="headerlink" title="系列引言"></a>系列引言</h2><p>最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对<strong>React 组件设计的相关实践和规范</strong>整理了一些文档, 将部分章节分享了出来. 由于经验有限, 文章可能会有某些错误, 希望大家指出, 互相交流.</p><p>由于篇幅太长, 所以拆分为几篇文章. 主要有以下几个主题:</p><ul><li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li><li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li><li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li><li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li><li><a href="/2019/05/20/react-component-design-05/">05 状态管理</a></li></ul><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>静态类型检查对于当今的前端项目越来越不可或缺, 尤其是大型项目. <strong>它可以在开发时就避免许多类型问题, 减少低级错误的; 另外通过类型智能提示, 可以提高编码的效率; 有利于书写自描述的代码(类型即文档); 方便代码重构(配合 IDE 可以自动重构)</strong>. 对于静态类型检查的好处这里就不予赘述, 读者可以查看这个回答<a href="https://www.zhihu.com/question/28016252/answer/39056940" target="_blank" rel="noopener">flow.js/typescript 这类定义参数类型的意义何在？</a>.</p><p>Javascript 的类型检查器主要有<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">Typescript</a>和<a href="https://flow.org" target="_blank" rel="noopener">Flow</a>, 笔者两者都用过, Typescript 更强大一些, 可以避免很多坑, 有更好的生态(例如第三方库类型声明), 而且 VSCode 内置支持. 而对于 Flow, 连 Facebook 自己的开源项目(如 Yarn, Jest)都抛弃了它, 所以不建议入坑. 所以本篇文章使用 Typescript(v3.3) 对 React 组件进行类型检查声明</p><p>建议通过官方文档来<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">学习 Typescript</a>. 笔者此前也整理了 Typescript 相关的<a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">思维导图(mindnode)</a></p><blockquote><p>当然 Flow 也有某些 Typescript 没有的特性: <a href="https://github.com/niieani/typescript-vs-flowtype" target="_blank" rel="noopener">typescript-vs-flowtype</a></p></blockquote><blockquote><p>React 组件类型检查依赖于<code>@types/react</code>和<code>@types/react-dom</code></p></blockquote><blockquote><p>直接上手使用试用 <br> <a href="https://codesandbox.io/s/5vx5wwmkvx?fontsize=14" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit typescript-react-playground"></a></p></blockquote><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#系列引言">系列引言</a></li><li><a href="#类型检查">类型检查</a><ul><li><a href="#1-函数组件">1. 函数组件</a><ul><li><a href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出">1️⃣ <strong>使用<code>ComponentNameProps</code> 形式命名 Props 类型, 并导出</strong></a></li><li><a href="#2️⃣-优先使用fc类型来声明函数组件">2️⃣ <strong>优先使用<code>FC</code>类型来声明函数组件</strong></a></li><li><a href="#3️⃣-不要直接使用export-default导出组件">3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</a></li><li><a href="#4️⃣-默认-props-声明">4️⃣ <strong>默认 props 声明</strong></a></li><li><a href="#5️⃣-泛型函数组件">5️⃣ <strong>泛型函数组件</strong></a></li><li><a href="#6️⃣-子组件声明">6️⃣ <strong>子组件声明</strong></a></li><li><a href="#7️⃣-forwarding-refs">7️⃣ <strong>Forwarding Refs</strong></a></li><li><a href="#8️⃣-配合高阶组件使用">8️⃣ <strong>配合高阶组件使用</strong></a></li></ul></li><li><a href="#2-类组件">2. 类组件</a><ul><li><a href="#1️⃣-继承-component-或-purecomponent">1️⃣ <strong>继承 Component 或 PureComponent</strong></a></li><li><a href="#2️⃣-使用static-defaultprops定义默认-props">2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></a></li><li><a href="#3️⃣-子组件声明">3️⃣ <strong>子组件声明</strong></a></li><li><a href="#4️⃣-泛型">4️⃣ <strong>泛型</strong></a></li></ul></li><li><a href="#3-高阶组件">3. 高阶组件</a></li><li><a href="#4-render-props">4. Render Props</a></li><li><a href="#5-context">5. Context</a></li><li><a href="#6-杂项">6. 杂项</a><ul><li><a href="#1️⃣-使用handleevent命名事件处理器">1️⃣ <strong>使用<code>handleEvent</code>命名事件处理器</strong>.</a></li><li><a href="#2️⃣-内置事件处理器的类型">2️⃣ <strong>内置事件处理器的类型</strong></a></li><li><a href="#3️⃣-自定义组件暴露事件处理器类型">3️⃣ <strong>自定义组件暴露事件处理器类型</strong></a></li><li><a href="#4️⃣-获取原生元素-props-定义">4️⃣ <strong>获取原生元素 props 定义</strong></a></li><li><a href="#5️⃣-不要使用-proptypes">5️⃣ <strong>不要使用 PropTypes</strong></a></li><li><a href="#6️⃣-styled-components">6️⃣ <strong>styled-components</strong></a></li><li><a href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明">7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></a></li><li><a href="#8️⃣-为文档生成做好准备">8️⃣ <strong>为文档生成做好准备</strong></a></li><li><a href="#9️⃣-开启-strict-模式">9️⃣ <strong>开启 strict 模式</strong></a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul></li></ul><!-- /TOC --><p><br></p><hr><p><br></p><h3 id="1-函数组件"><a href="#1-函数组件" class="headerlink" title="1. 函数组件"></a>1. 函数组件</h3><p>React Hooks 出现后, 函数组件有了更多出镜率. 由于函数组件只是普通函数, 它非常容易进行类型声明</p><p><br></p><h4 id="1️⃣-使用componentnameprops-形式命名-props-类型-并导出"><a href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出" class="headerlink" title="1️⃣ 使用ComponentNameProps 形式命名 Props 类型, 并导出"></a>1️⃣ <strong>使用<code>ComponentNameProps</code> 形式命名 Props 类型, 并导出</strong></h4><p><br></p><h4 id="2️⃣-优先使用fc类型来声明函数组件"><a href="#2️⃣-优先使用fc类型来声明函数组件" class="headerlink" title="2️⃣ 优先使用FC类型来声明函数组件"></a>2️⃣ <strong>优先使用<code>FC</code>类型来声明函数组件</strong></h4><p><code>FC</code>是<code>FunctionComponent</code>的简写, 这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Props类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyComponent: FC&lt;MyComponentProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>你也可以直接使用普通函数来进行组件声明, 下文会看到这种形式更加灵活:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  <span class="comment">// 手动声明children</span></span><br><span class="line">  children?: React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props: MyComponentProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="3️⃣-不要直接使用export-default导出组件"><a href="#3️⃣-不要直接使用export-default导出组件" class="headerlink" title="3️⃣ 不要直接使用export default导出组件."></a>3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</h4><p>这种方式导出的组件在<code>React Inspector</code>查看时会显示为<code>Unknown</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (props: &#123;&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>如果非得这么做, 请使用<code>命名 function</code> 定义:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">props: &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;xxx&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-默认-props-声明"><a href="#4️⃣-默认-props-声明" class="headerlink" title="4️⃣ 默认 props 声明"></a>4️⃣ <strong>默认 props 声明</strong></h4><p>实际上截止目前对于上面的使用<code>FC</code>类型声明的函数组件并<a href="https://github.com/Microsoft/TypeScript/issues/27425" target="_blank" rel="noopener">不能完美支持 defaultProps</a>:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ❌! missing name</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure><p>笔者一般喜欢这样子声明默认 props:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>; <span class="comment">// 声明为可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用对象默认属性值语法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name = 'TJ' &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br></pre></td></tr></table></figure><p>如果非得使用 defaultProps, 可以这样子声明 👇. Typescript 可以推断和在函数上定义的属性, 这个特性在 Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#properties-declarations-on-functions" target="_blank" rel="noopener">3.1</a>开始支持.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用函数参数声明</span></span><br><span class="line"><span class="comment">// PropsWithChildren只是扩展了children, 完全可以自己声明</span></span><br><span class="line"><span class="comment">// type PropsWithChildren&lt;P&gt; = P &amp; &#123;</span></span><br><span class="line"><span class="comment">//    children?: ReactNode;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">const</span> Hello = <span class="function">(<span class="params">&#123; name &#125;: PropsWithChildren&lt;HelloProps&gt;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ✅ ok!</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure><p>这种方式也非常简洁, 只不过 defaultProps 的类型和组件本身的 props 没有关联性, 这会使得 defaultProps 无法得到类型约束, 所以必要时进一步显式声明 defaultProps 的类型:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Hello.defaultProps = &#123; name: <span class="string">'TJ'</span> &#125; <span class="keyword">as</span> Partial&lt;HelloProps&gt;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5️⃣-泛型函数组件"><a href="#5️⃣-泛型函数组件" class="headerlink" title="5️⃣ 泛型函数组件"></a>5️⃣ <strong>泛型函数组件</strong></h4><p>泛型在一下列表型或容器型的组件中比较常用, 直接使用<code>FC</code>无法满足需求:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ListProps&lt;T&gt; &#123;</span><br><span class="line">  visible: <span class="built_in">boolean</span>;</span><br><span class="line">  list: T[];</span><br><span class="line">  renderItem: <span class="function">(<span class="params">item: T, index: <span class="built_in">number</span></span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: ListProps&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;List</span><br><span class="line">      list=&#123;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">      renderItem=&#123;<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/*自动推断i为number类型*/</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要配合高阶组件使用可以这样子声明:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const List = React.memo(props =&gt; &#123;</span><br><span class="line">  return &lt;div /&gt;;</span><br><span class="line">&#125;) as (&lt;T&gt;(props: ListProps&lt;T&gt;) =&gt; React.ReactElement)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="6️⃣-子组件声明"><a href="#6️⃣-子组件声明" class="headerlink" title="6️⃣ 子组件声明"></a>6️⃣ <strong>子组件声明</strong></h4><p>使用<code>Parent.Child</code>形式的 JSX 可以让节点父子关系更加直观, 它类似于一种命名空间的机制, 可以避免命名冲突. 相比<code>ParentChild</code>这种命名方式, <code>Parent.Child</code>更为优雅些. 当然也有可能让代码变得啰嗦.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutProps &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutHeaderProps &#123;&#125; <span class="comment">// 采用ParentChildProps形式命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutFooterProps &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">props: PropsWithChildren&lt;LayoutProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 作为父组件的属性</span></span><br><span class="line"><span class="regexp">Layout.Header = (props: PropsWithChildren&lt;LayoutHeaderProps&gt;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;div className="header"&gt;&#123;props.children&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Layout.Footer = <span class="function">(<span class="params">props: PropsWithChildren&lt;LayoutFooterProps&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"footer"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Test</span></span><br><span class="line"><span class="regexp">&lt;Layout&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Layout.Header&gt;header&lt;/</span>Layout.Header&gt;</span><br><span class="line">  &lt;Layout.Footer&gt;footer&lt;<span class="regexp">/Layout.Footer&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Layout&gt;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="7️⃣-forwarding-refs"><a href="#7️⃣-forwarding-refs" class="headerlink" title="7️⃣ Forwarding Refs"></a>7️⃣ <strong>Forwarding Refs</strong></h4><p><code>React.forwardRef</code> 在 16.3 新增, 可以用于转发 ref, 适用于 HOC 和函数组件.</p><p>函数组件在 16.8.4 之前是不支持 ref 的, 配合 forwardRef 和 useImperativeHandle 可以让函数组件向外暴露方法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment"> * MyModal.tsx</span></span><br><span class="line"><span class="comment"> ****************************/</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useImperativeHandle, FC, useRef, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalProps &#123;</span><br><span class="line">  title?: React.ReactNode;</span><br><span class="line">  onOk?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onCancel?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露的方法, 适用`&#123;ComponentName&#125;Methods`形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalMethods &#123;</span><br><span class="line">  show(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyModal = React.forwardRef&lt;MyModalMethods, MyModalProps&gt;<span class="function">(<span class="params">(<span class="params">props, ref</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> [visible, setVisible] = useState(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 初始化ref暴露的方法</span></span></span></span><br><span class="line"><span class="function"><span class="params">  useImperativeHandle(<span class="params">ref, (<span class="params"></span>) =&gt; (<span class="params">&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">    show: (<span class="params"></span>) =&gt; setVisible(<span class="params"><span class="literal">true</span></span>),</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">  &#125;</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> &lt;Modal visible=&#123;visible&#125;&gt;...&lt;/Modal&gt;;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/*******************</span></span><br><span class="line"><span class="function"> * <span class="params">Test</span>.<span class="params">tsx</span></span></span><br><span class="line"><span class="function"> *******************/</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">Test</span>: <span class="params">FC</span>&lt;&#123;&#125;&gt; = <span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 引用</span></span><br><span class="line">  <span class="keyword">const</span> modal = useRef&lt;MyModalMethods | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> confirm = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modal.current) &#123;</span><br><span class="line">      modal.current.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleOk = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;confirm&#125;&gt;show&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MyModal ref=&#123;modal&#125; onOk=&#123;handleOk&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="8️⃣-配合高阶组件使用"><a href="#8️⃣-配合高阶组件使用" class="headerlink" title="8️⃣ 配合高阶组件使用"></a>8️⃣ <strong>配合高阶组件使用</strong></h4><p>经常看到新手写出这样的代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Foo.tsx</span><br><span class="line">const Foo: FC&lt;FooProps&gt; = props =&gt; &#123;/* .. */&#125;)</span><br><span class="line">export default React.memo(Foo)</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">// Demo.tsx</span><br><span class="line">import &#123; Foo &#125; from &apos;./Foo&apos; // -&gt; 这里面误使用命名导入语句，导致React.memo没有起作用</span><br></pre></td></tr></table></figure><p>所以笔者一般这样子组织:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Foo.tsx</span><br><span class="line">const Foo: FC&lt;FooProps&gt; = React.memo(props =&gt; &#123;/* .. */&#125;))</span><br><span class="line">export default Foo</span><br></pre></td></tr></table></figure><p>上面的代码还是有一个缺陷, 即你在React开发者工具看到的节点名称是这样的<code>&lt;Memo(wrappedComponent)&gt;&lt;/Memo(wrappedComponent)&gt;</code>, 只是因为React Babel插件无法从匿名函数中推导出displayName导致的. 解决方案是显式添加displayName:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo: FC&lt;FooProps&gt; = React.memo(props =&gt; &#123;/* .. */&#125;))</span><br><span class="line">Foo.displayName = &apos;Foo&apos;</span><br><span class="line">export default Foo</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="2-类组件"><a href="#2-类组件" class="headerlink" title="2. 类组件"></a>2. 类组件</h3><p>相比函数, 基于类的类型检查可能会更好理解(例如那些熟悉传统面向对象编程语言的开发者).</p><h4 id="1️⃣-继承-component-或-purecomponent"><a href="#1️⃣-继承-component-或-purecomponent" class="headerlink" title="1️⃣ 继承 Component 或 PureComponent"></a>1️⃣ <strong>继承 Component 或 PureComponent</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先导出Props声明, 同样是&#123;ComponentName&#125;Props形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> CounterProps &#123;</span><br><span class="line">  defaultCount: <span class="built_in">number</span>; <span class="comment">// 可选props, 不需要?修饰</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组件状态, 不需要暴露</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类注释</span></span><br><span class="line"><span class="comment"> * 继承React.Component, 并声明Props和State类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Counter <span class="keyword">extends</span> React.Component&lt;CounterProps, State&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    defaultCount: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化State</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> state = &#123;</span><br><span class="line">    count: <span class="keyword">this</span>.props.defaultCount,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 声明周期方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 建议靠近componentDidMount, 资源消费和资源释放靠近在一起, 方便review</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentWillUnmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidCatch() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidUpdate(prevProps: CounterProps, prevState: State) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 渲染函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.decrement&#125;&gt;Decrement&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>**</span><br><span class="line">   * ① 组件私有方法, 不暴露</span><br><span class="line">   * ② 使用类实例属性+箭头函数形式绑定<span class="keyword">this</span></span><br><span class="line">   *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  private increment = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count + 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  private decrement = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count - 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="2️⃣-使用static-defaultprops定义默认-props"><a href="#2️⃣-使用static-defaultprops定义默认-props" class="headerlink" title="2️⃣ 使用static defaultProps定义默认 props"></a>2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></h4><p>Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx" target="_blank" rel="noopener">3.0</a>开始支持对使用 defaultProps 对 JSX props 进行推断, 在 defaultProps 中定义的 props 可以不需要’?’可选操作符修饰. 代码如上 👆</p><p><br></p><h4 id="3️⃣-子组件声明"><a href="#3️⃣-子组件声明" class="headerlink" title="3️⃣ 子组件声明"></a>3️⃣ <strong>子组件声明</strong></h4><p>类组件可以使用静态属性形式声明子组件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Layout <span class="keyword">extends</span> React.Component&lt;LayoutProps&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Header = Header;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Footer = Footer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-泛型"><a href="#4️⃣-泛型" class="headerlink" title="4️⃣ 泛型"></a>4️⃣ <strong>泛型</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> List&lt;T&gt; <span class="keyword">extends</span> React.Component&lt;ListProps&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="3-高阶组件"><a href="#3-高阶组件" class="headerlink" title="3. 高阶组件"></a>3. 高阶组件</h3><p>在 React Hooks 出来之前, 高阶组件是 React 的一个重要逻辑复用方式. 相比较而言高阶组件比较重, 且难以理解, 容易造成<code>嵌套地狱(wrapper)</code>. 另外对 Typescript 类型化也不友好(以前会使用<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/9c1c7e78a9a2b4af8e2cda842c3693f67bb9e42d/types/react-router/index.d.ts#L137" target="_blank" rel="noopener">Omit</a>来计算导出的 props). 所以新项目还是建议使用 React Hooks.</p><p>一个简单的高阶组件:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给指定组件注入'主题'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withTheme</span>&lt;<span class="title">P</span>&gt;(<span class="params">Component: React.ComponentType&lt;P &amp; ThemeProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * WithTheme 自己暴露的Props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件的props, 忽略ThemeProps, 外部不需要传递这些属性</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">type</span> WithThemeProps = P &amp; OwnProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> WithTheme = <span class="function">(<span class="params">props: WithThemeProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">    <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">      primary: <span class="string">'red'</span>,</span><br><span class="line">      secondary: <span class="string">'blue'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  WithTheme.displayName = <span class="string">`withTheme<span class="subst">$&#123;Component.displayName&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> WithTheme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">const</span> Foo: FC&lt;&#123; a: <span class="built_in">number</span> &#125; &amp; ThemeProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &lt;div style=&#123;&#123; color: props.primary &#125;&#125; /&gt;;</span><br><span class="line"><span class="keyword">const</span> FooWithTheme = withTheme(Foo);</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  &lt;FooWithTheme a=&#123;<span class="number">1</span>&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再重构一下:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽取出通用的高阶组件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> HOC&lt;InjectedProps, OwnProps = &#123;&#125;&gt; = &lt;P&gt;(</span><br><span class="line">  Component: React.ComponentType&lt;P &amp; InjectedProps&gt;,</span><br><span class="line">) =&gt; React.ComponentType&lt;P &amp; OwnProps&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withTheme: HOC&lt;ThemeProps&gt; = <span class="function"><span class="params">Component</span> =&gt;</span> props =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">  <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用高阶组件还有一些痛点:</p><ul><li>无法完美地使用 ref(这已不算什么痛点)<ul><li>在 React.forwardRef 发布之前, 有一些库会使用 innerRef 或者 wrapperRef, 转发给封装的组件的 ref.</li><li>无法推断 ref 引用组件的类型, 需要显式声明.</li></ul></li><li>高阶组件类型报错很难理解</li></ul><p><br></p><hr><p><br></p><h3 id="4-render-props"><a href="#4-render-props" class="headerlink" title="4. Render Props"></a>4. Render Props</h3><p>React 的 props(包括 children)并没有限定类型, 它可以是一个函数. 于是就有了 render props, 这是和高阶组件一样常见的模式:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeConsumerProps &#123;</span><br><span class="line">  children: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeConsumer = <span class="function">(<span class="params">props: ThemeConsumerProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fakeTheme = &#123; primary: <span class="string">'red'</span>, secondary: <span class="string">'blue'</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> props.children(fakeTheme);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line">&lt;ThemeConsumer&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">&#123; primary &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div style=&#123;&#123; color: primary &#125;&#125; /&gt;;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/ThemeConsumer&gt;;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="5-context"><a href="#5-context" class="headerlink" title="5. Context"></a>5. Context</h3><p>Context 提供了一种跨组件间状态共享机制</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Theme &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Context的类型, 以&#123;Name&#125;ContextValue命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeContextValue &#123;</span><br><span class="line">  theme: Theme;</span><br><span class="line">  onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Context, 并设置默认值, 以&#123;Name&#125;Context命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext&lt;ThemeContextValue&gt;(&#123;</span><br><span class="line">  theme: &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  onThemeChange: noop,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provider, 以&#123;Name&#125;Provider命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeProvider: FC&lt;&#123; theme: Theme; onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;&#123; theme: props.theme, onThemeChange: props.onThemeChange &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 暴露hooks, 以use&#123;Name&#125;命名</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">export function useTheme() &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h3 id="6-杂项"><a href="#6-杂项" class="headerlink" title="6. 杂项"></a>6. 杂项</h3><h4 id="1️⃣-使用handleevent命名事件处理器"><a href="#1️⃣-使用handleevent命名事件处理器" class="headerlink" title="1️⃣ 使用handleEvent命名事件处理器."></a>1️⃣ <strong>使用<code>handleEvent</code>命名事件处理器</strong>.</h4><p>如果存在多个相同事件处理器, 则按照<code>handle{Type}{Event}</code>命名, 例如 handleNameChange.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback&lt;React.MouseEventHandler&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    evt.preventDefault();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;handleClick&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2️⃣-内置事件处理器的类型"><a href="#2️⃣-内置事件处理器的类型" class="headerlink" title="2️⃣ 内置事件处理器的类型"></a>2️⃣ <strong>内置事件处理器的类型</strong></h4><p><code>@types/react</code>内置了以下事件处理器的类型 👇</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EventHandler&lt;E <span class="keyword">extends</span> SyntheticEvent&lt;<span class="built_in">any</span>&gt;&gt; = &#123; bivarianceHack(event: E): <span class="built_in">void</span> &#125;[<span class="string">'bivarianceHack'</span>];</span><br><span class="line"><span class="keyword">type</span> ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> CompositionEventHandler&lt;T = Element&gt; = EventHandler&lt;CompositionEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure><p>可以简洁地声明事件处理器类型:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ChangeEventHandler &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 可以限定具体Target的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback&lt;ChangeEventHandler&lt;HTMLInputElement&gt;&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(evt.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;input onChange=&#123;handleChange&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3️⃣-自定义组件暴露事件处理器类型"><a href="#3️⃣-自定义组件暴露事件处理器类型" class="headerlink" title="3️⃣ 自定义组件暴露事件处理器类型"></a>3️⃣ <strong>自定义组件暴露事件处理器类型</strong></h4><p>和原生 html 元素一样, 自定义组件应该暴露自己的事件处理器类型, 尤其是较为复杂的事件处理器, 这样可以避免开发者手动为每个事件处理器的参数声明类型</p><p>自定义事件处理器类型以<code>{ComponentName}{Event}Handler</code>命名. 为了和原生事件处理器类型区分, 不使用<code>EventHandler</code>形式的后缀</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadValue &#123;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露事件处理器类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> UploadChangeHandler = <span class="function">(<span class="params">value?: UploadValue, file?: File</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadProps &#123;</span><br><span class="line">  value?: UploadValue;</span><br><span class="line">  onChange?: UploadChangeHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Upload: FC&lt;UploadProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;...&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="4️⃣-获取原生元素-props-定义"><a href="#4️⃣-获取原生元素-props-定义" class="headerlink" title="4️⃣ 获取原生元素 props 定义"></a>4️⃣ <strong>获取原生元素 props 定义</strong></h4><p>有些场景我们希望原生元素扩展一下一些 props. 所有原生元素 props 都继承了<code>React.HTMLAttributes</code>, 某些特殊元素也会扩展了自己的属性, 例如<code>InputHTMLAttributes</code>. 具体可以参考<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/eafef8bd049017b3998939de2edbab5d8a96423b/types/react/index.d.ts#L203" target="_blank" rel="noopener"><code>React.createElement</code></a>方法的实现</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fixClass</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">T</span> <span class="title">extends</span> <span class="title">Element</span> = <span class="title">HTMLDivElement</span>,</span></span><br><span class="line"><span class="function">  <span class="title">Attribute</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt; = <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params">cls: <span class="built_in">string</span>, <span class="keyword">type</span>: keyof React.ReactHTML = 'div'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FixedClassName: FC&lt;Attribute&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="keyword">type</span>, &#123; ...props, className: <span class="string">`<span class="subst">$&#123;cls&#125;</span> <span class="subst">$&#123;props.className&#125;</span>`</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FixedClassName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Container = fixClass(<span class="string">'card'</span>);</span><br><span class="line"><span class="keyword">const</span> Header = fixClass(<span class="string">'card__header'</span>, <span class="string">'header'</span>);</span><br><span class="line"><span class="keyword">const</span> Body = fixClass(<span class="string">'card__body'</span>, <span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">const</span> Footer = fixClass(<span class="string">'card__body'</span>, <span class="string">'footer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &lt;Header&gt;header&lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Body&gt;header&lt;/</span>Body&gt;</span><br><span class="line">      &lt;Footer&gt;footer&lt;<span class="regexp">/Footer&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Container&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5️⃣-不要使用-proptypes"><a href="#5️⃣-不要使用-proptypes" class="headerlink" title="5️⃣ 不要使用 PropTypes"></a>5️⃣ <strong>不要使用 PropTypes</strong></h4><p>有了 Typescript 之后可以安全地约束 Props 和 State, 没有必要引入 React.PropTypes, 而且它的表达能力比较弱</p><p><br></p><h4 id="6️⃣-styled-components"><a href="#6️⃣-styled-components" class="headerlink" title="6️⃣ styled-components"></a>6️⃣ <strong>styled-components</strong></h4><p>styled-components 是目前最流行的<code>CSS-in-js</code>库, Typescript 在 2.9 支持泛型<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#generic-type-arguments-in-generic-tagged-templates" target="_blank" rel="noopener"><code>标签模板</code></a>. 这意味着可以简单地对 styled-components 创建的组件进行类型约束</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖于@types/styled-components</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components/macro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1&lt;&#123; active?: <span class="built_in">boolean</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; (props.active ? 'red' : 'gray')&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展已有组件</span></span><br><span class="line"><span class="keyword">const</span> NewHeader = styled(Header)&lt;&#123; customColor: <span class="built_in">string</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; props.customColor&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>了解更多<a href="https://www.styled-components.com/docs/api#typescript" target="_blank" rel="noopener">styled-components 和 Typescript</a></p><p><br></p><h4 id="7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明"><a href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明" class="headerlink" title="7️⃣ 为没有提供 Typescript 声明文件的第三方库自定义模块声明"></a>7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></h4><p>笔者一般习惯在项目根目录下(和 tsconfig.json 同在一个目录下)放置一个<code>global.d.ts</code>. 放置项目的全局声明文件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /global.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模块声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'awesome-react-component' &#123;</span><br><span class="line">  <span class="comment">// 依赖其他模块的声明文件</span></span><br><span class="line">  <span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> Foo: React.FC&lt;&#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解更多<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">如何定义声明文件</a></p><p><br></p><h4 id="8️⃣-为文档生成做好准备"><a href="#8️⃣-为文档生成做好准备" class="headerlink" title="8️⃣ 为文档生成做好准备"></a>8️⃣ <strong>为文档生成做好准备</strong></h4><p>目前社区有多种 react 组件文档生成方案, 例如<a href="https://www.docz.site" target="_blank" rel="noopener"><code>docz</code></a>, <a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener"><code>styleguidist</code></a>还有<a href="https://github.com/storybooks/storybook" target="_blank" rel="noopener">storybook</a>. 它们底层都使用<a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener">react-docgen-typescript</a>对 Typescript 进行解析. 就目前而言, 它还有些坑, 而且解析比较慢. 不管不妨碍我们使用它的风格对代码进行注释:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Props注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ColumnProps <span class="keyword">extends</span> React.HTMLAttributes&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">/** prop1 description */</span></span><br><span class="line">  prop1?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">/** prop2 description */</span></span><br><span class="line">  prop2: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * prop3 description</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  prop3: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">/** prop4 description */</span></span><br><span class="line">  prop4: <span class="string">'option1'</span> | <span class="string">'option2'</span> | <span class="string">'option3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对组件进行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Column <span class="keyword">extends</span> Component&lt;ColumnProps, &#123;&#125;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;Column&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9️⃣-开启-strict-模式"><a href="#9️⃣-开启-strict-模式" class="headerlink" title="9️⃣ 开启 strict 模式"></a>9️⃣ <strong>开启 strict 模式</strong></h4><p>为了真正把 Typescript 用起来, 应该始终开启 strict 模式, 避免使用 any 类型声明.</p><p><br></p><hr><p><br></p><h3 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h3><ul><li><a href="https://github.com/piotrwitek/react-redux-typescript-guide" target="_blank" rel="noopener">piotrwitek/react-redux-typescript-guide</a></li><li><a href="https://www.zhihu.com/question/279911703" target="_blank" rel="noopener">TypeScript 如何完美地书写 React 中的 HOC？</a></li><li><a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">Typescript 官方文档</a></li><li><a href="https://basarat.gitbooks.io/typescript/docs/why-typescript.html" target="_blank" rel="noopener">Typescript-deep-dive</a></li><li><a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">Typescript 思维导图</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系列引言&quot;&gt;&lt;a href=&quot;#系列引言&quot; class=&quot;headerlink&quot; title=&quot;系列引言&quot;&gt;&lt;/a&gt;系列引言&lt;/h2&gt;&lt;p&gt;最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对&lt;strong&gt;R
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Rx建模入门</title>
    <link href="https://bobi.ink/2019/04/19/rxjs-by-example/"/>
    <id>https://bobi.ink/2019/04/19/rxjs-by-example/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-05-21T23:07:52.763Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何使用 Rx 的响应式编程思维来对业务逻辑进行建模, 你会了解到响应式编程的优势和业务抽象能力, 学会将现有的业务流程以数据流的方式表达出来. 你的工具库中不能少了 Rx 这件利器.</p><p>Rx 学习曲线陡峭是总所周知的, 我们接触的大部分编程语言或框架都是面向对象的. 在面对 Rx 这响应式编程的方式, 会觉得无从入手,<br>笔者也是 Rx 的初学者, 拜读过多次<a href="https://www.zhihu.com/people/sharpmaster/posts" target="_blank" rel="noopener">徐飞</a>Rx 的相关文章, 基本上都是云里雾里. 主要原因还是思维没有转换过来.</p><p>如果你不理解响应式编程的奥妙，是很难在<strong>‘面向场景编程’</strong>时考虑到 Rx 的优势. 笔者一般遵循’面向场景编程’, 即在对应的场景考虑不同的技术或框架. 可能是痛点还没有到难以忍受的地步，或许是现有应用还不够复杂，我目前为止还没接触到必须要应用 Rx 的场景.</p><p>我觉得应该反过来，采取刻意学习的方式来学习 Rx, 以流的方式来思考，再将其放在现有的场景中看是否有更简洁的解决方案或化学反应.<br>不得不说写 Rx 是一个比较有趣的事情。 但也要认识到 Rx 不是万金油，正如很多教程所说的 Rx 擅长复杂的异步协调，并不是所有场景都适合，一些问题有更简洁的解决方案</p><p><br></p><h2 id="rx-的建模过程"><a href="#rx-的建模过程" class="headerlink" title="Rx 的建模过程"></a>Rx 的建模过程</h2><p>对于 Rx 的入门者, 可以使用下面的流程, 一步一步将业务逻辑转换为 Rx 数据流来进行表达.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">流程图 -&gt; 数据流抽象 -&gt; 实现</span><br></pre></td></tr></table></figure><h3 id="①-流程图"><a href="#①-流程图" class="headerlink" title="① 流程图"></a><code>① 流程图</code></h3><p>首先从流程图开始, 这个阶段没什么特别的, 不管是响应式编程还是其他范式, 编码之前都需要缕清业务逻辑.</p><p>这个阶段使用<code>流程图</code>来描述技术无关的事务过程, 让业务逻辑更加清晰, 也方便我们识别业务流程的主体和关键事件.</p><blockquote><p>什么是业务逻辑? <a href="https://en.wikipedia.org/wiki/Business_logic" target="_blank" rel="noopener">wiki</a> 上这样定义:<br><strong>Business logic</strong> or domain logic is that part of the program which encodes the real-world business rules that determine how data can be created, displayed, stored, and changed. It prescribes how business objects interact with one another, and enforces the routes and the methods by which business objects are accessed and updated.<br><br> <strong>Business Rules</strong> describe the operations, definitions and constraints that apply to an organization. The operations collectively form a process; every business uses these processes to form systems that get things done.</p></blockquote><p><br><br><br></p><h3 id="②-数据流抽象"><a href="#②-数据流抽象" class="headerlink" title="② 数据流抽象"></a><code>② 数据流抽象</code></h3><p>Rx 的世界里面<em>一切皆流</em>, 换句话说就是<strong>面向流编程</strong>. 和<em>面向对象编程</em>把现实世界的实体抽象为对象一样. 响应式编程将业务中的<em>变动实体</em>(<em>想不到更好的词, 或者变量?</em>)抽象为流</p><p><strong>(1)首先需要识别什么是<em>变动实体</em></strong>? 变动实体一般是数据流的源头, 它驱动着业务走向. 像河流一样, 源头可能不只一个. 我认为变动实体至少具备以下特征之一:</p><ul><li>它是变动的. 例如鼠标的位置, 商品的价格, 随着时间的迁移状态会进行变动</li><li>它是业务的’输入’. 变动实体是一个系统的输入(外部事件)或者是另一个流(衍生)的输入.</li><li>它是业务的参与者(或者说业务的主体).</li><li>它表示业务的状态. 例如一个 todo 列表, 这是一个纯状态的流</li></ul><p><strong>(2)接着识别<em>变动实体</em>之间的关系</strong>. 主体之间的关系也就是流之间的关系, 这是 Rx 建模的核心. 只有理解了主体之间的关系, 才能将主体与业务流程串联起来, 才能真正地使用数据流的方式将业务表达出来. 在<a href="https://www.jianshu.com/p/c95e29854cb1" target="_blank" rel="noopener">重新理解响应式编程</a>一文中对’响应式编程’的定义和笔者的理解非常契合:</p><blockquote><p>响应式编程是一种通过异步和数据流来构建事务关系的编程模型 . 事务关系是响应式编程的核心理念, “数据流”和“异步”是实现这个核心理念的关键.</p></blockquote><p>这种关系和面向对象的类关系是不一样的, 面向对象的关系一般是指依赖关系. 而<strong>数据流之间关系, 是业务之间的实际关系</strong>, 比如流程 b 依赖流程 a, 数据流是变动实体之间的沟通桥梁.</p><p>一般以下面的方法来构建流之间的关系:</p><ul><li>分治: 将业务划分为多个模块(流), 一个大的流总是由小的流组成, 小的流职责更单一, 更容易理解和测试</li><li>变换: 将流映射为另外一个流. 一般用于状态变更或业务衍生(高阶流变换)</li><li>合并: 像河流一样, 数据流最终是需要汇聚在一起注入大海的. 拆分和合并的方式都是依赖于所要表达的业务逻辑</li></ul><p>总的来说变动实体一般就是业务的’<strong>输入</strong>‘, 我们首先把它们确定为流, 再根据关系衍生出其他流(<strong>输出</strong>). 对于流本身来说, <strong>本质上只有输入和输出的关系</strong>:</p><p><img src="/images/03/stream.png" alt="stream"></p><p>例如 increment$和decrement$就是 action$的输入, action$就是 count$的输入, 以此类推. <strong>响应式编程将复杂业务关系转换成原始的输出/输出关系</strong></p><p><strong>(3)符合函数式编程的约束</strong>. 一般来说, 我们说的响应式编程指的是<code>函数式响应式编程(Functional reactive programming FRP)</code>, 所以需要符合函数式的一些约束:</p><ul><li><code>纯函数(Pure)</code>: 函数只是输入参数到输出结果的映射, 不要产生副作用<ul><li>没有共享状态: 不依赖外部变量来维护流程的状态.</li><li>幂等性: 幂等性在复杂流程中很重要, 这使得整个流程可被重试</li><li>没有副作用: 可预测, 可测试.</li></ul></li><li><code>不可变性(Immuatability)</code>: 数据一旦产生, 就肯定它的值不会变化, 这有利于代码的理解. 易于并发</li><li><code>声明式(Declarative)</code>:<ul><li>函数式编程和命令式编程相比有较高的抽象级别, 他可以让你专注于定义与事件相互依存的业务逻辑, 而不是在实现细节上. 换句话说, 函数式编程定义关系, 而命令式编程定义步骤</li><li>集中的逻辑. Rx 自然而然在一处定义逻辑, 避免其他范式逻辑分散在代码库的各个地方. 另外 Rx 的 Observable 通过订阅来创建资源, 通过取消订阅来释放资源, 一般开发几乎不需要去关心资源的生命周期, 例如时间器.</li></ul></li></ul><p>这个阶段将第一个阶段的流程图转换为 Rx <code>弹珠图(Marble Diagrams)</code>表示, 弹珠图可以描述流之间关系, 表现’时间’的流逝, 让复杂的数据流更容易理解</p><p><br><br><br></p><h3 id="③-实现"><a href="#③-实现" class="headerlink" title="③ 实现"></a><code>③ 实现</code></h3><p>这个阶段就是把弹珠图翻译为实现代码, 根据需求在 rxjs 工具箱中查找合适的操作符. 当缕清了业务逻辑, 使用数据流进行建模后,<br>代码实现就是一件很简单的事情了.</p><blockquote><p>可以配合 Rxjs 官方的<a href="https://rxjs.dev/operator-decision-tree" target="_blank" rel="noopener">操作符决策树</a>选择合适的操作符</p></blockquote><p><br></p><hr><p><br></p><p>下面使用例子来体会 Rx 的编程思维:</p><h2 id="example-1-c-a-b"><a href="#example-1-c-a-b" class="headerlink" title="Example 1: c := a + b"></a>Example 1: c := a + b</h2><p>这是最简单的实例, 我们期望当 a 和 b 变动时能够响应到 c, 我们按照上述的步骤对这个需求进行建模:</p><ul><li><p><code>流程</code>:</p><p><img src="/images/03/process-02.png" alt="c=a+b"></p></li><li><p><code>数据流抽象</code>: 从上可以识别出两个变动的实体 a 和 b, 所以 a 和 b 都可以视作流, 那么 c 就是 a 和 b 衍生出来的流, 表示 a 和 b 的实时加法结果, 使用弹珠图来描述三者的关系:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">a$</span>: ----1------------2---------------</span><br><span class="line"><span class="meta">b$</span>: --2-------4------------6------8------</span><br><span class="line">              \ (a + b) /</span><br><span class="line"><span class="meta">c$</span>: ----3-----5------6-----8------10-----</span><br></pre></td></tr></table></figure></li><li><p><code>代码实现</code>: 由弹珠图可以看出, c$流的输出值就是a$和 b$输出值的实时计算结果, 也就是说c$接收来自 a$和b$ 的最新数据, 输出他们的和.<br>另外由原本的两个流合并为单个流, 在 rxjs 工具箱中可以找到<code>combineLatest</code>操作符符合该场景. 代码实现如下:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a$ = interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> b$ = interval(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">a$.pipe(combineLatest(b$))</span><br><span class="line">  .pipe(map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b))</span><br><span class="line">  .subscribe(<span class="function"><span class="params">sum</span> =&gt;</span> <span class="built_in">console</span>.log(sum));</span><br></pre></td></tr></table></figure></li></ul><p><br></p><hr><p><br></p><h2 id="example-2-元素拖拽的例子"><a href="#example-2-元素拖拽的例子" class="headerlink" title="Example 2: 元素拖拽的例子"></a>Example 2: 元素拖拽的例子</h2><p>元素拖拽也是 Rx 的经典例子的的例子. 假设我们需要先移动端和桌面端都支持元素拖拽移动.</p><p><code>流程图</code></p><p><img src="/images/03/process-01.png" alt></p><p><code>数据流抽象</code></p><p>这里使用分治的方法, 将流程进行一步步拆解, 然后使用弹珠图的形式进行描述.</p><p>由上面的流程图可以识别出来, down, move 以及 up 都是<code>变动实体</code>, 我们可以将他们视作’流’.</p><p>① down/move/up 都是抽象的事件, 在桌面端下是 mousedown/mousemove/mouseup, 移动端下对应的是<br>touchstart/touchmove/touchend. 我们不区分这些事件, 例如接收到 mousedown 或 touchstart 事件都认为是一个’down’事件. 所以事件监听的数据流如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 1</span><br><span class="line"><span class="meta">mousedown$</span> : ---d----------d--------</span><br><span class="line"><span class="meta">touchstart$</span>: -s---s-----------s-----</span><br><span class="line">        \(merge)/</span><br><span class="line"><span class="meta">down$</span>      : -s-d-s--------d--s-----</span><br></pre></td></tr></table></figure><p>move 和 up 事件同理</p><p>② 接下来要识别 up$, move$, down$ 三个数据流之间的关系, down 事件触发后我们才会去监听 move 和 up 事件, 也就是说由 down$可以衍生出 move$和 up$流. 在 up 事件触发后整个流程就终止. up$流决定了整个流程的生命周期的结束</p><p>使用弹珠图的描述三者的关系如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 2</span><br><span class="line"><span class="meta">down$</span>: -----d-------------------------</span><br><span class="line">             \</span><br><span class="line"><span class="meta">up$</span>  :        ----------u|</span><br><span class="line"><span class="meta">move$</span>:        -m--m--m---|</span><br></pre></td></tr></table></figure><p>③ 一个拖拽结束后还可以重新再发起拖拽, 即我们会持续监听 down 事件. 上面的流程还规定如果当前拖拽还未结束,<br>其他 down 事件应该被忽略, 在移动端下多点触摸是可能导致多个 down 事件触发的.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 3</span><br><span class="line"><span class="meta">down$</span>: ---d---d--d---------d------    # 中间两个事件因为拖拽未完成被忽略</span><br><span class="line">           \                \</span><br><span class="line"><span class="meta">up$</span>:        -----u|          ------u|</span><br><span class="line"><span class="meta">move$</span>:      -m-mm-|          m-m-m--|</span><br></pre></td></tr></table></figure><p><code>实现</code>:</p><p>有了弹珠图后, 就是把翻译问题了, 现在就打开 rxjs 的工具箱, 找找有什么合适的工具.</p><p>首先是抽象事件的处理. 由#1 可以看出, 这就是一个数据流合并, 这个适合使用<code>merge</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">merge(fromEvent(el, <span class="string">'touchstart'</span>), fromEvent(el, <span class="string">'mousedown'</span>));</span><br></pre></td></tr></table></figure><p>down$流的切换可以使用<code>exhaustMap</code>操作符, 这个操作符可以将输出值映射为Observable, 最后再使用exhaust操作符对Observable进行合并.<br>这可以满足我们’当一个拖拽未结束时, 新发起的 down$输出会被忽略, 直到拖拽完结’的需求</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">down$</span><br><span class="line">  .pipe(</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">evt</span> =&gt;</span> <span class="comment">/* 转换为新的Observable流 */</span>)</span><br></pre></td></tr></table></figure><p>使用 exhaustMap 来将 down$输出值转换为move$ 流, 并在 up$ 输出后结束, 可以使用<code>takeUntil</code>操作符:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">down$</span><br><span class="line">  .pipe(</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">      evt.preventDefault();</span><br><span class="line">      <span class="keyword">if</span> (evt.type === <span class="string">'mousedown'</span>) &#123;</span><br><span class="line">        <span class="comment">// 鼠标控制</span></span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = evt <span class="keyword">as</span> MouseEvent;</span><br><span class="line">        <span class="keyword">return</span> mouseMove$.pipe(</span><br><span class="line">          map(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              deltaX: (evt <span class="keyword">as</span> MouseEvent).clientX - clientX,</span><br><span class="line">              deltaY: (evt <span class="keyword">as</span> MouseEvent).clientY - clientY,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;),</span><br><span class="line">          takeUntil(mouseUp$),</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 触摸事件</span></span><br><span class="line">        <span class="keyword">const</span> &#123; touches &#125; = evt <span class="keyword">as</span> TouchEvent;</span><br><span class="line">        <span class="keyword">const</span> touch = touches[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = touch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> getTouch = <span class="function">(<span class="params">evt: TouchEvent</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> touches = <span class="built_in">Array</span>.from(evt.changedTouches);</span><br><span class="line">          <span class="keyword">return</span> touches.find(<span class="function"><span class="params">t</span> =&gt;</span> t.identifier === touch.identifier);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> touchFilter = filter(<span class="function">(<span class="params">e: Event</span>) =&gt;</span> !!getTouch(e <span class="keyword">as</span> TouchEvent));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> touchMove$.pipe(</span><br><span class="line">          touchFilter,</span><br><span class="line">          map(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> touch = getTouch(evt <span class="keyword">as</span> TouchEvent)!;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              deltaX: touch.clientX - clientX,</span><br><span class="line">              deltaY: touch.clientY - clientY,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;),</span><br><span class="line">          takeUntil(touchUp$.pipe(touchFilter)),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">delta</span> =&gt;</span> &#123;</span><br><span class="line">    el.style.transform = <span class="string">`translate(<span class="subst">$&#123;delta.deltaX&#125;</span>px, <span class="subst">$&#123;delta.deltaY&#125;</span>px)`</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h2 id="example-3-todos"><a href="#example-3-todos" class="headerlink" title="Example 3: Todos"></a>Example 3: Todos</h2><p>如果使用 rxjs 来创建 Todos 应用, 首先是<code>流程图</code>:</p><p><img src="/images/03/process-03.png" alt></p><p><code>数据流抽象</code>:</p><p>首先识别变动的实体, 变动的实体就是 todos 列表, 所以可以认为 todos 列表就是一个流. 它从 localStorage 中恢复<br>初始化状态. 由<code>新增</code>, <code>删除</code>等事件触发状态改变, 这些事件也可以视作流</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">add$</span>:      --a-----a------</span><br><span class="line"><span class="meta">modify$</span>:   ----m----------</span><br><span class="line"><span class="meta">remove$</span>    -------r-------</span><br><span class="line"><span class="meta">complete$</span>: ------c----c---</span><br><span class="line">             \(merge)/</span><br><span class="line"><span class="meta">update$</span>    --a-m-cra--c--- # 各种事件合并为update$流</span><br><span class="line">              \(reduce)/</span><br><span class="line"><span class="meta">todos$</span>:    i-u-u-uuu--u---- # i 为初始化数据, update$的输出将触发重新计算状态</span><br></pre></td></tr></table></figure><p>todos$流会响应到 view 上, 另一方面需要持久化到本地存储. 也就是说这是一个多播流.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">todos$</span>: i-u-u-uuu--u---- #</span><br><span class="line">          \(debounce)/</span><br><span class="line"><span class="meta">save$</span>   i--u--u---u----- # 存储流, 使用debounce来避免频繁存储</span><br></pre></td></tr></table></figure><p>并行渲染到页面:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">todos$</span>: i-u-u-uuu--u---- #</span><br><span class="line">       \(render)/</span><br><span class="line"><span class="meta">dom$</span>:   i-u-u-uuu--u---- # dom渲染, 假设也是流(cycle.js就是如此)</span><br></pre></td></tr></table></figure><p>这个实例的数据流和 Redux 的模型非常像, add$, modify$, remove$和complete$就是 Action, todos 流会使用<br>类似 Reducer 的机制来处理这些 Action 生成新的 State</p><p><img src="/images/03/redux.png" alt="redux"></p><p><code>代码实现</code>:</p><p>首先 add$, modify$以及 remove$和complete$可以分别使用一个 Subject 对象来表示, 用于接收外部事件. 其实还可以简化为一个流,<br>它们的区别只是参数</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Action&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  payload: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INIT_ACTION = <span class="string">'INIT'</span>; <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> ADD_ACTION = <span class="string">'ADD'</span>;</span><br><span class="line"><span class="keyword">const</span> REMOVE_ACTION = <span class="string">'REMOVE'</span>;</span><br><span class="line"><span class="keyword">const</span> MODIFY_ACTION = <span class="string">'MODIFY'</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETE_ACTION = <span class="string">'COMPLETE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update$ = <span class="keyword">new</span> Subject&lt;Action&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: ADD_ACTION,</span><br><span class="line">    payload: value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: REMOVE_ACTION,</span><br><span class="line">    payload: id,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: COMPLETE_ACTION,</span><br><span class="line">    payload: id,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">id: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  update$.next(&#123;</span><br><span class="line">    <span class="keyword">type</span>: MODIFY_ACTION,</span><br><span class="line">    payload: &#123; id, value &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建todos$流, 对update$ 的输出进行 reduce:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化Store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialStore</span>(<span class="params"></span>): <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="built_in">window</span>.localStorage.getItem(STORAGE_KEY);</span><br><span class="line">  <span class="keyword">return</span> value ? <span class="built_in">JSON</span>.parse(value) : &#123; list: [] &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos$ = update$.pipe(</span><br><span class="line">  <span class="comment">// 从INIT_ACTION 触发scan初始化</span></span><br><span class="line">  startWith(&#123; <span class="keyword">type</span>: INIT_ACTION &#125; <span class="keyword">as</span> Action),</span><br><span class="line">  <span class="comment">// reducer</span></span><br><span class="line">  scan&lt;Action, Store&gt;<span class="function">(<span class="params">(<span class="params">state, &#123; <span class="keyword">type</span>, payload &#125;</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> produce(<span class="params">state, draftState =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">let</span> idx: <span class="built_in">number</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">switch</span> (<span class="params"><span class="keyword">type</span></span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> ADD_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          draftState.list.push(<span class="params">&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">            id: <span class="built_in">Date</span>.now(<span class="params"></span>).toString(<span class="params"></span>),</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">            value: payload,</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          &#125;</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> MODIFY_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload.id</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list[idx].value = payload.value;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> REMOVE_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list.splice(<span class="params">idx, 1</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">case</span> COMPLETE_ACTION:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          idx = draftState.list.findIndex(<span class="params">i =&gt; i.id === payload</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">if</span> (<span class="params">idx !== -1</span>) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            draftState.list[idx].completed = <span class="literal">true</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">          <span class="keyword">break</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">default</span>:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, initialStore(<span class="params"></span>)</span>),</span></span><br><span class="line"><span class="function">  // 支持多播</span></span><br><span class="line"><span class="function">  <span class="params">shareReplay</span><span class="params">()</span>,</span></span><br><span class="line"><span class="function">);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 持久化</span></span><br><span class="line"><span class="function"><span class="params">todos</span>$.<span class="params">pipe</span>(<span class="params">debounceTime(<span class="params">1000</span>)</span>).<span class="params">subscribe</span>(<span class="params">store =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">window</span>.localStorage.setItem(<span class="params">STORAGE_KEY, <span class="built_in">JSON</span>.stringify(<span class="params">store</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br></pre></td></tr></table></figure><blockquote><p>更多例子: 徐飞在<a href="https://github.com/xufei/blog/issues/44" target="_blank" rel="noopener">“RxJS 入门指引和初步应用&gt;”</a>提到了一个”幸福人生”的例子, 挺有意思, 读者可以尝试对其进行建模</p></blockquote><p><br></p><hr><p><br></p><p>经过上述过程, 可以深刻体会到<em>函数响应式编程</em>的<strong>优势</strong>:</p><ul><li><strong>数据流抽象了很多现实问题</strong>. 也就说数据流对业务逻辑的表达能力流程图基本一致. 可以说弹珠图是流程图的直观翻译, 而 Rx 代码则是弹珠图的直观翻译. 使用 Rx 以声明式形式编写代码, 可以让代码更容易理解, 因为它们接近业务流程.</li><li><strong>把复杂的问题分解成简单的问题的组合</strong>. Rx 编程本质上就是数据流的分治和合并</li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.jianshu.com/p/c95e29854cb1" target="_blank" rel="noopener">重新理解响应式编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/53009201" target="_blank" rel="noopener">【响应式编程的思维艺术】响应式 Vs 面向对象</a></li><li><a href="http://www.uml.org.cn/zjjs/201008021.asp" target="_blank" rel="noopener">细说业务逻辑</a></li><li><a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">Reactive programming</a></li><li><a href="https://github.com/xufei/blog/issues/44" target="_blank" rel="noopener">RxJS 入门指引和初步应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍如何使用 Rx 的响应式编程思维来对业务逻辑进行建模, 你会了解到响应式编程的优势和业务抽象能力, 学会将现有的业务流程以数据流的方式表达出来. 你的工具库中不能少了 Rx 这件利器.&lt;/p&gt;
&lt;p&gt;Rx 学习曲线陡峭是总所周知的, 我们接触的大部分编程语言或框架都
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
